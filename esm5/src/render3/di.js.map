{"version":3,"file":"di.js","sourceRoot":"","sources":["../../../../../../packages/core/src/render3/di.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// We are temporarily importing the existing viewEngine_from core so we can be sure we are\n// correctly implementing its interfaces for backwards compatibility.\nimport {ChangeDetectorRef as viewEngine_ChangeDetectorRef} from '../change_detection/change_detector_ref';\nimport {Injector} from '../di/injector';\nimport {ComponentFactory as viewEngine_ComponentFactory, ComponentRef as viewEngine_ComponentRef} from '../linker/component_factory';\nimport {ElementRef as viewEngine_ElementRef} from '../linker/element_ref';\nimport {NgModuleRef as viewEngine_NgModuleRef} from '../linker/ng_module_factory';\nimport {TemplateRef as viewEngine_TemplateRef} from '../linker/template_ref';\nimport {ViewContainerRef as viewEngine_ViewContainerRef} from '../linker/view_container_ref';\nimport {EmbeddedViewRef as viewEngine_EmbeddedViewRef, ViewRef as viewEngine_ViewRef} from '../linker/view_ref';\nimport {Type} from '../type';\n\nimport {assertGreaterThan, assertLessThan, assertNotNull} from './assert';\nimport {addToViewTree, assertPreviousIsParent, createLContainer, createLNodeObject, getDirectiveInstance, getPreviousOrParentNode, getRenderer, isComponent, renderEmbeddedTemplate, resolveDirective} from './instructions';\nimport {ComponentTemplate, DirectiveDef} from './interfaces/definition';\nimport {LInjector} from './interfaces/injector';\nimport {LContainerNode, LElementNode, LNode, LNodeType, LViewNode, TNodeFlags} from './interfaces/node';\nimport {QueryReadType} from './interfaces/query';\nimport {Renderer3} from './interfaces/renderer';\nimport {LView} from './interfaces/view';\nimport {assertNodeOfPossibleTypes, assertNodeType} from './node_assert';\nimport {insertView, removeView} from './node_manipulation';\nimport {notImplemented, stringify} from './util';\nimport {EmbeddedViewRef, ViewRef, addDestroyable, createViewRef} from './view_ref';\n\n\n\n/**\n * If a directive is diPublic, bloomAdd sets a property on the instance with this constant as\n * the key and the directive's unique ID as the value. This allows us to map directives to their\n * bloom filter bit for DI.\n */\nconst NG_ELEMENT_ID = '__NG_ELEMENT_ID__';\n\n/**\n * The number of slots in each bloom filter (used by DI). The larger this number, the fewer\n * directives that will share slots, and thus, the fewer false positives when checking for\n * the existence of a directive.\n */\nconst BLOOM_SIZE = 256;\n\n/** Counter used to generate unique IDs for directives. */\nlet nextNgElementId = 0;\n\n/**\n * Registers this directive as present in its node's injector by flipping the directive's\n * corresponding bit in the injector's bloom filter.\n *\n * @param injector The node injector in which the directive should be registered\n * @param type The directive to register\n */\nexport function bloomAdd(injector: LInjector, type: Type<any>): void {\n  let id: number|undefined = (type as any)[NG_ELEMENT_ID];\n\n  // Set a unique ID on the directive type, so if something tries to inject the directive,\n  // we can easily retrieve the ID and hash it into the bloom bit that should be checked.\n  if (id == null) {\n    id = (type as any)[NG_ELEMENT_ID] = nextNgElementId++;\n  }\n\n  // We only have BLOOM_SIZE (256) slots in our bloom filter (8 buckets * 32 bits each),\n  // so all unique IDs must be modulo-ed into a number from 0 - 255 to fit into the filter.\n  // This means that after 255, some directives will share slots, leading to some false positives\n  // when checking for a directive's presence.\n  const bloomBit = id % BLOOM_SIZE;\n\n  // Create a mask that targets the specific bit associated with the directive.\n  // JS bit operations are 32 bits, so this will be a number between 2^0 and 2^31, corresponding\n  // to bit positions 0 - 31 in a 32 bit integer.\n  const mask = 1 << bloomBit;\n\n  // Use the raw bloomBit number to determine which bloom filter bucket we should check\n  // e.g: bf0 = [0 - 31], bf1 = [32 - 63], bf2 = [64 - 95], bf3 = [96 - 127], etc\n  if (bloomBit < 128) {\n    // Then use the mask to flip on the bit (0-31) associated with the directive in that bucket\n    bloomBit < 64 ? (bloomBit < 32 ? (injector.bf0 |= mask) : (injector.bf1 |= mask)) :\n                    (bloomBit < 96 ? (injector.bf2 |= mask) : (injector.bf3 |= mask));\n  } else {\n    bloomBit < 192 ? (bloomBit < 160 ? (injector.bf4 |= mask) : (injector.bf5 |= mask)) :\n                     (bloomBit < 224 ? (injector.bf6 |= mask) : (injector.bf7 |= mask));\n  }\n}\n\nexport function getOrCreateNodeInjector(): LInjector {\n  ngDevMode && assertPreviousIsParent();\n  return getOrCreateNodeInjectorForNode(getPreviousOrParentNode() as LElementNode | LContainerNode);\n}\n\n/**\n * Creates (or gets an existing) injector for a given element or container.\n *\n * @param node for which an injector should be retrieved / created.\n * @returns Node injector\n */\nexport function getOrCreateNodeInjectorForNode(node: LElementNode | LContainerNode): LInjector {\n  const nodeInjector = node.nodeInjector;\n  const parentInjector = node.parent && node.parent.nodeInjector;\n  if (nodeInjector != parentInjector) {\n    return nodeInjector !;\n  }\n  return node.nodeInjector = {\n    parent: parentInjector,\n    node: node,\n    bf0: 0,\n    bf1: 0,\n    bf2: 0,\n    bf3: 0,\n    bf4: 0,\n    bf5: 0,\n    bf6: 0,\n    bf7: 0,\n    cbf0: parentInjector == null ? 0 : parentInjector.cbf0 | parentInjector.bf0,\n    cbf1: parentInjector == null ? 0 : parentInjector.cbf1 | parentInjector.bf1,\n    cbf2: parentInjector == null ? 0 : parentInjector.cbf2 | parentInjector.bf2,\n    cbf3: parentInjector == null ? 0 : parentInjector.cbf3 | parentInjector.bf3,\n    cbf4: parentInjector == null ? 0 : parentInjector.cbf4 | parentInjector.bf4,\n    cbf5: parentInjector == null ? 0 : parentInjector.cbf5 | parentInjector.bf5,\n    cbf6: parentInjector == null ? 0 : parentInjector.cbf6 | parentInjector.bf6,\n    cbf7: parentInjector == null ? 0 : parentInjector.cbf7 | parentInjector.bf7,\n    injector: null,\n    templateRef: null,\n    viewContainerRef: null,\n    elementRef: null,\n    changeDetectorRef: null\n  };\n}\n\n/** Injection flags for DI. */\nexport const enum InjectFlags {\n  /** Dependency is not required. Null will be injected if there is no provider for the dependency.\n     */\n  Optional = 1 << 0,\n  /** When resolving a dependency, include the node that is requesting injection. */\n  CheckSelf = 1 << 1,\n  /** When resolving a dependency, include ancestors of the node requesting injection. */\n  CheckParent = 1 << 2,\n  /** Default injection options: required, checks both self and ancestors. */\n  Default = CheckSelf | CheckParent,\n}\n\n/**\n * Constructs an injection error with the given text and token.\n *\n * @param text The text of the error\n * @param token The token associated with the error\n * @returns The error that was created\n */\nfunction createInjectionError(text: string, token: any) {\n  return new Error(`ElementInjector: ${text} [${stringify(token)}]`);\n}\n\n/**\n * Makes a directive public to the DI system by adding it to an injector's bloom filter.\n *\n * @param di The node injector in which a directive will be added\n * @param def The definition of the directive to be made public\n */\nexport function diPublicInInjector(di: LInjector, def: DirectiveDef<any>): void {\n  bloomAdd(di, def.type);\n}\n\n/**\n * Makes a directive public to the DI system by adding it to an injector's bloom filter.\n *\n * @param def The definition of the directive to be made public\n */\nexport function diPublic(def: DirectiveDef<any>): void {\n  diPublicInInjector(getOrCreateNodeInjector(), def);\n}\n\n/**\n * Searches for an instance of the given type up the injector tree and returns\n * that instance if found.\n *\n * If not found, it will propagate up to the next parent injector until the token\n * is found or the top is reached.\n *\n * Usage example (in factory function):\n *\n * class SomeDirective {\n *   constructor(directive: DirectiveA) {}\n *\n *   static ngDirectiveDef = defineDirective({\n *     type: SomeDirective,\n *     factory: () => new SomeDirective(directiveInject(DirectiveA))\n *   });\n * }\n *\n * NOTE: use `directiveInject` with `@Directive`, `@Component`, and `@Pipe`. For\n * all other injection use `inject` which does not walk the DOM render tree.\n *\n * @param token The directive type to search for\n * @param flags Injection flags (e.g. CheckParent)\n * @returns The instance found\n */\nexport function directiveInject<T>(token: Type<T>, flags?: InjectFlags, defaultValue?: T): T {\n  return getOrCreateInjectable<T>(getOrCreateNodeInjector(), token, flags, defaultValue);\n}\n\n/**\n * Creates an ElementRef and stores it on the injector.\n * Or, if the ElementRef already exists, retrieves the existing ElementRef.\n *\n * @returns The ElementRef instance to use\n */\nexport function injectElementRef(): viewEngine_ElementRef {\n  return getOrCreateElementRef(getOrCreateNodeInjector());\n}\n\n/**\n * Creates a TemplateRef and stores it on the injector. Or, if the TemplateRef already\n * exists, retrieves the existing TemplateRef.\n *\n * @returns The TemplateRef instance to use\n */\nexport function injectTemplateRef<T>(): viewEngine_TemplateRef<T> {\n  return getOrCreateTemplateRef<T>(getOrCreateNodeInjector());\n}\n\n/**\n * Creates a ViewContainerRef and stores it on the injector. Or, if the ViewContainerRef\n * already exists, retrieves the existing ViewContainerRef.\n *\n * @returns The ViewContainerRef instance to use\n */\nexport function injectViewContainerRef(): viewEngine_ViewContainerRef {\n  return getOrCreateContainerRef(getOrCreateNodeInjector());\n}\n\n/** Returns a ChangeDetectorRef (a.k.a. a ViewRef) */\nexport function injectChangeDetectorRef(): viewEngine_ChangeDetectorRef {\n  return getOrCreateChangeDetectorRef(getOrCreateNodeInjector(), null);\n}\n\n/**\n * Inject static attribute value into directive constructor.\n *\n * This method is used with `factory` functions which are generated as part of\n * `defineDirective` or `defineComponent`. The method retrieves the static value\n * of an attribute. (Dynamic attributes are not supported since they are not resolved\n *  at the time of injection and can change over time.)\n *\n * # Example\n * Given:\n * ```\n * @Component(...)\n * class MyComponent {\n *   constructor(@Attribute('title') title: string) { ... }\n * }\n * ```\n * When instantiated with\n * ```\n * <my-component title=\"Hello\"></my-component>\n * ```\n *\n * Then factory method generated is:\n * ```\n * MyComponent.ngComponentDef = defineComponent({\n *   factory: () => new MyComponent(injectAttribute('title'))\n *   ...\n * })\n * ```\n *\n * @experimental\n */\nexport function injectAttribute(attrName: string): string|undefined {\n  ngDevMode && assertPreviousIsParent();\n  const lElement = getPreviousOrParentNode() as LElementNode;\n  ngDevMode && assertNodeType(lElement, LNodeType.Element);\n  const tElement = lElement.tNode !;\n  ngDevMode && assertNotNull(tElement, 'expecting tNode');\n  const attrs = tElement.attrs;\n  if (attrs) {\n    for (let i = 0; i < attrs.length; i = i + 2) {\n      if (attrs[i] == attrName) {\n        return attrs[i + 1];\n      }\n    }\n  }\n  return undefined;\n}\n\n/**\n * Creates a ViewRef and stores it on the injector as ChangeDetectorRef (public alias).\n * Or, if it already exists, retrieves the existing instance.\n *\n * @returns The ChangeDetectorRef to use\n */\nexport function getOrCreateChangeDetectorRef(\n    di: LInjector, context: any): viewEngine_ChangeDetectorRef {\n  if (di.changeDetectorRef) return di.changeDetectorRef;\n\n  const currentNode = di.node;\n  if (isComponent(currentNode.tNode !)) {\n    return di.changeDetectorRef = createViewRef(currentNode.data as LView, context);\n  } else if (currentNode.type === LNodeType.Element) {\n    return di.changeDetectorRef = getOrCreateHostChangeDetector(currentNode.view.node);\n  }\n  return null !;\n}\n\n/** Gets or creates ChangeDetectorRef for the closest host component */\nfunction getOrCreateHostChangeDetector(currentNode: LViewNode | LElementNode):\n    viewEngine_ChangeDetectorRef {\n  const hostNode = getClosestComponentAncestor(currentNode);\n  const hostInjector = hostNode.nodeInjector;\n  const existingRef = hostInjector && hostInjector.changeDetectorRef;\n\n  return existingRef ?\n      existingRef :\n      createViewRef(\n          hostNode.data as LView,\n          hostNode.view\n              .directives ![hostNode.tNode !.flags >> TNodeFlags.DirectiveStartingIndexShift]);\n}\n\n/**\n * If the node is an embedded view, traverses up the view tree to return the closest\n * ancestor view that is attached to a component. If it's already a component node,\n * returns itself.\n */\nfunction getClosestComponentAncestor(node: LViewNode | LElementNode): LElementNode {\n  while (node.type === LNodeType.View) {\n    node = node.view.node;\n  }\n  return node as LElementNode;\n}\n\n/**\n * Searches for an instance of the given directive type up the injector tree and returns\n * that instance if found.\n *\n * Specifically, it gets the bloom filter bit associated with the directive (see bloomHashBit),\n * checks that bit against the bloom filter structure to identify an injector that might have\n * the directive (see bloomFindPossibleInjector), then searches the directives on that injector\n * for a match.\n *\n * If not found, it will propagate up to the next parent injector until the token\n * is found or the top is reached.\n *\n * @param di Node injector where the search should start\n * @param token The directive type to search for\n * @param flags Injection flags (e.g. CheckParent)\n * @returns The instance found\n */\nexport function getOrCreateInjectable<T>(\n    di: LInjector, token: Type<T>, flags?: InjectFlags, defaultValue?: T): T {\n  const bloomHash = bloomHashBit(token);\n\n  // If the token has a bloom hash, then it is a directive that is public to the injection system\n  // (diPublic). If there is no hash, fall back to the module injector.\n  if (bloomHash === null) {\n    const moduleInjector = di.injector;\n    if (!moduleInjector) {\n      if (defaultValue != null) {\n        return defaultValue;\n      }\n      throw createInjectionError('NotFound', token);\n    }\n    moduleInjector.get(token);\n  } else {\n    let injector: LInjector|null = di;\n\n    while (injector) {\n      // Get the closest potential matching injector (upwards in the injector tree) that\n      // *potentially* has the token.\n      injector = bloomFindPossibleInjector(injector, bloomHash);\n\n      // If no injector is found, we *know* that there is no ancestor injector that contains the\n      // token, so we abort.\n      if (!injector) {\n        break;\n      }\n\n      // At this point, we have an injector which *may* contain the token, so we step through the\n      // directives associated with the injector's corresponding node to get the directive instance.\n      const node = injector.node;\n      const flags = node.tNode !.flags;\n      const count = flags & TNodeFlags.DirectiveCountMask;\n\n      if (count !== 0) {\n        const start = flags >> TNodeFlags.DirectiveStartingIndexShift;\n        const end = start + count;\n        const defs = node.view.tView.directives !;\n\n        for (let i = start; i < end; i++) {\n          // Get the definition for the directive at this index and, if it is injectable (diPublic),\n          // and matches the given token, return the directive instance.\n          const directiveDef = defs[i] as DirectiveDef<any>;\n          if (directiveDef.type === token && directiveDef.diPublic) {\n            return getDirectiveInstance(node.view.directives ![i]);\n          }\n        }\n      }\n\n      // If we *didn't* find the directive for the token and we are searching the current node's\n      // injector, it's possible the directive is on this node and hasn't been created yet.\n      let instance: T|null;\n      if (injector === di && (instance = searchMatchesQueuedForCreation<T>(node, token))) {\n        return instance;\n      }\n\n      // The def wasn't found anywhere on this node, so it might be a false positive.\n      // Traverse up the tree and continue searching.\n      injector = injector.parent;\n    }\n  }\n\n  // No directive was found for the given token.\n  // TODO: implement optional, check-self, and check-parent.\n  throw createInjectionError('Not found', token);\n}\n\nfunction searchMatchesQueuedForCreation<T>(node: LNode, token: any): T|null {\n  const matches = node.view.tView.currentMatches;\n  if (matches) {\n    for (let i = 0; i < matches.length; i += 2) {\n      const def = matches[i] as DirectiveDef<any>;\n      if (def.type === token) {\n        return resolveDirective(def, i + 1, matches, node.view.tView);\n      }\n    }\n  }\n  return null;\n}\n\n/**\n * Given a directive type, this function returns the bit in an injector's bloom filter\n * that should be used to determine whether or not the directive is present.\n *\n * When the directive was added to the bloom filter, it was given a unique ID that can be\n * retrieved on the class. Since there are only BLOOM_SIZE slots per bloom filter, the directive's\n * ID must be modulo-ed by BLOOM_SIZE to get the correct bloom bit (directives share slots after\n * BLOOM_SIZE is reached).\n *\n * @param type The directive type\n * @returns The bloom bit to check for the directive\n */\nfunction bloomHashBit(type: Type<any>): number|null {\n  let id: number|undefined = (type as any)[NG_ELEMENT_ID];\n  return typeof id === 'number' ? id % BLOOM_SIZE : null;\n}\n\n/**\n * Finds the closest injector that might have a certain directive.\n *\n * Each directive corresponds to a bit in an injector's bloom filter. Given the bloom bit to\n * check and a starting injector, this function traverses up injectors until it finds an\n * injector that contains a 1 for that bit in its bloom filter. A 1 indicates that the\n * injector may have that directive. It only *may* have the directive because directives begin\n * to share bloom filter bits after the BLOOM_SIZE is reached, and it could correspond to a\n * different directive sharing the bit.\n *\n * Note: We can skip checking further injectors up the tree if an injector's cbf structure\n * has a 0 for that bloom bit. Since cbf contains the merged value of all the parent\n * injectors, a 0 in the bloom bit indicates that the parents definitely do not contain\n * the directive and do not need to be checked.\n *\n * @param injector The starting node injector to check\n * @param  bloomBit The bit to check in each injector's bloom filter\n * @returns An injector that might have the directive\n */\nexport function bloomFindPossibleInjector(startInjector: LInjector, bloomBit: number): LInjector|\n    null {\n  // Create a mask that targets the specific bit associated with the directive we're looking for.\n  // JS bit operations are 32 bits, so this will be a number between 2^0 and 2^31, corresponding\n  // to bit positions 0 - 31 in a 32 bit integer.\n  const mask = 1 << bloomBit;\n\n  // Traverse up the injector tree until we find a potential match or until we know there *isn't* a\n  // match.\n  let injector: LInjector|null = startInjector;\n  while (injector) {\n    // Our bloom filter size is 256 bits, which is eight 32-bit bloom filter buckets:\n    // bf0 = [0 - 31], bf1 = [32 - 63], bf2 = [64 - 95], bf3 = [96 - 127], etc.\n    // Get the bloom filter value from the appropriate bucket based on the directive's bloomBit.\n    let value: number;\n    if (bloomBit < 128) {\n      value = bloomBit < 64 ? (bloomBit < 32 ? injector.bf0 : injector.bf1) :\n                              (bloomBit < 96 ? injector.bf2 : injector.bf3);\n    } else {\n      value = bloomBit < 192 ? (bloomBit < 160 ? injector.bf4 : injector.bf5) :\n                               (bloomBit < 224 ? injector.bf6 : injector.bf7);\n    }\n\n    // If the bloom filter value has the bit corresponding to the directive's bloomBit flipped on,\n    // this injector is a potential match.\n    if ((value & mask) === mask) {\n      return injector;\n    }\n\n    // If the current injector does not have the directive, check the bloom filters for the ancestor\n    // injectors (cbf0 - cbf7). These filters capture *all* ancestor injectors.\n    if (bloomBit < 128) {\n      value = bloomBit < 64 ? (bloomBit < 32 ? injector.cbf0 : injector.cbf1) :\n                              (bloomBit < 96 ? injector.cbf2 : injector.cbf3);\n    } else {\n      value = bloomBit < 192 ? (bloomBit < 160 ? injector.cbf4 : injector.cbf5) :\n                               (bloomBit < 224 ? injector.cbf6 : injector.cbf7);\n    }\n\n    // If the ancestor bloom filter value has the bit corresponding to the directive, traverse up to\n    // find the specific injector. If the ancestor bloom filter does not have the bit, we can abort.\n    injector = (value & mask) ? injector.parent : null;\n  }\n  return null;\n}\n\nexport class ReadFromInjectorFn<T> {\n  constructor(readonly read: (injector: LInjector, node: LNode, directiveIndex?: number) => T) {}\n}\n\n/**\n * Creates an ElementRef for a given node injector and stores it on the injector.\n * Or, if the ElementRef already exists, retrieves the existing ElementRef.\n *\n * @param di The node injector where we should store a created ElementRef\n * @returns The ElementRef instance to use\n */\nexport function getOrCreateElementRef(di: LInjector): viewEngine_ElementRef {\n  return di.elementRef || (di.elementRef = new ElementRef(\n                               di.node.type === LNodeType.Container ? null : di.node.native));\n}\n\nexport const QUERY_READ_TEMPLATE_REF = <QueryReadType<viewEngine_TemplateRef<any>>>(\n    new ReadFromInjectorFn<viewEngine_TemplateRef<any>>(\n        (injector: LInjector) => getOrCreateTemplateRef(injector)) as any);\n\nexport const QUERY_READ_CONTAINER_REF = <QueryReadType<viewEngine_ViewContainerRef>>(\n    new ReadFromInjectorFn<viewEngine_ViewContainerRef>(\n        (injector: LInjector) => getOrCreateContainerRef(injector)) as any);\n\nexport const QUERY_READ_ELEMENT_REF =\n    <QueryReadType<viewEngine_ElementRef>>(new ReadFromInjectorFn<viewEngine_ElementRef>(\n        (injector: LInjector) => getOrCreateElementRef(injector)) as any);\n\nexport const QUERY_READ_FROM_NODE =\n    (new ReadFromInjectorFn<any>((injector: LInjector, node: LNode, directiveIdx: number) => {\n      ngDevMode && assertNodeOfPossibleTypes(node, LNodeType.Container, LNodeType.Element);\n      if (directiveIdx > -1) {\n        return node.view.directives ![directiveIdx];\n      } else if (node.type === LNodeType.Element) {\n        return getOrCreateElementRef(injector);\n      } else if (node.type === LNodeType.Container) {\n        return getOrCreateTemplateRef(injector);\n      }\n      throw new Error('fail');\n    }) as any as QueryReadType<any>);\n\n/** A ref to a node's native element. */\nclass ElementRef implements viewEngine_ElementRef {\n  readonly nativeElement: any;\n  constructor(nativeElement: any) { this.nativeElement = nativeElement; }\n}\n\n/**\n * Creates a ViewContainerRef and stores it on the injector. Or, if the ViewContainerRef\n * already exists, retrieves the existing ViewContainerRef.\n *\n * @returns The ViewContainerRef instance to use\n */\nexport function getOrCreateContainerRef(di: LInjector): viewEngine_ViewContainerRef {\n  if (!di.viewContainerRef) {\n    const vcRefHost = di.node;\n\n    ngDevMode && assertNodeOfPossibleTypes(vcRefHost, LNodeType.Container, LNodeType.Element);\n\n    const lContainer = createLContainer(vcRefHost.parent !, vcRefHost.view);\n    const lContainerNode: LContainerNode = createLNodeObject(\n        LNodeType.Container, vcRefHost.view, vcRefHost.parent !, undefined, lContainer, null);\n\n    vcRefHost.dynamicLContainerNode = lContainerNode;\n\n    addToViewTree(vcRefHost.view, lContainer);\n\n    di.viewContainerRef = new ViewContainerRef(lContainerNode);\n  }\n\n  return di.viewContainerRef;\n}\n\n/**\n * A ref to a container that enables adding and removing views from that container\n * imperatively.\n */\nclass ViewContainerRef implements viewEngine_ViewContainerRef {\n  private _viewRefs: viewEngine_ViewRef[] = [];\n  element: viewEngine_ElementRef;\n  injector: Injector;\n  parentInjector: Injector;\n\n  constructor(private _lContainerNode: LContainerNode) {}\n\n  clear(): void {\n    const lContainer = this._lContainerNode.data;\n    while (lContainer.views.length) {\n      this.remove(0);\n    }\n  }\n\n  get(index: number): viewEngine_ViewRef|null { return this._viewRefs[index] || null; }\n\n  get length(): number {\n    const lContainer = this._lContainerNode.data;\n    return lContainer.views.length;\n  }\n\n  createEmbeddedView<C>(templateRef: viewEngine_TemplateRef<C>, context?: C, index?: number):\n      viewEngine_EmbeddedViewRef<C> {\n    const viewRef = templateRef.createEmbeddedView(context || <any>{});\n    this.insert(viewRef, index);\n    return viewRef;\n  }\n\n  createComponent<C>(\n      componentFactory: viewEngine_ComponentFactory<C>, index?: number|undefined,\n      injector?: Injector|undefined, projectableNodes?: any[][]|undefined,\n      ngModule?: viewEngine_NgModuleRef<any>|undefined): viewEngine_ComponentRef<C> {\n    throw notImplemented();\n  }\n\n  insert(viewRef: viewEngine_ViewRef, index?: number): viewEngine_ViewRef {\n    const lViewNode = (viewRef as EmbeddedViewRef<any>)._lViewNode;\n    const adjustedIdx = this._adjustIndex(index);\n\n    insertView(this._lContainerNode, lViewNode, adjustedIdx);\n    // invalidate cache of next sibling RNode (we do similar operation in the containerRefreshEnd\n    // instruction)\n    this._lContainerNode.native = undefined;\n\n    this._viewRefs.splice(adjustedIdx, 0, viewRef);\n\n    (lViewNode as{parent: LNode}).parent = this._lContainerNode;\n\n    // If the view is dynamic (has a template), it needs to be counted both at the container\n    // level and at the node above the container.\n    if (lViewNode.data.template !== null) {\n      // Increment the container view count.\n      this._lContainerNode.data.dynamicViewCount++;\n\n      // Look for the parent node and increment its dynamic view count.\n      if (this._lContainerNode.parent !== null && this._lContainerNode.parent.data !== null) {\n        ngDevMode && assertNodeOfPossibleTypes(\n                         this._lContainerNode.parent, LNodeType.View, LNodeType.Element);\n        this._lContainerNode.parent.data.dynamicViewCount++;\n      }\n    }\n    return viewRef;\n  }\n\n  move(viewRef: viewEngine_ViewRef, newIndex: number): viewEngine_ViewRef {\n    const index = this.indexOf(viewRef);\n    this.detach(index);\n    this.insert(viewRef, this._adjustIndex(newIndex));\n    return viewRef;\n  }\n\n  indexOf(viewRef: viewEngine_ViewRef): number { return this._viewRefs.indexOf(viewRef); }\n\n  remove(index?: number): void {\n    this.detach(index);\n    // TODO(ml): proper destroy of the ViewRef, i.e. recursively destroy the LviewNode and its\n    // children, delete DOM nodes and QueryList, trigger hooks (onDestroy), destroy the renderer,\n    // detach projected nodes\n  }\n\n  detach(index?: number): viewEngine_ViewRef|null {\n    const adjustedIdx = this._adjustIndex(index, -1);\n    removeView(this._lContainerNode, adjustedIdx);\n    return this._viewRefs.splice(adjustedIdx, 1)[0] || null;\n  }\n\n  private _adjustIndex(index?: number, shift: number = 0) {\n    if (index == null) {\n      return this._lContainerNode.data.views.length + shift;\n    }\n    if (ngDevMode) {\n      assertGreaterThan(index, -1, 'index must be positive');\n      // +1 because it's legal to insert at the end.\n      assertLessThan(index, this._lContainerNode.data.views.length + 1 + shift, 'index');\n    }\n    return index;\n  }\n}\n\n/**\n * Creates a TemplateRef and stores it on the injector. Or, if the TemplateRef already\n * exists, retrieves the existing TemplateRef.\n *\n * @param di The node injector where we should store a created TemplateRef\n * @returns The TemplateRef instance to use\n */\nexport function getOrCreateTemplateRef<T>(di: LInjector): viewEngine_TemplateRef<T> {\n  ngDevMode && assertNodeType(di.node, LNodeType.Container);\n  const data = (di.node as LContainerNode).data;\n  return di.templateRef || (di.templateRef = new TemplateRef<any>(\n                                getOrCreateElementRef(di), data.template !, getRenderer()));\n}\n\nclass TemplateRef<T> implements viewEngine_TemplateRef<T> {\n  readonly elementRef: viewEngine_ElementRef;\n  private _template: ComponentTemplate<T>;\n\n  constructor(\n      elementRef: viewEngine_ElementRef, template: ComponentTemplate<T>,\n      private _renderer: Renderer3) {\n    this.elementRef = elementRef;\n    this._template = template;\n  }\n\n  createEmbeddedView(context: T): viewEngine_EmbeddedViewRef<T> {\n    const viewNode = renderEmbeddedTemplate(null, this._template, context, this._renderer);\n    return addDestroyable(new EmbeddedViewRef(viewNode, this._template, context));\n  }\n}\n"]}
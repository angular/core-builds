{"version":3,"file":"injector.js","sourceRoot":"","sources":["../../../../../../packages/core/src/di/injector.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '../type';\nimport {stringify} from '../util';\n\nimport {InjectableDef, defineInjectable} from './defs';\nimport {resolveForwardRef} from './forward_ref';\nimport {InjectionToken} from './injection_token';\nimport {Inject, Optional, Self, SkipSelf} from './metadata';\nimport {ConstructorProvider, ExistingProvider, FactoryProvider, StaticClassProvider, StaticProvider, ValueProvider} from './provider';\n\nexport const SOURCE = '__source';\nconst _THROW_IF_NOT_FOUND = new Object();\nexport const THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;\n\n/**\n * An InjectionToken that gets the current `Injector` for `createInjector()`-style injectors.\n *\n * Requesting this token instead of `Injector` allows `StaticInjector` to be tree-shaken from a\n * project.\n *\n * @experimental\n */\nexport const INJECTOR = new InjectionToken<Injector>('INJECTOR');\n\nexport class NullInjector implements Injector {\n  get(token: any, notFoundValue: any = _THROW_IF_NOT_FOUND): any {\n    if (notFoundValue === _THROW_IF_NOT_FOUND) {\n      throw new Error(`NullInjectorError: No provider for ${stringify(token)}!`);\n    }\n    return notFoundValue;\n  }\n}\n\n/**\n * @whatItDoes Injector interface\n * @howToUse\n * ```\n * const injector: Injector = ...;\n * injector.get(...);\n * ```\n *\n * @description\n * For more details, see the {@linkDocs guide/dependency-injection \"Dependency Injection Guide\"}.\n *\n * ### Example\n *\n * {@example core/di/ts/injector_spec.ts region='Injector'}\n *\n * `Injector` returns itself when given `Injector` as a token:\n * {@example core/di/ts/injector_spec.ts region='injectInjector'}\n *\n * @stable\n */\nexport abstract class Injector {\n  static THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;\n  static NULL: Injector = new NullInjector();\n\n  /**\n   * Retrieves an instance from the injector based on the provided token.\n   * If not found:\n   * - Throws an error if no `notFoundValue` that is not equal to\n   * Injector.THROW_IF_NOT_FOUND is given\n   * - Returns the `notFoundValue` otherwise\n   */\n  abstract get<T>(token: Type<T>|InjectionToken<T>, notFoundValue?: T, flags?: InjectFlags): T;\n  /**\n   * @deprecated from v4.0.0 use Type<T> or InjectionToken<T>\n   * @suppress {duplicate}\n   */\n  abstract get(token: any, notFoundValue?: any): any;\n\n  /**\n   * @deprecated from v5 use the new signature Injector.create(options)\n   */\n  static create(providers: StaticProvider[], parent?: Injector): Injector;\n\n  static create(options: {providers: StaticProvider[], parent?: Injector, name?: string}): Injector;\n\n  /**\n   * Create a new Injector which is configure using `StaticProvider`s.\n   *\n   * ### Example\n   *\n   * {@example core/di/ts/provider_spec.ts region='ConstructorProvider'}\n   */\n  static create(\n      options: StaticProvider[]|{providers: StaticProvider[], parent?: Injector, name?: string},\n      parent?: Injector): Injector {\n    if (Array.isArray(options)) {\n      return new StaticInjector(options, parent);\n    } else {\n      return new StaticInjector(options.providers, options.parent, options.name || null);\n    }\n  }\n\n  static ngInjectableDef = defineInjectable({\n    providedIn: 'any' as any,\n    factory: () => inject(INJECTOR),\n  });\n}\n\n\n\nconst IDENT = function<T>(value: T): T {\n  return value;\n};\nconst EMPTY = <any[]>[];\nconst CIRCULAR = IDENT;\nconst MULTI_PROVIDER_FN = function(): any[] {\n  return Array.prototype.slice.call(arguments);\n};\nconst GET_PROPERTY_NAME = {} as any;\nexport const USE_VALUE =\n    getClosureSafeProperty<ValueProvider>({provide: String, useValue: GET_PROPERTY_NAME});\nconst NG_TOKEN_PATH = 'ngTokenPath';\nconst NG_TEMP_TOKEN_PATH = 'ngTempTokenPath';\nconst enum OptionFlags {\n  Optional = 1 << 0,\n  CheckSelf = 1 << 1,\n  CheckParent = 1 << 2,\n  Default = CheckSelf | CheckParent\n}\nconst NULL_INJECTOR = Injector.NULL;\nconst NEW_LINE = /\\n/gm;\nconst NO_NEW_LINE = 'Éµ';\n\nexport class StaticInjector implements Injector {\n  readonly parent: Injector;\n  readonly source: string|null;\n\n  private _records: Map<any, Record>;\n\n  constructor(\n      providers: StaticProvider[], parent: Injector = NULL_INJECTOR, source: string|null = null) {\n    this.parent = parent;\n    this.source = source;\n    const records = this._records = new Map<any, Record>();\n    records.set(\n        Injector, <Record>{token: Injector, fn: IDENT, deps: EMPTY, value: this, useNew: false});\n    records.set(\n        INJECTOR, <Record>{token: INJECTOR, fn: IDENT, deps: EMPTY, value: this, useNew: false});\n    recursivelyProcessProviders(records, providers);\n  }\n\n  get<T>(token: Type<T>|InjectionToken<T>, notFoundValue?: T, flags?: InjectFlags): T;\n  get(token: any, notFoundValue?: any): any;\n  get(token: any, notFoundValue?: any, flags: InjectFlags = InjectFlags.Default): any {\n    const record = this._records.get(token);\n    try {\n      return tryResolveToken(token, record, this._records, this.parent, notFoundValue, flags);\n    } catch (e) {\n      const tokenPath: any[] = e[NG_TEMP_TOKEN_PATH];\n      if (token[SOURCE]) {\n        tokenPath.unshift(token[SOURCE]);\n      }\n      e.message = formatError('\\n' + e.message, tokenPath, this.source);\n      e[NG_TOKEN_PATH] = tokenPath;\n      e[NG_TEMP_TOKEN_PATH] = null;\n      throw e;\n    }\n  }\n\n  toString() {\n    const tokens = <string[]>[], records = this._records;\n    records.forEach((v, token) => tokens.push(stringify(token)));\n    return `StaticInjector[${tokens.join(', ')}]`;\n  }\n}\n\ntype SupportedProvider =\n    ValueProvider | ExistingProvider | StaticClassProvider | ConstructorProvider | FactoryProvider;\n\ninterface Record {\n  fn: Function;\n  useNew: boolean;\n  deps: DependencyRecord[];\n  value: any;\n}\n\ninterface DependencyRecord {\n  token: any;\n  options: number;\n}\n\ntype TokenPath = Array<any>;\n\nfunction resolveProvider(provider: SupportedProvider): Record {\n  const deps = computeDeps(provider);\n  let fn: Function = IDENT;\n  let value: any = EMPTY;\n  let useNew: boolean = false;\n  let provide = resolveForwardRef(provider.provide);\n  if (USE_VALUE in provider) {\n    // We need to use USE_VALUE in provider since provider.useValue could be defined as undefined.\n    value = (provider as ValueProvider).useValue;\n  } else if ((provider as FactoryProvider).useFactory) {\n    fn = (provider as FactoryProvider).useFactory;\n  } else if ((provider as ExistingProvider).useExisting) {\n    // Just use IDENT\n  } else if ((provider as StaticClassProvider).useClass) {\n    useNew = true;\n    fn = resolveForwardRef((provider as StaticClassProvider).useClass);\n  } else if (typeof provide == 'function') {\n    useNew = true;\n    fn = provide;\n  } else {\n    throw staticError(\n        'StaticProvider does not have [useValue|useFactory|useExisting|useClass] or [provide] is not newable',\n        provider);\n  }\n  return {deps, fn, useNew, value};\n}\n\nfunction multiProviderMixError(token: any) {\n  return staticError('Cannot mix multi providers and regular providers', token);\n}\n\nfunction recursivelyProcessProviders(records: Map<any, Record>, provider: StaticProvider) {\n  if (provider) {\n    provider = resolveForwardRef(provider);\n    if (provider instanceof Array) {\n      // if we have an array recurse into the array\n      for (let i = 0; i < provider.length; i++) {\n        recursivelyProcessProviders(records, provider[i]);\n      }\n    } else if (typeof provider === 'function') {\n      // Functions were supported in ReflectiveInjector, but are not here. For safety give useful\n      // error messages\n      throw staticError('Function/Class not supported', provider);\n    } else if (provider && typeof provider === 'object' && provider.provide) {\n      // At this point we have what looks like a provider: {provide: ?, ....}\n      let token = resolveForwardRef(provider.provide);\n      const resolvedProvider = resolveProvider(provider);\n      if (provider.multi === true) {\n        // This is a multi provider.\n        let multiProvider: Record|undefined = records.get(token);\n        if (multiProvider) {\n          if (multiProvider.fn !== MULTI_PROVIDER_FN) {\n            throw multiProviderMixError(token);\n          }\n        } else {\n          // Create a placeholder factory which will look up the constituents of the multi provider.\n          records.set(token, multiProvider = <Record>{\n            token: provider.provide,\n            deps: [],\n            useNew: false,\n            fn: MULTI_PROVIDER_FN,\n            value: EMPTY\n          });\n        }\n        // Treat the provider as the token.\n        token = provider;\n        multiProvider.deps.push({token, options: OptionFlags.Default});\n      }\n      const record = records.get(token);\n      if (record && record.fn == MULTI_PROVIDER_FN) {\n        throw multiProviderMixError(token);\n      }\n      records.set(token, resolvedProvider);\n    } else {\n      throw staticError('Unexpected provider', provider);\n    }\n  }\n}\n\nfunction tryResolveToken(\n    token: any, record: Record | undefined, records: Map<any, Record>, parent: Injector,\n    notFoundValue: any, flags: InjectFlags): any {\n  try {\n    return resolveToken(token, record, records, parent, notFoundValue, flags);\n  } catch (e) {\n    // ensure that 'e' is of type Error.\n    if (!(e instanceof Error)) {\n      e = new Error(e);\n    }\n    const path: any[] = e[NG_TEMP_TOKEN_PATH] = e[NG_TEMP_TOKEN_PATH] || [];\n    path.unshift(token);\n    if (record && record.value == CIRCULAR) {\n      // Reset the Circular flag.\n      record.value = EMPTY;\n    }\n    throw e;\n  }\n}\n\nfunction resolveToken(\n    token: any, record: Record | undefined, records: Map<any, Record>, parent: Injector,\n    notFoundValue: any, flags: InjectFlags): any {\n  let value;\n  if (record && !(flags & InjectFlags.SkipSelf)) {\n    // If we don't have a record, this implies that we don't own the provider hence don't know how\n    // to resolve it.\n    value = record.value;\n    if (value == CIRCULAR) {\n      throw Error(NO_NEW_LINE + 'Circular dependency');\n    } else if (value === EMPTY) {\n      record.value = CIRCULAR;\n      let obj = undefined;\n      let useNew = record.useNew;\n      let fn = record.fn;\n      let depRecords = record.deps;\n      let deps = EMPTY;\n      if (depRecords.length) {\n        deps = [];\n        for (let i = 0; i < depRecords.length; i++) {\n          const depRecord: DependencyRecord = depRecords[i];\n          const options = depRecord.options;\n          const childRecord =\n              options & OptionFlags.CheckSelf ? records.get(depRecord.token) : undefined;\n          deps.push(tryResolveToken(\n              // Current Token to resolve\n              depRecord.token,\n              // A record which describes how to resolve the token.\n              // If undefined, this means we don't have such a record\n              childRecord,\n              // Other records we know about.\n              records,\n              // If we don't know how to resolve dependency and we should not check parent for it,\n              // than pass in Null injector.\n              !childRecord && !(options & OptionFlags.CheckParent) ? NULL_INJECTOR : parent,\n              options & OptionFlags.Optional ? null : Injector.THROW_IF_NOT_FOUND,\n              InjectFlags.Default));\n        }\n      }\n      record.value = value = useNew ? new (fn as any)(...deps) : fn.apply(obj, deps);\n    }\n  } else if (!(flags & InjectFlags.Self)) {\n    value = parent.get(token, notFoundValue, InjectFlags.Default);\n  }\n  return value;\n}\n\n\nfunction computeDeps(provider: StaticProvider): DependencyRecord[] {\n  let deps: DependencyRecord[] = EMPTY;\n  const providerDeps: any[] =\n      (provider as ExistingProvider & StaticClassProvider & ConstructorProvider).deps;\n  if (providerDeps && providerDeps.length) {\n    deps = [];\n    for (let i = 0; i < providerDeps.length; i++) {\n      let options = OptionFlags.Default;\n      let token = resolveForwardRef(providerDeps[i]);\n      if (token instanceof Array) {\n        for (let j = 0, annotations = token; j < annotations.length; j++) {\n          const annotation = annotations[j];\n          if (annotation instanceof Optional || annotation == Optional) {\n            options = options | OptionFlags.Optional;\n          } else if (annotation instanceof SkipSelf || annotation == SkipSelf) {\n            options = options & ~OptionFlags.CheckSelf;\n          } else if (annotation instanceof Self || annotation == Self) {\n            options = options & ~OptionFlags.CheckParent;\n          } else if (annotation instanceof Inject) {\n            token = (annotation as Inject).token;\n          } else {\n            token = resolveForwardRef(annotation);\n          }\n        }\n      }\n      deps.push({token, options});\n    }\n  } else if ((provider as ExistingProvider).useExisting) {\n    const token = resolveForwardRef((provider as ExistingProvider).useExisting);\n    deps = [{token, options: OptionFlags.Default}];\n  } else if (!providerDeps && !(USE_VALUE in provider)) {\n    // useValue & useExisting are the only ones which are exempt from deps all others need it.\n    throw staticError('\\'deps\\' required', provider);\n  }\n  return deps;\n}\n\nfunction formatError(text: string, obj: any, source: string | null = null): string {\n  text = text && text.charAt(0) === '\\n' && text.charAt(1) == NO_NEW_LINE ? text.substr(2) : text;\n  let context = stringify(obj);\n  if (obj instanceof Array) {\n    context = obj.map(stringify).join(' -> ');\n  } else if (typeof obj === 'object') {\n    let parts = <string[]>[];\n    for (let key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        let value = obj[key];\n        parts.push(\n            key + ':' + (typeof value === 'string' ? JSON.stringify(value) : stringify(value)));\n      }\n    }\n    context = `{${parts.join(', ')}}`;\n  }\n  return `StaticInjectorError${source ? '(' + source + ')' : ''}[${context}]: ${text.replace(NEW_LINE, '\\n  ')}`;\n}\n\nfunction staticError(text: string, obj: any): Error {\n  return new Error(formatError(text, obj));\n}\n\nfunction getClosureSafeProperty<T>(objWithPropertyToExtract: T): string {\n  for (let key in objWithPropertyToExtract) {\n    if (objWithPropertyToExtract[key] === GET_PROPERTY_NAME) {\n      return key;\n    }\n  }\n  throw Error('!prop');\n}\n\n/**\n * Injection flags for DI.\n *\n * @stable\n */\nexport const enum InjectFlags {\n  Default = 0,\n\n  /** Skip the node that is requesting injection. */\n  SkipSelf = 1 << 0,\n  /** Don't descend into ancestors of the node requesting injection. */\n  Self = 1 << 1,\n}\n\nlet _currentInjector: Injector|null = null;\n\nexport function setCurrentInjector(injector: Injector | null): Injector|null {\n  const former = _currentInjector;\n  _currentInjector = injector;\n  return former;\n}\n\n/**\n * Injects a token from the currently active injector.\n *\n * This function must be used in the context of a factory function such as one defined for an\n * `InjectionToken`, and will throw an error if not called from such a context. For example:\n *\n * {@example core/di/ts/injector_spec.ts region='ShakeableInjectionToken'}\n *\n * Within such a factory function `inject` is utilized to request injection of a dependency, instead\n * of providing an additional array of dependencies as was common to do with `useFactory` providers.\n * `inject` is faster and more type-safe.\n *\n * @experimental\n */\nexport function inject<T>(\n    token: Type<T>| InjectionToken<T>, notFoundValue?: undefined, flags?: InjectFlags): T;\nexport function inject<T>(\n    token: Type<T>| InjectionToken<T>, notFoundValue: T, flags?: InjectFlags): T;\nexport function inject<T>(\n    token: Type<T>| InjectionToken<T>, notFoundValue: null, flags?: InjectFlags): T|null;\nexport function inject<T>(\n    token: Type<T>| InjectionToken<T>, notFoundValue?: T | null, flags = InjectFlags.Default): T|\n    null {\n  if (_currentInjector === null) {\n    throw new Error(`inject() must be called from an injection context`);\n  }\n  return _currentInjector.get(token, notFoundValue, flags);\n}\n\nexport function injectArgs(types: (Type<any>| InjectionToken<any>| any[])[]): any[] {\n  const args: any[] = [];\n  for (let i = 0; i < types.length; i++) {\n    const arg = types[i];\n    if (Array.isArray(arg)) {\n      if (arg.length === 0) {\n        throw new Error('Arguments array must have arguments.');\n      }\n      let type: Type<any>|undefined = undefined;\n      let defaultValue: null|undefined = undefined;\n      let flags: InjectFlags = InjectFlags.Default;\n\n      for (let j = 0; j < arg.length; j++) {\n        const meta = arg[j];\n        if (meta instanceof Optional || meta.__proto__.ngMetadataName === 'Optional') {\n          defaultValue = null;\n        } else if (meta instanceof SkipSelf || meta.__proto__.ngMetadataName === 'SkipSelf') {\n          flags |= InjectFlags.SkipSelf;\n        } else if (meta instanceof Self || meta.__proto__.ngMetadataName === 'Self') {\n          flags |= InjectFlags.Self;\n        } else if (meta instanceof Inject) {\n          type = meta.token;\n        } else {\n          type = meta;\n        }\n      }\n\n      args.push(inject(type !, defaultValue, InjectFlags.Default));\n    } else {\n      args.push(inject(arg));\n    }\n  }\n  return args;\n}\n"]}
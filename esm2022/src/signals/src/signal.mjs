/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { createSignalFromFunction, defaultEquals } from './api';
import { ReactiveNode } from './graph';
class WritableSignalImpl extends ReactiveNode {
    constructor(value, equal) {
        super();
        this.value = value;
        this.equal = equal;
    }
    onConsumerDependencyMayHaveChanged() {
        // This never happens for writable signals as they're not consumers.
    }
    onProducerUpdateValueVersion() {
        // Writable signal value versions are always up to date.
    }
    /**
     * Directly update the value of the signal to a new value, which may or may not be
     * equal to the previous.
     *
     * In the event that `newValue` is semantically equal to the current value, `set` is
     * a no-op.
     */
    set(newValue) {
        if (!this.equal(this.value, newValue)) {
            this.value = newValue;
            this.valueVersion++;
            this.producerMayHaveChanged();
        }
    }
    /**
     * Derive a new value for the signal from its current value using the `updater` function.
     *
     * This is equivalent to calling `set` on the result of running `updater` on the current
     * value.
     */
    update(updater) {
        this.set(updater(this.value));
    }
    /**
     * Calls `mutator` on the current value and assumes that it has been mutated.
     */
    mutate(mutator) {
        // Mutate bypasses equality checks as it's by definition changing the value.
        mutator(this.value);
        this.valueVersion++;
        this.producerMayHaveChanged();
    }
    signal() {
        this.producerAccessed();
        return this.value;
    }
}
/**
 * Create a `Signal` that can be set or updated directly.
 *
 * @developerPreview
 */
export function signal(initialValue, options) {
    const signalNode = new WritableSignalImpl(initialValue, options?.equal ?? defaultEquals);
    // Casting here is required for g3, as TS inference behavior is slightly different between our
    // version/options and g3's.
    const signalFn = createSignalFromFunction(signalNode, signalNode.signal.bind(signalNode), {
        set: signalNode.set.bind(signalNode),
        update: signalNode.update.bind(signalNode),
        mutate: signalNode.mutate.bind(signalNode),
    });
    return signalFn;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2lnbmFsLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvY29yZS9zcmMvc2lnbmFscy9zcmMvc2lnbmFsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7R0FNRztBQUVILE9BQU8sRUFBQyx3QkFBd0IsRUFBZ0IsYUFBYSxFQUEwQixNQUFNLE9BQU8sQ0FBQztBQUNyRyxPQUFPLEVBQUMsWUFBWSxFQUFDLE1BQU0sU0FBUyxDQUFDO0FBMEJyQyxNQUFNLGtCQUFzQixTQUFRLFlBQVk7SUFDOUMsWUFBb0IsS0FBUSxFQUFVLEtBQXlCO1FBQzdELEtBQUssRUFBRSxDQUFDO1FBRFUsVUFBSyxHQUFMLEtBQUssQ0FBRztRQUFVLFVBQUssR0FBTCxLQUFLLENBQW9CO0lBRS9ELENBQUM7SUFFa0Isa0NBQWtDO1FBQ25ELG9FQUFvRTtJQUN0RSxDQUFDO0lBRWtCLDRCQUE0QjtRQUM3Qyx3REFBd0Q7SUFDMUQsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNILEdBQUcsQ0FBQyxRQUFXO1FBQ2IsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxRQUFRLENBQUMsRUFBRTtZQUNyQyxJQUFJLENBQUMsS0FBSyxHQUFHLFFBQVEsQ0FBQztZQUN0QixJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7WUFDcEIsSUFBSSxDQUFDLHNCQUFzQixFQUFFLENBQUM7U0FDL0I7SUFDSCxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxNQUFNLENBQUMsT0FBd0I7UUFDN0IsSUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7SUFDaEMsQ0FBQztJQUVEOztPQUVHO0lBQ0gsTUFBTSxDQUFDLE9BQTJCO1FBQ2hDLDRFQUE0RTtRQUM1RSxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ3BCLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQztRQUNwQixJQUFJLENBQUMsc0JBQXNCLEVBQUUsQ0FBQztJQUNoQyxDQUFDO0lBRUQsTUFBTTtRQUNKLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO1FBQ3hCLE9BQU8sSUFBSSxDQUFDLEtBQW1DLENBQUM7SUFDbEQsQ0FBQztDQUNGO0FBY0Q7Ozs7R0FJRztBQUNILE1BQU0sVUFBVSxNQUFNLENBQUksWUFBZSxFQUFFLE9BQWdDO0lBQ3pFLE1BQU0sVUFBVSxHQUFHLElBQUksa0JBQWtCLENBQUMsWUFBWSxFQUFFLE9BQU8sRUFBRSxLQUFLLElBQUksYUFBYSxDQUFDLENBQUM7SUFFekYsOEZBQThGO0lBQzlGLDRCQUE0QjtJQUM1QixNQUFNLFFBQVEsR0FBRyx3QkFBd0IsQ0FBQyxVQUFVLEVBQUUsVUFBVSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLEVBQUU7UUFDdkUsR0FBRyxFQUFFLFVBQVUsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQztRQUNwQyxNQUFNLEVBQUUsVUFBVSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDO1FBQzFDLE1BQU0sRUFBRSxVQUFVLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUM7S0FDM0MsQ0FBaUMsQ0FBQztJQUNwRCxPQUFPLFFBQVEsQ0FBQztBQUNsQixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbmltcG9ydCB7Y3JlYXRlU2lnbmFsRnJvbUZ1bmN0aW9uLCBEZWVwUmVhZG9ubHksIGRlZmF1bHRFcXVhbHMsIFNpZ25hbCwgVmFsdWVFcXVhbGl0eUZufSBmcm9tICcuL2FwaSc7XG5pbXBvcnQge1JlYWN0aXZlTm9kZX0gZnJvbSAnLi9ncmFwaCc7XG5cbi8qKlxuICogQSBgU2lnbmFsYCB3aXRoIGEgdmFsdWUgdGhhdCBjYW4gYmUgbXV0YXRlZCB2aWEgYSBzZXR0ZXIgaW50ZXJmYWNlLlxuICpcbiAqIEBkZXZlbG9wZXJQcmV2aWV3XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgV3JpdGFibGVTaWduYWw8VD4gZXh0ZW5kcyBTaWduYWw8VD4ge1xuICAvKipcbiAgICogRGlyZWN0bHkgc2V0IHRoZSBzaWduYWwgdG8gYSBuZXcgdmFsdWUsIGFuZCBub3RpZnkgYW55IGRlcGVuZGVudHMuXG4gICAqL1xuICBzZXQodmFsdWU6IFQpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIHZhbHVlIG9mIHRoZSBzaWduYWwgYmFzZWQgb24gaXRzIGN1cnJlbnQgdmFsdWUsIGFuZFxuICAgKiBub3RpZnkgYW55IGRlcGVuZGVudHMuXG4gICAqL1xuICB1cGRhdGUodXBkYXRlRm46ICh2YWx1ZTogVCkgPT4gVCk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgY3VycmVudCB2YWx1ZSBieSBtdXRhdGluZyBpdCBpbi1wbGFjZSwgYW5kXG4gICAqIG5vdGlmeSBhbnkgZGVwZW5kZW50cy5cbiAgICovXG4gIG11dGF0ZShtdXRhdG9yRm46ICh2YWx1ZTogVCkgPT4gdm9pZCk6IHZvaWQ7XG59XG5cbmNsYXNzIFdyaXRhYmxlU2lnbmFsSW1wbDxUPiBleHRlbmRzIFJlYWN0aXZlTm9kZSB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgdmFsdWU6IFQsIHByaXZhdGUgZXF1YWw6IFZhbHVlRXF1YWxpdHlGbjxUPikge1xuICAgIHN1cGVyKCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgb3ZlcnJpZGUgb25Db25zdW1lckRlcGVuZGVuY3lNYXlIYXZlQ2hhbmdlZCgpOiB2b2lkIHtcbiAgICAvLyBUaGlzIG5ldmVyIGhhcHBlbnMgZm9yIHdyaXRhYmxlIHNpZ25hbHMgYXMgdGhleSdyZSBub3QgY29uc3VtZXJzLlxuICB9XG5cbiAgcHJvdGVjdGVkIG92ZXJyaWRlIG9uUHJvZHVjZXJVcGRhdGVWYWx1ZVZlcnNpb24oKTogdm9pZCB7XG4gICAgLy8gV3JpdGFibGUgc2lnbmFsIHZhbHVlIHZlcnNpb25zIGFyZSBhbHdheXMgdXAgdG8gZGF0ZS5cbiAgfVxuXG4gIC8qKlxuICAgKiBEaXJlY3RseSB1cGRhdGUgdGhlIHZhbHVlIG9mIHRoZSBzaWduYWwgdG8gYSBuZXcgdmFsdWUsIHdoaWNoIG1heSBvciBtYXkgbm90IGJlXG4gICAqIGVxdWFsIHRvIHRoZSBwcmV2aW91cy5cbiAgICpcbiAgICogSW4gdGhlIGV2ZW50IHRoYXQgYG5ld1ZhbHVlYCBpcyBzZW1hbnRpY2FsbHkgZXF1YWwgdG8gdGhlIGN1cnJlbnQgdmFsdWUsIGBzZXRgIGlzXG4gICAqIGEgbm8tb3AuXG4gICAqL1xuICBzZXQobmV3VmFsdWU6IFQpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuZXF1YWwodGhpcy52YWx1ZSwgbmV3VmFsdWUpKSB7XG4gICAgICB0aGlzLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgICB0aGlzLnZhbHVlVmVyc2lvbisrO1xuICAgICAgdGhpcy5wcm9kdWNlck1heUhhdmVDaGFuZ2VkKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERlcml2ZSBhIG5ldyB2YWx1ZSBmb3IgdGhlIHNpZ25hbCBmcm9tIGl0cyBjdXJyZW50IHZhbHVlIHVzaW5nIHRoZSBgdXBkYXRlcmAgZnVuY3Rpb24uXG4gICAqXG4gICAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byBjYWxsaW5nIGBzZXRgIG9uIHRoZSByZXN1bHQgb2YgcnVubmluZyBgdXBkYXRlcmAgb24gdGhlIGN1cnJlbnRcbiAgICogdmFsdWUuXG4gICAqL1xuICB1cGRhdGUodXBkYXRlcjogKHZhbHVlOiBUKSA9PiBUKTogdm9pZCB7XG4gICAgdGhpcy5zZXQodXBkYXRlcih0aGlzLnZhbHVlKSk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbHMgYG11dGF0b3JgIG9uIHRoZSBjdXJyZW50IHZhbHVlIGFuZCBhc3N1bWVzIHRoYXQgaXQgaGFzIGJlZW4gbXV0YXRlZC5cbiAgICovXG4gIG11dGF0ZShtdXRhdG9yOiAodmFsdWU6IFQpID0+IHZvaWQpOiB2b2lkIHtcbiAgICAvLyBNdXRhdGUgYnlwYXNzZXMgZXF1YWxpdHkgY2hlY2tzIGFzIGl0J3MgYnkgZGVmaW5pdGlvbiBjaGFuZ2luZyB0aGUgdmFsdWUuXG4gICAgbXV0YXRvcih0aGlzLnZhbHVlKTtcbiAgICB0aGlzLnZhbHVlVmVyc2lvbisrO1xuICAgIHRoaXMucHJvZHVjZXJNYXlIYXZlQ2hhbmdlZCgpO1xuICB9XG5cbiAgc2lnbmFsKCk6IERlZXBSZWFkb25seTxUPiB7XG4gICAgdGhpcy5wcm9kdWNlckFjY2Vzc2VkKCk7XG4gICAgcmV0dXJuIHRoaXMudmFsdWUgYXMgdW5rbm93biBhcyBEZWVwUmVhZG9ubHk8VD47XG4gIH1cbn1cblxuLyoqXG4gKiBPcHRpb25zIHBhc3NlZCB0byB0aGUgYHNpZ25hbGAgY3JlYXRpb24gZnVuY3Rpb24uXG4gKlxuICogQGRldmVsb3BlclByZXZpZXdcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDcmVhdGVTaWduYWxPcHRpb25zPFQ+IHtcbiAgLyoqXG4gICAqIEEgY29tcGFyaXNvbiBmdW5jdGlvbiB3aGljaCBkZWZpbmVzIGVxdWFsaXR5IGZvciBzaWduYWwgdmFsdWVzLlxuICAgKi9cbiAgZXF1YWw/OiBWYWx1ZUVxdWFsaXR5Rm48VD47XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgYFNpZ25hbGAgdGhhdCBjYW4gYmUgc2V0IG9yIHVwZGF0ZWQgZGlyZWN0bHkuXG4gKlxuICogQGRldmVsb3BlclByZXZpZXdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNpZ25hbDxUPihpbml0aWFsVmFsdWU6IFQsIG9wdGlvbnM/OiBDcmVhdGVTaWduYWxPcHRpb25zPFQ+KTogV3JpdGFibGVTaWduYWw8VD4ge1xuICBjb25zdCBzaWduYWxOb2RlID0gbmV3IFdyaXRhYmxlU2lnbmFsSW1wbChpbml0aWFsVmFsdWUsIG9wdGlvbnM/LmVxdWFsID8/IGRlZmF1bHRFcXVhbHMpO1xuXG4gIC8vIENhc3RpbmcgaGVyZSBpcyByZXF1aXJlZCBmb3IgZzMsIGFzIFRTIGluZmVyZW5jZSBiZWhhdmlvciBpcyBzbGlnaHRseSBkaWZmZXJlbnQgYmV0d2VlbiBvdXJcbiAgLy8gdmVyc2lvbi9vcHRpb25zIGFuZCBnMydzLlxuICBjb25zdCBzaWduYWxGbiA9IGNyZWF0ZVNpZ25hbEZyb21GdW5jdGlvbihzaWduYWxOb2RlLCBzaWduYWxOb2RlLnNpZ25hbC5iaW5kKHNpZ25hbE5vZGUpLCB7XG4gICAgICAgICAgICAgICAgICAgICBzZXQ6IHNpZ25hbE5vZGUuc2V0LmJpbmQoc2lnbmFsTm9kZSksXG4gICAgICAgICAgICAgICAgICAgICB1cGRhdGU6IHNpZ25hbE5vZGUudXBkYXRlLmJpbmQoc2lnbmFsTm9kZSksXG4gICAgICAgICAgICAgICAgICAgICBtdXRhdGU6IHNpZ25hbE5vZGUubXV0YXRlLmJpbmQoc2lnbmFsTm9kZSksXG4gICAgICAgICAgICAgICAgICAgfSkgYXMgdW5rbm93biBhcyBXcml0YWJsZVNpZ25hbDxUPjtcbiAgcmV0dXJuIHNpZ25hbEZuO1xufVxuIl19
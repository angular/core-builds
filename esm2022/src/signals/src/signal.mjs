/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { createSignalFromFunction, defaultEquals } from './api';
import { nextReactiveId, producerAccessed, producerNotifyConsumers } from './graph';
import { newWeakRef } from './weak_ref';
/**
 * Backing type for a `SettableSignal`, a mutable reactive value.
 */
class SettableSignalImpl {
    constructor(value, equal) {
        this.value = value;
        this.equal = equal;
        this.id = nextReactiveId();
        this.ref = newWeakRef(this);
        this.consumers = new Map();
        this.valueVersion = 0;
    }
    checkForChangedValue() {
        // Settable signals can only change when set, so there's nothing to check here.
    }
    /**
     * Directly update the value of the signal to a new value, which may or may not be
     * equal to the previous.
     *
     * In the event that `newValue` is semantically equal to the current value, `set` is
     * a no-op.
     */
    set(newValue) {
        if (!this.equal(this.value, newValue)) {
            this.value = newValue;
            this.valueVersion++;
            producerNotifyConsumers(this);
        }
    }
    /**
     * Derive a new value for the signal from its current value using the `updater` function.
     *
     * This is equivalent to calling `set` on the result of running `updater` on the current
     * value.
     */
    update(updater) {
        this.set(updater(this.value));
    }
    /**
     * Calls `mutator` on the current value and assumes that it has been mutated.
     */
    mutate(mutator) {
        // Mutate bypasses equality checks as it's by definition changing the value.
        mutator(this.value);
        this.valueVersion++;
        producerNotifyConsumers(this);
    }
    signal() {
        producerAccessed(this);
        return this.value;
    }
}
/**
 * Create a `Signal` that can be set or updated directly.
 *
 * @developerPreview
 */
export function signal(initialValue, equal = defaultEquals) {
    const signalNode = new SettableSignalImpl(initialValue, equal);
    // Casting here is required for g3.
    const signalFn = createSignalFromFunction(signalNode.signal.bind(signalNode), {
        set: signalNode.set.bind(signalNode),
        update: signalNode.update.bind(signalNode),
        mutate: signalNode.mutate.bind(signalNode),
    });
    return signalFn;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2lnbmFsLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvY29yZS9zcmMvc2lnbmFscy9zcmMvc2lnbmFsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7R0FNRztBQUVILE9BQU8sRUFBQyx3QkFBd0IsRUFBRSxhQUFhLEVBQTBCLE1BQU0sT0FBTyxDQUFDO0FBQ3ZGLE9BQU8sRUFBbUIsY0FBYyxFQUFZLGdCQUFnQixFQUFFLHVCQUF1QixFQUFDLE1BQU0sU0FBUyxDQUFDO0FBQzlHLE9BQU8sRUFBQyxVQUFVLEVBQVUsTUFBTSxZQUFZLENBQUM7QUEwQi9DOztHQUVHO0FBQ0gsTUFBTSxrQkFBa0I7SUFDdEIsWUFBb0IsS0FBUSxFQUFVLEtBQXlCO1FBQTNDLFVBQUssR0FBTCxLQUFLLENBQUc7UUFBVSxVQUFLLEdBQUwsS0FBSyxDQUFvQjtRQUV0RCxPQUFFLEdBQUcsY0FBYyxFQUFFLENBQUM7UUFDdEIsUUFBRyxHQUFHLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN2QixjQUFTLEdBQUcsSUFBSSxHQUFHLEVBQW9CLENBQUM7UUFDakQsaUJBQVksR0FBRyxDQUFDLENBQUM7SUFMaUQsQ0FBQztJQU9uRSxvQkFBb0I7UUFDbEIsK0VBQStFO0lBQ2pGLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSCxHQUFHLENBQUMsUUFBVztRQUNiLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsUUFBUSxDQUFDLEVBQUU7WUFDckMsSUFBSSxDQUFDLEtBQUssR0FBRyxRQUFRLENBQUM7WUFDdEIsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO1lBQ3BCLHVCQUF1QixDQUFDLElBQUksQ0FBQyxDQUFDO1NBQy9CO0lBQ0gsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsTUFBTSxDQUFDLE9BQXdCO1FBQzdCLElBQUksQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBQ2hDLENBQUM7SUFFRDs7T0FFRztJQUNILE1BQU0sQ0FBQyxPQUEyQjtRQUNoQyw0RUFBNEU7UUFDNUUsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNwQixJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7UUFDcEIsdUJBQXVCLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDaEMsQ0FBQztJQUVELE1BQU07UUFDSixnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN2QixPQUFPLElBQUksQ0FBQyxLQUFLLENBQUM7SUFDcEIsQ0FBQztDQUNGO0FBRUQ7Ozs7R0FJRztBQUNILE1BQU0sVUFBVSxNQUFNLENBQ2xCLFlBQWUsRUFBRSxRQUE0QixhQUFhO0lBQzVELE1BQU0sVUFBVSxHQUFHLElBQUksa0JBQWtCLENBQUMsWUFBWSxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQy9ELG1DQUFtQztJQUNuQyxNQUFNLFFBQVEsR0FBRyx3QkFBd0IsQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsRUFBRTtRQUMzRCxHQUFHLEVBQUUsVUFBVSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDO1FBQ3BDLE1BQU0sRUFBRSxVQUFVLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUM7UUFDMUMsTUFBTSxFQUFFLFVBQVUsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQztLQUMzQyxDQUFpQyxDQUFDO0lBQ3BELE9BQU8sUUFBUSxDQUFDO0FBQ2xCLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuaW1wb3J0IHtjcmVhdGVTaWduYWxGcm9tRnVuY3Rpb24sIGRlZmF1bHRFcXVhbHMsIFNpZ25hbCwgVmFsdWVFcXVhbGl0eUZufSBmcm9tICcuL2FwaSc7XG5pbXBvcnQge0NvbnN1bWVySWQsIEVkZ2UsIG5leHRSZWFjdGl2ZUlkLCBQcm9kdWNlciwgcHJvZHVjZXJBY2Nlc3NlZCwgcHJvZHVjZXJOb3RpZnlDb25zdW1lcnN9IGZyb20gJy4vZ3JhcGgnO1xuaW1wb3J0IHtuZXdXZWFrUmVmLCBXZWFrUmVmfSBmcm9tICcuL3dlYWtfcmVmJztcblxuLyoqXG4gKiBBIGBTaWduYWxgIHdpdGggYSB2YWx1ZSB0aGF0IGNhbiBiZSBtdXRhdGVkIHZpYSBhIHNldHRlciBpbnRlcmZhY2UuXG4gKlxuICogQGRldmVsb3BlclByZXZpZXdcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTZXR0YWJsZVNpZ25hbDxUPiBleHRlbmRzIFNpZ25hbDxUPiB7XG4gIC8qKlxuICAgKiBEaXJlY3RseSBzZXQgdGhlIHNpZ25hbCB0byBhIG5ldyB2YWx1ZSwgYW5kIG5vdGlmeSBhbnkgZGVwZW5kZW50cy5cbiAgICovXG4gIHNldCh2YWx1ZTogVCk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgdmFsdWUgb2YgdGhlIHNpZ25hbCBiYXNlZCBvbiBpdHMgY3VycmVudCB2YWx1ZSwgYW5kXG4gICAqIG5vdGlmeSBhbnkgZGVwZW5kZW50cy5cbiAgICovXG4gIHVwZGF0ZSh1cGRhdGVGbjogKHZhbHVlOiBUKSA9PiBUKTogdm9pZDtcblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBjdXJyZW50IHZhbHVlIGJ5IG11dGF0aW5nIGl0IGluLXBsYWNlLCBhbmRcbiAgICogbm90aWZ5IGFueSBkZXBlbmRlbnRzLlxuICAgKi9cbiAgbXV0YXRlKG11dGF0b3JGbjogKHZhbHVlOiBUKSA9PiB2b2lkKTogdm9pZDtcbn1cblxuLyoqXG4gKiBCYWNraW5nIHR5cGUgZm9yIGEgYFNldHRhYmxlU2lnbmFsYCwgYSBtdXRhYmxlIHJlYWN0aXZlIHZhbHVlLlxuICovXG5jbGFzcyBTZXR0YWJsZVNpZ25hbEltcGw8VD4gaW1wbGVtZW50cyBQcm9kdWNlciB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgdmFsdWU6IFQsIHByaXZhdGUgZXF1YWw6IFZhbHVlRXF1YWxpdHlGbjxUPikge31cblxuICByZWFkb25seSBpZCA9IG5leHRSZWFjdGl2ZUlkKCk7XG4gIHJlYWRvbmx5IHJlZiA9IG5ld1dlYWtSZWYodGhpcyk7XG4gIHJlYWRvbmx5IGNvbnN1bWVycyA9IG5ldyBNYXA8Q29uc3VtZXJJZCwgRWRnZT4oKTtcbiAgdmFsdWVWZXJzaW9uID0gMDtcblxuICBjaGVja0ZvckNoYW5nZWRWYWx1ZSgpOiB2b2lkIHtcbiAgICAvLyBTZXR0YWJsZSBzaWduYWxzIGNhbiBvbmx5IGNoYW5nZSB3aGVuIHNldCwgc28gdGhlcmUncyBub3RoaW5nIHRvIGNoZWNrIGhlcmUuXG4gIH1cblxuICAvKipcbiAgICogRGlyZWN0bHkgdXBkYXRlIHRoZSB2YWx1ZSBvZiB0aGUgc2lnbmFsIHRvIGEgbmV3IHZhbHVlLCB3aGljaCBtYXkgb3IgbWF5IG5vdCBiZVxuICAgKiBlcXVhbCB0byB0aGUgcHJldmlvdXMuXG4gICAqXG4gICAqIEluIHRoZSBldmVudCB0aGF0IGBuZXdWYWx1ZWAgaXMgc2VtYW50aWNhbGx5IGVxdWFsIHRvIHRoZSBjdXJyZW50IHZhbHVlLCBgc2V0YCBpc1xuICAgKiBhIG5vLW9wLlxuICAgKi9cbiAgc2V0KG5ld1ZhbHVlOiBUKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmVxdWFsKHRoaXMudmFsdWUsIG5ld1ZhbHVlKSkge1xuICAgICAgdGhpcy52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgdGhpcy52YWx1ZVZlcnNpb24rKztcbiAgICAgIHByb2R1Y2VyTm90aWZ5Q29uc3VtZXJzKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZXJpdmUgYSBuZXcgdmFsdWUgZm9yIHRoZSBzaWduYWwgZnJvbSBpdHMgY3VycmVudCB2YWx1ZSB1c2luZyB0aGUgYHVwZGF0ZXJgIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gY2FsbGluZyBgc2V0YCBvbiB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgYHVwZGF0ZXJgIG9uIHRoZSBjdXJyZW50XG4gICAqIHZhbHVlLlxuICAgKi9cbiAgdXBkYXRlKHVwZGF0ZXI6ICh2YWx1ZTogVCkgPT4gVCk6IHZvaWQge1xuICAgIHRoaXMuc2V0KHVwZGF0ZXIodGhpcy52YWx1ZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxzIGBtdXRhdG9yYCBvbiB0aGUgY3VycmVudCB2YWx1ZSBhbmQgYXNzdW1lcyB0aGF0IGl0IGhhcyBiZWVuIG11dGF0ZWQuXG4gICAqL1xuICBtdXRhdGUobXV0YXRvcjogKHZhbHVlOiBUKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgLy8gTXV0YXRlIGJ5cGFzc2VzIGVxdWFsaXR5IGNoZWNrcyBhcyBpdCdzIGJ5IGRlZmluaXRpb24gY2hhbmdpbmcgdGhlIHZhbHVlLlxuICAgIG11dGF0b3IodGhpcy52YWx1ZSk7XG4gICAgdGhpcy52YWx1ZVZlcnNpb24rKztcbiAgICBwcm9kdWNlck5vdGlmeUNvbnN1bWVycyh0aGlzKTtcbiAgfVxuXG4gIHNpZ25hbCgpOiBUIHtcbiAgICBwcm9kdWNlckFjY2Vzc2VkKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgYFNpZ25hbGAgdGhhdCBjYW4gYmUgc2V0IG9yIHVwZGF0ZWQgZGlyZWN0bHkuXG4gKlxuICogQGRldmVsb3BlclByZXZpZXdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNpZ25hbDxUPihcbiAgICBpbml0aWFsVmFsdWU6IFQsIGVxdWFsOiBWYWx1ZUVxdWFsaXR5Rm48VD4gPSBkZWZhdWx0RXF1YWxzKTogU2V0dGFibGVTaWduYWw8VD4ge1xuICBjb25zdCBzaWduYWxOb2RlID0gbmV3IFNldHRhYmxlU2lnbmFsSW1wbChpbml0aWFsVmFsdWUsIGVxdWFsKTtcbiAgLy8gQ2FzdGluZyBoZXJlIGlzIHJlcXVpcmVkIGZvciBnMy5cbiAgY29uc3Qgc2lnbmFsRm4gPSBjcmVhdGVTaWduYWxGcm9tRnVuY3Rpb24oc2lnbmFsTm9kZS5zaWduYWwuYmluZChzaWduYWxOb2RlKSwge1xuICAgICAgICAgICAgICAgICAgICAgc2V0OiBzaWduYWxOb2RlLnNldC5iaW5kKHNpZ25hbE5vZGUpLFxuICAgICAgICAgICAgICAgICAgICAgdXBkYXRlOiBzaWduYWxOb2RlLnVwZGF0ZS5iaW5kKHNpZ25hbE5vZGUpLFxuICAgICAgICAgICAgICAgICAgICAgbXV0YXRlOiBzaWduYWxOb2RlLm11dGF0ZS5iaW5kKHNpZ25hbE5vZGUpLFxuICAgICAgICAgICAgICAgICAgIH0pIGFzIHVua25vd24gYXMgU2V0dGFibGVTaWduYWw8VD47XG4gIHJldHVybiBzaWduYWxGbjtcbn1cbiJdfQ==
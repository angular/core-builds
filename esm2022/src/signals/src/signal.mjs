/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { createSignalFromFunction, defaultEquals } from './api';
import { throwInvalidWriteToSignalError } from './errors';
import { ReactiveNode } from './graph';
/**
 * If set, called after `WritableSignal`s are updated.
 *
 * This hook can be used to achieve various effects, such as running effects synchronously as part
 * of setting a signal.
 */
let postSignalSetFn = null;
class WritableSignalImpl extends ReactiveNode {
    constructor(value, equal) {
        super();
        this.value = value;
        this.equal = equal;
        this.consumerAllowSignalWrites = false;
    }
    onConsumerDependencyMayHaveChanged() {
        // This never happens for writable signals as they're not consumers.
    }
    onProducerUpdateValueVersion() {
        // Writable signal value versions are always up to date.
    }
    /**
     * Directly update the value of the signal to a new value, which may or may not be
     * equal to the previous.
     *
     * In the event that `newValue` is semantically equal to the current value, `set` is
     * a no-op.
     */
    set(newValue) {
        if (!this.producerUpdatesAllowed) {
            throwInvalidWriteToSignalError();
        }
        if (!this.equal(this.value, newValue)) {
            this.value = newValue;
            this.valueVersion++;
            this.producerMayHaveChanged();
            postSignalSetFn?.();
        }
    }
    /**
     * Derive a new value for the signal from its current value using the `updater` function.
     *
     * This is equivalent to calling `set` on the result of running `updater` on the current
     * value.
     */
    update(updater) {
        if (!this.producerUpdatesAllowed) {
            throwInvalidWriteToSignalError();
        }
        this.set(updater(this.value));
    }
    /**
     * Calls `mutator` on the current value and assumes that it has been mutated.
     */
    mutate(mutator) {
        if (!this.producerUpdatesAllowed) {
            throwInvalidWriteToSignalError();
        }
        // Mutate bypasses equality checks as it's by definition changing the value.
        mutator(this.value);
        this.valueVersion++;
        this.producerMayHaveChanged();
        postSignalSetFn?.();
    }
    signal() {
        this.producerAccessed();
        return this.value;
    }
}
/**
 * Create a `Signal` that can be set or updated directly.
 *
 * @developerPreview
 */
export function signal(initialValue, options) {
    const signalNode = new WritableSignalImpl(initialValue, options?.equal ?? defaultEquals);
    // Casting here is required for g3, as TS inference behavior is slightly different between our
    // version/options and g3's.
    const signalFn = createSignalFromFunction(signalNode, signalNode.signal.bind(signalNode), {
        set: signalNode.set.bind(signalNode),
        update: signalNode.update.bind(signalNode),
        mutate: signalNode.mutate.bind(signalNode),
    });
    return signalFn;
}
export function setPostSignalSetFn(fn) {
    const prev = postSignalSetFn;
    postSignalSetFn = fn;
    return prev;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2lnbmFsLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvY29yZS9zcmMvc2lnbmFscy9zcmMvc2lnbmFsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7R0FNRztBQUVILE9BQU8sRUFBQyx3QkFBd0IsRUFBRSxhQUFhLEVBQTBCLE1BQU0sT0FBTyxDQUFDO0FBQ3ZGLE9BQU8sRUFBQyw4QkFBOEIsRUFBQyxNQUFNLFVBQVUsQ0FBQztBQUN4RCxPQUFPLEVBQUMsWUFBWSxFQUFDLE1BQU0sU0FBUyxDQUFDO0FBRXJDOzs7OztHQUtHO0FBQ0gsSUFBSSxlQUFlLEdBQXNCLElBQUksQ0FBQztBQTBCOUMsTUFBTSxrQkFBc0IsU0FBUSxZQUFZO0lBRzlDLFlBQW9CLEtBQVEsRUFBVSxLQUF5QjtRQUM3RCxLQUFLLEVBQUUsQ0FBQztRQURVLFVBQUssR0FBTCxLQUFLLENBQUc7UUFBVSxVQUFLLEdBQUwsS0FBSyxDQUFvQjtRQUZuQyw4QkFBeUIsR0FBRyxLQUFLLENBQUM7SUFJOUQsQ0FBQztJQUVrQixrQ0FBa0M7UUFDbkQsb0VBQW9FO0lBQ3RFLENBQUM7SUFFa0IsNEJBQTRCO1FBQzdDLHdEQUF3RDtJQUMxRCxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0gsR0FBRyxDQUFDLFFBQVc7UUFDYixJQUFJLENBQUMsSUFBSSxDQUFDLHNCQUFzQixFQUFFO1lBQ2hDLDhCQUE4QixFQUFFLENBQUM7U0FDbEM7UUFDRCxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLFFBQVEsQ0FBQyxFQUFFO1lBQ3JDLElBQUksQ0FBQyxLQUFLLEdBQUcsUUFBUSxDQUFDO1lBQ3RCLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQztZQUNwQixJQUFJLENBQUMsc0JBQXNCLEVBQUUsQ0FBQztZQUU5QixlQUFlLEVBQUUsRUFBRSxDQUFDO1NBQ3JCO0lBQ0gsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsTUFBTSxDQUFDLE9BQXdCO1FBQzdCLElBQUksQ0FBQyxJQUFJLENBQUMsc0JBQXNCLEVBQUU7WUFDaEMsOEJBQThCLEVBQUUsQ0FBQztTQUNsQztRQUNELElBQUksQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBQ2hDLENBQUM7SUFFRDs7T0FFRztJQUNILE1BQU0sQ0FBQyxPQUEyQjtRQUNoQyxJQUFJLENBQUMsSUFBSSxDQUFDLHNCQUFzQixFQUFFO1lBQ2hDLDhCQUE4QixFQUFFLENBQUM7U0FDbEM7UUFDRCw0RUFBNEU7UUFDNUUsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNwQixJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7UUFDcEIsSUFBSSxDQUFDLHNCQUFzQixFQUFFLENBQUM7UUFFOUIsZUFBZSxFQUFFLEVBQUUsQ0FBQztJQUN0QixDQUFDO0lBRUQsTUFBTTtRQUNKLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO1FBQ3hCLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQztJQUNwQixDQUFDO0NBQ0Y7QUFjRDs7OztHQUlHO0FBQ0gsTUFBTSxVQUFVLE1BQU0sQ0FBSSxZQUFlLEVBQUUsT0FBZ0M7SUFDekUsTUFBTSxVQUFVLEdBQUcsSUFBSSxrQkFBa0IsQ0FBQyxZQUFZLEVBQUUsT0FBTyxFQUFFLEtBQUssSUFBSSxhQUFhLENBQUMsQ0FBQztJQUV6Riw4RkFBOEY7SUFDOUYsNEJBQTRCO0lBQzVCLE1BQU0sUUFBUSxHQUFHLHdCQUF3QixDQUFDLFVBQVUsRUFBRSxVQUFVLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsRUFBRTtRQUN2RSxHQUFHLEVBQUUsVUFBVSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDO1FBQ3BDLE1BQU0sRUFBRSxVQUFVLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUM7UUFDMUMsTUFBTSxFQUFFLFVBQVUsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQztLQUMzQyxDQUFpQyxDQUFDO0lBQ3BELE9BQU8sUUFBUSxDQUFDO0FBQ2xCLENBQUM7QUFFRCxNQUFNLFVBQVUsa0JBQWtCLENBQUMsRUFBcUI7SUFDdEQsTUFBTSxJQUFJLEdBQUcsZUFBZSxDQUFDO0lBQzdCLGVBQWUsR0FBRyxFQUFFLENBQUM7SUFDckIsT0FBTyxJQUFJLENBQUM7QUFDZCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbmltcG9ydCB7Y3JlYXRlU2lnbmFsRnJvbUZ1bmN0aW9uLCBkZWZhdWx0RXF1YWxzLCBTaWduYWwsIFZhbHVlRXF1YWxpdHlGbn0gZnJvbSAnLi9hcGknO1xuaW1wb3J0IHt0aHJvd0ludmFsaWRXcml0ZVRvU2lnbmFsRXJyb3J9IGZyb20gJy4vZXJyb3JzJztcbmltcG9ydCB7UmVhY3RpdmVOb2RlfSBmcm9tICcuL2dyYXBoJztcblxuLyoqXG4gKiBJZiBzZXQsIGNhbGxlZCBhZnRlciBgV3JpdGFibGVTaWduYWxgcyBhcmUgdXBkYXRlZC5cbiAqXG4gKiBUaGlzIGhvb2sgY2FuIGJlIHVzZWQgdG8gYWNoaWV2ZSB2YXJpb3VzIGVmZmVjdHMsIHN1Y2ggYXMgcnVubmluZyBlZmZlY3RzIHN5bmNocm9ub3VzbHkgYXMgcGFydFxuICogb2Ygc2V0dGluZyBhIHNpZ25hbC5cbiAqL1xubGV0IHBvc3RTaWduYWxTZXRGbjogKCgpID0+IHZvaWQpfG51bGwgPSBudWxsO1xuXG4vKipcbiAqIEEgYFNpZ25hbGAgd2l0aCBhIHZhbHVlIHRoYXQgY2FuIGJlIG11dGF0ZWQgdmlhIGEgc2V0dGVyIGludGVyZmFjZS5cbiAqXG4gKiBAZGV2ZWxvcGVyUHJldmlld1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFdyaXRhYmxlU2lnbmFsPFQ+IGV4dGVuZHMgU2lnbmFsPFQ+IHtcbiAgLyoqXG4gICAqIERpcmVjdGx5IHNldCB0aGUgc2lnbmFsIHRvIGEgbmV3IHZhbHVlLCBhbmQgbm90aWZ5IGFueSBkZXBlbmRlbnRzLlxuICAgKi9cbiAgc2V0KHZhbHVlOiBUKTogdm9pZDtcblxuICAvKipcbiAgICogVXBkYXRlIHRoZSB2YWx1ZSBvZiB0aGUgc2lnbmFsIGJhc2VkIG9uIGl0cyBjdXJyZW50IHZhbHVlLCBhbmRcbiAgICogbm90aWZ5IGFueSBkZXBlbmRlbnRzLlxuICAgKi9cbiAgdXBkYXRlKHVwZGF0ZUZuOiAodmFsdWU6IFQpID0+IFQpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGN1cnJlbnQgdmFsdWUgYnkgbXV0YXRpbmcgaXQgaW4tcGxhY2UsIGFuZFxuICAgKiBub3RpZnkgYW55IGRlcGVuZGVudHMuXG4gICAqL1xuICBtdXRhdGUobXV0YXRvckZuOiAodmFsdWU6IFQpID0+IHZvaWQpOiB2b2lkO1xufVxuXG5jbGFzcyBXcml0YWJsZVNpZ25hbEltcGw8VD4gZXh0ZW5kcyBSZWFjdGl2ZU5vZGUge1xuICBwcm90ZWN0ZWQgb3ZlcnJpZGUgcmVhZG9ubHkgY29uc3VtZXJBbGxvd1NpZ25hbFdyaXRlcyA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgdmFsdWU6IFQsIHByaXZhdGUgZXF1YWw6IFZhbHVlRXF1YWxpdHlGbjxUPikge1xuICAgIHN1cGVyKCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgb3ZlcnJpZGUgb25Db25zdW1lckRlcGVuZGVuY3lNYXlIYXZlQ2hhbmdlZCgpOiB2b2lkIHtcbiAgICAvLyBUaGlzIG5ldmVyIGhhcHBlbnMgZm9yIHdyaXRhYmxlIHNpZ25hbHMgYXMgdGhleSdyZSBub3QgY29uc3VtZXJzLlxuICB9XG5cbiAgcHJvdGVjdGVkIG92ZXJyaWRlIG9uUHJvZHVjZXJVcGRhdGVWYWx1ZVZlcnNpb24oKTogdm9pZCB7XG4gICAgLy8gV3JpdGFibGUgc2lnbmFsIHZhbHVlIHZlcnNpb25zIGFyZSBhbHdheXMgdXAgdG8gZGF0ZS5cbiAgfVxuXG4gIC8qKlxuICAgKiBEaXJlY3RseSB1cGRhdGUgdGhlIHZhbHVlIG9mIHRoZSBzaWduYWwgdG8gYSBuZXcgdmFsdWUsIHdoaWNoIG1heSBvciBtYXkgbm90IGJlXG4gICAqIGVxdWFsIHRvIHRoZSBwcmV2aW91cy5cbiAgICpcbiAgICogSW4gdGhlIGV2ZW50IHRoYXQgYG5ld1ZhbHVlYCBpcyBzZW1hbnRpY2FsbHkgZXF1YWwgdG8gdGhlIGN1cnJlbnQgdmFsdWUsIGBzZXRgIGlzXG4gICAqIGEgbm8tb3AuXG4gICAqL1xuICBzZXQobmV3VmFsdWU6IFQpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMucHJvZHVjZXJVcGRhdGVzQWxsb3dlZCkge1xuICAgICAgdGhyb3dJbnZhbGlkV3JpdGVUb1NpZ25hbEVycm9yKCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5lcXVhbCh0aGlzLnZhbHVlLCBuZXdWYWx1ZSkpIHtcbiAgICAgIHRoaXMudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgIHRoaXMudmFsdWVWZXJzaW9uKys7XG4gICAgICB0aGlzLnByb2R1Y2VyTWF5SGF2ZUNoYW5nZWQoKTtcblxuICAgICAgcG9zdFNpZ25hbFNldEZuPy4oKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVyaXZlIGEgbmV3IHZhbHVlIGZvciB0aGUgc2lnbmFsIGZyb20gaXRzIGN1cnJlbnQgdmFsdWUgdXNpbmcgdGhlIGB1cGRhdGVyYCBmdW5jdGlvbi5cbiAgICpcbiAgICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIGNhbGxpbmcgYHNldGAgb24gdGhlIHJlc3VsdCBvZiBydW5uaW5nIGB1cGRhdGVyYCBvbiB0aGUgY3VycmVudFxuICAgKiB2YWx1ZS5cbiAgICovXG4gIHVwZGF0ZSh1cGRhdGVyOiAodmFsdWU6IFQpID0+IFQpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMucHJvZHVjZXJVcGRhdGVzQWxsb3dlZCkge1xuICAgICAgdGhyb3dJbnZhbGlkV3JpdGVUb1NpZ25hbEVycm9yKCk7XG4gICAgfVxuICAgIHRoaXMuc2V0KHVwZGF0ZXIodGhpcy52YWx1ZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxzIGBtdXRhdG9yYCBvbiB0aGUgY3VycmVudCB2YWx1ZSBhbmQgYXNzdW1lcyB0aGF0IGl0IGhhcyBiZWVuIG11dGF0ZWQuXG4gICAqL1xuICBtdXRhdGUobXV0YXRvcjogKHZhbHVlOiBUKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLnByb2R1Y2VyVXBkYXRlc0FsbG93ZWQpIHtcbiAgICAgIHRocm93SW52YWxpZFdyaXRlVG9TaWduYWxFcnJvcigpO1xuICAgIH1cbiAgICAvLyBNdXRhdGUgYnlwYXNzZXMgZXF1YWxpdHkgY2hlY2tzIGFzIGl0J3MgYnkgZGVmaW5pdGlvbiBjaGFuZ2luZyB0aGUgdmFsdWUuXG4gICAgbXV0YXRvcih0aGlzLnZhbHVlKTtcbiAgICB0aGlzLnZhbHVlVmVyc2lvbisrO1xuICAgIHRoaXMucHJvZHVjZXJNYXlIYXZlQ2hhbmdlZCgpO1xuXG4gICAgcG9zdFNpZ25hbFNldEZuPy4oKTtcbiAgfVxuXG4gIHNpZ25hbCgpOiBUIHtcbiAgICB0aGlzLnByb2R1Y2VyQWNjZXNzZWQoKTtcbiAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgfVxufVxuXG4vKipcbiAqIE9wdGlvbnMgcGFzc2VkIHRvIHRoZSBgc2lnbmFsYCBjcmVhdGlvbiBmdW5jdGlvbi5cbiAqXG4gKiBAZGV2ZWxvcGVyUHJldmlld1xuICovXG5leHBvcnQgaW50ZXJmYWNlIENyZWF0ZVNpZ25hbE9wdGlvbnM8VD4ge1xuICAvKipcbiAgICogQSBjb21wYXJpc29uIGZ1bmN0aW9uIHdoaWNoIGRlZmluZXMgZXF1YWxpdHkgZm9yIHNpZ25hbCB2YWx1ZXMuXG4gICAqL1xuICBlcXVhbD86IFZhbHVlRXF1YWxpdHlGbjxUPjtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBgU2lnbmFsYCB0aGF0IGNhbiBiZSBzZXQgb3IgdXBkYXRlZCBkaXJlY3RseS5cbiAqXG4gKiBAZGV2ZWxvcGVyUHJldmlld1xuICovXG5leHBvcnQgZnVuY3Rpb24gc2lnbmFsPFQ+KGluaXRpYWxWYWx1ZTogVCwgb3B0aW9ucz86IENyZWF0ZVNpZ25hbE9wdGlvbnM8VD4pOiBXcml0YWJsZVNpZ25hbDxUPiB7XG4gIGNvbnN0IHNpZ25hbE5vZGUgPSBuZXcgV3JpdGFibGVTaWduYWxJbXBsKGluaXRpYWxWYWx1ZSwgb3B0aW9ucz8uZXF1YWwgPz8gZGVmYXVsdEVxdWFscyk7XG5cbiAgLy8gQ2FzdGluZyBoZXJlIGlzIHJlcXVpcmVkIGZvciBnMywgYXMgVFMgaW5mZXJlbmNlIGJlaGF2aW9yIGlzIHNsaWdodGx5IGRpZmZlcmVudCBiZXR3ZWVuIG91clxuICAvLyB2ZXJzaW9uL29wdGlvbnMgYW5kIGczJ3MuXG4gIGNvbnN0IHNpZ25hbEZuID0gY3JlYXRlU2lnbmFsRnJvbUZ1bmN0aW9uKHNpZ25hbE5vZGUsIHNpZ25hbE5vZGUuc2lnbmFsLmJpbmQoc2lnbmFsTm9kZSksIHtcbiAgICAgICAgICAgICAgICAgICAgIHNldDogc2lnbmFsTm9kZS5zZXQuYmluZChzaWduYWxOb2RlKSxcbiAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZTogc2lnbmFsTm9kZS51cGRhdGUuYmluZChzaWduYWxOb2RlKSxcbiAgICAgICAgICAgICAgICAgICAgIG11dGF0ZTogc2lnbmFsTm9kZS5tdXRhdGUuYmluZChzaWduYWxOb2RlKSxcbiAgICAgICAgICAgICAgICAgICB9KSBhcyB1bmtub3duIGFzIFdyaXRhYmxlU2lnbmFsPFQ+O1xuICByZXR1cm4gc2lnbmFsRm47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRQb3N0U2lnbmFsU2V0Rm4oZm46ICgoKSA9PiB2b2lkKXxudWxsKTogKCgpID0+IHZvaWQpfG51bGwge1xuICBjb25zdCBwcmV2ID0gcG9zdFNpZ25hbFNldEZuO1xuICBwb3N0U2lnbmFsU2V0Rm4gPSBmbjtcbiAgcmV0dXJuIHByZXY7XG59XG4iXX0=
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { createSignalFromFunction, defaultEquals } from './api';
import { ReactiveNode } from './graph';
class WritableSignalImpl extends ReactiveNode {
    constructor(value, equal) {
        super();
        this.value = value;
        this.equal = equal;
    }
    onConsumerDependencyMayHaveChanged() {
        // This never happens for writable signals as they're not consumers.
    }
    onProducerUpdateValueVersion() {
        // Writable signal value versions are always up to date.
    }
    /**
     * Directly update the value of the signal to a new value, which may or may not be
     * equal to the previous.
     *
     * In the event that `newValue` is semantically equal to the current value, `set` is
     * a no-op.
     */
    set(newValue) {
        if (!this.equal(this.value, newValue)) {
            this.value = newValue;
            this.valueVersion++;
            this.producerMayHaveChanged();
        }
    }
    /**
     * Derive a new value for the signal from its current value using the `updater` function.
     *
     * This is equivalent to calling `set` on the result of running `updater` on the current
     * value.
     */
    update(updater) {
        this.set(updater(this.value));
    }
    /**
     * Calls `mutator` on the current value and assumes that it has been mutated.
     */
    mutate(mutator) {
        // Mutate bypasses equality checks as it's by definition changing the value.
        mutator(this.value);
        this.valueVersion++;
        this.producerMayHaveChanged();
    }
    signal() {
        this.producerAccessed();
        return this.value;
    }
}
/**
 * Create a `Signal` that can be set or updated directly.
 *
 * @developerPreview
 */
export function signal(initialValue, options) {
    const signalNode = new WritableSignalImpl(initialValue, options?.equal ?? defaultEquals);
    // Casting here is required for g3, as TS inference behavior is slightly different between our
    // version/options and g3's.
    const signalFn = createSignalFromFunction(signalNode, signalNode.signal.bind(signalNode), {
        set: signalNode.set.bind(signalNode),
        update: signalNode.update.bind(signalNode),
        mutate: signalNode.mutate.bind(signalNode),
    });
    return signalFn;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2lnbmFsLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvY29yZS9zcmMvc2lnbmFscy9zcmMvc2lnbmFsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7R0FNRztBQUVILE9BQU8sRUFBQyx3QkFBd0IsRUFBRSxhQUFhLEVBQTBCLE1BQU0sT0FBTyxDQUFDO0FBQ3ZGLE9BQU8sRUFBQyxZQUFZLEVBQUMsTUFBTSxTQUFTLENBQUM7QUEwQnJDLE1BQU0sa0JBQXNCLFNBQVEsWUFBWTtJQUM5QyxZQUFvQixLQUFRLEVBQVUsS0FBeUI7UUFDN0QsS0FBSyxFQUFFLENBQUM7UUFEVSxVQUFLLEdBQUwsS0FBSyxDQUFHO1FBQVUsVUFBSyxHQUFMLEtBQUssQ0FBb0I7SUFFL0QsQ0FBQztJQUVrQixrQ0FBa0M7UUFDbkQsb0VBQW9FO0lBQ3RFLENBQUM7SUFFa0IsNEJBQTRCO1FBQzdDLHdEQUF3RDtJQUMxRCxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0gsR0FBRyxDQUFDLFFBQVc7UUFDYixJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLFFBQVEsQ0FBQyxFQUFFO1lBQ3JDLElBQUksQ0FBQyxLQUFLLEdBQUcsUUFBUSxDQUFDO1lBQ3RCLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQztZQUNwQixJQUFJLENBQUMsc0JBQXNCLEVBQUUsQ0FBQztTQUMvQjtJQUNILENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILE1BQU0sQ0FBQyxPQUF3QjtRQUM3QixJQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztJQUNoQyxDQUFDO0lBRUQ7O09BRUc7SUFDSCxNQUFNLENBQUMsT0FBMkI7UUFDaEMsNEVBQTRFO1FBQzVFLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDcEIsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO1FBQ3BCLElBQUksQ0FBQyxzQkFBc0IsRUFBRSxDQUFDO0lBQ2hDLENBQUM7SUFFRCxNQUFNO1FBQ0osSUFBSSxDQUFDLGdCQUFnQixFQUFFLENBQUM7UUFDeEIsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDO0lBQ3BCLENBQUM7Q0FDRjtBQWNEOzs7O0dBSUc7QUFDSCxNQUFNLFVBQVUsTUFBTSxDQUFJLFlBQWUsRUFBRSxPQUFnQztJQUN6RSxNQUFNLFVBQVUsR0FBRyxJQUFJLGtCQUFrQixDQUFDLFlBQVksRUFBRSxPQUFPLEVBQUUsS0FBSyxJQUFJLGFBQWEsQ0FBQyxDQUFDO0lBRXpGLDhGQUE4RjtJQUM5Riw0QkFBNEI7SUFDNUIsTUFBTSxRQUFRLEdBQUcsd0JBQXdCLENBQUMsVUFBVSxFQUFFLFVBQVUsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxFQUFFO1FBQ3ZFLEdBQUcsRUFBRSxVQUFVLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUM7UUFDcEMsTUFBTSxFQUFFLFVBQVUsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQztRQUMxQyxNQUFNLEVBQUUsVUFBVSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDO0tBQzNDLENBQWlDLENBQUM7SUFDcEQsT0FBTyxRQUFRLENBQUM7QUFDbEIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG5pbXBvcnQge2NyZWF0ZVNpZ25hbEZyb21GdW5jdGlvbiwgZGVmYXVsdEVxdWFscywgU2lnbmFsLCBWYWx1ZUVxdWFsaXR5Rm59IGZyb20gJy4vYXBpJztcbmltcG9ydCB7UmVhY3RpdmVOb2RlfSBmcm9tICcuL2dyYXBoJztcblxuLyoqXG4gKiBBIGBTaWduYWxgIHdpdGggYSB2YWx1ZSB0aGF0IGNhbiBiZSBtdXRhdGVkIHZpYSBhIHNldHRlciBpbnRlcmZhY2UuXG4gKlxuICogQGRldmVsb3BlclByZXZpZXdcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBXcml0YWJsZVNpZ25hbDxUPiBleHRlbmRzIFNpZ25hbDxUPiB7XG4gIC8qKlxuICAgKiBEaXJlY3RseSBzZXQgdGhlIHNpZ25hbCB0byBhIG5ldyB2YWx1ZSwgYW5kIG5vdGlmeSBhbnkgZGVwZW5kZW50cy5cbiAgICovXG4gIHNldCh2YWx1ZTogVCk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgdmFsdWUgb2YgdGhlIHNpZ25hbCBiYXNlZCBvbiBpdHMgY3VycmVudCB2YWx1ZSwgYW5kXG4gICAqIG5vdGlmeSBhbnkgZGVwZW5kZW50cy5cbiAgICovXG4gIHVwZGF0ZSh1cGRhdGVGbjogKHZhbHVlOiBUKSA9PiBUKTogdm9pZDtcblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBjdXJyZW50IHZhbHVlIGJ5IG11dGF0aW5nIGl0IGluLXBsYWNlLCBhbmRcbiAgICogbm90aWZ5IGFueSBkZXBlbmRlbnRzLlxuICAgKi9cbiAgbXV0YXRlKG11dGF0b3JGbjogKHZhbHVlOiBUKSA9PiB2b2lkKTogdm9pZDtcbn1cblxuY2xhc3MgV3JpdGFibGVTaWduYWxJbXBsPFQ+IGV4dGVuZHMgUmVhY3RpdmVOb2RlIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSB2YWx1ZTogVCwgcHJpdmF0ZSBlcXVhbDogVmFsdWVFcXVhbGl0eUZuPFQ+KSB7XG4gICAgc3VwZXIoKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvdmVycmlkZSBvbkNvbnN1bWVyRGVwZW5kZW5jeU1heUhhdmVDaGFuZ2VkKCk6IHZvaWQge1xuICAgIC8vIFRoaXMgbmV2ZXIgaGFwcGVucyBmb3Igd3JpdGFibGUgc2lnbmFscyBhcyB0aGV5J3JlIG5vdCBjb25zdW1lcnMuXG4gIH1cblxuICBwcm90ZWN0ZWQgb3ZlcnJpZGUgb25Qcm9kdWNlclVwZGF0ZVZhbHVlVmVyc2lvbigpOiB2b2lkIHtcbiAgICAvLyBXcml0YWJsZSBzaWduYWwgdmFsdWUgdmVyc2lvbnMgYXJlIGFsd2F5cyB1cCB0byBkYXRlLlxuICB9XG5cbiAgLyoqXG4gICAqIERpcmVjdGx5IHVwZGF0ZSB0aGUgdmFsdWUgb2YgdGhlIHNpZ25hbCB0byBhIG5ldyB2YWx1ZSwgd2hpY2ggbWF5IG9yIG1heSBub3QgYmVcbiAgICogZXF1YWwgdG8gdGhlIHByZXZpb3VzLlxuICAgKlxuICAgKiBJbiB0aGUgZXZlbnQgdGhhdCBgbmV3VmFsdWVgIGlzIHNlbWFudGljYWxseSBlcXVhbCB0byB0aGUgY3VycmVudCB2YWx1ZSwgYHNldGAgaXNcbiAgICogYSBuby1vcC5cbiAgICovXG4gIHNldChuZXdWYWx1ZTogVCk6IHZvaWQge1xuICAgIGlmICghdGhpcy5lcXVhbCh0aGlzLnZhbHVlLCBuZXdWYWx1ZSkpIHtcbiAgICAgIHRoaXMudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgIHRoaXMudmFsdWVWZXJzaW9uKys7XG4gICAgICB0aGlzLnByb2R1Y2VyTWF5SGF2ZUNoYW5nZWQoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVyaXZlIGEgbmV3IHZhbHVlIGZvciB0aGUgc2lnbmFsIGZyb20gaXRzIGN1cnJlbnQgdmFsdWUgdXNpbmcgdGhlIGB1cGRhdGVyYCBmdW5jdGlvbi5cbiAgICpcbiAgICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIGNhbGxpbmcgYHNldGAgb24gdGhlIHJlc3VsdCBvZiBydW5uaW5nIGB1cGRhdGVyYCBvbiB0aGUgY3VycmVudFxuICAgKiB2YWx1ZS5cbiAgICovXG4gIHVwZGF0ZSh1cGRhdGVyOiAodmFsdWU6IFQpID0+IFQpOiB2b2lkIHtcbiAgICB0aGlzLnNldCh1cGRhdGVyKHRoaXMudmFsdWUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxscyBgbXV0YXRvcmAgb24gdGhlIGN1cnJlbnQgdmFsdWUgYW5kIGFzc3VtZXMgdGhhdCBpdCBoYXMgYmVlbiBtdXRhdGVkLlxuICAgKi9cbiAgbXV0YXRlKG11dGF0b3I6ICh2YWx1ZTogVCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIC8vIE11dGF0ZSBieXBhc3NlcyBlcXVhbGl0eSBjaGVja3MgYXMgaXQncyBieSBkZWZpbml0aW9uIGNoYW5naW5nIHRoZSB2YWx1ZS5cbiAgICBtdXRhdG9yKHRoaXMudmFsdWUpO1xuICAgIHRoaXMudmFsdWVWZXJzaW9uKys7XG4gICAgdGhpcy5wcm9kdWNlck1heUhhdmVDaGFuZ2VkKCk7XG4gIH1cblxuICBzaWduYWwoKTogVCB7XG4gICAgdGhpcy5wcm9kdWNlckFjY2Vzc2VkKCk7XG4gICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBPcHRpb25zIHBhc3NlZCB0byB0aGUgYHNpZ25hbGAgY3JlYXRpb24gZnVuY3Rpb24uXG4gKlxuICogQGRldmVsb3BlclByZXZpZXdcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDcmVhdGVTaWduYWxPcHRpb25zPFQ+IHtcbiAgLyoqXG4gICAqIEEgY29tcGFyaXNvbiBmdW5jdGlvbiB3aGljaCBkZWZpbmVzIGVxdWFsaXR5IGZvciBzaWduYWwgdmFsdWVzLlxuICAgKi9cbiAgZXF1YWw/OiBWYWx1ZUVxdWFsaXR5Rm48VD47XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgYFNpZ25hbGAgdGhhdCBjYW4gYmUgc2V0IG9yIHVwZGF0ZWQgZGlyZWN0bHkuXG4gKlxuICogQGRldmVsb3BlclByZXZpZXdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNpZ25hbDxUPihpbml0aWFsVmFsdWU6IFQsIG9wdGlvbnM/OiBDcmVhdGVTaWduYWxPcHRpb25zPFQ+KTogV3JpdGFibGVTaWduYWw8VD4ge1xuICBjb25zdCBzaWduYWxOb2RlID0gbmV3IFdyaXRhYmxlU2lnbmFsSW1wbChpbml0aWFsVmFsdWUsIG9wdGlvbnM/LmVxdWFsID8/IGRlZmF1bHRFcXVhbHMpO1xuXG4gIC8vIENhc3RpbmcgaGVyZSBpcyByZXF1aXJlZCBmb3IgZzMsIGFzIFRTIGluZmVyZW5jZSBiZWhhdmlvciBpcyBzbGlnaHRseSBkaWZmZXJlbnQgYmV0d2VlbiBvdXJcbiAgLy8gdmVyc2lvbi9vcHRpb25zIGFuZCBnMydzLlxuICBjb25zdCBzaWduYWxGbiA9IGNyZWF0ZVNpZ25hbEZyb21GdW5jdGlvbihzaWduYWxOb2RlLCBzaWduYWxOb2RlLnNpZ25hbC5iaW5kKHNpZ25hbE5vZGUpLCB7XG4gICAgICAgICAgICAgICAgICAgICBzZXQ6IHNpZ25hbE5vZGUuc2V0LmJpbmQoc2lnbmFsTm9kZSksXG4gICAgICAgICAgICAgICAgICAgICB1cGRhdGU6IHNpZ25hbE5vZGUudXBkYXRlLmJpbmQoc2lnbmFsTm9kZSksXG4gICAgICAgICAgICAgICAgICAgICBtdXRhdGU6IHNpZ25hbE5vZGUubXV0YXRlLmJpbmQoc2lnbmFsTm9kZSksXG4gICAgICAgICAgICAgICAgICAgfSkgYXMgdW5rbm93biBhcyBXcml0YWJsZVNpZ25hbDxUPjtcbiAgcmV0dXJuIHNpZ25hbEZuO1xufVxuIl19
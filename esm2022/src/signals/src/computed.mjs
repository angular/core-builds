/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { defaultEquals, SIGNAL } from './api';
import { consumerAfterComputation, consumerBeforeComputation, producerAccessed, producerUpdateValueVersion, REACTIVE_NODE } from './graph';
/**
 * Create a computed `Signal` which derives a reactive value from an expression.
 *
 * @developerPreview
 */
export function computed(computation, options) {
    const node = Object.create(COMPUTED_NODE);
    node.computation = computation;
    options?.equal && (node.equal = options.equal);
    const computed = () => {
        // Check if the value needs updating before returning it.
        producerUpdateValueVersion(node);
        // Record that someone looked at this signal.
        producerAccessed(node);
        if (node.value === ERRORED) {
            throw node.error;
        }
        return node.value;
    };
    computed[SIGNAL] = node;
    return computed;
}
/**
 * A dedicated symbol used before a computed value has been calculated for the first time.
 * Explicitly typed as `any` so we can use it as signal's value.
 */
const UNSET = Symbol('UNSET');
/**
 * A dedicated symbol used in place of a computed signal value to indicate that a given computation
 * is in progress. Used to detect cycles in computation chains.
 * Explicitly typed as `any` so we can use it as signal's value.
 */
const COMPUTING = Symbol('COMPUTING');
/**
 * A dedicated symbol used in place of a computed signal value to indicate that a given computation
 * failed. The thrown error is cached until the computation gets dirty again.
 * Explicitly typed as `any` so we can use it as signal's value.
 */
const ERRORED = Symbol('ERRORED');
const COMPUTED_NODE = {
    ...REACTIVE_NODE,
    value: UNSET,
    dirty: true,
    error: null,
    equal: defaultEquals,
    producerMustRecompute(node) {
        // Force a recomputation if there's no current value, or if the current value is in the process
        // of being calculated (which should throw an error).
        return node.value === UNSET || node.value === COMPUTING;
    },
    producerRecomputeValue(node) {
        if (node.value === COMPUTING) {
            // Our computation somehow led to a cyclic read of itself.
            throw new Error('Detected cycle in computations.');
        }
        const oldValue = node.value;
        node.value = COMPUTING;
        const prevConsumer = consumerBeforeComputation(node);
        let newValue;
        try {
            newValue = node.computation();
        }
        catch (err) {
            newValue = ERRORED;
            node.error = err;
        }
        finally {
            consumerAfterComputation(node, prevConsumer);
        }
        if (oldValue !== UNSET && oldValue !== ERRORED && newValue !== ERRORED &&
            node.equal(oldValue, newValue)) {
            // No change to `valueVersion` - old and new values are
            // semantically equivalent.
            node.value = oldValue;
            return;
        }
        node.value = newValue;
        node.version++;
    },
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tcHV0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9jb3JlL3NyYy9zaWduYWxzL3NyYy9jb21wdXRlZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0dBTUc7QUFFSCxPQUFPLEVBQUMsYUFBYSxFQUFFLE1BQU0sRUFBMEIsTUFBTSxPQUFPLENBQUM7QUFDckUsT0FBTyxFQUFDLHdCQUF3QixFQUFFLHlCQUF5QixFQUFFLGdCQUFnQixFQUFFLDBCQUEwQixFQUFFLGFBQWEsRUFBZSxNQUFNLFNBQVMsQ0FBQztBQWN2Sjs7OztHQUlHO0FBQ0gsTUFBTSxVQUFVLFFBQVEsQ0FBSSxXQUFvQixFQUFFLE9BQWtDO0lBQ2xGLE1BQU0sSUFBSSxHQUFvQixNQUFNLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQyxDQUFDO0lBQzNELElBQUksQ0FBQyxXQUFXLEdBQUcsV0FBVyxDQUFDO0lBQy9CLE9BQU8sRUFBRSxLQUFLLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUUvQyxNQUFNLFFBQVEsR0FBRyxHQUFHLEVBQUU7UUFDcEIseURBQXlEO1FBQ3pELDBCQUEwQixDQUFDLElBQUksQ0FBQyxDQUFDO1FBRWpDLDZDQUE2QztRQUM3QyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUV2QixJQUFJLElBQUksQ0FBQyxLQUFLLEtBQUssT0FBTyxFQUFFO1lBQzFCLE1BQU0sSUFBSSxDQUFDLEtBQUssQ0FBQztTQUNsQjtRQUVELE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQztJQUNwQixDQUFDLENBQUM7SUFDRCxRQUFnQixDQUFDLE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQztJQUNqQyxPQUFPLFFBQTRCLENBQUM7QUFDdEMsQ0FBQztBQUdEOzs7R0FHRztBQUNILE1BQU0sS0FBSyxHQUFRLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUVuQzs7OztHQUlHO0FBQ0gsTUFBTSxTQUFTLEdBQVEsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0FBRTNDOzs7O0dBSUc7QUFDSCxNQUFNLE9BQU8sR0FBUSxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUM7QUE0QnZDLE1BQU0sYUFBYSxHQUFHO0lBQ3BCLEdBQUcsYUFBYTtJQUNoQixLQUFLLEVBQUUsS0FBSztJQUNaLEtBQUssRUFBRSxJQUFJO0lBQ1gsS0FBSyxFQUFFLElBQUk7SUFDWCxLQUFLLEVBQUUsYUFBYTtJQUVwQixxQkFBcUIsQ0FBQyxJQUEyQjtRQUMvQywrRkFBK0Y7UUFDL0YscURBQXFEO1FBQ3JELE9BQU8sSUFBSSxDQUFDLEtBQUssS0FBSyxLQUFLLElBQUksSUFBSSxDQUFDLEtBQUssS0FBSyxTQUFTLENBQUM7SUFDMUQsQ0FBQztJQUVELHNCQUFzQixDQUFDLElBQTJCO1FBQ2hELElBQUksSUFBSSxDQUFDLEtBQUssS0FBSyxTQUFTLEVBQUU7WUFDNUIsMERBQTBEO1lBQzFELE1BQU0sSUFBSSxLQUFLLENBQUMsaUNBQWlDLENBQUMsQ0FBQztTQUNwRDtRQUVELE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUM7UUFDNUIsSUFBSSxDQUFDLEtBQUssR0FBRyxTQUFTLENBQUM7UUFFdkIsTUFBTSxZQUFZLEdBQUcseUJBQXlCLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDckQsSUFBSSxRQUFpQixDQUFDO1FBQ3RCLElBQUk7WUFDRixRQUFRLEdBQUcsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO1NBQy9CO1FBQUMsT0FBTyxHQUFHLEVBQUU7WUFDWixRQUFRLEdBQUcsT0FBTyxDQUFDO1lBQ25CLElBQUksQ0FBQyxLQUFLLEdBQUcsR0FBRyxDQUFDO1NBQ2xCO2dCQUFTO1lBQ1Isd0JBQXdCLENBQUMsSUFBSSxFQUFFLFlBQVksQ0FBQyxDQUFDO1NBQzlDO1FBRUQsSUFBSSxRQUFRLEtBQUssS0FBSyxJQUFJLFFBQVEsS0FBSyxPQUFPLElBQUksUUFBUSxLQUFLLE9BQU87WUFDbEUsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLEVBQUUsUUFBUSxDQUFDLEVBQUU7WUFDbEMsdURBQXVEO1lBQ3ZELDJCQUEyQjtZQUMzQixJQUFJLENBQUMsS0FBSyxHQUFHLFFBQVEsQ0FBQztZQUN0QixPQUFPO1NBQ1I7UUFFRCxJQUFJLENBQUMsS0FBSyxHQUFHLFFBQVEsQ0FBQztRQUN0QixJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7SUFDakIsQ0FBQztDQUNGLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuaW1wb3J0IHtkZWZhdWx0RXF1YWxzLCBTSUdOQUwsIFNpZ25hbCwgVmFsdWVFcXVhbGl0eUZufSBmcm9tICcuL2FwaSc7XG5pbXBvcnQge2NvbnN1bWVyQWZ0ZXJDb21wdXRhdGlvbiwgY29uc3VtZXJCZWZvcmVDb21wdXRhdGlvbiwgcHJvZHVjZXJBY2Nlc3NlZCwgcHJvZHVjZXJVcGRhdGVWYWx1ZVZlcnNpb24sIFJFQUNUSVZFX05PREUsIFJlYWN0aXZlTm9kZX0gZnJvbSAnLi9ncmFwaCc7XG5cbi8qKlxuICogT3B0aW9ucyBwYXNzZWQgdG8gdGhlIGBjb21wdXRlZGAgY3JlYXRpb24gZnVuY3Rpb24uXG4gKlxuICogQGRldmVsb3BlclByZXZpZXdcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDcmVhdGVDb21wdXRlZE9wdGlvbnM8VD4ge1xuICAvKipcbiAgICogQSBjb21wYXJpc29uIGZ1bmN0aW9uIHdoaWNoIGRlZmluZXMgZXF1YWxpdHkgZm9yIGNvbXB1dGVkIHZhbHVlcy5cbiAgICovXG4gIGVxdWFsPzogVmFsdWVFcXVhbGl0eUZuPFQ+O1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGNvbXB1dGVkIGBTaWduYWxgIHdoaWNoIGRlcml2ZXMgYSByZWFjdGl2ZSB2YWx1ZSBmcm9tIGFuIGV4cHJlc3Npb24uXG4gKlxuICogQGRldmVsb3BlclByZXZpZXdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVkPFQ+KGNvbXB1dGF0aW9uOiAoKSA9PiBULCBvcHRpb25zPzogQ3JlYXRlQ29tcHV0ZWRPcHRpb25zPFQ+KTogU2lnbmFsPFQ+IHtcbiAgY29uc3Qgbm9kZTogQ29tcHV0ZWROb2RlPFQ+ID0gT2JqZWN0LmNyZWF0ZShDT01QVVRFRF9OT0RFKTtcbiAgbm9kZS5jb21wdXRhdGlvbiA9IGNvbXB1dGF0aW9uO1xuICBvcHRpb25zPy5lcXVhbCAmJiAobm9kZS5lcXVhbCA9IG9wdGlvbnMuZXF1YWwpO1xuXG4gIGNvbnN0IGNvbXB1dGVkID0gKCkgPT4ge1xuICAgIC8vIENoZWNrIGlmIHRoZSB2YWx1ZSBuZWVkcyB1cGRhdGluZyBiZWZvcmUgcmV0dXJuaW5nIGl0LlxuICAgIHByb2R1Y2VyVXBkYXRlVmFsdWVWZXJzaW9uKG5vZGUpO1xuXG4gICAgLy8gUmVjb3JkIHRoYXQgc29tZW9uZSBsb29rZWQgYXQgdGhpcyBzaWduYWwuXG4gICAgcHJvZHVjZXJBY2Nlc3NlZChub2RlKTtcblxuICAgIGlmIChub2RlLnZhbHVlID09PSBFUlJPUkVEKSB7XG4gICAgICB0aHJvdyBub2RlLmVycm9yO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlLnZhbHVlO1xuICB9O1xuICAoY29tcHV0ZWQgYXMgYW55KVtTSUdOQUxdID0gbm9kZTtcbiAgcmV0dXJuIGNvbXB1dGVkIGFzIGFueSBhcyBTaWduYWw8VD47XG59XG5cblxuLyoqXG4gKiBBIGRlZGljYXRlZCBzeW1ib2wgdXNlZCBiZWZvcmUgYSBjb21wdXRlZCB2YWx1ZSBoYXMgYmVlbiBjYWxjdWxhdGVkIGZvciB0aGUgZmlyc3QgdGltZS5cbiAqIEV4cGxpY2l0bHkgdHlwZWQgYXMgYGFueWAgc28gd2UgY2FuIHVzZSBpdCBhcyBzaWduYWwncyB2YWx1ZS5cbiAqL1xuY29uc3QgVU5TRVQ6IGFueSA9IFN5bWJvbCgnVU5TRVQnKTtcblxuLyoqXG4gKiBBIGRlZGljYXRlZCBzeW1ib2wgdXNlZCBpbiBwbGFjZSBvZiBhIGNvbXB1dGVkIHNpZ25hbCB2YWx1ZSB0byBpbmRpY2F0ZSB0aGF0IGEgZ2l2ZW4gY29tcHV0YXRpb25cbiAqIGlzIGluIHByb2dyZXNzLiBVc2VkIHRvIGRldGVjdCBjeWNsZXMgaW4gY29tcHV0YXRpb24gY2hhaW5zLlxuICogRXhwbGljaXRseSB0eXBlZCBhcyBgYW55YCBzbyB3ZSBjYW4gdXNlIGl0IGFzIHNpZ25hbCdzIHZhbHVlLlxuICovXG5jb25zdCBDT01QVVRJTkc6IGFueSA9IFN5bWJvbCgnQ09NUFVUSU5HJyk7XG5cbi8qKlxuICogQSBkZWRpY2F0ZWQgc3ltYm9sIHVzZWQgaW4gcGxhY2Ugb2YgYSBjb21wdXRlZCBzaWduYWwgdmFsdWUgdG8gaW5kaWNhdGUgdGhhdCBhIGdpdmVuIGNvbXB1dGF0aW9uXG4gKiBmYWlsZWQuIFRoZSB0aHJvd24gZXJyb3IgaXMgY2FjaGVkIHVudGlsIHRoZSBjb21wdXRhdGlvbiBnZXRzIGRpcnR5IGFnYWluLlxuICogRXhwbGljaXRseSB0eXBlZCBhcyBgYW55YCBzbyB3ZSBjYW4gdXNlIGl0IGFzIHNpZ25hbCdzIHZhbHVlLlxuICovXG5jb25zdCBFUlJPUkVEOiBhbnkgPSBTeW1ib2woJ0VSUk9SRUQnKTtcblxuLyoqXG4gKiBBIGNvbXB1dGF0aW9uLCB3aGljaCBkZXJpdmVzIGEgdmFsdWUgZnJvbSBhIGRlY2xhcmF0aXZlIHJlYWN0aXZlIGV4cHJlc3Npb24uXG4gKlxuICogYENvbXB1dGVkYHMgYXJlIGJvdGggcHJvZHVjZXJzIGFuZCBjb25zdW1lcnMgb2YgcmVhY3Rpdml0eS5cbiAqL1xuaW50ZXJmYWNlIENvbXB1dGVkTm9kZTxUPiBleHRlbmRzIFJlYWN0aXZlTm9kZSB7XG4gIC8qKlxuICAgKiBDdXJyZW50IHZhbHVlIG9mIHRoZSBjb21wdXRhdGlvbiwgb3Igb25lIG9mIHRoZSBzZW50aW5lbCB2YWx1ZXMgYWJvdmUgKGBVTlNFVGAsIGBDT01QVVRJTkdgLFxuICAgKiBgRVJST1JgKS5cbiAgICovXG4gIHZhbHVlOiBUO1xuXG4gIC8qKlxuICAgKiBJZiBgdmFsdWVgIGlzIGBFUlJPUkVEYCwgdGhlIGVycm9yIGNhdWdodCBmcm9tIHRoZSBsYXN0IGNvbXB1dGF0aW9uIGF0dGVtcHQgd2hpY2ggd2lsbFxuICAgKiBiZSByZS10aHJvd24uXG4gICAqL1xuICBlcnJvcjogdW5rbm93bjtcblxuICAvKipcbiAgICogVGhlIGNvbXB1dGF0aW9uIGZ1bmN0aW9uIHdoaWNoIHdpbGwgcHJvZHVjZSBhIG5ldyB2YWx1ZS5cbiAgICovXG4gIGNvbXB1dGF0aW9uOiAoKSA9PiBUO1xuXG4gIGVxdWFsOiBWYWx1ZUVxdWFsaXR5Rm48VD47XG59XG5cbmNvbnN0IENPTVBVVEVEX05PREUgPSB7XG4gIC4uLlJFQUNUSVZFX05PREUsXG4gIHZhbHVlOiBVTlNFVCxcbiAgZGlydHk6IHRydWUsXG4gIGVycm9yOiBudWxsLFxuICBlcXVhbDogZGVmYXVsdEVxdWFscyxcblxuICBwcm9kdWNlck11c3RSZWNvbXB1dGUobm9kZTogQ29tcHV0ZWROb2RlPHVua25vd24+KTogYm9vbGVhbiB7XG4gICAgLy8gRm9yY2UgYSByZWNvbXB1dGF0aW9uIGlmIHRoZXJlJ3Mgbm8gY3VycmVudCB2YWx1ZSwgb3IgaWYgdGhlIGN1cnJlbnQgdmFsdWUgaXMgaW4gdGhlIHByb2Nlc3NcbiAgICAvLyBvZiBiZWluZyBjYWxjdWxhdGVkICh3aGljaCBzaG91bGQgdGhyb3cgYW4gZXJyb3IpLlxuICAgIHJldHVybiBub2RlLnZhbHVlID09PSBVTlNFVCB8fCBub2RlLnZhbHVlID09PSBDT01QVVRJTkc7XG4gIH0sXG5cbiAgcHJvZHVjZXJSZWNvbXB1dGVWYWx1ZShub2RlOiBDb21wdXRlZE5vZGU8dW5rbm93bj4pOiB2b2lkIHtcbiAgICBpZiAobm9kZS52YWx1ZSA9PT0gQ09NUFVUSU5HKSB7XG4gICAgICAvLyBPdXIgY29tcHV0YXRpb24gc29tZWhvdyBsZWQgdG8gYSBjeWNsaWMgcmVhZCBvZiBpdHNlbGYuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RldGVjdGVkIGN5Y2xlIGluIGNvbXB1dGF0aW9ucy4nKTtcbiAgICB9XG5cbiAgICBjb25zdCBvbGRWYWx1ZSA9IG5vZGUudmFsdWU7XG4gICAgbm9kZS52YWx1ZSA9IENPTVBVVElORztcblxuICAgIGNvbnN0IHByZXZDb25zdW1lciA9IGNvbnN1bWVyQmVmb3JlQ29tcHV0YXRpb24obm9kZSk7XG4gICAgbGV0IG5ld1ZhbHVlOiB1bmtub3duO1xuICAgIHRyeSB7XG4gICAgICBuZXdWYWx1ZSA9IG5vZGUuY29tcHV0YXRpb24oKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIG5ld1ZhbHVlID0gRVJST1JFRDtcbiAgICAgIG5vZGUuZXJyb3IgPSBlcnI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGNvbnN1bWVyQWZ0ZXJDb21wdXRhdGlvbihub2RlLCBwcmV2Q29uc3VtZXIpO1xuICAgIH1cblxuICAgIGlmIChvbGRWYWx1ZSAhPT0gVU5TRVQgJiYgb2xkVmFsdWUgIT09IEVSUk9SRUQgJiYgbmV3VmFsdWUgIT09IEVSUk9SRUQgJiZcbiAgICAgICAgbm9kZS5lcXVhbChvbGRWYWx1ZSwgbmV3VmFsdWUpKSB7XG4gICAgICAvLyBObyBjaGFuZ2UgdG8gYHZhbHVlVmVyc2lvbmAgLSBvbGQgYW5kIG5ldyB2YWx1ZXMgYXJlXG4gICAgICAvLyBzZW1hbnRpY2FsbHkgZXF1aXZhbGVudC5cbiAgICAgIG5vZGUudmFsdWUgPSBvbGRWYWx1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBub2RlLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgbm9kZS52ZXJzaW9uKys7XG4gIH0sXG59O1xuIl19
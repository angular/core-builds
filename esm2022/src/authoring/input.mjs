/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { createInputSignal } from './input_signal';
import { REQUIRED_UNSET_VALUE } from './input_signal_node';
export function inputFunction(initialValue, opts) {
    return createInputSignal(initialValue, opts);
}
export function inputRequiredFunction(opts) {
    return createInputSignal(REQUIRED_UNSET_VALUE, opts);
}
/**
 * Initializes an input with an initial value. If no explicit value
 * is specified, Angular will use `undefined`.
 *
 * Consider using `input.required` for inputs that don't need an
 * initial value.
 *
 * @usageNotes
 * Initialize an input in your directive or component by declaring a
 * class field and initializing it with the `input()` function.
 *
 * ```ts
 * @Directive({..})
 * export class MyDir {
 *   firstName = input<string>();            // string|undefined
 *   lastName = input.required<string>();    // string
 *   age = input(0);                         // number
 * }
 * ```
 */
export const input = (() => {
    // Note: This may be considered a side-effect, but nothing will depend on
    // this assignment, unless this `input` constant export is accessed. It's a
    // self-contained side effect that is local to the user facing`input` export.
    inputFunction.required = inputRequiredFunction;
    return inputFunction;
})();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5wdXQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9jb3JlL3NyYy9hdXRob3JpbmcvaW5wdXQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztHQU1HO0FBRUgsT0FBTyxFQUFDLGlCQUFpQixFQUFxRixNQUFNLGdCQUFnQixDQUFDO0FBQ3JJLE9BQU8sRUFBQyxvQkFBb0IsRUFBQyxNQUFNLHFCQUFxQixDQUFDO0FBNEJ6RCxNQUFNLFVBQVUsYUFBYSxDQUN6QixZQUFvQixFQUNwQixJQUFrQztJQUNwQyxPQUFPLGlCQUFpQixDQUFDLFlBQVksRUFBRSxJQUFJLENBQUMsQ0FBQztBQUMvQyxDQUFDO0FBdUJELE1BQU0sVUFBVSxxQkFBcUIsQ0FBZ0IsSUFBa0M7SUFFckYsT0FBTyxpQkFBaUIsQ0FBQyxvQkFBNkIsRUFBRSxJQUFJLENBQUMsQ0FBQztBQUNoRSxDQUFDO0FBVUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FtQkc7QUFDSCxNQUFNLENBQUMsTUFBTSxLQUFLLEdBQWtCLENBQUMsR0FBRyxFQUFFO0lBQ3hDLHlFQUF5RTtJQUN6RSwyRUFBMkU7SUFDM0UsNkVBQTZFO0lBQzVFLGFBQXFCLENBQUMsUUFBUSxHQUFHLHFCQUFxQixDQUFDO0lBQ3hELE9BQU8sYUFBOEIsQ0FBQztBQUN4QyxDQUFDLENBQUMsRUFBRSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbmltcG9ydCB7Y3JlYXRlSW5wdXRTaWduYWwsIElucHV0T3B0aW9ucywgSW5wdXRPcHRpb25zV2l0aG91dFRyYW5zZm9ybSwgSW5wdXRPcHRpb25zV2l0aFRyYW5zZm9ybSwgSW5wdXRTaWduYWx9IGZyb20gJy4vaW5wdXRfc2lnbmFsJztcbmltcG9ydCB7UkVRVUlSRURfVU5TRVRfVkFMVUV9IGZyb20gJy4vaW5wdXRfc2lnbmFsX25vZGUnO1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIGlucHV0IHdpdGggYW4gaW5pdGlhbCB2YWx1ZS4gSWYgbm8gZXhwbGljaXQgdmFsdWVcbiAqIGlzIHNwZWNpZmllZCwgQW5ndWxhciB3aWxsIHVzZSBgdW5kZWZpbmVkYC5cbiAqXG4gKiBDb25zaWRlciB1c2luZyBgaW5wdXQucmVxdWlyZWRgIGZvciBpbnB1dHMgdGhhdCBkb24ndCBuZWVkIGFuXG4gKiBpbml0aWFsIHZhbHVlLlxuICpcbiAqIEB1c2FnZU5vdGVzXG4gKiBJbml0aWFsaXplIGFuIGlucHV0IGluIHlvdXIgZGlyZWN0aXZlIG9yIGNvbXBvbmVudCBieSBkZWNsYXJpbmcgYVxuICogY2xhc3MgZmllbGQgYW5kIGluaXRpYWxpemluZyBpdCB3aXRoIHRoZSBgaW5wdXQoKWAgZnVuY3Rpb24uXG4gKlxuICogYGBgdHNcbiAqIEBEaXJlY3RpdmUoey4ufSlcbiAqIGV4cG9ydCBjbGFzcyBNeURpciB7XG4gKiAgIGZpcnN0TmFtZSA9IGlucHV0PHN0cmluZz4oKTsgICAgICAgICAgICAvLyBzdHJpbmd8dW5kZWZpbmVkXG4gKiAgIGxhc3ROYW1lID0gaW5wdXQucmVxdWlyZWQ8c3RyaW5nPigpOyAgICAvLyBzdHJpbmdcbiAqICAgYWdlID0gaW5wdXQoMCk7ICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG51bWJlclxuICogfVxuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnB1dEZ1bmN0aW9uPFJlYWRUPigpOiBJbnB1dFNpZ25hbDxSZWFkVHx1bmRlZmluZWQ+O1xuZXhwb3J0IGZ1bmN0aW9uIGlucHV0RnVuY3Rpb248UmVhZFQ+KFxuICAgIGluaXRpYWxWYWx1ZTogUmVhZFQsIG9wdHM/OiBJbnB1dE9wdGlvbnNXaXRob3V0VHJhbnNmb3JtPFJlYWRUPik6IElucHV0U2lnbmFsPFJlYWRUPjtcbmV4cG9ydCBmdW5jdGlvbiBpbnB1dEZ1bmN0aW9uPFJlYWRULCBXcml0ZVQ+KFxuICAgIGluaXRpYWxWYWx1ZTogUmVhZFQsXG4gICAgb3B0czogSW5wdXRPcHRpb25zV2l0aFRyYW5zZm9ybTxSZWFkVCwgV3JpdGVUPik6IElucHV0U2lnbmFsPFJlYWRULCBXcml0ZVQ+O1xuZXhwb3J0IGZ1bmN0aW9uIGlucHV0RnVuY3Rpb248UmVhZFQsIFdyaXRlVD4oXG4gICAgaW5pdGlhbFZhbHVlPzogUmVhZFQsXG4gICAgb3B0cz86IElucHV0T3B0aW9uczxSZWFkVCwgV3JpdGVUPik6IElucHV0U2lnbmFsPFJlYWRUfHVuZGVmaW5lZCwgV3JpdGVUPiB7XG4gIHJldHVybiBjcmVhdGVJbnB1dFNpZ25hbChpbml0aWFsVmFsdWUsIG9wdHMpO1xufVxuXG4vKipcbiAqIEluaXRpYWxpemVzIGEgcmVxdWlyZWQgaW5wdXQuIFVzZXJzIG9mIHlvdXIgZGlyZWN0aXZlL2NvbXBvbmVudCxcbiAqIG5lZWQgdG8gYmluZCB0byB0aGlzIGlucHV0LCBvdGhlcndpc2UgdGhleSB3aWxsIHNlZSBlcnJvcnMuXG4gKiAqXG4gKiBAdXNhZ2VOb3Rlc1xuICogSW5pdGlhbGl6ZSBhbiBpbnB1dCBpbiB5b3VyIGRpcmVjdGl2ZSBvciBjb21wb25lbnQgYnkgZGVjbGFyaW5nIGFcbiAqIGNsYXNzIGZpZWxkIGFuZCBpbml0aWFsaXppbmcgaXQgd2l0aCB0aGUgYGlucHV0KClgIGZ1bmN0aW9uLlxuICpcbiAqIGBgYHRzXG4gKiBARGlyZWN0aXZlKHsuLn0pXG4gKiBleHBvcnQgY2xhc3MgTXlEaXIge1xuICogICBmaXJzdE5hbWUgPSBpbnB1dDxzdHJpbmc+KCk7ICAgICAgICAgICAgLy8gc3RyaW5nfHVuZGVmaW5lZFxuICogICBsYXN0TmFtZSA9IGlucHV0LnJlcXVpcmVkPHN0cmluZz4oKTsgICAgLy8gc3RyaW5nXG4gKiAgIGFnZSA9IGlucHV0KDApOyAgICAgICAgICAgICAgICAgICAgICAgICAvLyBudW1iZXJcbiAqIH1cbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5wdXRSZXF1aXJlZEZ1bmN0aW9uPFJlYWRUPihvcHRzPzogSW5wdXRPcHRpb25zV2l0aG91dFRyYW5zZm9ybTxSZWFkVD4pOlxuICAgIElucHV0U2lnbmFsPFJlYWRUPjtcbmV4cG9ydCBmdW5jdGlvbiBpbnB1dFJlcXVpcmVkRnVuY3Rpb248UmVhZFQsIFdyaXRlVD4oXG4gICAgb3B0czogSW5wdXRPcHRpb25zV2l0aFRyYW5zZm9ybTxSZWFkVCwgV3JpdGVUPik6IElucHV0U2lnbmFsPFJlYWRULCBXcml0ZVQ+O1xuZXhwb3J0IGZ1bmN0aW9uIGlucHV0UmVxdWlyZWRGdW5jdGlvbjxSZWFkVCwgV3JpdGVUPihvcHRzPzogSW5wdXRPcHRpb25zPFJlYWRULCBXcml0ZVQ+KTpcbiAgICBJbnB1dFNpZ25hbDxSZWFkVCwgV3JpdGVUPiB7XG4gIHJldHVybiBjcmVhdGVJbnB1dFNpZ25hbChSRVFVSVJFRF9VTlNFVF9WQUxVRSBhcyBuZXZlciwgb3B0cyk7XG59XG5cbi8qKlxuICogVHlwZSBvZiB0aGUgYGlucHV0YCBmdW5jdGlvbi5cbiAqXG4gKiBUaGUgaW5wdXQgZnVuY3Rpb24gaXMgYSBzcGVjaWFsIGZ1bmN0aW9uIHRoYXQgYWxzbyBwcm92aWRlcyBhY2Nlc3MgdG9cbiAqIHJlcXVpcmVkIGlucHV0cyB2aWEgdGhlIGAucmVxdWlyZWRgIHByb3BlcnR5LlxuICovXG5leHBvcnQgdHlwZSBJbnB1dEZ1bmN0aW9uID0gdHlwZW9mIGlucHV0RnVuY3Rpb24me3JlcXVpcmVkOiB0eXBlb2YgaW5wdXRSZXF1aXJlZEZ1bmN0aW9ufTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBpbnB1dCB3aXRoIGFuIGluaXRpYWwgdmFsdWUuIElmIG5vIGV4cGxpY2l0IHZhbHVlXG4gKiBpcyBzcGVjaWZpZWQsIEFuZ3VsYXIgd2lsbCB1c2UgYHVuZGVmaW5lZGAuXG4gKlxuICogQ29uc2lkZXIgdXNpbmcgYGlucHV0LnJlcXVpcmVkYCBmb3IgaW5wdXRzIHRoYXQgZG9uJ3QgbmVlZCBhblxuICogaW5pdGlhbCB2YWx1ZS5cbiAqXG4gKiBAdXNhZ2VOb3Rlc1xuICogSW5pdGlhbGl6ZSBhbiBpbnB1dCBpbiB5b3VyIGRpcmVjdGl2ZSBvciBjb21wb25lbnQgYnkgZGVjbGFyaW5nIGFcbiAqIGNsYXNzIGZpZWxkIGFuZCBpbml0aWFsaXppbmcgaXQgd2l0aCB0aGUgYGlucHV0KClgIGZ1bmN0aW9uLlxuICpcbiAqIGBgYHRzXG4gKiBARGlyZWN0aXZlKHsuLn0pXG4gKiBleHBvcnQgY2xhc3MgTXlEaXIge1xuICogICBmaXJzdE5hbWUgPSBpbnB1dDxzdHJpbmc+KCk7ICAgICAgICAgICAgLy8gc3RyaW5nfHVuZGVmaW5lZFxuICogICBsYXN0TmFtZSA9IGlucHV0LnJlcXVpcmVkPHN0cmluZz4oKTsgICAgLy8gc3RyaW5nXG4gKiAgIGFnZSA9IGlucHV0KDApOyAgICAgICAgICAgICAgICAgICAgICAgICAvLyBudW1iZXJcbiAqIH1cbiAqIGBgYFxuICovXG5leHBvcnQgY29uc3QgaW5wdXQ6IElucHV0RnVuY3Rpb24gPSAoKCkgPT4ge1xuICAvLyBOb3RlOiBUaGlzIG1heSBiZSBjb25zaWRlcmVkIGEgc2lkZS1lZmZlY3QsIGJ1dCBub3RoaW5nIHdpbGwgZGVwZW5kIG9uXG4gIC8vIHRoaXMgYXNzaWdubWVudCwgdW5sZXNzIHRoaXMgYGlucHV0YCBjb25zdGFudCBleHBvcnQgaXMgYWNjZXNzZWQuIEl0J3MgYVxuICAvLyBzZWxmLWNvbnRhaW5lZCBzaWRlIGVmZmVjdCB0aGF0IGlzIGxvY2FsIHRvIHRoZSB1c2VyIGZhY2luZ2BpbnB1dGAgZXhwb3J0LlxuICAoaW5wdXRGdW5jdGlvbiBhcyBhbnkpLnJlcXVpcmVkID0gaW5wdXRSZXF1aXJlZEZ1bmN0aW9uO1xuICByZXR1cm4gaW5wdXRGdW5jdGlvbiBhcyBJbnB1dEZ1bmN0aW9uO1xufSkoKTtcbiJdfQ==
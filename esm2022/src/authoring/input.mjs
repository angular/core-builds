/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { createInputSignal } from './input_signal';
import { REQUIRED_UNSET_VALUE } from './input_signal_node';
export function inputFunction(initialValue, opts) {
    return createInputSignal(initialValue, opts);
}
export function inputRequiredFunction(opts) {
    return createInputSignal(REQUIRED_UNSET_VALUE, opts);
}
/**
 * The `input` function allows declaration of inputs in directives and
 * components.
 *
 * Initializes an input with an initial value. If no explicit value
 * is specified, Angular will use `undefined`.
 *
 * Consider using `input.required` for inputs that don't need an
 * initial value.
 *
 * @usageNotes
 * Initialize an input in your directive or component by declaring a
 * class field and initializing it with the `input()` function.
 *
 * ```ts
 * @Directive({..})
 * export class MyDir {
 *   firstName = input<string>();            // string|undefined
 *   lastName = input.required<string>();    // string
 *   age = input(0);                         // number
 * }
 * ```
 *
 * @developerPreview
 */
export const input = (() => {
    // Note: This may be considered a side-effect, but nothing will depend on
    // this assignment, unless this `input` constant export is accessed. It's a
    // self-contained side effect that is local to the user facing`input` export.
    inputFunction.required = inputRequiredFunction;
    return inputFunction;
})();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5wdXQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9jb3JlL3NyYy9hdXRob3JpbmcvaW5wdXQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztHQU1HO0FBRUgsT0FBTyxFQUFDLGlCQUFpQixFQUFxRixNQUFNLGdCQUFnQixDQUFDO0FBQ3JJLE9BQU8sRUFBQyxvQkFBb0IsRUFBQyxNQUFNLHFCQUFxQixDQUFDO0FBRXpELE1BQU0sVUFBVSxhQUFhLENBQ3pCLFlBQW9CLEVBQ3BCLElBQWtDO0lBQ3BDLE9BQU8saUJBQWlCLENBQUMsWUFBWSxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQy9DLENBQUM7QUFFRCxNQUFNLFVBQVUscUJBQXFCLENBQWdCLElBQWtDO0lBRXJGLE9BQU8saUJBQWlCLENBQUMsb0JBQTZCLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFDaEUsQ0FBQztBQXNERDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBd0JHO0FBQ0gsTUFBTSxDQUFDLE1BQU0sS0FBSyxHQUFrQixDQUFDLEdBQUcsRUFBRTtJQUN4Qyx5RUFBeUU7SUFDekUsMkVBQTJFO0lBQzNFLDZFQUE2RTtJQUM1RSxhQUFxQixDQUFDLFFBQVEsR0FBRyxxQkFBcUIsQ0FBQztJQUN4RCxPQUFPLGFBQWdGLENBQUM7QUFDMUYsQ0FBQyxDQUFDLEVBQUUsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG5pbXBvcnQge2NyZWF0ZUlucHV0U2lnbmFsLCBJbnB1dE9wdGlvbnMsIElucHV0T3B0aW9uc1dpdGhvdXRUcmFuc2Zvcm0sIElucHV0T3B0aW9uc1dpdGhUcmFuc2Zvcm0sIElucHV0U2lnbmFsfSBmcm9tICcuL2lucHV0X3NpZ25hbCc7XG5pbXBvcnQge1JFUVVJUkVEX1VOU0VUX1ZBTFVFfSBmcm9tICcuL2lucHV0X3NpZ25hbF9ub2RlJztcblxuZXhwb3J0IGZ1bmN0aW9uIGlucHV0RnVuY3Rpb248UmVhZFQsIFdyaXRlVD4oXG4gICAgaW5pdGlhbFZhbHVlPzogUmVhZFQsXG4gICAgb3B0cz86IElucHV0T3B0aW9uczxSZWFkVCwgV3JpdGVUPik6IElucHV0U2lnbmFsPFJlYWRUfHVuZGVmaW5lZCwgV3JpdGVUPiB7XG4gIHJldHVybiBjcmVhdGVJbnB1dFNpZ25hbChpbml0aWFsVmFsdWUsIG9wdHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5wdXRSZXF1aXJlZEZ1bmN0aW9uPFJlYWRULCBXcml0ZVQ+KG9wdHM/OiBJbnB1dE9wdGlvbnM8UmVhZFQsIFdyaXRlVD4pOlxuICAgIElucHV0U2lnbmFsPFJlYWRULCBXcml0ZVQ+IHtcbiAgcmV0dXJuIGNyZWF0ZUlucHV0U2lnbmFsKFJFUVVJUkVEX1VOU0VUX1ZBTFVFIGFzIG5ldmVyLCBvcHRzKTtcbn1cblxuLyoqXG4gKiBUaGUgYGlucHV0YCBmdW5jdGlvbiBhbGxvd3MgZGVjbGFyYXRpb24gb2YgaW5wdXRzIGluIGRpcmVjdGl2ZXMgYW5kXG4gKiBjb21wb25lbnRzLlxuICpcbiAqIFRoZSBmdW5jdGlvbiBleHBvc2VzIGFuIEFQSSBmb3IgYWxzbyBkZWNsYXJpbmcgcmVxdWlyZWQgaW5wdXRzIHZpYSB0aGVcbiAqIGBpbnB1dC5yZXF1aXJlZGAgZnVuY3Rpb24uXG4gKlxuICogQHVzYWdlTm90ZXNcbiAqIEluaXRpYWxpemUgYW4gaW5wdXQgaW4geW91ciBkaXJlY3RpdmUgb3IgY29tcG9uZW50IGJ5IGRlY2xhcmluZyBhXG4gKiBjbGFzcyBmaWVsZCBhbmQgaW5pdGlhbGl6aW5nIGl0IHdpdGggdGhlIGBpbnB1dCgpYCBvciBgaW5wdXQucmVxdWlyZWQoKWBcbiAqIGZ1bmN0aW9uLlxuICpcbiAqIGBgYHRzXG4gKiBARGlyZWN0aXZlKHsuLn0pXG4gKiBleHBvcnQgY2xhc3MgTXlEaXIge1xuICogICBmaXJzdE5hbWUgPSBpbnB1dDxzdHJpbmc+KCk7ICAgICAgICAgICAgLy8gc3RyaW5nfHVuZGVmaW5lZFxuICogICBsYXN0TmFtZSA9IGlucHV0LnJlcXVpcmVkPHN0cmluZz4oKTsgICAgLy8gc3RyaW5nXG4gKiAgIGFnZSA9IGlucHV0KDApOyAgICAgICAgICAgICAgICAgICAgICAgICAvLyBudW1iZXJcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBkZXZlbG9wZXJQcmV2aWV3XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSW5wdXRGdW5jdGlvbiB7XG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBhbiBpbnB1dCB3aXRoIGFuIGluaXRpYWwgdmFsdWUuIElmIG5vIGV4cGxpY2l0IHZhbHVlXG4gICAqIGlzIHNwZWNpZmllZCwgQW5ndWxhciB3aWxsIHVzZSBgdW5kZWZpbmVkYC5cbiAgICpcbiAgICogQ29uc2lkZXIgdXNpbmcgYGlucHV0LnJlcXVpcmVkYCBmb3IgaW5wdXRzIHRoYXQgZG9uJ3QgbmVlZCBhblxuICAgKiBpbml0aWFsIHZhbHVlLlxuICAgKlxuICAgKiBAZGV2ZWxvcGVyUHJldmlld1xuICAgKi9cbiAgPFJlYWRUPigpOiBJbnB1dFNpZ25hbDxSZWFkVHx1bmRlZmluZWQ+O1xuICA8UmVhZFQ+KGluaXRpYWxWYWx1ZTogUmVhZFQsIG9wdHM/OiBJbnB1dE9wdGlvbnNXaXRob3V0VHJhbnNmb3JtPFJlYWRUPik6IElucHV0U2lnbmFsPFJlYWRUPjtcbiAgPFJlYWRULCBXcml0ZVQ+KGluaXRpYWxWYWx1ZTogUmVhZFQsIG9wdHM6IElucHV0T3B0aW9uc1dpdGhUcmFuc2Zvcm08UmVhZFQsIFdyaXRlVD4pOlxuICAgICAgSW5wdXRTaWduYWw8UmVhZFQsIFdyaXRlVD47XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGEgcmVxdWlyZWQgaW5wdXQuXG4gICAqXG4gICAqIFVzZXJzIG9mIHlvdXIgZGlyZWN0aXZlL2NvbXBvbmVudCBuZWVkIHRvIGJpbmQgdG8gdGhpc1xuICAgKiBpbnB1dC4gSWYgdW5zZXQsIGEgY29tcGlsZSB0aW1lIGVycm9yIHdpbGwgYmUgcmVwb3J0ZWQuXG4gICAqXG4gICAqIEBkZXZlbG9wZXJQcmV2aWV3XG4gICAqL1xuICByZXF1aXJlZDoge1xuICAgIDxSZWFkVD4ob3B0cz86IElucHV0T3B0aW9uc1dpdGhvdXRUcmFuc2Zvcm08UmVhZFQ+KTogSW5wdXRTaWduYWw8UmVhZFQ+O1xuICAgIDxSZWFkVCwgV3JpdGVUPihvcHRzOiBJbnB1dE9wdGlvbnNXaXRoVHJhbnNmb3JtPFJlYWRULCBXcml0ZVQ+KTogSW5wdXRTaWduYWw8UmVhZFQsIFdyaXRlVD47XG4gIH07XG59XG5cbi8qKlxuICogVGhlIGBpbnB1dGAgZnVuY3Rpb24gYWxsb3dzIGRlY2xhcmF0aW9uIG9mIGlucHV0cyBpbiBkaXJlY3RpdmVzIGFuZFxuICogY29tcG9uZW50cy5cbiAqXG4gKiBJbml0aWFsaXplcyBhbiBpbnB1dCB3aXRoIGFuIGluaXRpYWwgdmFsdWUuIElmIG5vIGV4cGxpY2l0IHZhbHVlXG4gKiBpcyBzcGVjaWZpZWQsIEFuZ3VsYXIgd2lsbCB1c2UgYHVuZGVmaW5lZGAuXG4gKlxuICogQ29uc2lkZXIgdXNpbmcgYGlucHV0LnJlcXVpcmVkYCBmb3IgaW5wdXRzIHRoYXQgZG9uJ3QgbmVlZCBhblxuICogaW5pdGlhbCB2YWx1ZS5cbiAqXG4gKiBAdXNhZ2VOb3Rlc1xuICogSW5pdGlhbGl6ZSBhbiBpbnB1dCBpbiB5b3VyIGRpcmVjdGl2ZSBvciBjb21wb25lbnQgYnkgZGVjbGFyaW5nIGFcbiAqIGNsYXNzIGZpZWxkIGFuZCBpbml0aWFsaXppbmcgaXQgd2l0aCB0aGUgYGlucHV0KClgIGZ1bmN0aW9uLlxuICpcbiAqIGBgYHRzXG4gKiBARGlyZWN0aXZlKHsuLn0pXG4gKiBleHBvcnQgY2xhc3MgTXlEaXIge1xuICogICBmaXJzdE5hbWUgPSBpbnB1dDxzdHJpbmc+KCk7ICAgICAgICAgICAgLy8gc3RyaW5nfHVuZGVmaW5lZFxuICogICBsYXN0TmFtZSA9IGlucHV0LnJlcXVpcmVkPHN0cmluZz4oKTsgICAgLy8gc3RyaW5nXG4gKiAgIGFnZSA9IGlucHV0KDApOyAgICAgICAgICAgICAgICAgICAgICAgICAvLyBudW1iZXJcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBkZXZlbG9wZXJQcmV2aWV3XG4gKi9cbmV4cG9ydCBjb25zdCBpbnB1dDogSW5wdXRGdW5jdGlvbiA9ICgoKSA9PiB7XG4gIC8vIE5vdGU6IFRoaXMgbWF5IGJlIGNvbnNpZGVyZWQgYSBzaWRlLWVmZmVjdCwgYnV0IG5vdGhpbmcgd2lsbCBkZXBlbmQgb25cbiAgLy8gdGhpcyBhc3NpZ25tZW50LCB1bmxlc3MgdGhpcyBgaW5wdXRgIGNvbnN0YW50IGV4cG9ydCBpcyBhY2Nlc3NlZC4gSXQncyBhXG4gIC8vIHNlbGYtY29udGFpbmVkIHNpZGUgZWZmZWN0IHRoYXQgaXMgbG9jYWwgdG8gdGhlIHVzZXIgZmFjaW5nYGlucHV0YCBleHBvcnQuXG4gIChpbnB1dEZ1bmN0aW9uIGFzIGFueSkucmVxdWlyZWQgPSBpbnB1dFJlcXVpcmVkRnVuY3Rpb247XG4gIHJldHVybiBpbnB1dEZ1bmN0aW9uIGFzICh0eXBlb2YgaW5wdXRGdW5jdGlvbiZ7cmVxdWlyZWQ6IHR5cGVvZiBpbnB1dFJlcXVpcmVkRnVuY3Rpb259KTtcbn0pKCk7XG4iXX0=
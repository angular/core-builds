/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { assertInInjectionContext } from '../../di';
import { REQUIRED_UNSET_VALUE } from '../input/input_signal_node';
import { createModelSignal } from './model_signal';
export function modelFunction(initialValue) {
    ngDevMode && assertInInjectionContext(model);
    return createModelSignal(initialValue);
}
export function modelRequiredFunction() {
    ngDevMode && assertInInjectionContext(model);
    return createModelSignal(REQUIRED_UNSET_VALUE);
}
/**
 * `model` declares a writeable signal that is exposed as an input/output pair on the containing
 * directive. The input name is taken either from the class member or from the `alias` option.
 * The output name is generated by taking the input name and appending `Change`.
 *
 * Initializes a model with an initial value. If no explicit value
 * is specified, Angular will use `undefined`.
 *
 * Consider using `model.required` for models that don't need an
 * initial value.
 *
 * @usageNotes
 * Initialize a model in your directive or component by declaring a
 * class field and initializing it with the `model()` or `model.required()`
 * function.
 *
 * ```ts
 * @Directive({..})
 * export class MyDir {
 *   firstName = model<string>();            // string|undefined
 *   lastName = model.required<string>();    // string
 *   age = model(0);                         // number
 * }
 * ```
 *
 * @developerPreview
 */
export const model = (() => {
    // Note: This may be considered a side-effect, but nothing will depend on
    // this assignment, unless this `model` constant export is accessed. It's a
    // self-contained side effect that is local to the user facing `model` export.
    modelFunction.required = modelRequiredFunction;
    return modelFunction;
})();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9kZWwuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9jb3JlL3NyYy9hdXRob3JpbmcvbW9kZWwvbW9kZWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztHQU1HO0FBRUgsT0FBTyxFQUFDLHdCQUF3QixFQUFDLE1BQU0sVUFBVSxDQUFDO0FBQ2xELE9BQU8sRUFBQyxvQkFBb0IsRUFBQyxNQUFNLDRCQUE0QixDQUFDO0FBRWhFLE9BQU8sRUFBQyxpQkFBaUIsRUFBNEIsTUFBTSxnQkFBZ0IsQ0FBQztBQUU1RSxNQUFNLFVBQVUsYUFBYSxDQUFJLFlBQWdCO0lBQy9DLFNBQVMsSUFBSSx3QkFBd0IsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUU3QyxPQUFPLGlCQUFpQixDQUFDLFlBQVksQ0FBQyxDQUFDO0FBQ3pDLENBQUM7QUFFRCxNQUFNLFVBQVUscUJBQXFCO0lBQ25DLFNBQVMsSUFBSSx3QkFBd0IsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUU3QyxPQUFPLGlCQUFpQixDQUFDLG9CQUF5QixDQUFDLENBQUM7QUFDdEQsQ0FBQztBQWtERDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0EwQkc7QUFDSCxNQUFNLENBQUMsTUFBTSxLQUFLLEdBQWtCLENBQUMsR0FBRyxFQUFFO0lBQ3hDLHlFQUF5RTtJQUN6RSwyRUFBMkU7SUFDM0UsOEVBQThFO0lBQzdFLGFBQXFCLENBQUMsUUFBUSxHQUFHLHFCQUFxQixDQUFDO0lBQ3hELE9BQU8sYUFBZ0YsQ0FBQztBQUMxRixDQUFDLENBQUMsRUFBRSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbmltcG9ydCB7YXNzZXJ0SW5JbmplY3Rpb25Db250ZXh0fSBmcm9tICcuLi8uLi9kaSc7XG5pbXBvcnQge1JFUVVJUkVEX1VOU0VUX1ZBTFVFfSBmcm9tICcuLi9pbnB1dC9pbnB1dF9zaWduYWxfbm9kZSc7XG5cbmltcG9ydCB7Y3JlYXRlTW9kZWxTaWduYWwsIE1vZGVsT3B0aW9ucywgTW9kZWxTaWduYWx9IGZyb20gJy4vbW9kZWxfc2lnbmFsJztcblxuZXhwb3J0IGZ1bmN0aW9uIG1vZGVsRnVuY3Rpb248VD4oaW5pdGlhbFZhbHVlPzogVCk6IE1vZGVsU2lnbmFsPFR8dW5kZWZpbmVkPiB7XG4gIG5nRGV2TW9kZSAmJiBhc3NlcnRJbkluamVjdGlvbkNvbnRleHQobW9kZWwpO1xuXG4gIHJldHVybiBjcmVhdGVNb2RlbFNpZ25hbChpbml0aWFsVmFsdWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbW9kZWxSZXF1aXJlZEZ1bmN0aW9uPFQ+KCk6IE1vZGVsU2lnbmFsPFQ+IHtcbiAgbmdEZXZNb2RlICYmIGFzc2VydEluSW5qZWN0aW9uQ29udGV4dChtb2RlbCk7XG5cbiAgcmV0dXJuIGNyZWF0ZU1vZGVsU2lnbmFsKFJFUVVJUkVEX1VOU0VUX1ZBTFVFIGFzIFQpO1xufVxuXG4vKipcbiAqIGBtb2RlbGAgZGVjbGFyZXMgYSB3cml0ZWFibGUgc2lnbmFsIHRoYXQgaXMgZXhwb3NlZCBhcyBhbiBpbnB1dC9vdXRwdXQgcGFpciBvbiB0aGUgY29udGFpbmluZ1xuICogZGlyZWN0aXZlLiBUaGUgaW5wdXQgbmFtZSBpcyB0YWtlbiBlaXRoZXIgZnJvbSB0aGUgY2xhc3MgbWVtYmVyIG9yIGZyb20gdGhlIGBhbGlhc2Agb3B0aW9uLlxuICogVGhlIG91dHB1dCBuYW1lIGlzIGdlbmVyYXRlZCBieSB0YWtpbmcgdGhlIGlucHV0IG5hbWUgYW5kIGFwcGVuZGluZyBgQ2hhbmdlYC5cbiAqXG4gKiBUaGUgZnVuY3Rpb24gZXhwb3NlcyBhbiBBUEkgZm9yIGFsc28gZGVjbGFyaW5nIHJlcXVpcmVkIG1vZGVscyB2aWEgdGhlXG4gKiBgbW9kZWwucmVxdWlyZWRgIGZ1bmN0aW9uLlxuICpcbiAqIEB1c2FnZU5vdGVzXG4gKiBJbml0aWFsaXplIGEgbW9kZWwgaW4geW91ciBkaXJlY3RpdmUgb3IgY29tcG9uZW50IGJ5IGRlY2xhcmluZyBhXG4gKiBjbGFzcyBmaWVsZCBhbmQgaW5pdGlhbGl6aW5nIGl0IHdpdGggdGhlIGBtb2RlbCgpYCBvciBgbW9kZWwucmVxdWlyZWQoKWBcbiAqIGZ1bmN0aW9uLlxuICpcbiAqIGBgYHRzXG4gKiBARGlyZWN0aXZlKHsuLn0pXG4gKiBleHBvcnQgY2xhc3MgTXlEaXIge1xuICogICBmaXJzdE5hbWUgPSBtb2RlbDxzdHJpbmc+KCk7ICAgICAgICAgICAgLy8gc3RyaW5nfHVuZGVmaW5lZFxuICogICBsYXN0TmFtZSA9IG1vZGVsLnJlcXVpcmVkPHN0cmluZz4oKTsgICAgLy8gc3RyaW5nXG4gKiAgIGFnZSA9IG1vZGVsKDApOyAgICAgICAgICAgICAgICAgICAgICAgICAvLyBudW1iZXJcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBkZXZlbG9wZXJQcmV2aWV3XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTW9kZWxGdW5jdGlvbiB7XG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBhIG1vZGVsIHdpdGggYW4gaW5pdGlhbCB2YWx1ZS4gSWYgbm8gZXhwbGljaXQgdmFsdWVcbiAgICogaXMgc3BlY2lmaWVkLCBBbmd1bGFyIHdpbGwgdXNlIGB1bmRlZmluZWRgLlxuICAgKlxuICAgKiBDb25zaWRlciB1c2luZyBgbW9kZWwucmVxdWlyZWRgIGZvciBtb2RlbHMgdGhhdCBkb24ndCBuZWVkIGFuXG4gICAqIGluaXRpYWwgdmFsdWUuXG4gICAqXG4gICAqIEBkZXZlbG9wZXJQcmV2aWV3XG4gICAqL1xuICA8VD4oKTogTW9kZWxTaWduYWw8VHx1bmRlZmluZWQ+O1xuICA8VD4oaW5pdGlhbFZhbHVlOiBULCBvcHRzPzogTW9kZWxPcHRpb25zKTogTW9kZWxTaWduYWw8VD47XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGEgcmVxdWlyZWQgbW9kZWwuXG4gICAqXG4gICAqIFVzZXJzIG9mIHlvdXIgZGlyZWN0aXZlL2NvbXBvbmVudCBuZWVkIHRvIGJpbmQgdG8gdGhlIGlucHV0IHNpZGUgb2YgdGhlIG1vZGVsLlxuICAgKiBJZiB1bnNldCwgYSBjb21waWxlIHRpbWUgZXJyb3Igd2lsbCBiZSByZXBvcnRlZC5cbiAgICpcbiAgICogQGRldmVsb3BlclByZXZpZXdcbiAgICovXG4gIHJlcXVpcmVkPFQ+KG9wdHM/OiBNb2RlbE9wdGlvbnMpOiBNb2RlbFNpZ25hbDxUPjtcbn1cblxuLyoqXG4gKiBgbW9kZWxgIGRlY2xhcmVzIGEgd3JpdGVhYmxlIHNpZ25hbCB0aGF0IGlzIGV4cG9zZWQgYXMgYW4gaW5wdXQvb3V0cHV0IHBhaXIgb24gdGhlIGNvbnRhaW5pbmdcbiAqIGRpcmVjdGl2ZS4gVGhlIGlucHV0IG5hbWUgaXMgdGFrZW4gZWl0aGVyIGZyb20gdGhlIGNsYXNzIG1lbWJlciBvciBmcm9tIHRoZSBgYWxpYXNgIG9wdGlvbi5cbiAqIFRoZSBvdXRwdXQgbmFtZSBpcyBnZW5lcmF0ZWQgYnkgdGFraW5nIHRoZSBpbnB1dCBuYW1lIGFuZCBhcHBlbmRpbmcgYENoYW5nZWAuXG4gKlxuICogSW5pdGlhbGl6ZXMgYSBtb2RlbCB3aXRoIGFuIGluaXRpYWwgdmFsdWUuIElmIG5vIGV4cGxpY2l0IHZhbHVlXG4gKiBpcyBzcGVjaWZpZWQsIEFuZ3VsYXIgd2lsbCB1c2UgYHVuZGVmaW5lZGAuXG4gKlxuICogQ29uc2lkZXIgdXNpbmcgYG1vZGVsLnJlcXVpcmVkYCBmb3IgbW9kZWxzIHRoYXQgZG9uJ3QgbmVlZCBhblxuICogaW5pdGlhbCB2YWx1ZS5cbiAqXG4gKiBAdXNhZ2VOb3Rlc1xuICogSW5pdGlhbGl6ZSBhIG1vZGVsIGluIHlvdXIgZGlyZWN0aXZlIG9yIGNvbXBvbmVudCBieSBkZWNsYXJpbmcgYVxuICogY2xhc3MgZmllbGQgYW5kIGluaXRpYWxpemluZyBpdCB3aXRoIHRoZSBgbW9kZWwoKWAgb3IgYG1vZGVsLnJlcXVpcmVkKClgXG4gKiBmdW5jdGlvbi5cbiAqXG4gKiBgYGB0c1xuICogQERpcmVjdGl2ZSh7Li59KVxuICogZXhwb3J0IGNsYXNzIE15RGlyIHtcbiAqICAgZmlyc3ROYW1lID0gbW9kZWw8c3RyaW5nPigpOyAgICAgICAgICAgIC8vIHN0cmluZ3x1bmRlZmluZWRcbiAqICAgbGFzdE5hbWUgPSBtb2RlbC5yZXF1aXJlZDxzdHJpbmc+KCk7ICAgIC8vIHN0cmluZ1xuICogICBhZ2UgPSBtb2RlbCgwKTsgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbnVtYmVyXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAZGV2ZWxvcGVyUHJldmlld1xuICovXG5leHBvcnQgY29uc3QgbW9kZWw6IE1vZGVsRnVuY3Rpb24gPSAoKCkgPT4ge1xuICAvLyBOb3RlOiBUaGlzIG1heSBiZSBjb25zaWRlcmVkIGEgc2lkZS1lZmZlY3QsIGJ1dCBub3RoaW5nIHdpbGwgZGVwZW5kIG9uXG4gIC8vIHRoaXMgYXNzaWdubWVudCwgdW5sZXNzIHRoaXMgYG1vZGVsYCBjb25zdGFudCBleHBvcnQgaXMgYWNjZXNzZWQuIEl0J3MgYVxuICAvLyBzZWxmLWNvbnRhaW5lZCBzaWRlIGVmZmVjdCB0aGF0IGlzIGxvY2FsIHRvIHRoZSB1c2VyIGZhY2luZyBgbW9kZWxgIGV4cG9ydC5cbiAgKG1vZGVsRnVuY3Rpb24gYXMgYW55KS5yZXF1aXJlZCA9IG1vZGVsUmVxdWlyZWRGdW5jdGlvbjtcbiAgcmV0dXJuIG1vZGVsRnVuY3Rpb24gYXMgKHR5cGVvZiBtb2RlbEZ1bmN0aW9uJntyZXF1aXJlZDogdHlwZW9mIG1vZGVsUmVxdWlyZWRGdW5jdGlvbn0pO1xufSkoKTtcbiJdfQ==
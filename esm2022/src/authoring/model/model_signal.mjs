/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { producerAccessed, SIGNAL, signalSetFn } from '@angular/core/primitives/signals';
import { RuntimeError } from '../../errors';
import { ɵINPUT_SIGNAL_BRAND_READ_TYPE, ɵINPUT_SIGNAL_BRAND_WRITE_TYPE } from '../input/input_signal';
import { INPUT_SIGNAL_NODE, REQUIRED_UNSET_VALUE } from '../input/input_signal_node';
import { OutputEmitterRef } from '../output/output_emitter_ref';
/**
 * Creates a model signal.
 *
 * @param initialValue The initial value.
 *   Can be set to {@link REQUIRED_UNSET_VALUE} for required model signals.
 * @param options Additional options for the model.
 */
export function createModelSignal(initialValue) {
    const node = Object.create(INPUT_SIGNAL_NODE);
    const emitterRef = new OutputEmitterRef();
    node.value = initialValue;
    function getter() {
        producerAccessed(node);
        assertModelSet(node.value);
        return node.value;
    }
    getter[SIGNAL] = node;
    getter.asReadonly = (() => getter());
    // TODO: Should we throw an error when updating a destroyed model?
    getter.set = (newValue) => {
        if (!node.equal(node.value, newValue)) {
            signalSetFn(node, newValue);
            emitterRef.emit(newValue);
        }
    };
    getter.update = (updateFn) => {
        assertModelSet(node.value);
        getter.set(updateFn(node.value));
    };
    getter.subscribe = emitterRef.subscribe.bind(emitterRef);
    getter.destroyRef = emitterRef.destroyRef;
    if (ngDevMode) {
        getter.toString = () => `[Model Signal: ${getter()}]`;
    }
    return getter;
}
/** Asserts that a model's value is set. */
function assertModelSet(value) {
    if (value === REQUIRED_UNSET_VALUE) {
        throw new RuntimeError(-952 /* RuntimeErrorCode.REQUIRED_MODEL_NO_VALUE */, ngDevMode && 'Model is required but no value is available yet.');
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9kZWxfc2lnbmFsLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvY29yZS9zcmMvYXV0aG9yaW5nL21vZGVsL21vZGVsX3NpZ25hbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0dBTUc7QUFFSCxPQUFPLEVBQUMsZ0JBQWdCLEVBQUUsTUFBTSxFQUFFLFdBQVcsRUFBQyxNQUFNLGtDQUFrQyxDQUFDO0FBRXZGLE9BQU8sRUFBQyxZQUFZLEVBQW1CLE1BQU0sY0FBYyxDQUFDO0FBRzVELE9BQU8sRUFBQyw2QkFBNkIsRUFBRSw4QkFBOEIsRUFBQyxNQUFNLHVCQUF1QixDQUFDO0FBQ3BHLE9BQU8sRUFBQyxpQkFBaUIsRUFBbUIsb0JBQW9CLEVBQUMsTUFBTSw0QkFBNEIsQ0FBQztBQUNwRyxPQUFPLEVBQUMsZ0JBQWdCLEVBQUMsTUFBTSw4QkFBOEIsQ0FBQztBQThCOUQ7Ozs7OztHQU1HO0FBQ0gsTUFBTSxVQUFVLGlCQUFpQixDQUFJLFlBQWU7SUFDbEQsTUFBTSxJQUFJLEdBQTBCLE1BQU0sQ0FBQyxNQUFNLENBQUMsaUJBQWlCLENBQUMsQ0FBQztJQUNyRSxNQUFNLFVBQVUsR0FBRyxJQUFJLGdCQUFnQixFQUFLLENBQUM7SUFFN0MsSUFBSSxDQUFDLEtBQUssR0FBRyxZQUFZLENBQUM7SUFFMUIsU0FBUyxNQUFNO1FBQ2IsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDdkIsY0FBYyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUMzQixPQUFPLElBQUksQ0FBQyxLQUFLLENBQUM7SUFDcEIsQ0FBQztJQUVELE1BQU0sQ0FBQyxNQUFNLENBQUMsR0FBRyxJQUFJLENBQUM7SUFDdEIsTUFBTSxDQUFDLFVBQVUsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDLE1BQU0sRUFBRSxDQUFvQixDQUFDO0lBRXhELGtFQUFrRTtJQUNsRSxNQUFNLENBQUMsR0FBRyxHQUFHLENBQUMsUUFBVyxFQUFFLEVBQUU7UUFDM0IsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxRQUFRLENBQUMsRUFBRSxDQUFDO1lBQ3RDLFdBQVcsQ0FBQyxJQUFJLEVBQUUsUUFBUSxDQUFDLENBQUM7WUFDNUIsVUFBVSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUM1QixDQUFDO0lBQ0gsQ0FBQyxDQUFDO0lBRUYsTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDLFFBQXlCLEVBQUUsRUFBRTtRQUM1QyxjQUFjLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzNCLE1BQU0sQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBQ25DLENBQUMsQ0FBQztJQUVGLE1BQU0sQ0FBQyxTQUFTLEdBQUcsVUFBVSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDekQsTUFBTSxDQUFDLFVBQVUsR0FBRyxVQUFVLENBQUMsVUFBVSxDQUFDO0lBRTFDLElBQUksU0FBUyxFQUFFLENBQUM7UUFDZCxNQUFNLENBQUMsUUFBUSxHQUFHLEdBQUcsRUFBRSxDQUFDLGtCQUFrQixNQUFNLEVBQUUsR0FBRyxDQUFDO0lBQ3hELENBQUM7SUFFRCxPQUFPLE1BR29DLENBQUM7QUFDOUMsQ0FBQztBQUVELDJDQUEyQztBQUMzQyxTQUFTLGNBQWMsQ0FBQyxLQUFjO0lBQ3BDLElBQUksS0FBSyxLQUFLLG9CQUFvQixFQUFFLENBQUM7UUFDbkMsTUFBTSxJQUFJLFlBQVksc0RBRWxCLFNBQVMsSUFBSSxrREFBa0QsQ0FBQyxDQUFDO0lBQ3ZFLENBQUM7QUFDSCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbmltcG9ydCB7cHJvZHVjZXJBY2Nlc3NlZCwgU0lHTkFMLCBzaWduYWxTZXRGbn0gZnJvbSAnQGFuZ3VsYXIvY29yZS9wcmltaXRpdmVzL3NpZ25hbHMnO1xuXG5pbXBvcnQge1J1bnRpbWVFcnJvciwgUnVudGltZUVycm9yQ29kZX0gZnJvbSAnLi4vLi4vZXJyb3JzJztcbmltcG9ydCB7U2lnbmFsfSBmcm9tICcuLi8uLi9yZW5kZXIzL3JlYWN0aXZpdHkvYXBpJztcbmltcG9ydCB7V3JpdGFibGVTaWduYWwsIMm1V1JJVEFCTEVfU0lHTkFMfSBmcm9tICcuLi8uLi9yZW5kZXIzL3JlYWN0aXZpdHkvc2lnbmFsJztcbmltcG9ydCB7ybVJTlBVVF9TSUdOQUxfQlJBTkRfUkVBRF9UWVBFLCDJtUlOUFVUX1NJR05BTF9CUkFORF9XUklURV9UWVBFfSBmcm9tICcuLi9pbnB1dC9pbnB1dF9zaWduYWwnO1xuaW1wb3J0IHtJTlBVVF9TSUdOQUxfTk9ERSwgSW5wdXRTaWduYWxOb2RlLCBSRVFVSVJFRF9VTlNFVF9WQUxVRX0gZnJvbSAnLi4vaW5wdXQvaW5wdXRfc2lnbmFsX25vZGUnO1xuaW1wb3J0IHtPdXRwdXRFbWl0dGVyUmVmfSBmcm9tICcuLi9vdXRwdXQvb3V0cHV0X2VtaXR0ZXJfcmVmJztcbmltcG9ydCB7T3V0cHV0UmVmfSBmcm9tICcuLi9vdXRwdXQvb3V0cHV0X3JlZic7XG5cbi8qKlxuICogQGRldmVsb3BlclByZXZpZXdcbiAqXG4gKiBPcHRpb25zIGZvciBtb2RlbCBzaWduYWxzLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE1vZGVsT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBPcHRpb25hbCBwdWJsaWMgbmFtZSBvZiB0aGUgaW5wdXQgc2lkZSBvZiB0aGUgbW9kZWwuIFRoZSBvdXRwdXQgc2lkZSB3aWxsIGhhdmUgdGhlIHNhbWVcbiAgICogbmFtZSBhcyB0aGUgaW5wdXQsIGJ1dCBzdWZmaXhlZCB3aXRoIGBDaGFuZ2VgLiBCeSBkZWZhdWx0LCB0aGUgY2xhc3MgZmllbGQgbmFtZSBpcyB1c2VkLlxuICAgKi9cbiAgYWxpYXM/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogYE1vZGVsU2lnbmFsYCByZXByZXNlbnRzIGEgc3BlY2lhbCBgU2lnbmFsYCBmb3IgYSBkaXJlY3RpdmUvY29tcG9uZW50IG1vZGVsIGZpZWxkLlxuICpcbiAqIEEgbW9kZWwgc2lnbmFsIGlzIGEgd3JpdGVhYmxlIHNpZ25hbCB0aGF0IGNhbiBiZSBleHBvc2VkIGFzIGFuIG91dHB1dC5cbiAqIFdoZW5ldmVyIGl0cyB2YWx1ZSBpcyB1cGRhdGVkLCBpdCBlbWl0cyB0byB0aGUgb3V0cHV0LlxuICpcbiAqIEBkZXZlbG9wZXJQcmV2aWV3XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTW9kZWxTaWduYWw8VD4gZXh0ZW5kcyBXcml0YWJsZVNpZ25hbDxUPiwgT3V0cHV0UmVmPFQ+IHtcbiAgW1NJR05BTF06IElucHV0U2lnbmFsTm9kZTxULCBUPjtcbiAgW8m1SU5QVVRfU0lHTkFMX0JSQU5EX1JFQURfVFlQRV06IFQ7XG4gIFvJtUlOUFVUX1NJR05BTF9CUkFORF9XUklURV9UWVBFXTogVDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbW9kZWwgc2lnbmFsLlxuICpcbiAqIEBwYXJhbSBpbml0aWFsVmFsdWUgVGhlIGluaXRpYWwgdmFsdWUuXG4gKiAgIENhbiBiZSBzZXQgdG8ge0BsaW5rIFJFUVVJUkVEX1VOU0VUX1ZBTFVFfSBmb3IgcmVxdWlyZWQgbW9kZWwgc2lnbmFscy5cbiAqIEBwYXJhbSBvcHRpb25zIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIG1vZGVsLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTW9kZWxTaWduYWw8VD4oaW5pdGlhbFZhbHVlOiBUKTogTW9kZWxTaWduYWw8VD4ge1xuICBjb25zdCBub2RlOiBJbnB1dFNpZ25hbE5vZGU8VCwgVD4gPSBPYmplY3QuY3JlYXRlKElOUFVUX1NJR05BTF9OT0RFKTtcbiAgY29uc3QgZW1pdHRlclJlZiA9IG5ldyBPdXRwdXRFbWl0dGVyUmVmPFQ+KCk7XG5cbiAgbm9kZS52YWx1ZSA9IGluaXRpYWxWYWx1ZTtcblxuICBmdW5jdGlvbiBnZXR0ZXIoKTogVCB7XG4gICAgcHJvZHVjZXJBY2Nlc3NlZChub2RlKTtcbiAgICBhc3NlcnRNb2RlbFNldChub2RlLnZhbHVlKTtcbiAgICByZXR1cm4gbm9kZS52YWx1ZTtcbiAgfVxuXG4gIGdldHRlcltTSUdOQUxdID0gbm9kZTtcbiAgZ2V0dGVyLmFzUmVhZG9ubHkgPSAoKCkgPT4gZ2V0dGVyKCkpIGFzICgpID0+IFNpZ25hbDxUPjtcblxuICAvLyBUT0RPOiBTaG91bGQgd2UgdGhyb3cgYW4gZXJyb3Igd2hlbiB1cGRhdGluZyBhIGRlc3Ryb3llZCBtb2RlbD9cbiAgZ2V0dGVyLnNldCA9IChuZXdWYWx1ZTogVCkgPT4ge1xuICAgIGlmICghbm9kZS5lcXVhbChub2RlLnZhbHVlLCBuZXdWYWx1ZSkpIHtcbiAgICAgIHNpZ25hbFNldEZuKG5vZGUsIG5ld1ZhbHVlKTtcbiAgICAgIGVtaXR0ZXJSZWYuZW1pdChuZXdWYWx1ZSk7XG4gICAgfVxuICB9O1xuXG4gIGdldHRlci51cGRhdGUgPSAodXBkYXRlRm46ICh2YWx1ZTogVCkgPT4gVCkgPT4ge1xuICAgIGFzc2VydE1vZGVsU2V0KG5vZGUudmFsdWUpO1xuICAgIGdldHRlci5zZXQodXBkYXRlRm4obm9kZS52YWx1ZSkpO1xuICB9O1xuXG4gIGdldHRlci5zdWJzY3JpYmUgPSBlbWl0dGVyUmVmLnN1YnNjcmliZS5iaW5kKGVtaXR0ZXJSZWYpO1xuICBnZXR0ZXIuZGVzdHJveVJlZiA9IGVtaXR0ZXJSZWYuZGVzdHJveVJlZjtcblxuICBpZiAobmdEZXZNb2RlKSB7XG4gICAgZ2V0dGVyLnRvU3RyaW5nID0gKCkgPT4gYFtNb2RlbCBTaWduYWw6ICR7Z2V0dGVyKCl9XWA7XG4gIH1cblxuICByZXR1cm4gZ2V0dGVyIGFzICh0eXBlb2YgZ2V0dGVyJlBpY2s8XG4gICAgICAgICAgICAgICAgICAgIE1vZGVsU2lnbmFsPFQ+LFxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgybVJTlBVVF9TSUdOQUxfQlJBTkRfUkVBRF9UWVBFfHR5cGVvZiDJtUlOUFVUX1NJR05BTF9CUkFORF9XUklURV9UWVBFfFxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgybVXUklUQUJMRV9TSUdOQUw+KTtcbn1cblxuLyoqIEFzc2VydHMgdGhhdCBhIG1vZGVsJ3MgdmFsdWUgaXMgc2V0LiAqL1xuZnVuY3Rpb24gYXNzZXJ0TW9kZWxTZXQodmFsdWU6IHVua25vd24pOiB2b2lkIHtcbiAgaWYgKHZhbHVlID09PSBSRVFVSVJFRF9VTlNFVF9WQUxVRSkge1xuICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IoXG4gICAgICAgIFJ1bnRpbWVFcnJvckNvZGUuUkVRVUlSRURfTU9ERUxfTk9fVkFMVUUsXG4gICAgICAgIG5nRGV2TW9kZSAmJiAnTW9kZWwgaXMgcmVxdWlyZWQgYnV0IG5vIHZhbHVlIGlzIGF2YWlsYWJsZSB5ZXQuJyk7XG4gIH1cbn1cbiJdfQ==
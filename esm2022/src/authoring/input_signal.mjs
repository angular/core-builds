/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { producerAccessed, SIGNAL } from '@angular/core/primitives/signals';
import { INPUT_SIGNAL_NODE, REQUIRED_UNSET_VALUE } from './input_signal_node';
export const ɵINPUT_SIGNAL_BRAND_READ_TYPE = /* @__PURE__ */ Symbol();
export const ɵINPUT_SIGNAL_BRAND_WRITE_TYPE = /* @__PURE__ */ Symbol();
/**
 * Creates an input signal.
 *
 * @param initialValue The initial value.
 *   Can be set to {@link REQUIRED_UNSET_VALUE} for required inputs.
 * @param options Additional options for the input. e.g. a transform, or an alias.
 */
export function createInputSignal(initialValue, options) {
    const node = Object.create(INPUT_SIGNAL_NODE);
    node.value = initialValue;
    // Perf note: Always set `transformFn` here to ensure that `node` always
    // has the same v8 class shape, allowing monomorphic reads on input signals.
    node.transformFn = options?.transform;
    function inputValueFn() {
        // Record that someone looked at this signal.
        producerAccessed(node);
        if (node.value === REQUIRED_UNSET_VALUE) {
            // TODO: Use a runtime error w/ error guide.
            throw new Error('Input is required, but no value set yet.');
        }
        return node.value;
    }
    inputValueFn[SIGNAL] = node;
    return inputValueFn;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5wdXRfc2lnbmFsLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvY29yZS9zcmMvYXV0aG9yaW5nL2lucHV0X3NpZ25hbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0dBTUc7QUFFSCxPQUFPLEVBQUMsZ0JBQWdCLEVBQUUsTUFBTSxFQUFDLE1BQU0sa0NBQWtDLENBQUM7QUFJMUUsT0FBTyxFQUFDLGlCQUFpQixFQUFtQixvQkFBb0IsRUFBQyxNQUFNLHFCQUFxQixDQUFDO0FBNkI3RixNQUFNLENBQUMsTUFBTSw2QkFBNkIsR0FBRyxlQUFlLENBQUMsTUFBTSxFQUFFLENBQUM7QUFDdEUsTUFBTSxDQUFDLE1BQU0sOEJBQThCLEdBQUcsZUFBZSxDQUFDLE1BQU0sRUFBRSxDQUFDO0FBZXZFOzs7Ozs7R0FNRztBQUNILE1BQU0sVUFBVSxpQkFBaUIsQ0FDN0IsWUFBbUIsRUFBRSxPQUFxQztJQUM1RCxNQUFNLElBQUksR0FBbUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO0lBRTlFLElBQUksQ0FBQyxLQUFLLEdBQUcsWUFBWSxDQUFDO0lBRTFCLHdFQUF3RTtJQUN4RSw0RUFBNEU7SUFDNUUsSUFBSSxDQUFDLFdBQVcsR0FBRyxPQUFPLEVBQUUsU0FBUyxDQUFDO0lBRXRDLFNBQVMsWUFBWTtRQUNuQiw2Q0FBNkM7UUFDN0MsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFdkIsSUFBSSxJQUFJLENBQUMsS0FBSyxLQUFLLG9CQUFvQixFQUFFLENBQUM7WUFDeEMsNENBQTRDO1lBQzVDLE1BQU0sSUFBSSxLQUFLLENBQUMsMENBQTBDLENBQUMsQ0FBQztRQUM5RCxDQUFDO1FBRUQsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDO0lBQ3BCLENBQUM7SUFFQSxZQUFvQixDQUFDLE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQztJQUNyQyxPQUFPLFlBQTBDLENBQUM7QUFDcEQsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG5pbXBvcnQge3Byb2R1Y2VyQWNjZXNzZWQsIFNJR05BTH0gZnJvbSAnQGFuZ3VsYXIvY29yZS9wcmltaXRpdmVzL3NpZ25hbHMnO1xuXG5pbXBvcnQge1NpZ25hbH0gZnJvbSAnLi4vcmVuZGVyMy9yZWFjdGl2aXR5L2FwaSc7XG5cbmltcG9ydCB7SU5QVVRfU0lHTkFMX05PREUsIElucHV0U2lnbmFsTm9kZSwgUkVRVUlSRURfVU5TRVRfVkFMVUV9IGZyb20gJy4vaW5wdXRfc2lnbmFsX25vZGUnO1xuXG4vKipcbiAqIE9wdGlvbnMgZm9yIHNpZ25hbCBpbnB1dHMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSW5wdXRPcHRpb25zPFJlYWRULCBXcml0ZVQ+IHtcbiAgLyoqIE9wdGlvbmFsIHB1YmxpYyBuYW1lIGZvciB0aGUgaW5wdXQuIEJ5IGRlZmF1bHQsIHRoZSBjbGFzcyBmaWVsZCBuYW1lIGlzIHVzZWQuICovXG4gIGFsaWFzPzogc3RyaW5nO1xuICAvKipcbiAgICogT3B0aW9uYWwgdHJhbnNmb3JtIHRoYXQgcnVucyB3aGVuZXZlciBhIG5ldyB2YWx1ZSBpcyBib3VuZC4gQ2FuIGJlIHVzZWQgdG9cbiAgICogdHJhbnNmb3JtIHRoZSBpbnB1dCB2YWx1ZSBiZWZvcmUgdGhlIGlucHV0IGlzIHVwZGF0ZWQuXG4gICAqXG4gICAqIFRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24gY2FuIHdpZGVuIHRoZSB0eXBlIG9mIHRoZSBpbnB1dC4gRm9yIGV4YW1wbGUsIGNvbnNpZGVyXG4gICAqIGFuIGlucHV0IGZvciBgZGlzYWJsZWRgLiBJbiBwcmFjdGljZSwgYXMgdGhlIGNvbXBvbmVudCBhdXRob3IsIHlvdSB3YW50IHRvIG9ubHlcbiAgICogZGVhbCB3aXRoIGEgYm9vbGVhbiwgYnV0IHVzZXJzIG1heSB3YW50IHRvIGJpbmQgYSBzdHJpbmcgaWYgdGhleSBqdXN0IHVzZSB0aGVcbiAgICogYXR0cmlidXRlIGZvcm0gdG8gYmluZCB0byB0aGUgaW5wdXQgdmlhIGA8bXktZGlyIGlucHV0PmAuIEEgdHJhbnNmb3JtIGNhbiB0aGVuXG4gICAqIGhhbmRsZSBzdWNoIHN0cmluZyB2YWx1ZXMgYW5kIGNvbnZlcnQgdGhlbSB0byBgYm9vbGVhbmAuIFNlZToge0BsaW5rIGJvb2xlYW5BdHRyaWJ1dGV9LlxuICAgKi9cbiAgdHJhbnNmb3JtPzogKHY6IFdyaXRlVCkgPT4gUmVhZFQ7XG59XG5cbi8qKiBTaWduYWwgaW5wdXQgb3B0aW9ucyB3aXRob3V0IHRoZSB0cmFuc2Zvcm0gb3B0aW9uLiAqL1xuZXhwb3J0IHR5cGUgSW5wdXRPcHRpb25zV2l0aG91dFRyYW5zZm9ybTxSZWFkVD4gPVxuICAgIC8vIE5vdGU6IFdlIHN0aWxsIGtlZXAgYSBub3Rpb24gb2YgYHRyYW5zZm9ybWAgZm9yIGF1dG8tY29tcGxldGlvbi5cbiAgICBPbWl0PElucHV0T3B0aW9uczxSZWFkVCwgUmVhZFQ+LCAndHJhbnNmb3JtJz4me3RyYW5zZm9ybT86IHVuZGVmaW5lZH07XG4vKiogU2lnbmFsIGlucHV0IG9wdGlvbnMgd2l0aCB0aGUgdHJhbnNmb3JtIG9wdGlvbiByZXF1aXJlZC4gKi9cbmV4cG9ydCB0eXBlIElucHV0T3B0aW9uc1dpdGhUcmFuc2Zvcm08UmVhZFQsIFdyaXRlVD4gPVxuICAgIFJlcXVpcmVkPFBpY2s8SW5wdXRPcHRpb25zPFJlYWRULCBXcml0ZVQ+LCAndHJhbnNmb3JtJz4+JklucHV0T3B0aW9uczxSZWFkVCwgV3JpdGVUPjtcblxuZXhwb3J0IGNvbnN0IMm1SU5QVVRfU0lHTkFMX0JSQU5EX1JFQURfVFlQRSA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2woKTtcbmV4cG9ydCBjb25zdCDJtUlOUFVUX1NJR05BTF9CUkFORF9XUklURV9UWVBFID0gLyogQF9fUFVSRV9fICovIFN5bWJvbCgpO1xuXG4vKipcbiAqIGBJbnB1dFNpZ25hbGAgaXMgcmVwcmVzZW50cyBhIHNwZWNpYWwgYFNpZ25hbGAgZm9yIGEgZGlyZWN0aXZlL2NvbXBvbmVudCBpbnB1dC5cbiAqXG4gKiBBbiBpbnB1dCBzaWduYWwgaXMgc2ltaWxhciB0byBhIG5vbi13cml0YWJsZSBzaWduYWwgZXhjZXB0IHRoYXQgaXQgYWxzb1xuICogY2FycmllcyBhZGRpdGlvbmFsIHR5cGUtaW5mb3JtYXRpb24gZm9yIHRyYW5zZm9ybXMsIGFuZCB0aGF0IEFuZ3VsYXIgaW50ZXJuYWxseVxuICogdXBkYXRlcyB0aGUgc2lnbmFsIHdoZW5ldmVyIGEgbmV3IHZhbHVlIGlzIGJvdW5kLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIElucHV0U2lnbmFsPFJlYWRULCBXcml0ZVQgPSBSZWFkVD4gZXh0ZW5kcyBTaWduYWw8UmVhZFQ+IHtcbiAgW8m1SU5QVVRfU0lHTkFMX0JSQU5EX1JFQURfVFlQRV06IFJlYWRUO1xuICBbybVJTlBVVF9TSUdOQUxfQlJBTkRfV1JJVEVfVFlQRV06IFdyaXRlVDtcbiAgW1NJR05BTF06IElucHV0U2lnbmFsTm9kZTxSZWFkVCwgV3JpdGVUPjtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGlucHV0IHNpZ25hbC5cbiAqXG4gKiBAcGFyYW0gaW5pdGlhbFZhbHVlIFRoZSBpbml0aWFsIHZhbHVlLlxuICogICBDYW4gYmUgc2V0IHRvIHtAbGluayBSRVFVSVJFRF9VTlNFVF9WQUxVRX0gZm9yIHJlcXVpcmVkIGlucHV0cy5cbiAqIEBwYXJhbSBvcHRpb25zIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIGlucHV0LiBlLmcuIGEgdHJhbnNmb3JtLCBvciBhbiBhbGlhcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUlucHV0U2lnbmFsPFJlYWRULCBXcml0ZVQ+KFxuICAgIGluaXRpYWxWYWx1ZTogUmVhZFQsIG9wdGlvbnM/OiBJbnB1dE9wdGlvbnM8UmVhZFQsIFdyaXRlVD4pOiBJbnB1dFNpZ25hbDxSZWFkVCwgV3JpdGVUPiB7XG4gIGNvbnN0IG5vZGU6IElucHV0U2lnbmFsTm9kZTxSZWFkVCwgV3JpdGVUPiA9IE9iamVjdC5jcmVhdGUoSU5QVVRfU0lHTkFMX05PREUpO1xuXG4gIG5vZGUudmFsdWUgPSBpbml0aWFsVmFsdWU7XG5cbiAgLy8gUGVyZiBub3RlOiBBbHdheXMgc2V0IGB0cmFuc2Zvcm1GbmAgaGVyZSB0byBlbnN1cmUgdGhhdCBgbm9kZWAgYWx3YXlzXG4gIC8vIGhhcyB0aGUgc2FtZSB2OCBjbGFzcyBzaGFwZSwgYWxsb3dpbmcgbW9ub21vcnBoaWMgcmVhZHMgb24gaW5wdXQgc2lnbmFscy5cbiAgbm9kZS50cmFuc2Zvcm1GbiA9IG9wdGlvbnM/LnRyYW5zZm9ybTtcblxuICBmdW5jdGlvbiBpbnB1dFZhbHVlRm4oKSB7XG4gICAgLy8gUmVjb3JkIHRoYXQgc29tZW9uZSBsb29rZWQgYXQgdGhpcyBzaWduYWwuXG4gICAgcHJvZHVjZXJBY2Nlc3NlZChub2RlKTtcblxuICAgIGlmIChub2RlLnZhbHVlID09PSBSRVFVSVJFRF9VTlNFVF9WQUxVRSkge1xuICAgICAgLy8gVE9ETzogVXNlIGEgcnVudGltZSBlcnJvciB3LyBlcnJvciBndWlkZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgaXMgcmVxdWlyZWQsIGJ1dCBubyB2YWx1ZSBzZXQgeWV0LicpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlLnZhbHVlO1xuICB9XG5cbiAgKGlucHV0VmFsdWVGbiBhcyBhbnkpW1NJR05BTF0gPSBub2RlO1xuICByZXR1cm4gaW5wdXRWYWx1ZUZuIGFzIElucHV0U2lnbmFsPFJlYWRULCBXcml0ZVQ+O1xufVxuIl19
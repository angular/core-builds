/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { producerAccessed, SIGNAL } from '@angular/core/primitives/signals';
import { RuntimeError } from '../errors';
import { INPUT_SIGNAL_NODE, REQUIRED_UNSET_VALUE } from './input_signal_node';
export const ɵINPUT_SIGNAL_BRAND_READ_TYPE = /* @__PURE__ */ Symbol();
export const ɵINPUT_SIGNAL_BRAND_WRITE_TYPE = /* @__PURE__ */ Symbol();
/**
 * Creates an input signal.
 *
 * @param initialValue The initial value.
 *   Can be set to {@link REQUIRED_UNSET_VALUE} for required inputs.
 * @param options Additional options for the input. e.g. a transform, or an alias.
 */
export function createInputSignal(initialValue, options) {
    const node = Object.create(INPUT_SIGNAL_NODE);
    node.value = initialValue;
    // Perf note: Always set `transformFn` here to ensure that `node` always
    // has the same v8 class shape, allowing monomorphic reads on input signals.
    node.transformFn = options?.transform;
    function inputValueFn() {
        // Record that someone looked at this signal.
        producerAccessed(node);
        if (node.value === REQUIRED_UNSET_VALUE) {
            throw new RuntimeError(-950 /* RuntimeErrorCode.REQUIRED_INPUT_NO_VALUE */, ngDevMode && 'Input is required but no value is available yet.');
        }
        return node.value;
    }
    inputValueFn[SIGNAL] = node;
    return inputValueFn;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5wdXRfc2lnbmFsLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvY29yZS9zcmMvYXV0aG9yaW5nL2lucHV0X3NpZ25hbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0dBTUc7QUFFSCxPQUFPLEVBQUMsZ0JBQWdCLEVBQUUsTUFBTSxFQUFDLE1BQU0sa0NBQWtDLENBQUM7QUFFMUUsT0FBTyxFQUFDLFlBQVksRUFBbUIsTUFBTSxXQUFXLENBQUM7QUFHekQsT0FBTyxFQUFDLGlCQUFpQixFQUFtQixvQkFBb0IsRUFBQyxNQUFNLHFCQUFxQixDQUFDO0FBNkI3RixNQUFNLENBQUMsTUFBTSw2QkFBNkIsR0FBRyxlQUFlLENBQUMsTUFBTSxFQUFFLENBQUM7QUFDdEUsTUFBTSxDQUFDLE1BQU0sOEJBQThCLEdBQUcsZUFBZSxDQUFDLE1BQU0sRUFBRSxDQUFDO0FBZXZFOzs7Ozs7R0FNRztBQUNILE1BQU0sVUFBVSxpQkFBaUIsQ0FDN0IsWUFBbUIsRUFBRSxPQUFxQztJQUM1RCxNQUFNLElBQUksR0FBbUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO0lBRTlFLElBQUksQ0FBQyxLQUFLLEdBQUcsWUFBWSxDQUFDO0lBRTFCLHdFQUF3RTtJQUN4RSw0RUFBNEU7SUFDNUUsSUFBSSxDQUFDLFdBQVcsR0FBRyxPQUFPLEVBQUUsU0FBUyxDQUFDO0lBRXRDLFNBQVMsWUFBWTtRQUNuQiw2Q0FBNkM7UUFDN0MsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFdkIsSUFBSSxJQUFJLENBQUMsS0FBSyxLQUFLLG9CQUFvQixFQUFFLENBQUM7WUFDeEMsTUFBTSxJQUFJLFlBQVksc0RBRWxCLFNBQVMsSUFBSSxrREFBa0QsQ0FBQyxDQUFDO1FBQ3ZFLENBQUM7UUFFRCxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUM7SUFDcEIsQ0FBQztJQUVBLFlBQW9CLENBQUMsTUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDO0lBQ3JDLE9BQU8sWUFBMEMsQ0FBQztBQUNwRCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbmltcG9ydCB7cHJvZHVjZXJBY2Nlc3NlZCwgU0lHTkFMfSBmcm9tICdAYW5ndWxhci9jb3JlL3ByaW1pdGl2ZXMvc2lnbmFscyc7XG5cbmltcG9ydCB7UnVudGltZUVycm9yLCBSdW50aW1lRXJyb3JDb2RlfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHtTaWduYWx9IGZyb20gJy4uL3JlbmRlcjMvcmVhY3Rpdml0eS9hcGknO1xuXG5pbXBvcnQge0lOUFVUX1NJR05BTF9OT0RFLCBJbnB1dFNpZ25hbE5vZGUsIFJFUVVJUkVEX1VOU0VUX1ZBTFVFfSBmcm9tICcuL2lucHV0X3NpZ25hbF9ub2RlJztcblxuLyoqXG4gKiBPcHRpb25zIGZvciBzaWduYWwgaW5wdXRzLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIElucHV0T3B0aW9uczxSZWFkVCwgV3JpdGVUPiB7XG4gIC8qKiBPcHRpb25hbCBwdWJsaWMgbmFtZSBmb3IgdGhlIGlucHV0LiBCeSBkZWZhdWx0LCB0aGUgY2xhc3MgZmllbGQgbmFtZSBpcyB1c2VkLiAqL1xuICBhbGlhcz86IHN0cmluZztcbiAgLyoqXG4gICAqIE9wdGlvbmFsIHRyYW5zZm9ybSB0aGF0IHJ1bnMgd2hlbmV2ZXIgYSBuZXcgdmFsdWUgaXMgYm91bmQuIENhbiBiZSB1c2VkIHRvXG4gICAqIHRyYW5zZm9ybSB0aGUgaW5wdXQgdmFsdWUgYmVmb3JlIHRoZSBpbnB1dCBpcyB1cGRhdGVkLlxuICAgKlxuICAgKiBUaGUgdHJhbnNmb3JtIGZ1bmN0aW9uIGNhbiB3aWRlbiB0aGUgdHlwZSBvZiB0aGUgaW5wdXQuIEZvciBleGFtcGxlLCBjb25zaWRlclxuICAgKiBhbiBpbnB1dCBmb3IgYGRpc2FibGVkYC4gSW4gcHJhY3RpY2UsIGFzIHRoZSBjb21wb25lbnQgYXV0aG9yLCB5b3Ugd2FudCB0byBvbmx5XG4gICAqIGRlYWwgd2l0aCBhIGJvb2xlYW4sIGJ1dCB1c2VycyBtYXkgd2FudCB0byBiaW5kIGEgc3RyaW5nIGlmIHRoZXkganVzdCB1c2UgdGhlXG4gICAqIGF0dHJpYnV0ZSBmb3JtIHRvIGJpbmQgdG8gdGhlIGlucHV0IHZpYSBgPG15LWRpciBpbnB1dD5gLiBBIHRyYW5zZm9ybSBjYW4gdGhlblxuICAgKiBoYW5kbGUgc3VjaCBzdHJpbmcgdmFsdWVzIGFuZCBjb252ZXJ0IHRoZW0gdG8gYGJvb2xlYW5gLiBTZWU6IHtAbGluayBib29sZWFuQXR0cmlidXRlfS5cbiAgICovXG4gIHRyYW5zZm9ybT86ICh2OiBXcml0ZVQpID0+IFJlYWRUO1xufVxuXG4vKiogU2lnbmFsIGlucHV0IG9wdGlvbnMgd2l0aG91dCB0aGUgdHJhbnNmb3JtIG9wdGlvbi4gKi9cbmV4cG9ydCB0eXBlIElucHV0T3B0aW9uc1dpdGhvdXRUcmFuc2Zvcm08UmVhZFQ+ID1cbiAgICAvLyBOb3RlOiBXZSBzdGlsbCBrZWVwIGEgbm90aW9uIG9mIGB0cmFuc2Zvcm1gIGZvciBhdXRvLWNvbXBsZXRpb24uXG4gICAgT21pdDxJbnB1dE9wdGlvbnM8UmVhZFQsIFJlYWRUPiwgJ3RyYW5zZm9ybSc+Jnt0cmFuc2Zvcm0/OiB1bmRlZmluZWR9O1xuLyoqIFNpZ25hbCBpbnB1dCBvcHRpb25zIHdpdGggdGhlIHRyYW5zZm9ybSBvcHRpb24gcmVxdWlyZWQuICovXG5leHBvcnQgdHlwZSBJbnB1dE9wdGlvbnNXaXRoVHJhbnNmb3JtPFJlYWRULCBXcml0ZVQ+ID1cbiAgICBSZXF1aXJlZDxQaWNrPElucHV0T3B0aW9uczxSZWFkVCwgV3JpdGVUPiwgJ3RyYW5zZm9ybSc+PiZJbnB1dE9wdGlvbnM8UmVhZFQsIFdyaXRlVD47XG5cbmV4cG9ydCBjb25zdCDJtUlOUFVUX1NJR05BTF9CUkFORF9SRUFEX1RZUEUgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sKCk7XG5leHBvcnQgY29uc3QgybVJTlBVVF9TSUdOQUxfQlJBTkRfV1JJVEVfVFlQRSA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2woKTtcblxuLyoqXG4gKiBgSW5wdXRTaWduYWxgIGlzIHJlcHJlc2VudHMgYSBzcGVjaWFsIGBTaWduYWxgIGZvciBhIGRpcmVjdGl2ZS9jb21wb25lbnQgaW5wdXQuXG4gKlxuICogQW4gaW5wdXQgc2lnbmFsIGlzIHNpbWlsYXIgdG8gYSBub24td3JpdGFibGUgc2lnbmFsIGV4Y2VwdCB0aGF0IGl0IGFsc29cbiAqIGNhcnJpZXMgYWRkaXRpb25hbCB0eXBlLWluZm9ybWF0aW9uIGZvciB0cmFuc2Zvcm1zLCBhbmQgdGhhdCBBbmd1bGFyIGludGVybmFsbHlcbiAqIHVwZGF0ZXMgdGhlIHNpZ25hbCB3aGVuZXZlciBhIG5ldyB2YWx1ZSBpcyBib3VuZC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJbnB1dFNpZ25hbDxSZWFkVCwgV3JpdGVUID0gUmVhZFQ+IGV4dGVuZHMgU2lnbmFsPFJlYWRUPiB7XG4gIFvJtUlOUFVUX1NJR05BTF9CUkFORF9SRUFEX1RZUEVdOiBSZWFkVDtcbiAgW8m1SU5QVVRfU0lHTkFMX0JSQU5EX1dSSVRFX1RZUEVdOiBXcml0ZVQ7XG4gIFtTSUdOQUxdOiBJbnB1dFNpZ25hbE5vZGU8UmVhZFQsIFdyaXRlVD47XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBpbnB1dCBzaWduYWwuXG4gKlxuICogQHBhcmFtIGluaXRpYWxWYWx1ZSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAqICAgQ2FuIGJlIHNldCB0byB7QGxpbmsgUkVRVUlSRURfVU5TRVRfVkFMVUV9IGZvciByZXF1aXJlZCBpbnB1dHMuXG4gKiBAcGFyYW0gb3B0aW9ucyBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIHRoZSBpbnB1dC4gZS5nLiBhIHRyYW5zZm9ybSwgb3IgYW4gYWxpYXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVJbnB1dFNpZ25hbDxSZWFkVCwgV3JpdGVUPihcbiAgICBpbml0aWFsVmFsdWU6IFJlYWRULCBvcHRpb25zPzogSW5wdXRPcHRpb25zPFJlYWRULCBXcml0ZVQ+KTogSW5wdXRTaWduYWw8UmVhZFQsIFdyaXRlVD4ge1xuICBjb25zdCBub2RlOiBJbnB1dFNpZ25hbE5vZGU8UmVhZFQsIFdyaXRlVD4gPSBPYmplY3QuY3JlYXRlKElOUFVUX1NJR05BTF9OT0RFKTtcblxuICBub2RlLnZhbHVlID0gaW5pdGlhbFZhbHVlO1xuXG4gIC8vIFBlcmYgbm90ZTogQWx3YXlzIHNldCBgdHJhbnNmb3JtRm5gIGhlcmUgdG8gZW5zdXJlIHRoYXQgYG5vZGVgIGFsd2F5c1xuICAvLyBoYXMgdGhlIHNhbWUgdjggY2xhc3Mgc2hhcGUsIGFsbG93aW5nIG1vbm9tb3JwaGljIHJlYWRzIG9uIGlucHV0IHNpZ25hbHMuXG4gIG5vZGUudHJhbnNmb3JtRm4gPSBvcHRpb25zPy50cmFuc2Zvcm07XG5cbiAgZnVuY3Rpb24gaW5wdXRWYWx1ZUZuKCkge1xuICAgIC8vIFJlY29yZCB0aGF0IHNvbWVvbmUgbG9va2VkIGF0IHRoaXMgc2lnbmFsLlxuICAgIHByb2R1Y2VyQWNjZXNzZWQobm9kZSk7XG5cbiAgICBpZiAobm9kZS52YWx1ZSA9PT0gUkVRVUlSRURfVU5TRVRfVkFMVUUpIHtcbiAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IoXG4gICAgICAgICAgUnVudGltZUVycm9yQ29kZS5SRVFVSVJFRF9JTlBVVF9OT19WQUxVRSxcbiAgICAgICAgICBuZ0Rldk1vZGUgJiYgJ0lucHV0IGlzIHJlcXVpcmVkIGJ1dCBubyB2YWx1ZSBpcyBhdmFpbGFibGUgeWV0LicpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlLnZhbHVlO1xuICB9XG5cbiAgKGlucHV0VmFsdWVGbiBhcyBhbnkpW1NJR05BTF0gPSBub2RlO1xuICByZXR1cm4gaW5wdXRWYWx1ZUZuIGFzIElucHV0U2lnbmFsPFJlYWRULCBXcml0ZVQ+O1xufVxuIl19
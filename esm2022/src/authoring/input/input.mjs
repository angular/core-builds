/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { assertInInjectionContext } from '../../di';
import { createInputSignal } from './input_signal';
import { REQUIRED_UNSET_VALUE } from './input_signal_node';
export function inputFunction(initialValue, opts) {
    ngDevMode && assertInInjectionContext(input);
    return createInputSignal(initialValue, opts);
}
export function inputRequiredFunction(opts) {
    ngDevMode && assertInInjectionContext(input);
    return createInputSignal(REQUIRED_UNSET_VALUE, opts);
}
/**
 * The `input` function allows declaration of inputs in directives and
 * components.
 *
 * Initializes an input with an initial value. If no explicit value
 * is specified, Angular will use `undefined`.
 *
 * Consider using `input.required` for inputs that don't need an
 * initial value.
 *
 * @usageNotes
 * Initialize an input in your directive or component by declaring a
 * class field and initializing it with the `input()` function.
 *
 * ```ts
 * @Directive({..})
 * export class MyDir {
 *   firstName = input<string>();            // string|undefined
 *   lastName = input.required<string>();    // string
 *   age = input(0);                         // number
 * }
 * ```
 *
 * @developerPreview
 */
export const input = (() => {
    // Note: This may be considered a side-effect, but nothing will depend on
    // this assignment, unless this `input` constant export is accessed. It's a
    // self-contained side effect that is local to the user facing`input` export.
    inputFunction.required = inputRequiredFunction;
    return inputFunction;
})();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5wdXQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9jb3JlL3NyYy9hdXRob3JpbmcvaW5wdXQvaW5wdXQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztHQU1HO0FBRUgsT0FBTyxFQUFDLHdCQUF3QixFQUFDLE1BQU0sVUFBVSxDQUFDO0FBRWxELE9BQU8sRUFBQyxpQkFBaUIsRUFBK0csTUFBTSxnQkFBZ0IsQ0FBQztBQUMvSixPQUFPLEVBQUMsb0JBQW9CLEVBQUMsTUFBTSxxQkFBcUIsQ0FBQztBQUV6RCxNQUFNLFVBQVUsYUFBYSxDQUN6QixZQUFvQixFQUNwQixJQUFrQztJQUNwQyxTQUFTLElBQUksd0JBQXdCLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDN0MsT0FBTyxpQkFBaUIsQ0FBQyxZQUFZLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFDL0MsQ0FBQztBQUVELE1BQU0sVUFBVSxxQkFBcUIsQ0FBZ0IsSUFBa0M7SUFFckYsU0FBUyxJQUFJLHdCQUF3QixDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQzdDLE9BQU8saUJBQWlCLENBQUMsb0JBQTZCLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFDaEUsQ0FBQztBQXdERDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBd0JHO0FBQ0gsTUFBTSxDQUFDLE1BQU0sS0FBSyxHQUFrQixDQUFDLEdBQUcsRUFBRTtJQUN4Qyx5RUFBeUU7SUFDekUsMkVBQTJFO0lBQzNFLDZFQUE2RTtJQUM1RSxhQUFxQixDQUFDLFFBQVEsR0FBRyxxQkFBcUIsQ0FBQztJQUN4RCxPQUFPLGFBQWdGLENBQUM7QUFDMUYsQ0FBQyxDQUFDLEVBQUUsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG5pbXBvcnQge2Fzc2VydEluSW5qZWN0aW9uQ29udGV4dH0gZnJvbSAnLi4vLi4vZGknO1xuXG5pbXBvcnQge2NyZWF0ZUlucHV0U2lnbmFsLCBJbnB1dE9wdGlvbnMsIElucHV0T3B0aW9uc1dpdGhvdXRUcmFuc2Zvcm0sIElucHV0T3B0aW9uc1dpdGhUcmFuc2Zvcm0sIElucHV0U2lnbmFsLCBJbnB1dFNpZ25hbFdpdGhUcmFuc2Zvcm19IGZyb20gJy4vaW5wdXRfc2lnbmFsJztcbmltcG9ydCB7UkVRVUlSRURfVU5TRVRfVkFMVUV9IGZyb20gJy4vaW5wdXRfc2lnbmFsX25vZGUnO1xuXG5leHBvcnQgZnVuY3Rpb24gaW5wdXRGdW5jdGlvbjxSZWFkVCwgV3JpdGVUPihcbiAgICBpbml0aWFsVmFsdWU/OiBSZWFkVCxcbiAgICBvcHRzPzogSW5wdXRPcHRpb25zPFJlYWRULCBXcml0ZVQ+KTogSW5wdXRTaWduYWxXaXRoVHJhbnNmb3JtPFJlYWRUfHVuZGVmaW5lZCwgV3JpdGVUPiB7XG4gIG5nRGV2TW9kZSAmJiBhc3NlcnRJbkluamVjdGlvbkNvbnRleHQoaW5wdXQpO1xuICByZXR1cm4gY3JlYXRlSW5wdXRTaWduYWwoaW5pdGlhbFZhbHVlLCBvcHRzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlucHV0UmVxdWlyZWRGdW5jdGlvbjxSZWFkVCwgV3JpdGVUPihvcHRzPzogSW5wdXRPcHRpb25zPFJlYWRULCBXcml0ZVQ+KTpcbiAgICBJbnB1dFNpZ25hbFdpdGhUcmFuc2Zvcm08UmVhZFQsIFdyaXRlVD4ge1xuICBuZ0Rldk1vZGUgJiYgYXNzZXJ0SW5JbmplY3Rpb25Db250ZXh0KGlucHV0KTtcbiAgcmV0dXJuIGNyZWF0ZUlucHV0U2lnbmFsKFJFUVVJUkVEX1VOU0VUX1ZBTFVFIGFzIG5ldmVyLCBvcHRzKTtcbn1cblxuLyoqXG4gKiBUaGUgYGlucHV0YCBmdW5jdGlvbiBhbGxvd3MgZGVjbGFyYXRpb24gb2YgaW5wdXRzIGluIGRpcmVjdGl2ZXMgYW5kXG4gKiBjb21wb25lbnRzLlxuICpcbiAqIFRoZSBmdW5jdGlvbiBleHBvc2VzIGFuIEFQSSBmb3IgYWxzbyBkZWNsYXJpbmcgcmVxdWlyZWQgaW5wdXRzIHZpYSB0aGVcbiAqIGBpbnB1dC5yZXF1aXJlZGAgZnVuY3Rpb24uXG4gKlxuICogQHVzYWdlTm90ZXNcbiAqIEluaXRpYWxpemUgYW4gaW5wdXQgaW4geW91ciBkaXJlY3RpdmUgb3IgY29tcG9uZW50IGJ5IGRlY2xhcmluZyBhXG4gKiBjbGFzcyBmaWVsZCBhbmQgaW5pdGlhbGl6aW5nIGl0IHdpdGggdGhlIGBpbnB1dCgpYCBvciBgaW5wdXQucmVxdWlyZWQoKWBcbiAqIGZ1bmN0aW9uLlxuICpcbiAqIGBgYHRzXG4gKiBARGlyZWN0aXZlKHsuLn0pXG4gKiBleHBvcnQgY2xhc3MgTXlEaXIge1xuICogICBmaXJzdE5hbWUgPSBpbnB1dDxzdHJpbmc+KCk7ICAgICAgICAgICAgLy8gc3RyaW5nfHVuZGVmaW5lZFxuICogICBsYXN0TmFtZSA9IGlucHV0LnJlcXVpcmVkPHN0cmluZz4oKTsgICAgLy8gc3RyaW5nXG4gKiAgIGFnZSA9IGlucHV0KDApOyAgICAgICAgICAgICAgICAgICAgICAgICAvLyBudW1iZXJcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBkZXZlbG9wZXJQcmV2aWV3XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSW5wdXRGdW5jdGlvbiB7XG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBhbiBpbnB1dCB3aXRoIGFuIGluaXRpYWwgdmFsdWUuIElmIG5vIGV4cGxpY2l0IHZhbHVlXG4gICAqIGlzIHNwZWNpZmllZCwgQW5ndWxhciB3aWxsIHVzZSBgdW5kZWZpbmVkYC5cbiAgICpcbiAgICogQ29uc2lkZXIgdXNpbmcgYGlucHV0LnJlcXVpcmVkYCBmb3IgaW5wdXRzIHRoYXQgZG9uJ3QgbmVlZCBhblxuICAgKiBpbml0aWFsIHZhbHVlLlxuICAgKlxuICAgKiBAZGV2ZWxvcGVyUHJldmlld1xuICAgKi9cbiAgPFJlYWRUPigpOiBJbnB1dFNpZ25hbDxSZWFkVHx1bmRlZmluZWQ+O1xuICA8UmVhZFQ+KGluaXRpYWxWYWx1ZTogUmVhZFQsIG9wdHM/OiBJbnB1dE9wdGlvbnNXaXRob3V0VHJhbnNmb3JtPFJlYWRUPik6IElucHV0U2lnbmFsPFJlYWRUPjtcbiAgPFJlYWRULCBXcml0ZVQ+KGluaXRpYWxWYWx1ZTogUmVhZFQsIG9wdHM6IElucHV0T3B0aW9uc1dpdGhUcmFuc2Zvcm08UmVhZFQsIFdyaXRlVD4pOlxuICAgICAgSW5wdXRTaWduYWxXaXRoVHJhbnNmb3JtPFJlYWRULCBXcml0ZVQ+O1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBhIHJlcXVpcmVkIGlucHV0LlxuICAgKlxuICAgKiBVc2VycyBvZiB5b3VyIGRpcmVjdGl2ZS9jb21wb25lbnQgbmVlZCB0byBiaW5kIHRvIHRoaXNcbiAgICogaW5wdXQuIElmIHVuc2V0LCBhIGNvbXBpbGUgdGltZSBlcnJvciB3aWxsIGJlIHJlcG9ydGVkLlxuICAgKlxuICAgKiBAZGV2ZWxvcGVyUHJldmlld1xuICAgKi9cbiAgcmVxdWlyZWQ6IHtcbiAgICA8UmVhZFQ+KG9wdHM/OiBJbnB1dE9wdGlvbnNXaXRob3V0VHJhbnNmb3JtPFJlYWRUPik6IElucHV0U2lnbmFsPFJlYWRUPjtcblxuICAgIDxSZWFkVCwgV3JpdGVUPihvcHRzOiBJbnB1dE9wdGlvbnNXaXRoVHJhbnNmb3JtPFJlYWRULCBXcml0ZVQ+KTpcbiAgICAgICAgSW5wdXRTaWduYWxXaXRoVHJhbnNmb3JtPFJlYWRULCBXcml0ZVQ+O1xuICB9O1xufVxuXG4vKipcbiAqIFRoZSBgaW5wdXRgIGZ1bmN0aW9uIGFsbG93cyBkZWNsYXJhdGlvbiBvZiBpbnB1dHMgaW4gZGlyZWN0aXZlcyBhbmRcbiAqIGNvbXBvbmVudHMuXG4gKlxuICogSW5pdGlhbGl6ZXMgYW4gaW5wdXQgd2l0aCBhbiBpbml0aWFsIHZhbHVlLiBJZiBubyBleHBsaWNpdCB2YWx1ZVxuICogaXMgc3BlY2lmaWVkLCBBbmd1bGFyIHdpbGwgdXNlIGB1bmRlZmluZWRgLlxuICpcbiAqIENvbnNpZGVyIHVzaW5nIGBpbnB1dC5yZXF1aXJlZGAgZm9yIGlucHV0cyB0aGF0IGRvbid0IG5lZWQgYW5cbiAqIGluaXRpYWwgdmFsdWUuXG4gKlxuICogQHVzYWdlTm90ZXNcbiAqIEluaXRpYWxpemUgYW4gaW5wdXQgaW4geW91ciBkaXJlY3RpdmUgb3IgY29tcG9uZW50IGJ5IGRlY2xhcmluZyBhXG4gKiBjbGFzcyBmaWVsZCBhbmQgaW5pdGlhbGl6aW5nIGl0IHdpdGggdGhlIGBpbnB1dCgpYCBmdW5jdGlvbi5cbiAqXG4gKiBgYGB0c1xuICogQERpcmVjdGl2ZSh7Li59KVxuICogZXhwb3J0IGNsYXNzIE15RGlyIHtcbiAqICAgZmlyc3ROYW1lID0gaW5wdXQ8c3RyaW5nPigpOyAgICAgICAgICAgIC8vIHN0cmluZ3x1bmRlZmluZWRcbiAqICAgbGFzdE5hbWUgPSBpbnB1dC5yZXF1aXJlZDxzdHJpbmc+KCk7ICAgIC8vIHN0cmluZ1xuICogICBhZ2UgPSBpbnB1dCgwKTsgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbnVtYmVyXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAZGV2ZWxvcGVyUHJldmlld1xuICovXG5leHBvcnQgY29uc3QgaW5wdXQ6IElucHV0RnVuY3Rpb24gPSAoKCkgPT4ge1xuICAvLyBOb3RlOiBUaGlzIG1heSBiZSBjb25zaWRlcmVkIGEgc2lkZS1lZmZlY3QsIGJ1dCBub3RoaW5nIHdpbGwgZGVwZW5kIG9uXG4gIC8vIHRoaXMgYXNzaWdubWVudCwgdW5sZXNzIHRoaXMgYGlucHV0YCBjb25zdGFudCBleHBvcnQgaXMgYWNjZXNzZWQuIEl0J3MgYVxuICAvLyBzZWxmLWNvbnRhaW5lZCBzaWRlIGVmZmVjdCB0aGF0IGlzIGxvY2FsIHRvIHRoZSB1c2VyIGZhY2luZ2BpbnB1dGAgZXhwb3J0LlxuICAoaW5wdXRGdW5jdGlvbiBhcyBhbnkpLnJlcXVpcmVkID0gaW5wdXRSZXF1aXJlZEZ1bmN0aW9uO1xuICByZXR1cm4gaW5wdXRGdW5jdGlvbiBhcyAodHlwZW9mIGlucHV0RnVuY3Rpb24me3JlcXVpcmVkOiB0eXBlb2YgaW5wdXRSZXF1aXJlZEZ1bmN0aW9ufSk7XG59KSgpO1xuIl19
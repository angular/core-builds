/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { hasInSkipHydrationBlockFlag } from '../hydration/skip_hydration';
import { assertDefined } from '../util/assert';
import { assertLContainer, assertLView, assertTNodeForLView } from './assert';
import { renderView } from './instructions/render';
import { createLView } from './instructions/shared';
import { CONTAINER_HEADER_OFFSET, NATIVE } from './interfaces/container';
import { DECLARATION_LCONTAINER, FLAGS, QUERIES, RENDERER, T_HOST, TVIEW } from './interfaces/view';
import { addViewToDOM, destroyLView, detachView, getBeforeNodeForView, insertView, nativeParentNode } from './node_manipulation';
export function createAndRenderEmbeddedLView(declarationLView, templateTNode, context, options) {
    const embeddedTView = templateTNode.tView;
    ngDevMode && assertDefined(embeddedTView, 'TView must be defined for a template node.');
    ngDevMode && assertTNodeForLView(templateTNode, declarationLView);
    // Embedded views follow the change detection strategy of the view they're declared in.
    const isSignalView = declarationLView[FLAGS] & 4096 /* LViewFlags.SignalView */;
    const viewFlags = isSignalView ? 4096 /* LViewFlags.SignalView */ : 16 /* LViewFlags.CheckAlways */;
    const embeddedLView = createLView(declarationLView, embeddedTView, context, viewFlags, null, templateTNode, null, null, null, options?.injector ?? null, options?.dehydratedView ?? null);
    const declarationLContainer = declarationLView[templateTNode.index];
    ngDevMode && assertLContainer(declarationLContainer);
    embeddedLView[DECLARATION_LCONTAINER] = declarationLContainer;
    const declarationViewLQueries = declarationLView[QUERIES];
    if (declarationViewLQueries !== null) {
        embeddedLView[QUERIES] = declarationViewLQueries.createEmbeddedView(embeddedTView);
    }
    // execute creation mode of a view
    renderView(embeddedTView, embeddedLView, context);
    return embeddedLView;
}
export function getLViewFromLContainer(lContainer, index) {
    const adjustedIndex = CONTAINER_HEADER_OFFSET + index;
    // avoid reading past the array boundaries
    if (adjustedIndex < lContainer.length) {
        const lView = lContainer[adjustedIndex];
        ngDevMode && assertLView(lView);
        return lView;
    }
    return undefined;
}
/**
 * Returns whether an elements that belong to a view should be
 * inserted into the DOM. For client-only cases, DOM elements are
 * always inserted. For hydration cases, we check whether serialized
 * info is available for a view and the view is not in a "skip hydration"
 * block (in which case view contents was re-created, thus needing insertion).
 */
export function shouldAddViewToDom(tNode, dehydratedView) {
    return !dehydratedView || hasInSkipHydrationBlockFlag(tNode);
}
export function addLViewToLContainer(lContainer, lView, index, addToDOM = true) {
    const tView = lView[TVIEW];
    // insert to the view tree so the new view can be change-detected
    insertView(tView, lView, lContainer, index);
    // insert to the view to the DOM tree
    if (addToDOM) {
        const beforeNode = getBeforeNodeForView(index, lContainer);
        const renderer = lView[RENDERER];
        const parentRNode = nativeParentNode(renderer, lContainer[NATIVE]);
        if (parentRNode !== null) {
            addViewToDOM(tView, lContainer[T_HOST], renderer, lView, parentRNode, beforeNode);
        }
    }
}
export function removeLViewFromLContainer(lContainer, index) {
    const lView = detachView(lContainer, index);
    if (lView !== undefined) {
        destroyLView(lView[TVIEW], lView);
    }
    return lView;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmlld19tYW5pcHVsYXRpb24uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9jb3JlL3NyYy9yZW5kZXIzL3ZpZXdfbWFuaXB1bGF0aW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7R0FNRztBQUlILE9BQU8sRUFBQywyQkFBMkIsRUFBQyxNQUFNLDZCQUE2QixDQUFDO0FBQ3hFLE9BQU8sRUFBQyxhQUFhLEVBQUMsTUFBTSxnQkFBZ0IsQ0FBQztBQUU3QyxPQUFPLEVBQUMsZ0JBQWdCLEVBQUUsV0FBVyxFQUFFLG1CQUFtQixFQUFDLE1BQU0sVUFBVSxDQUFDO0FBQzVFLE9BQU8sRUFBQyxVQUFVLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUNqRCxPQUFPLEVBQUMsV0FBVyxFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFDbEQsT0FBTyxFQUFDLHVCQUF1QixFQUFjLE1BQU0sRUFBQyxNQUFNLHdCQUF3QixDQUFDO0FBR25GLE9BQU8sRUFBQyxzQkFBc0IsRUFBRSxLQUFLLEVBQXFCLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBQyxNQUFNLG1CQUFtQixDQUFDO0FBQ3JILE9BQU8sRUFBQyxZQUFZLEVBQUUsWUFBWSxFQUFFLFVBQVUsRUFBRSxvQkFBb0IsRUFBRSxVQUFVLEVBQUUsZ0JBQWdCLEVBQUMsTUFBTSxxQkFBcUIsQ0FBQztBQUUvSCxNQUFNLFVBQVUsNEJBQTRCLENBQ3hDLGdCQUFnQyxFQUFFLGFBQW9CLEVBQUUsT0FBVSxFQUNsRSxPQUE4RTtJQUNoRixNQUFNLGFBQWEsR0FBRyxhQUFhLENBQUMsS0FBTSxDQUFDO0lBQzNDLFNBQVMsSUFBSSxhQUFhLENBQUMsYUFBYSxFQUFFLDRDQUE0QyxDQUFDLENBQUM7SUFDeEYsU0FBUyxJQUFJLG1CQUFtQixDQUFDLGFBQWEsRUFBRSxnQkFBZ0IsQ0FBQyxDQUFDO0lBRWxFLHVGQUF1RjtJQUN2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QyxDQUFDO0lBQzVDLElBQUksS0FBSyxLQUFLLFNBQVMsRUFBRSxDQUFDO1FBQ3hCLFlBQVksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFDcEMsQ0FBQztJQUNELE9BQU8sS0FBSyxDQUFDO0FBQ2YsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG5pbXBvcnQge0luamVjdG9yfSBmcm9tICcuLi9kaS9pbmplY3Rvcic7XG5pbXBvcnQge0RlaHlkcmF0ZWRDb250YWluZXJWaWV3fSBmcm9tICcuLi9oeWRyYXRpb24vaW50ZXJmYWNlcyc7XG5pbXBvcnQge2hhc0luU2tpcEh5ZHJhdGlvbkJsb2NrRmxhZ30gZnJvbSAnLi4vaHlkcmF0aW9uL3NraXBfaHlkcmF0aW9uJztcbmltcG9ydCB7YXNzZXJ0RGVmaW5lZH0gZnJvbSAnLi4vdXRpbC9hc3NlcnQnO1xuXG5pbXBvcnQge2Fzc2VydExDb250YWluZXIsIGFzc2VydExWaWV3LCBhc3NlcnRUTm9kZUZvckxWaWV3fSBmcm9tICcuL2Fzc2VydCc7XG5pbXBvcnQge3JlbmRlclZpZXd9IGZyb20gJy4vaW5zdHJ1Y3Rpb25zL3JlbmRlcic7XG5pbXBvcnQge2NyZWF0ZUxWaWV3fSBmcm9tICcuL2luc3RydWN0aW9ucy9zaGFyZWQnO1xuaW1wb3J0IHtDT05UQUlORVJfSEVBREVSX09GRlNFVCwgTENvbnRhaW5lciwgTkFUSVZFfSBmcm9tICcuL2ludGVyZmFjZXMvY29udGFpbmVyJztcbmltcG9ydCB7VE5vZGV9IGZyb20gJy4vaW50ZXJmYWNlcy9ub2RlJztcbmltcG9ydCB7UkNvbW1lbnQsIFJFbGVtZW50fSBmcm9tICcuL2ludGVyZmFjZXMvcmVuZGVyZXJfZG9tJztcbmltcG9ydCB7REVDTEFSQVRJT05fTENPTlRBSU5FUiwgRkxBR1MsIExWaWV3LCBMVmlld0ZsYWdzLCBRVUVSSUVTLCBSRU5ERVJFUiwgVF9IT1NULCBUVklFV30gZnJvbSAnLi9pbnRlcmZhY2VzL3ZpZXcnO1xuaW1wb3J0IHthZGRWaWV3VG9ET00sIGRlc3Ryb3lMVmlldywgZGV0YWNoVmlldywgZ2V0QmVmb3JlTm9kZUZvclZpZXcsIGluc2VydFZpZXcsIG5hdGl2ZVBhcmVudE5vZGV9IGZyb20gJy4vbm9kZV9tYW5pcHVsYXRpb24nO1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQW5kUmVuZGVyRW1iZWRkZWRMVmlldzxUPihcbiAgICBkZWNsYXJhdGlvbkxWaWV3OiBMVmlldzx1bmtub3duPiwgdGVtcGxhdGVUTm9kZTogVE5vZGUsIGNvbnRleHQ6IFQsXG4gICAgb3B0aW9ucz86IHtpbmplY3Rvcj86IEluamVjdG9yLCBkZWh5ZHJhdGVkVmlldz86IERlaHlkcmF0ZWRDb250YWluZXJWaWV3fG51bGx9KTogTFZpZXc8VD4ge1xuICBjb25zdCBlbWJlZGRlZFRWaWV3ID0gdGVtcGxhdGVUTm9kZS50VmlldyE7XG4gIG5nRGV2TW9kZSAmJiBhc3NlcnREZWZpbmVkKGVtYmVkZGVkVFZpZXcsICdUVmlldyBtdXN0IGJlIGRlZmluZWQgZm9yIGEgdGVtcGxhdGUgbm9kZS4nKTtcbiAgbmdEZXZNb2RlICYmIGFzc2VydFROb2RlRm9yTFZpZXcodGVtcGxhdGVUTm9kZSwgZGVjbGFyYXRpb25MVmlldyk7XG5cbiAgLy8gRW1iZWRkZWQgdmlld3MgZm9sbG93IHRoZSBjaGFuZ2UgZGV0ZWN0aW9uIHN0cmF0ZWd5IG9mIHRoZSB2aWV3IHRoZXkncmUgZGVjbGFyZWQgaW4uXG4gIGNvbnN0IGlzU2lnbmFsVmlldyA9IGRlY2xhcmF0aW9uTFZpZXdbRkxBR1NdICYgTFZpZXdGbGFncy5TaWduYWxWaWV3O1xuICBjb25zdCB2aWV3RmxhZ3MgPSBpc1NpZ25hbFZpZXcgPyBMVmlld0ZsYWdzLlNpZ25hbFZpZXcgOiBMVmlld0ZsYWdzLkNoZWNrQWx3YXlzO1xuICBjb25zdCBlbWJlZGRlZExWaWV3ID0gY3JlYXRlTFZpZXc8VD4oXG4gICAgICBkZWNsYXJhdGlvbkxWaWV3LCBlbWJlZGRlZFRWaWV3LCBjb250ZXh0LCB2aWV3RmxhZ3MsIG51bGwsIHRlbXBsYXRlVE5vZGUsIG51bGwsIG51bGwsIG51bGwsXG4gICAgICBvcHRpb25zPy5pbmplY3RvciA/PyBudWxsLCBvcHRpb25zPy5kZWh5ZHJhdGVkVmlldyA/PyBudWxsKTtcblxuICBjb25zdCBkZWNsYXJhdGlvbkxDb250YWluZXIgPSBkZWNsYXJhdGlvbkxWaWV3W3RlbXBsYXRlVE5vZGUuaW5kZXhdO1xuICBuZ0Rldk1vZGUgJiYgYXNzZXJ0TENvbnRhaW5lcihkZWNsYXJhdGlvbkxDb250YWluZXIpO1xuICBlbWJlZGRlZExWaWV3W0RFQ0xBUkFUSU9OX0xDT05UQUlORVJdID0gZGVjbGFyYXRpb25MQ29udGFpbmVyO1xuXG4gIGNvbnN0IGRlY2xhcmF0aW9uVmlld0xRdWVyaWVzID0gZGVjbGFyYXRpb25MVmlld1tRVUVSSUVTXTtcbiAgaWYgKGRlY2xhcmF0aW9uVmlld0xRdWVyaWVzICE9PSBudWxsKSB7XG4gICAgZW1iZWRkZWRMVmlld1tRVUVSSUVTXSA9IGRlY2xhcmF0aW9uVmlld0xRdWVyaWVzLmNyZWF0ZUVtYmVkZGVkVmlldyhlbWJlZGRlZFRWaWV3KTtcbiAgfVxuXG4gIC8vIGV4ZWN1dGUgY3JlYXRpb24gbW9kZSBvZiBhIHZpZXdcbiAgcmVuZGVyVmlldyhlbWJlZGRlZFRWaWV3LCBlbWJlZGRlZExWaWV3LCBjb250ZXh0KTtcblxuICByZXR1cm4gZW1iZWRkZWRMVmlldztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldExWaWV3RnJvbUxDb250YWluZXI8VD4obENvbnRhaW5lcjogTENvbnRhaW5lciwgaW5kZXg6IG51bWJlcik6IExWaWV3PFQ+fFxuICAgIHVuZGVmaW5lZCB7XG4gIGNvbnN0IGFkanVzdGVkSW5kZXggPSBDT05UQUlORVJfSEVBREVSX09GRlNFVCArIGluZGV4O1xuICAvLyBhdm9pZCByZWFkaW5nIHBhc3QgdGhlIGFycmF5IGJvdW5kYXJpZXNcbiAgaWYgKGFkanVzdGVkSW5kZXggPCBsQ29udGFpbmVyLmxlbmd0aCkge1xuICAgIGNvbnN0IGxWaWV3ID0gbENvbnRhaW5lclthZGp1c3RlZEluZGV4XTtcbiAgICBuZ0Rldk1vZGUgJiYgYXNzZXJ0TFZpZXcobFZpZXcpO1xuICAgIHJldHVybiBsVmlldyBhcyBMVmlldzxUPjtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBhbiBlbGVtZW50cyB0aGF0IGJlbG9uZyB0byBhIHZpZXcgc2hvdWxkIGJlXG4gKiBpbnNlcnRlZCBpbnRvIHRoZSBET00uIEZvciBjbGllbnQtb25seSBjYXNlcywgRE9NIGVsZW1lbnRzIGFyZVxuICogYWx3YXlzIGluc2VydGVkLiBGb3IgaHlkcmF0aW9uIGNhc2VzLCB3ZSBjaGVjayB3aGV0aGVyIHNlcmlhbGl6ZWRcbiAqIGluZm8gaXMgYXZhaWxhYmxlIGZvciBhIHZpZXcgYW5kIHRoZSB2aWV3IGlzIG5vdCBpbiBhIFwic2tpcCBoeWRyYXRpb25cIlxuICogYmxvY2sgKGluIHdoaWNoIGNhc2UgdmlldyBjb250ZW50cyB3YXMgcmUtY3JlYXRlZCwgdGh1cyBuZWVkaW5nIGluc2VydGlvbikuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaG91bGRBZGRWaWV3VG9Eb20oXG4gICAgdE5vZGU6IFROb2RlLCBkZWh5ZHJhdGVkVmlldz86IERlaHlkcmF0ZWRDb250YWluZXJWaWV3fG51bGwpOiBib29sZWFuIHtcbiAgcmV0dXJuICFkZWh5ZHJhdGVkVmlldyB8fCBoYXNJblNraXBIeWRyYXRpb25CbG9ja0ZsYWcodE5vZGUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkTFZpZXdUb0xDb250YWluZXIoXG4gICAgbENvbnRhaW5lcjogTENvbnRhaW5lciwgbFZpZXc6IExWaWV3PHVua25vd24+LCBpbmRleDogbnVtYmVyLCBhZGRUb0RPTSA9IHRydWUpOiB2b2lkIHtcbiAgY29uc3QgdFZpZXcgPSBsVmlld1tUVklFV107XG5cbiAgLy8gaW5zZXJ0IHRvIHRoZSB2aWV3IHRyZWUgc28gdGhlIG5ldyB2aWV3IGNhbiBiZSBjaGFuZ2UtZGV0ZWN0ZWRcbiAgaW5zZXJ0Vmlldyh0VmlldywgbFZpZXcsIGxDb250YWluZXIsIGluZGV4KTtcblxuICAvLyBpbnNlcnQgdG8gdGhlIHZpZXcgdG8gdGhlIERPTSB0cmVlXG4gIGlmIChhZGRUb0RPTSkge1xuICAgIGNvbnN0IGJlZm9yZU5vZGUgPSBnZXRCZWZvcmVOb2RlRm9yVmlldyhpbmRleCwgbENvbnRhaW5lcik7XG4gICAgY29uc3QgcmVuZGVyZXIgPSBsVmlld1tSRU5ERVJFUl07XG4gICAgY29uc3QgcGFyZW50Uk5vZGUgPSBuYXRpdmVQYXJlbnROb2RlKHJlbmRlcmVyLCBsQ29udGFpbmVyW05BVElWRV0gYXMgUkVsZW1lbnQgfCBSQ29tbWVudCk7XG4gICAgaWYgKHBhcmVudFJOb2RlICE9PSBudWxsKSB7XG4gICAgICBhZGRWaWV3VG9ET00odFZpZXcsIGxDb250YWluZXJbVF9IT1NUXSwgcmVuZGVyZXIsIGxWaWV3LCBwYXJlbnRSTm9kZSwgYmVmb3JlTm9kZSk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVMVmlld0Zyb21MQ29udGFpbmVyKGxDb250YWluZXI6IExDb250YWluZXIsIGluZGV4OiBudW1iZXIpOiBMVmlldzx1bmtub3duPnxcbiAgICB1bmRlZmluZWQge1xuICBjb25zdCBsVmlldyA9IGRldGFjaFZpZXcobENvbnRhaW5lciwgaW5kZXgpO1xuICBpZiAobFZpZXcgIT09IHVuZGVmaW5lZCkge1xuICAgIGRlc3Ryb3lMVmlldyhsVmlld1tUVklFV10sIGxWaWV3KTtcbiAgfVxuICByZXR1cm4gbFZpZXc7XG59XG4iXX0=
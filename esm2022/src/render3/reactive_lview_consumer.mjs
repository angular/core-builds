/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { ReactiveNode, setActiveConsumer } from '../signals/src/graph';
import { assertDefined, assertEqual } from '../util/assert';
import { markViewDirty } from './instructions/mark_view_dirty';
const NG_DEV_MODE = typeof ngDevMode === 'undefined' || ngDevMode;
export class ReactiveLViewConsumer extends ReactiveNode {
    constructor() {
        super(...arguments);
        this._lView = null;
    }
    set lView(lView) {
        NG_DEV_MODE && assertEqual(this._lView, null, 'Consumer already associated with a view.');
        this._lView = lView;
    }
    onConsumerDependencyMayHaveChanged() {
        NG_DEV_MODE &&
            assertDefined(this._lView, 'Updating a signal during template or host binding execution is not allowed.');
        markViewDirty(this._lView);
    }
    onProducerUpdateValueVersion() {
        // This type doesn't implement the producer side of a `ReactiveNode`.
    }
    get hasReadASignal() {
        return this.hasProducers;
    }
    runInContext(fn, rf, ctx) {
        const prevConsumer = setActiveConsumer(this);
        this.trackingVersion++;
        try {
            fn(rf, ctx);
        }
        finally {
            setActiveConsumer(prevConsumer);
        }
    }
    destroy() {
        // Incrementing the version means that every producer which tries to update this consumer will
        // consider its record stale, and not notify.
        this.trackingVersion++;
    }
}
let currentConsumer = null;
function getOrCreateCurrentLViewConsumer() {
    currentConsumer ??= new ReactiveLViewConsumer();
    return currentConsumer;
}
/**
 * Create a new template consumer pointing at the specified LView.
 * Sometimes, a previously created consumer may be reused, in order to save on allocations. In that
 * case, the LView will be updated.
 */
export function getReactiveLViewConsumer(lView, slot) {
    return lView[slot] ?? getOrCreateCurrentLViewConsumer();
}
/**
 * Assigns the `currentTemplateContext` to its LView's `REACTIVE_CONSUMER` slot if there are tracked
 * producers.
 *
 * The presence of producers means that a signal was read while the consumer was the active
 * consumer.
 *
 * If no producers are present, we do not assign the current template context. This also means we
 * can just reuse the template context for the next LView.
 */
export function commitLViewConsumerIfHasProducers(lView, slot) {
    const consumer = getOrCreateCurrentLViewConsumer();
    if (!consumer.hasReadASignal) {
        return;
    }
    lView[slot] = currentConsumer;
    consumer.lView = lView;
    currentConsumer = new ReactiveLViewConsumer();
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVhY3RpdmVfbHZpZXdfY29uc3VtZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9jb3JlL3NyYy9yZW5kZXIzL3JlYWN0aXZlX2x2aWV3X2NvbnN1bWVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7R0FNRztBQUVILE9BQU8sRUFBQyxZQUFZLEVBQUUsaUJBQWlCLEVBQUMsTUFBTSxzQkFBc0IsQ0FBQztBQUNyRSxPQUFPLEVBQUMsYUFBYSxFQUFFLFdBQVcsRUFBQyxNQUFNLGdCQUFnQixDQUFDO0FBRTFELE9BQU8sRUFBQyxhQUFhLEVBQUMsTUFBTSxnQ0FBZ0MsQ0FBQztBQUk3RCxNQUFNLFdBQVcsR0FBRyxPQUFPLFNBQVMsS0FBSyxXQUFXLElBQUksU0FBUyxDQUFDO0FBRWxFLE1BQU0sT0FBTyxxQkFBc0IsU0FBUSxZQUFZO0lBQXZEOztRQUNVLFdBQU0sR0FBZSxJQUFJLENBQUM7SUF3Q3BDLENBQUM7SUF0Q0MsSUFBSSxLQUFLLENBQUMsS0FBWTtRQUNwQixXQUFXLElBQUksV0FBVyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsSUFBSSxFQUFFLDBDQUEwQyxDQUFDLENBQUM7UUFDMUYsSUFBSSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUM7SUFDdEIsQ0FBQztJQUVrQixrQ0FBa0M7UUFDbkQsV0FBVztZQUNQLGFBQWEsQ0FDVCxJQUFJLENBQUMsTUFBTSxFQUNYLDZFQUE2RSxDQUFDLENBQUM7UUFDdkYsYUFBYSxDQUFDLElBQUksQ0FBQyxNQUFPLENBQUMsQ0FBQztJQUM5QixDQUFDO0lBRWtCLDRCQUE0QjtRQUM3QyxxRUFBcUU7SUFDdkUsQ0FBQztJQUVELElBQUksY0FBYztRQUNoQixPQUFPLElBQUksQ0FBQyxZQUFZLENBQUM7SUFDM0IsQ0FBQztJQUVELFlBQVksQ0FDUixFQUE0RCxFQUFFLEVBQWUsRUFDN0UsR0FBWTtRQUNkLE1BQU0sWUFBWSxHQUFHLGlCQUFpQixDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzdDLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztRQUN2QixJQUFJO1lBQ0YsRUFBRSxDQUFDLEVBQUUsRUFBRSxHQUFHLENBQUMsQ0FBQztTQUNiO2dCQUFTO1lBQ1IsaUJBQWlCLENBQUMsWUFBWSxDQUFDLENBQUM7U0FDakM7SUFDSCxDQUFDO0lBRUQsT0FBTztRQUNMLDhGQUE4RjtRQUM5Riw2Q0FBNkM7UUFDN0MsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO0lBQ3pCLENBQUM7Q0FDRjtBQUVELElBQUksZUFBZSxHQUErQixJQUFJLENBQUM7QUFFdkQsU0FBUywrQkFBK0I7SUFDdEMsZUFBZSxLQUFLLElBQUkscUJBQXFCLEVBQUUsQ0FBQztJQUNoRCxPQUFPLGVBQWUsQ0FBQztBQUN6QixDQUFDO0FBRUQ7Ozs7R0FJRztBQUNILE1BQU0sVUFBVSx3QkFBd0IsQ0FDcEMsS0FBWSxFQUFFLElBQTZFO0lBRTdGLE9BQU8sS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLCtCQUErQixFQUFFLENBQUM7QUFDMUQsQ0FBQztBQUVEOzs7Ozs7Ozs7R0FTRztBQUNILE1BQU0sVUFBVSxpQ0FBaUMsQ0FDN0MsS0FBWSxFQUNaLElBQTZFO0lBQy9FLE1BQU0sUUFBUSxHQUFHLCtCQUErQixFQUFFLENBQUM7SUFDbkQsSUFBSSxDQUFDLFFBQVEsQ0FBQyxjQUFjLEVBQUU7UUFDNUIsT0FBTztLQUNSO0lBRUQsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLGVBQWUsQ0FBQztJQUM5QixRQUFRLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztJQUN2QixlQUFlLEdBQUcsSUFBSSxxQkFBcUIsRUFBRSxDQUFDO0FBQ2hELENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuaW1wb3J0IHtSZWFjdGl2ZU5vZGUsIHNldEFjdGl2ZUNvbnN1bWVyfSBmcm9tICcuLi9zaWduYWxzL3NyYy9ncmFwaCc7XG5pbXBvcnQge2Fzc2VydERlZmluZWQsIGFzc2VydEVxdWFsfSBmcm9tICcuLi91dGlsL2Fzc2VydCc7XG5cbmltcG9ydCB7bWFya1ZpZXdEaXJ0eX0gZnJvbSAnLi9pbnN0cnVjdGlvbnMvbWFya192aWV3X2RpcnR5JztcbmltcG9ydCB7Q29tcG9uZW50VGVtcGxhdGUsIEhvc3RCaW5kaW5nc0Z1bmN0aW9uLCBSZW5kZXJGbGFnc30gZnJvbSAnLi9pbnRlcmZhY2VzL2RlZmluaXRpb24nO1xuaW1wb3J0IHtMVmlldywgUkVBQ1RJVkVfSE9TVF9CSU5ESU5HX0NPTlNVTUVSLCBSRUFDVElWRV9URU1QTEFURV9DT05TVU1FUn0gZnJvbSAnLi9pbnRlcmZhY2VzL3ZpZXcnO1xuXG5jb25zdCBOR19ERVZfTU9ERSA9IHR5cGVvZiBuZ0Rldk1vZGUgPT09ICd1bmRlZmluZWQnIHx8IG5nRGV2TW9kZTtcblxuZXhwb3J0IGNsYXNzIFJlYWN0aXZlTFZpZXdDb25zdW1lciBleHRlbmRzIFJlYWN0aXZlTm9kZSB7XG4gIHByaXZhdGUgX2xWaWV3OiBMVmlld3xudWxsID0gbnVsbDtcblxuICBzZXQgbFZpZXcobFZpZXc6IExWaWV3KSB7XG4gICAgTkdfREVWX01PREUgJiYgYXNzZXJ0RXF1YWwodGhpcy5fbFZpZXcsIG51bGwsICdDb25zdW1lciBhbHJlYWR5IGFzc29jaWF0ZWQgd2l0aCBhIHZpZXcuJyk7XG4gICAgdGhpcy5fbFZpZXcgPSBsVmlldztcbiAgfVxuXG4gIHByb3RlY3RlZCBvdmVycmlkZSBvbkNvbnN1bWVyRGVwZW5kZW5jeU1heUhhdmVDaGFuZ2VkKCkge1xuICAgIE5HX0RFVl9NT0RFICYmXG4gICAgICAgIGFzc2VydERlZmluZWQoXG4gICAgICAgICAgICB0aGlzLl9sVmlldyxcbiAgICAgICAgICAgICdVcGRhdGluZyBhIHNpZ25hbCBkdXJpbmcgdGVtcGxhdGUgb3IgaG9zdCBiaW5kaW5nIGV4ZWN1dGlvbiBpcyBub3QgYWxsb3dlZC4nKTtcbiAgICBtYXJrVmlld0RpcnR5KHRoaXMuX2xWaWV3ISk7XG4gIH1cblxuICBwcm90ZWN0ZWQgb3ZlcnJpZGUgb25Qcm9kdWNlclVwZGF0ZVZhbHVlVmVyc2lvbigpOiB2b2lkIHtcbiAgICAvLyBUaGlzIHR5cGUgZG9lc24ndCBpbXBsZW1lbnQgdGhlIHByb2R1Y2VyIHNpZGUgb2YgYSBgUmVhY3RpdmVOb2RlYC5cbiAgfVxuXG4gIGdldCBoYXNSZWFkQVNpZ25hbCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5oYXNQcm9kdWNlcnM7XG4gIH1cblxuICBydW5JbkNvbnRleHQoXG4gICAgICBmbjogSG9zdEJpbmRpbmdzRnVuY3Rpb248dW5rbm93bj58Q29tcG9uZW50VGVtcGxhdGU8dW5rbm93bj4sIHJmOiBSZW5kZXJGbGFncyxcbiAgICAgIGN0eDogdW5rbm93bik6IHZvaWQge1xuICAgIGNvbnN0IHByZXZDb25zdW1lciA9IHNldEFjdGl2ZUNvbnN1bWVyKHRoaXMpO1xuICAgIHRoaXMudHJhY2tpbmdWZXJzaW9uKys7XG4gICAgdHJ5IHtcbiAgICAgIGZuKHJmLCBjdHgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRBY3RpdmVDb25zdW1lcihwcmV2Q29uc3VtZXIpO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3koKTogdm9pZCB7XG4gICAgLy8gSW5jcmVtZW50aW5nIHRoZSB2ZXJzaW9uIG1lYW5zIHRoYXQgZXZlcnkgcHJvZHVjZXIgd2hpY2ggdHJpZXMgdG8gdXBkYXRlIHRoaXMgY29uc3VtZXIgd2lsbFxuICAgIC8vIGNvbnNpZGVyIGl0cyByZWNvcmQgc3RhbGUsIGFuZCBub3Qgbm90aWZ5LlxuICAgIHRoaXMudHJhY2tpbmdWZXJzaW9uKys7XG4gIH1cbn1cblxubGV0IGN1cnJlbnRDb25zdW1lcjogUmVhY3RpdmVMVmlld0NvbnN1bWVyfG51bGwgPSBudWxsO1xuXG5mdW5jdGlvbiBnZXRPckNyZWF0ZUN1cnJlbnRMVmlld0NvbnN1bWVyKCkge1xuICBjdXJyZW50Q29uc3VtZXIgPz89IG5ldyBSZWFjdGl2ZUxWaWV3Q29uc3VtZXIoKTtcbiAgcmV0dXJuIGN1cnJlbnRDb25zdW1lcjtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgdGVtcGxhdGUgY29uc3VtZXIgcG9pbnRpbmcgYXQgdGhlIHNwZWNpZmllZCBMVmlldy5cbiAqIFNvbWV0aW1lcywgYSBwcmV2aW91c2x5IGNyZWF0ZWQgY29uc3VtZXIgbWF5IGJlIHJldXNlZCwgaW4gb3JkZXIgdG8gc2F2ZSBvbiBhbGxvY2F0aW9ucy4gSW4gdGhhdFxuICogY2FzZSwgdGhlIExWaWV3IHdpbGwgYmUgdXBkYXRlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFJlYWN0aXZlTFZpZXdDb25zdW1lcihcbiAgICBsVmlldzogTFZpZXcsIHNsb3Q6IHR5cGVvZiBSRUFDVElWRV9URU1QTEFURV9DT05TVU1FUnx0eXBlb2YgUkVBQ1RJVkVfSE9TVF9CSU5ESU5HX0NPTlNVTUVSKTpcbiAgICBSZWFjdGl2ZUxWaWV3Q29uc3VtZXIge1xuICByZXR1cm4gbFZpZXdbc2xvdF0gPz8gZ2V0T3JDcmVhdGVDdXJyZW50TFZpZXdDb25zdW1lcigpO1xufVxuXG4vKipcbiAqIEFzc2lnbnMgdGhlIGBjdXJyZW50VGVtcGxhdGVDb250ZXh0YCB0byBpdHMgTFZpZXcncyBgUkVBQ1RJVkVfQ09OU1VNRVJgIHNsb3QgaWYgdGhlcmUgYXJlIHRyYWNrZWRcbiAqIHByb2R1Y2Vycy5cbiAqXG4gKiBUaGUgcHJlc2VuY2Ugb2YgcHJvZHVjZXJzIG1lYW5zIHRoYXQgYSBzaWduYWwgd2FzIHJlYWQgd2hpbGUgdGhlIGNvbnN1bWVyIHdhcyB0aGUgYWN0aXZlXG4gKiBjb25zdW1lci5cbiAqXG4gKiBJZiBubyBwcm9kdWNlcnMgYXJlIHByZXNlbnQsIHdlIGRvIG5vdCBhc3NpZ24gdGhlIGN1cnJlbnQgdGVtcGxhdGUgY29udGV4dC4gVGhpcyBhbHNvIG1lYW5zIHdlXG4gKiBjYW4ganVzdCByZXVzZSB0aGUgdGVtcGxhdGUgY29udGV4dCBmb3IgdGhlIG5leHQgTFZpZXcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21taXRMVmlld0NvbnN1bWVySWZIYXNQcm9kdWNlcnMoXG4gICAgbFZpZXc6IExWaWV3LFxuICAgIHNsb3Q6IHR5cGVvZiBSRUFDVElWRV9URU1QTEFURV9DT05TVU1FUnx0eXBlb2YgUkVBQ1RJVkVfSE9TVF9CSU5ESU5HX0NPTlNVTUVSKTogdm9pZCB7XG4gIGNvbnN0IGNvbnN1bWVyID0gZ2V0T3JDcmVhdGVDdXJyZW50TFZpZXdDb25zdW1lcigpO1xuICBpZiAoIWNvbnN1bWVyLmhhc1JlYWRBU2lnbmFsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbFZpZXdbc2xvdF0gPSBjdXJyZW50Q29uc3VtZXI7XG4gIGNvbnN1bWVyLmxWaWV3ID0gbFZpZXc7XG4gIGN1cnJlbnRDb25zdW1lciA9IG5ldyBSZWFjdGl2ZUxWaWV3Q29uc3VtZXIoKTtcbn1cbiJdfQ==
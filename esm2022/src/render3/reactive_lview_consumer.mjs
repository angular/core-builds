/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { ReactiveNode, setActiveConsumer } from '../signals/src/graph';
import { assertDefined, assertEqual } from '../util/assert';
import { markViewDirty } from './instructions/mark_view_dirty';
const NG_DEV_MODE = typeof ngDevMode === 'undefined' || ngDevMode;
export class ReactiveLViewConsumer extends ReactiveNode {
    constructor() {
        super(...arguments);
        this.consumerAllowSignalWrites = false;
        this._lView = null;
    }
    set lView(lView) {
        NG_DEV_MODE && assertEqual(this._lView, null, 'Consumer already associated with a view.');
        this._lView = lView;
    }
    onConsumerDependencyMayHaveChanged() {
        NG_DEV_MODE &&
            assertDefined(this._lView, 'Updating a signal during template or host binding execution is not allowed.');
        markViewDirty(this._lView);
    }
    onProducerUpdateValueVersion() {
        // This type doesn't implement the producer side of a `ReactiveNode`.
    }
    get hasReadASignal() {
        return this.hasProducers;
    }
    runInContext(fn, rf, ctx) {
        const prevConsumer = setActiveConsumer(this);
        this.trackingVersion++;
        try {
            fn(rf, ctx);
        }
        finally {
            setActiveConsumer(prevConsumer);
        }
    }
    destroy() {
        // Incrementing the version means that every producer which tries to update this consumer will
        // consider its record stale, and not notify.
        this.trackingVersion++;
    }
}
let currentConsumer = null;
function getOrCreateCurrentLViewConsumer() {
    currentConsumer ??= new ReactiveLViewConsumer();
    return currentConsumer;
}
/**
 * Create a new template consumer pointing at the specified LView.
 * Sometimes, a previously created consumer may be reused, in order to save on allocations. In that
 * case, the LView will be updated.
 */
export function getReactiveLViewConsumer(lView, slot) {
    return lView[slot] ?? getOrCreateCurrentLViewConsumer();
}
/**
 * Assigns the `currentTemplateContext` to its LView's `REACTIVE_CONSUMER` slot if there are tracked
 * producers.
 *
 * The presence of producers means that a signal was read while the consumer was the active
 * consumer.
 *
 * If no producers are present, we do not assign the current template context. This also means we
 * can just reuse the template context for the next LView.
 */
export function commitLViewConsumerIfHasProducers(lView, slot) {
    const consumer = getOrCreateCurrentLViewConsumer();
    if (!consumer.hasReadASignal) {
        return;
    }
    lView[slot] = currentConsumer;
    consumer.lView = lView;
    currentConsumer = new ReactiveLViewConsumer();
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVhY3RpdmVfbHZpZXdfY29uc3VtZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9jb3JlL3NyYy9yZW5kZXIzL3JlYWN0aXZlX2x2aWV3X2NvbnN1bWVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7R0FNRztBQUVILE9BQU8sRUFBQyxZQUFZLEVBQUUsaUJBQWlCLEVBQUMsTUFBTSxzQkFBc0IsQ0FBQztBQUNyRSxPQUFPLEVBQUMsYUFBYSxFQUFFLFdBQVcsRUFBQyxNQUFNLGdCQUFnQixDQUFDO0FBRTFELE9BQU8sRUFBQyxhQUFhLEVBQUMsTUFBTSxnQ0FBZ0MsQ0FBQztBQUk3RCxNQUFNLFdBQVcsR0FBRyxPQUFPLFNBQVMsS0FBSyxXQUFXLElBQUksU0FBUyxDQUFDO0FBRWxFLE1BQU0sT0FBTyxxQkFBc0IsU0FBUSxZQUFZO0lBQXZEOztRQUNxQiw4QkFBeUIsR0FBRyxLQUFLLENBQUM7UUFDN0MsV0FBTSxHQUFlLElBQUksQ0FBQztJQXdDcEMsQ0FBQztJQXRDQyxJQUFJLEtBQUssQ0FBQyxLQUFZO1FBQ3BCLFdBQVcsSUFBSSxXQUFXLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLEVBQUUsMENBQTBDLENBQUMsQ0FBQztRQUMxRixJQUFJLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQztJQUN0QixDQUFDO0lBRWtCLGtDQUFrQztRQUNuRCxXQUFXO1lBQ1AsYUFBYSxDQUNULElBQUksQ0FBQyxNQUFNLEVBQ1gsNkVBQTZFLENBQUMsQ0FBQztRQUN2RixhQUFhLENBQUMsSUFBSSxDQUFDLE1BQU8sQ0FBQyxDQUFDO0lBQzlCLENBQUM7SUFFa0IsNEJBQTRCO1FBQzdDLHFFQUFxRTtJQUN2RSxDQUFDO0lBRUQsSUFBSSxjQUFjO1FBQ2hCLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQztJQUMzQixDQUFDO0lBRUQsWUFBWSxDQUNSLEVBQTRELEVBQUUsRUFBZSxFQUM3RSxHQUFZO1FBQ2QsTUFBTSxZQUFZLEdBQUcsaUJBQWlCLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDN0MsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO1FBQ3ZCLElBQUk7WUFDRixFQUFFLENBQUMsRUFBRSxFQUFFLEdBQUcsQ0FBQyxDQUFDO1NBQ2I7Z0JBQVM7WUFDUixpQkFBaUIsQ0FBQyxZQUFZLENBQUMsQ0FBQztTQUNqQztJQUNILENBQUM7SUFFRCxPQUFPO1FBQ0wsOEZBQThGO1FBQzlGLDZDQUE2QztRQUM3QyxJQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7SUFDekIsQ0FBQztDQUNGO0FBRUQsSUFBSSxlQUFlLEdBQStCLElBQUksQ0FBQztBQUV2RCxTQUFTLCtCQUErQjtJQUN0QyxlQUFlLEtBQUssSUFBSSxxQkFBcUIsRUFBRSxDQUFDO0lBQ2hELE9BQU8sZUFBZSxDQUFDO0FBQ3pCLENBQUM7QUFFRDs7OztHQUlHO0FBQ0gsTUFBTSxVQUFVLHdCQUF3QixDQUNwQyxLQUFZLEVBQUUsSUFBNkU7SUFFN0YsT0FBTyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksK0JBQStCLEVBQUUsQ0FBQztBQUMxRCxDQUFDO0FBRUQ7Ozs7Ozs7OztHQVNHO0FBQ0gsTUFBTSxVQUFVLGlDQUFpQyxDQUM3QyxLQUFZLEVBQ1osSUFBNkU7SUFDL0UsTUFBTSxRQUFRLEdBQUcsK0JBQStCLEVBQUUsQ0FBQztJQUNuRCxJQUFJLENBQUMsUUFBUSxDQUFDLGNBQWMsRUFBRTtRQUM1QixPQUFPO0tBQ1I7SUFFRCxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsZUFBZSxDQUFDO0lBQzlCLFFBQVEsQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO0lBQ3ZCLGVBQWUsR0FBRyxJQUFJLHFCQUFxQixFQUFFLENBQUM7QUFDaEQsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG5pbXBvcnQge1JlYWN0aXZlTm9kZSwgc2V0QWN0aXZlQ29uc3VtZXJ9IGZyb20gJy4uL3NpZ25hbHMvc3JjL2dyYXBoJztcbmltcG9ydCB7YXNzZXJ0RGVmaW5lZCwgYXNzZXJ0RXF1YWx9IGZyb20gJy4uL3V0aWwvYXNzZXJ0JztcblxuaW1wb3J0IHttYXJrVmlld0RpcnR5fSBmcm9tICcuL2luc3RydWN0aW9ucy9tYXJrX3ZpZXdfZGlydHknO1xuaW1wb3J0IHtDb21wb25lbnRUZW1wbGF0ZSwgSG9zdEJpbmRpbmdzRnVuY3Rpb24sIFJlbmRlckZsYWdzfSBmcm9tICcuL2ludGVyZmFjZXMvZGVmaW5pdGlvbic7XG5pbXBvcnQge0xWaWV3LCBSRUFDVElWRV9IT1NUX0JJTkRJTkdfQ09OU1VNRVIsIFJFQUNUSVZFX1RFTVBMQVRFX0NPTlNVTUVSfSBmcm9tICcuL2ludGVyZmFjZXMvdmlldyc7XG5cbmNvbnN0IE5HX0RFVl9NT0RFID0gdHlwZW9mIG5nRGV2TW9kZSA9PT0gJ3VuZGVmaW5lZCcgfHwgbmdEZXZNb2RlO1xuXG5leHBvcnQgY2xhc3MgUmVhY3RpdmVMVmlld0NvbnN1bWVyIGV4dGVuZHMgUmVhY3RpdmVOb2RlIHtcbiAgcHJvdGVjdGVkIG92ZXJyaWRlIGNvbnN1bWVyQWxsb3dTaWduYWxXcml0ZXMgPSBmYWxzZTtcbiAgcHJpdmF0ZSBfbFZpZXc6IExWaWV3fG51bGwgPSBudWxsO1xuXG4gIHNldCBsVmlldyhsVmlldzogTFZpZXcpIHtcbiAgICBOR19ERVZfTU9ERSAmJiBhc3NlcnRFcXVhbCh0aGlzLl9sVmlldywgbnVsbCwgJ0NvbnN1bWVyIGFscmVhZHkgYXNzb2NpYXRlZCB3aXRoIGEgdmlldy4nKTtcbiAgICB0aGlzLl9sVmlldyA9IGxWaWV3O1xuICB9XG5cbiAgcHJvdGVjdGVkIG92ZXJyaWRlIG9uQ29uc3VtZXJEZXBlbmRlbmN5TWF5SGF2ZUNoYW5nZWQoKSB7XG4gICAgTkdfREVWX01PREUgJiZcbiAgICAgICAgYXNzZXJ0RGVmaW5lZChcbiAgICAgICAgICAgIHRoaXMuX2xWaWV3LFxuICAgICAgICAgICAgJ1VwZGF0aW5nIGEgc2lnbmFsIGR1cmluZyB0ZW1wbGF0ZSBvciBob3N0IGJpbmRpbmcgZXhlY3V0aW9uIGlzIG5vdCBhbGxvd2VkLicpO1xuICAgIG1hcmtWaWV3RGlydHkodGhpcy5fbFZpZXchKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvdmVycmlkZSBvblByb2R1Y2VyVXBkYXRlVmFsdWVWZXJzaW9uKCk6IHZvaWQge1xuICAgIC8vIFRoaXMgdHlwZSBkb2Vzbid0IGltcGxlbWVudCB0aGUgcHJvZHVjZXIgc2lkZSBvZiBhIGBSZWFjdGl2ZU5vZGVgLlxuICB9XG5cbiAgZ2V0IGhhc1JlYWRBU2lnbmFsKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmhhc1Byb2R1Y2VycztcbiAgfVxuXG4gIHJ1bkluQ29udGV4dChcbiAgICAgIGZuOiBIb3N0QmluZGluZ3NGdW5jdGlvbjx1bmtub3duPnxDb21wb25lbnRUZW1wbGF0ZTx1bmtub3duPiwgcmY6IFJlbmRlckZsYWdzLFxuICAgICAgY3R4OiB1bmtub3duKTogdm9pZCB7XG4gICAgY29uc3QgcHJldkNvbnN1bWVyID0gc2V0QWN0aXZlQ29uc3VtZXIodGhpcyk7XG4gICAgdGhpcy50cmFja2luZ1ZlcnNpb24rKztcbiAgICB0cnkge1xuICAgICAgZm4ocmYsIGN0eCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldEFjdGl2ZUNvbnN1bWVyKHByZXZDb25zdW1lcik7XG4gICAgfVxuICB9XG5cbiAgZGVzdHJveSgpOiB2b2lkIHtcbiAgICAvLyBJbmNyZW1lbnRpbmcgdGhlIHZlcnNpb24gbWVhbnMgdGhhdCBldmVyeSBwcm9kdWNlciB3aGljaCB0cmllcyB0byB1cGRhdGUgdGhpcyBjb25zdW1lciB3aWxsXG4gICAgLy8gY29uc2lkZXIgaXRzIHJlY29yZCBzdGFsZSwgYW5kIG5vdCBub3RpZnkuXG4gICAgdGhpcy50cmFja2luZ1ZlcnNpb24rKztcbiAgfVxufVxuXG5sZXQgY3VycmVudENvbnN1bWVyOiBSZWFjdGl2ZUxWaWV3Q29uc3VtZXJ8bnVsbCA9IG51bGw7XG5cbmZ1bmN0aW9uIGdldE9yQ3JlYXRlQ3VycmVudExWaWV3Q29uc3VtZXIoKSB7XG4gIGN1cnJlbnRDb25zdW1lciA/Pz0gbmV3IFJlYWN0aXZlTFZpZXdDb25zdW1lcigpO1xuICByZXR1cm4gY3VycmVudENvbnN1bWVyO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyB0ZW1wbGF0ZSBjb25zdW1lciBwb2ludGluZyBhdCB0aGUgc3BlY2lmaWVkIExWaWV3LlxuICogU29tZXRpbWVzLCBhIHByZXZpb3VzbHkgY3JlYXRlZCBjb25zdW1lciBtYXkgYmUgcmV1c2VkLCBpbiBvcmRlciB0byBzYXZlIG9uIGFsbG9jYXRpb25zLiBJbiB0aGF0XG4gKiBjYXNlLCB0aGUgTFZpZXcgd2lsbCBiZSB1cGRhdGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmVhY3RpdmVMVmlld0NvbnN1bWVyKFxuICAgIGxWaWV3OiBMVmlldywgc2xvdDogdHlwZW9mIFJFQUNUSVZFX1RFTVBMQVRFX0NPTlNVTUVSfHR5cGVvZiBSRUFDVElWRV9IT1NUX0JJTkRJTkdfQ09OU1VNRVIpOlxuICAgIFJlYWN0aXZlTFZpZXdDb25zdW1lciB7XG4gIHJldHVybiBsVmlld1tzbG90XSA/PyBnZXRPckNyZWF0ZUN1cnJlbnRMVmlld0NvbnN1bWVyKCk7XG59XG5cbi8qKlxuICogQXNzaWducyB0aGUgYGN1cnJlbnRUZW1wbGF0ZUNvbnRleHRgIHRvIGl0cyBMVmlldydzIGBSRUFDVElWRV9DT05TVU1FUmAgc2xvdCBpZiB0aGVyZSBhcmUgdHJhY2tlZFxuICogcHJvZHVjZXJzLlxuICpcbiAqIFRoZSBwcmVzZW5jZSBvZiBwcm9kdWNlcnMgbWVhbnMgdGhhdCBhIHNpZ25hbCB3YXMgcmVhZCB3aGlsZSB0aGUgY29uc3VtZXIgd2FzIHRoZSBhY3RpdmVcbiAqIGNvbnN1bWVyLlxuICpcbiAqIElmIG5vIHByb2R1Y2VycyBhcmUgcHJlc2VudCwgd2UgZG8gbm90IGFzc2lnbiB0aGUgY3VycmVudCB0ZW1wbGF0ZSBjb250ZXh0LiBUaGlzIGFsc28gbWVhbnMgd2VcbiAqIGNhbiBqdXN0IHJldXNlIHRoZSB0ZW1wbGF0ZSBjb250ZXh0IGZvciB0aGUgbmV4dCBMVmlldy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbW1pdExWaWV3Q29uc3VtZXJJZkhhc1Byb2R1Y2VycyhcbiAgICBsVmlldzogTFZpZXcsXG4gICAgc2xvdDogdHlwZW9mIFJFQUNUSVZFX1RFTVBMQVRFX0NPTlNVTUVSfHR5cGVvZiBSRUFDVElWRV9IT1NUX0JJTkRJTkdfQ09OU1VNRVIpOiB2b2lkIHtcbiAgY29uc3QgY29uc3VtZXIgPSBnZXRPckNyZWF0ZUN1cnJlbnRMVmlld0NvbnN1bWVyKCk7XG4gIGlmICghY29uc3VtZXIuaGFzUmVhZEFTaWduYWwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBsVmlld1tzbG90XSA9IGN1cnJlbnRDb25zdW1lcjtcbiAgY29uc3VtZXIubFZpZXcgPSBsVmlldztcbiAgY3VycmVudENvbnN1bWVyID0gbmV3IFJlYWN0aXZlTFZpZXdDb25zdW1lcigpO1xufVxuIl19
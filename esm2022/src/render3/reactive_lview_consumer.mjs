/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { ReactiveNode, setActiveConsumer } from '../signals';
import { assertDefined, assertEqual } from '../util/assert';
import { markViewDirty } from './instructions/mark_view_dirty';
const NG_DEV_MODE = typeof ngDevMode === 'undefined' || ngDevMode;
export class ReactiveLViewConsumer extends ReactiveNode {
    constructor() {
        super(...arguments);
        this.consumerAllowSignalWrites = false;
        this._lView = null;
    }
    set lView(lView) {
        NG_DEV_MODE && assertEqual(this._lView, null, 'Consumer already associated with a view.');
        this._lView = lView;
    }
    onConsumerDependencyMayHaveChanged() {
        NG_DEV_MODE &&
            assertDefined(this._lView, 'Updating a signal during template or host binding execution is not allowed.');
        markViewDirty(this._lView);
    }
    onProducerUpdateValueVersion() {
        // This type doesn't implement the producer side of a `ReactiveNode`.
    }
    get hasReadASignal() {
        return this.hasProducers;
    }
    runInContext(fn, rf, ctx) {
        const prevConsumer = setActiveConsumer(this);
        this.trackingVersion++;
        try {
            fn(rf, ctx);
        }
        finally {
            setActiveConsumer(prevConsumer);
        }
    }
    destroy() {
        // Incrementing the version means that every producer which tries to update this consumer will
        // consider its record stale, and not notify.
        this.trackingVersion++;
    }
}
let currentConsumer = null;
function getOrCreateCurrentLViewConsumer() {
    currentConsumer ??= new ReactiveLViewConsumer();
    return currentConsumer;
}
/**
 * Create a new template consumer pointing at the specified LView.
 * Sometimes, a previously created consumer may be reused, in order to save on allocations. In that
 * case, the LView will be updated.
 */
export function getReactiveLViewConsumer(lView, slot) {
    return lView[slot] ?? getOrCreateCurrentLViewConsumer();
}
/**
 * Assigns the `currentTemplateContext` to its LView's `REACTIVE_CONSUMER` slot if there are tracked
 * producers.
 *
 * The presence of producers means that a signal was read while the consumer was the active
 * consumer.
 *
 * If no producers are present, we do not assign the current template context. This also means we
 * can just reuse the template context for the next LView.
 */
export function commitLViewConsumerIfHasProducers(lView, slot) {
    const consumer = getOrCreateCurrentLViewConsumer();
    if (!consumer.hasReadASignal) {
        return;
    }
    lView[slot] = currentConsumer;
    consumer.lView = lView;
    currentConsumer = new ReactiveLViewConsumer();
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVhY3RpdmVfbHZpZXdfY29uc3VtZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9jb3JlL3NyYy9yZW5kZXIzL3JlYWN0aXZlX2x2aWV3X2NvbnN1bWVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7R0FNRztBQUVILE9BQU8sRUFBQyxZQUFZLEVBQUUsaUJBQWlCLEVBQUMsTUFBTSxZQUFZLENBQUM7QUFDM0QsT0FBTyxFQUFDLGFBQWEsRUFBRSxXQUFXLEVBQUMsTUFBTSxnQkFBZ0IsQ0FBQztBQUUxRCxPQUFPLEVBQUMsYUFBYSxFQUFDLE1BQU0sZ0NBQWdDLENBQUM7QUFJN0QsTUFBTSxXQUFXLEdBQUcsT0FBTyxTQUFTLEtBQUssV0FBVyxJQUFJLFNBQVMsQ0FBQztBQUVsRSxNQUFNLE9BQU8scUJBQXNCLFNBQVEsWUFBWTtJQUF2RDs7UUFDcUIsOEJBQXlCLEdBQUcsS0FBSyxDQUFDO1FBQzdDLFdBQU0sR0FBZSxJQUFJLENBQUM7SUF3Q3BDLENBQUM7SUF0Q0MsSUFBSSxLQUFLLENBQUMsS0FBWTtRQUNwQixXQUFXLElBQUksV0FBVyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsSUFBSSxFQUFFLDBDQUEwQyxDQUFDLENBQUM7UUFDMUYsSUFBSSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUM7SUFDdEIsQ0FBQztJQUVrQixrQ0FBa0M7UUFDbkQsV0FBVztZQUNQLGFBQWEsQ0FDVCxJQUFJLENBQUMsTUFBTSxFQUNYLDZFQUE2RSxDQUFDLENBQUM7UUFDdkYsYUFBYSxDQUFDLElBQUksQ0FBQyxNQUFPLENBQUMsQ0FBQztJQUM5QixDQUFDO0lBRWtCLDRCQUE0QjtRQUM3QyxxRUFBcUU7SUFDdkUsQ0FBQztJQUVELElBQUksY0FBYztRQUNoQixPQUFPLElBQUksQ0FBQyxZQUFZLENBQUM7SUFDM0IsQ0FBQztJQUVELFlBQVksQ0FDUixFQUE0RCxFQUFFLEVBQWUsRUFDN0UsR0FBWTtRQUNkLE1BQU0sWUFBWSxHQUFHLGlCQUFpQixDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzdDLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztRQUN2QixJQUFJO1lBQ0YsRUFBRSxDQUFDLEVBQUUsRUFBRSxHQUFHLENBQUMsQ0FBQztTQUNiO2dCQUFTO1lBQ1IsaUJBQWlCLENBQUMsWUFBWSxDQUFDLENBQUM7U0FDakM7SUFDSCxDQUFDO0lBRUQsT0FBTztRQUNMLDhGQUE4RjtRQUM5Riw2Q0FBNkM7UUFDN0MsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO0lBQ3pCLENBQUM7Q0FDRjtBQUVELElBQUksZUFBZSxHQUErQixJQUFJLENBQUM7QUFFdkQsU0FBUywrQkFBK0I7SUFDdEMsZUFBZSxLQUFLLElBQUkscUJBQXFCLEVBQUUsQ0FBQztJQUNoRCxPQUFPLGVBQWUsQ0FBQztBQUN6QixDQUFDO0FBRUQ7Ozs7R0FJRztBQUNILE1BQU0sVUFBVSx3QkFBd0IsQ0FDcEMsS0FBWSxFQUFFLElBQTZFO0lBRTdGLE9BQU8sS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLCtCQUErQixFQUFFLENBQUM7QUFDMUQsQ0FBQztBQUVEOzs7Ozs7Ozs7R0FTRztBQUNILE1BQU0sVUFBVSxpQ0FBaUMsQ0FDN0MsS0FBWSxFQUNaLElBQTZFO0lBQy9FLE1BQU0sUUFBUSxHQUFHLCtCQUErQixFQUFFLENBQUM7SUFDbkQsSUFBSSxDQUFDLFFBQVEsQ0FBQyxjQUFjLEVBQUU7UUFDNUIsT0FBTztLQUNSO0lBRUQsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLGVBQWUsQ0FBQztJQUM5QixRQUFRLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztJQUN2QixlQUFlLEdBQUcsSUFBSSxxQkFBcUIsRUFBRSxDQUFDO0FBQ2hELENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuaW1wb3J0IHtSZWFjdGl2ZU5vZGUsIHNldEFjdGl2ZUNvbnN1bWVyfSBmcm9tICcuLi9zaWduYWxzJztcbmltcG9ydCB7YXNzZXJ0RGVmaW5lZCwgYXNzZXJ0RXF1YWx9IGZyb20gJy4uL3V0aWwvYXNzZXJ0JztcblxuaW1wb3J0IHttYXJrVmlld0RpcnR5fSBmcm9tICcuL2luc3RydWN0aW9ucy9tYXJrX3ZpZXdfZGlydHknO1xuaW1wb3J0IHtDb21wb25lbnRUZW1wbGF0ZSwgSG9zdEJpbmRpbmdzRnVuY3Rpb24sIFJlbmRlckZsYWdzfSBmcm9tICcuL2ludGVyZmFjZXMvZGVmaW5pdGlvbic7XG5pbXBvcnQge0xWaWV3LCBSRUFDVElWRV9IT1NUX0JJTkRJTkdfQ09OU1VNRVIsIFJFQUNUSVZFX1RFTVBMQVRFX0NPTlNVTUVSfSBmcm9tICcuL2ludGVyZmFjZXMvdmlldyc7XG5cbmNvbnN0IE5HX0RFVl9NT0RFID0gdHlwZW9mIG5nRGV2TW9kZSA9PT0gJ3VuZGVmaW5lZCcgfHwgbmdEZXZNb2RlO1xuXG5leHBvcnQgY2xhc3MgUmVhY3RpdmVMVmlld0NvbnN1bWVyIGV4dGVuZHMgUmVhY3RpdmVOb2RlIHtcbiAgcHJvdGVjdGVkIG92ZXJyaWRlIGNvbnN1bWVyQWxsb3dTaWduYWxXcml0ZXMgPSBmYWxzZTtcbiAgcHJpdmF0ZSBfbFZpZXc6IExWaWV3fG51bGwgPSBudWxsO1xuXG4gIHNldCBsVmlldyhsVmlldzogTFZpZXcpIHtcbiAgICBOR19ERVZfTU9ERSAmJiBhc3NlcnRFcXVhbCh0aGlzLl9sVmlldywgbnVsbCwgJ0NvbnN1bWVyIGFscmVhZHkgYXNzb2NpYXRlZCB3aXRoIGEgdmlldy4nKTtcbiAgICB0aGlzLl9sVmlldyA9IGxWaWV3O1xuICB9XG5cbiAgcHJvdGVjdGVkIG92ZXJyaWRlIG9uQ29uc3VtZXJEZXBlbmRlbmN5TWF5SGF2ZUNoYW5nZWQoKSB7XG4gICAgTkdfREVWX01PREUgJiZcbiAgICAgICAgYXNzZXJ0RGVmaW5lZChcbiAgICAgICAgICAgIHRoaXMuX2xWaWV3LFxuICAgICAgICAgICAgJ1VwZGF0aW5nIGEgc2lnbmFsIGR1cmluZyB0ZW1wbGF0ZSBvciBob3N0IGJpbmRpbmcgZXhlY3V0aW9uIGlzIG5vdCBhbGxvd2VkLicpO1xuICAgIG1hcmtWaWV3RGlydHkodGhpcy5fbFZpZXchKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvdmVycmlkZSBvblByb2R1Y2VyVXBkYXRlVmFsdWVWZXJzaW9uKCk6IHZvaWQge1xuICAgIC8vIFRoaXMgdHlwZSBkb2Vzbid0IGltcGxlbWVudCB0aGUgcHJvZHVjZXIgc2lkZSBvZiBhIGBSZWFjdGl2ZU5vZGVgLlxuICB9XG5cbiAgZ2V0IGhhc1JlYWRBU2lnbmFsKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmhhc1Byb2R1Y2VycztcbiAgfVxuXG4gIHJ1bkluQ29udGV4dChcbiAgICAgIGZuOiBIb3N0QmluZGluZ3NGdW5jdGlvbjx1bmtub3duPnxDb21wb25lbnRUZW1wbGF0ZTx1bmtub3duPiwgcmY6IFJlbmRlckZsYWdzLFxuICAgICAgY3R4OiB1bmtub3duKTogdm9pZCB7XG4gICAgY29uc3QgcHJldkNvbnN1bWVyID0gc2V0QWN0aXZlQ29uc3VtZXIodGhpcyk7XG4gICAgdGhpcy50cmFja2luZ1ZlcnNpb24rKztcbiAgICB0cnkge1xuICAgICAgZm4ocmYsIGN0eCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldEFjdGl2ZUNvbnN1bWVyKHByZXZDb25zdW1lcik7XG4gICAgfVxuICB9XG5cbiAgZGVzdHJveSgpOiB2b2lkIHtcbiAgICAvLyBJbmNyZW1lbnRpbmcgdGhlIHZlcnNpb24gbWVhbnMgdGhhdCBldmVyeSBwcm9kdWNlciB3aGljaCB0cmllcyB0byB1cGRhdGUgdGhpcyBjb25zdW1lciB3aWxsXG4gICAgLy8gY29uc2lkZXIgaXRzIHJlY29yZCBzdGFsZSwgYW5kIG5vdCBub3RpZnkuXG4gICAgdGhpcy50cmFja2luZ1ZlcnNpb24rKztcbiAgfVxufVxuXG5sZXQgY3VycmVudENvbnN1bWVyOiBSZWFjdGl2ZUxWaWV3Q29uc3VtZXJ8bnVsbCA9IG51bGw7XG5cbmZ1bmN0aW9uIGdldE9yQ3JlYXRlQ3VycmVudExWaWV3Q29uc3VtZXIoKSB7XG4gIGN1cnJlbnRDb25zdW1lciA/Pz0gbmV3IFJlYWN0aXZlTFZpZXdDb25zdW1lcigpO1xuICByZXR1cm4gY3VycmVudENvbnN1bWVyO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyB0ZW1wbGF0ZSBjb25zdW1lciBwb2ludGluZyBhdCB0aGUgc3BlY2lmaWVkIExWaWV3LlxuICogU29tZXRpbWVzLCBhIHByZXZpb3VzbHkgY3JlYXRlZCBjb25zdW1lciBtYXkgYmUgcmV1c2VkLCBpbiBvcmRlciB0byBzYXZlIG9uIGFsbG9jYXRpb25zLiBJbiB0aGF0XG4gKiBjYXNlLCB0aGUgTFZpZXcgd2lsbCBiZSB1cGRhdGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmVhY3RpdmVMVmlld0NvbnN1bWVyKFxuICAgIGxWaWV3OiBMVmlldywgc2xvdDogdHlwZW9mIFJFQUNUSVZFX1RFTVBMQVRFX0NPTlNVTUVSfHR5cGVvZiBSRUFDVElWRV9IT1NUX0JJTkRJTkdfQ09OU1VNRVIpOlxuICAgIFJlYWN0aXZlTFZpZXdDb25zdW1lciB7XG4gIHJldHVybiBsVmlld1tzbG90XSA/PyBnZXRPckNyZWF0ZUN1cnJlbnRMVmlld0NvbnN1bWVyKCk7XG59XG5cbi8qKlxuICogQXNzaWducyB0aGUgYGN1cnJlbnRUZW1wbGF0ZUNvbnRleHRgIHRvIGl0cyBMVmlldydzIGBSRUFDVElWRV9DT05TVU1FUmAgc2xvdCBpZiB0aGVyZSBhcmUgdHJhY2tlZFxuICogcHJvZHVjZXJzLlxuICpcbiAqIFRoZSBwcmVzZW5jZSBvZiBwcm9kdWNlcnMgbWVhbnMgdGhhdCBhIHNpZ25hbCB3YXMgcmVhZCB3aGlsZSB0aGUgY29uc3VtZXIgd2FzIHRoZSBhY3RpdmVcbiAqIGNvbnN1bWVyLlxuICpcbiAqIElmIG5vIHByb2R1Y2VycyBhcmUgcHJlc2VudCwgd2UgZG8gbm90IGFzc2lnbiB0aGUgY3VycmVudCB0ZW1wbGF0ZSBjb250ZXh0LiBUaGlzIGFsc28gbWVhbnMgd2VcbiAqIGNhbiBqdXN0IHJldXNlIHRoZSB0ZW1wbGF0ZSBjb250ZXh0IGZvciB0aGUgbmV4dCBMVmlldy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbW1pdExWaWV3Q29uc3VtZXJJZkhhc1Byb2R1Y2VycyhcbiAgICBsVmlldzogTFZpZXcsXG4gICAgc2xvdDogdHlwZW9mIFJFQUNUSVZFX1RFTVBMQVRFX0NPTlNVTUVSfHR5cGVvZiBSRUFDVElWRV9IT1NUX0JJTkRJTkdfQ09OU1VNRVIpOiB2b2lkIHtcbiAgY29uc3QgY29uc3VtZXIgPSBnZXRPckNyZWF0ZUN1cnJlbnRMVmlld0NvbnN1bWVyKCk7XG4gIGlmICghY29uc3VtZXIuaGFzUmVhZEFTaWduYWwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBsVmlld1tzbG90XSA9IGN1cnJlbnRDb25zdW1lcjtcbiAgY29uc3VtZXIubFZpZXcgPSBsVmlldztcbiAgY3VycmVudENvbnN1bWVyID0gbmV3IFJlYWN0aXZlTFZpZXdDb25zdW1lcigpO1xufVxuIl19
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { REACTIVE_NODE } from '../signals';
import { assertDefined, assertEqual } from '../util/assert';
import { markViewDirty } from './instructions/mark_view_dirty';
let currentConsumer = null;
export function setLViewForConsumer(node, lView) {
    (typeof ngDevMode === 'undefined' || ngDevMode) &&
        assertEqual(node.lView, null, 'Consumer already associated with a view.');
    node.lView = lView;
}
/**
 * Create a new template consumer pointing at the specified LView.
 * Sometimes, a previously created consumer may be reused, in order to save on allocations. In that
 * case, the LView will be updated.
 */
export function getReactiveLViewConsumer(lView, slot) {
    return lView[slot] ?? getOrCreateCurrentLViewConsumer();
}
/**
 * Assigns the `currentTemplateContext` to its LView's `REACTIVE_CONSUMER` slot if there are tracked
 * producers.
 *
 * The presence of producers means that a signal was read while the consumer was the active
 * consumer.
 *
 * If no producers are present, we do not assign the current template context. This also means we
 * can just reuse the template context for the next LView.
 */
export function commitLViewConsumerIfHasProducers(lView, slot) {
    const consumer = getOrCreateCurrentLViewConsumer();
    if (!consumer.producerNode?.length) {
        return;
    }
    lView[slot] = currentConsumer;
    consumer.lView = lView;
    currentConsumer = createLViewConsumer();
}
const REACTIVE_LVIEW_CONSUMER_NODE = {
    ...REACTIVE_NODE,
    consumerIsAlwaysLive: true,
    consumerMarkedDirty: (node) => {
        (typeof ngDevMode === 'undefined' || ngDevMode) &&
            assertDefined(node.lView, 'Updating a signal during template or host binding execution is not allowed.');
        markViewDirty(node.lView);
    },
    lView: null,
};
function createLViewConsumer() {
    return Object.create(REACTIVE_LVIEW_CONSUMER_NODE);
}
function getOrCreateCurrentLViewConsumer() {
    currentConsumer ??= createLViewConsumer();
    return currentConsumer;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVhY3RpdmVfbHZpZXdfY29uc3VtZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9jb3JlL3NyYy9yZW5kZXIzL3JlYWN0aXZlX2x2aWV3X2NvbnN1bWVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7R0FNRztBQUVILE9BQU8sRUFBQyxhQUFhLEVBQWUsTUFBTSxZQUFZLENBQUM7QUFDdkQsT0FBTyxFQUFDLGFBQWEsRUFBRSxXQUFXLEVBQUMsTUFBTSxnQkFBZ0IsQ0FBQztBQUUxRCxPQUFPLEVBQUMsYUFBYSxFQUFDLE1BQU0sZ0NBQWdDLENBQUM7QUFHN0QsSUFBSSxlQUFlLEdBQStCLElBQUksQ0FBQztBQUt2RCxNQUFNLFVBQVUsbUJBQW1CLENBQUMsSUFBMkIsRUFBRSxLQUFZO0lBQzNFLENBQUMsT0FBTyxTQUFTLEtBQUssV0FBVyxJQUFJLFNBQVMsQ0FBQztRQUMzQyxXQUFXLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLEVBQUUsMENBQTBDLENBQUMsQ0FBQztJQUM5RSxJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztBQUNyQixDQUFDO0FBRUQ7Ozs7R0FJRztBQUNILE1BQU0sVUFBVSx3QkFBd0IsQ0FDcEMsS0FBWSxFQUFFLElBQTZFO0lBRTdGLE9BQU8sS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLCtCQUErQixFQUFFLENBQUM7QUFDMUQsQ0FBQztBQUVEOzs7Ozs7Ozs7R0FTRztBQUNILE1BQU0sVUFBVSxpQ0FBaUMsQ0FDN0MsS0FBWSxFQUNaLElBQTZFO0lBQy9FLE1BQU0sUUFBUSxHQUFHLCtCQUErQixFQUFFLENBQUM7SUFDbkQsSUFBSSxDQUFDLFFBQVEsQ0FBQyxZQUFZLEVBQUUsTUFBTSxFQUFFO1FBQ2xDLE9BQU87S0FDUjtJQUVELEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxlQUFlLENBQUM7SUFDOUIsUUFBUSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7SUFDdkIsZUFBZSxHQUFHLG1CQUFtQixFQUFFLENBQUM7QUFDMUMsQ0FBQztBQUVELE1BQU0sNEJBQTRCLEdBQUc7SUFDbkMsR0FBRyxhQUFhO0lBQ2hCLG9CQUFvQixFQUFFLElBQUk7SUFDMUIsbUJBQW1CLEVBQUUsQ0FBQyxJQUEyQixFQUFFLEVBQUU7UUFDbkQsQ0FBQyxPQUFPLFNBQVMsS0FBSyxXQUFXLElBQUksU0FBUyxDQUFDO1lBQzNDLGFBQWEsQ0FDVCxJQUFJLENBQUMsS0FBSyxFQUNWLDZFQUE2RSxDQUFDLENBQUM7UUFDdkYsYUFBYSxDQUFDLElBQUksQ0FBQyxLQUFNLENBQUMsQ0FBQztJQUM3QixDQUFDO0lBQ0QsS0FBSyxFQUFFLElBQUk7Q0FDWixDQUFDO0FBRUYsU0FBUyxtQkFBbUI7SUFDMUIsT0FBTyxNQUFNLENBQUMsTUFBTSxDQUFDLDRCQUE0QixDQUFDLENBQUM7QUFDckQsQ0FBQztBQUVELFNBQVMsK0JBQStCO0lBQ3RDLGVBQWUsS0FBSyxtQkFBbUIsRUFBRSxDQUFDO0lBQzFDLE9BQU8sZUFBZSxDQUFDO0FBQ3pCLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuaW1wb3J0IHtSRUFDVElWRV9OT0RFLCBSZWFjdGl2ZU5vZGV9IGZyb20gJy4uL3NpZ25hbHMnO1xuaW1wb3J0IHthc3NlcnREZWZpbmVkLCBhc3NlcnRFcXVhbH0gZnJvbSAnLi4vdXRpbC9hc3NlcnQnO1xuXG5pbXBvcnQge21hcmtWaWV3RGlydHl9IGZyb20gJy4vaW5zdHJ1Y3Rpb25zL21hcmtfdmlld19kaXJ0eSc7XG5pbXBvcnQge0xWaWV3LCBSRUFDVElWRV9IT1NUX0JJTkRJTkdfQ09OU1VNRVIsIFJFQUNUSVZFX1RFTVBMQVRFX0NPTlNVTUVSfSBmcm9tICcuL2ludGVyZmFjZXMvdmlldyc7XG5cbmxldCBjdXJyZW50Q29uc3VtZXI6IFJlYWN0aXZlTFZpZXdDb25zdW1lcnxudWxsID0gbnVsbDtcbmV4cG9ydCBpbnRlcmZhY2UgUmVhY3RpdmVMVmlld0NvbnN1bWVyIGV4dGVuZHMgUmVhY3RpdmVOb2RlIHtcbiAgbFZpZXc6IExWaWV3fG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRMVmlld0ZvckNvbnN1bWVyKG5vZGU6IFJlYWN0aXZlTFZpZXdDb25zdW1lciwgbFZpZXc6IExWaWV3KTogdm9pZCB7XG4gICh0eXBlb2YgbmdEZXZNb2RlID09PSAndW5kZWZpbmVkJyB8fCBuZ0Rldk1vZGUpICYmXG4gICAgICBhc3NlcnRFcXVhbChub2RlLmxWaWV3LCBudWxsLCAnQ29uc3VtZXIgYWxyZWFkeSBhc3NvY2lhdGVkIHdpdGggYSB2aWV3LicpO1xuICBub2RlLmxWaWV3ID0gbFZpZXc7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHRlbXBsYXRlIGNvbnN1bWVyIHBvaW50aW5nIGF0IHRoZSBzcGVjaWZpZWQgTFZpZXcuXG4gKiBTb21ldGltZXMsIGEgcHJldmlvdXNseSBjcmVhdGVkIGNvbnN1bWVyIG1heSBiZSByZXVzZWQsIGluIG9yZGVyIHRvIHNhdmUgb24gYWxsb2NhdGlvbnMuIEluIHRoYXRcbiAqIGNhc2UsIHRoZSBMVmlldyB3aWxsIGJlIHVwZGF0ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRSZWFjdGl2ZUxWaWV3Q29uc3VtZXIoXG4gICAgbFZpZXc6IExWaWV3LCBzbG90OiB0eXBlb2YgUkVBQ1RJVkVfVEVNUExBVEVfQ09OU1VNRVJ8dHlwZW9mIFJFQUNUSVZFX0hPU1RfQklORElOR19DT05TVU1FUik6XG4gICAgUmVhY3RpdmVMVmlld0NvbnN1bWVyIHtcbiAgcmV0dXJuIGxWaWV3W3Nsb3RdID8/IGdldE9yQ3JlYXRlQ3VycmVudExWaWV3Q29uc3VtZXIoKTtcbn1cblxuLyoqXG4gKiBBc3NpZ25zIHRoZSBgY3VycmVudFRlbXBsYXRlQ29udGV4dGAgdG8gaXRzIExWaWV3J3MgYFJFQUNUSVZFX0NPTlNVTUVSYCBzbG90IGlmIHRoZXJlIGFyZSB0cmFja2VkXG4gKiBwcm9kdWNlcnMuXG4gKlxuICogVGhlIHByZXNlbmNlIG9mIHByb2R1Y2VycyBtZWFucyB0aGF0IGEgc2lnbmFsIHdhcyByZWFkIHdoaWxlIHRoZSBjb25zdW1lciB3YXMgdGhlIGFjdGl2ZVxuICogY29uc3VtZXIuXG4gKlxuICogSWYgbm8gcHJvZHVjZXJzIGFyZSBwcmVzZW50LCB3ZSBkbyBub3QgYXNzaWduIHRoZSBjdXJyZW50IHRlbXBsYXRlIGNvbnRleHQuIFRoaXMgYWxzbyBtZWFucyB3ZVxuICogY2FuIGp1c3QgcmV1c2UgdGhlIHRlbXBsYXRlIGNvbnRleHQgZm9yIHRoZSBuZXh0IExWaWV3LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tbWl0TFZpZXdDb25zdW1lcklmSGFzUHJvZHVjZXJzKFxuICAgIGxWaWV3OiBMVmlldyxcbiAgICBzbG90OiB0eXBlb2YgUkVBQ1RJVkVfVEVNUExBVEVfQ09OU1VNRVJ8dHlwZW9mIFJFQUNUSVZFX0hPU1RfQklORElOR19DT05TVU1FUik6IHZvaWQge1xuICBjb25zdCBjb25zdW1lciA9IGdldE9yQ3JlYXRlQ3VycmVudExWaWV3Q29uc3VtZXIoKTtcbiAgaWYgKCFjb25zdW1lci5wcm9kdWNlck5vZGU/Lmxlbmd0aCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxWaWV3W3Nsb3RdID0gY3VycmVudENvbnN1bWVyO1xuICBjb25zdW1lci5sVmlldyA9IGxWaWV3O1xuICBjdXJyZW50Q29uc3VtZXIgPSBjcmVhdGVMVmlld0NvbnN1bWVyKCk7XG59XG5cbmNvbnN0IFJFQUNUSVZFX0xWSUVXX0NPTlNVTUVSX05PREUgPSB7XG4gIC4uLlJFQUNUSVZFX05PREUsXG4gIGNvbnN1bWVySXNBbHdheXNMaXZlOiB0cnVlLFxuICBjb25zdW1lck1hcmtlZERpcnR5OiAobm9kZTogUmVhY3RpdmVMVmlld0NvbnN1bWVyKSA9PiB7XG4gICAgKHR5cGVvZiBuZ0Rldk1vZGUgPT09ICd1bmRlZmluZWQnIHx8IG5nRGV2TW9kZSkgJiZcbiAgICAgICAgYXNzZXJ0RGVmaW5lZChcbiAgICAgICAgICAgIG5vZGUubFZpZXcsXG4gICAgICAgICAgICAnVXBkYXRpbmcgYSBzaWduYWwgZHVyaW5nIHRlbXBsYXRlIG9yIGhvc3QgYmluZGluZyBleGVjdXRpb24gaXMgbm90IGFsbG93ZWQuJyk7XG4gICAgbWFya1ZpZXdEaXJ0eShub2RlLmxWaWV3ISk7XG4gIH0sXG4gIGxWaWV3OiBudWxsLFxufTtcblxuZnVuY3Rpb24gY3JlYXRlTFZpZXdDb25zdW1lcigpOiBSZWFjdGl2ZUxWaWV3Q29uc3VtZXIge1xuICByZXR1cm4gT2JqZWN0LmNyZWF0ZShSRUFDVElWRV9MVklFV19DT05TVU1FUl9OT0RFKTtcbn1cblxuZnVuY3Rpb24gZ2V0T3JDcmVhdGVDdXJyZW50TFZpZXdDb25zdW1lcigpIHtcbiAgY3VycmVudENvbnN1bWVyID8/PSBjcmVhdGVMVmlld0NvbnN1bWVyKCk7XG4gIHJldHVybiBjdXJyZW50Q29uc3VtZXI7XG59XG4iXX0=
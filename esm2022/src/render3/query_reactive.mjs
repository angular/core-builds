/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { consumerMarkDirty, producerAccessed, producerUpdateValueVersion, REACTIVE_NODE, SIGNAL } from '@angular/core/primitives/signals';
import { RuntimeError } from '../errors';
import { unwrapElementRef } from '../linker/element_ref';
import { EMPTY_ARRAY } from '../util/empty';
import { TVIEW } from './interfaces/view';
import { collectQueryResults, getTQuery, loadQueryInternal, materializeViewResults } from './query';
import { getLView } from './state';
/** Function used as the `toString` implementation of query signals. */
const querySignalToString = () => '[QUERY_SIGNAL]';
function createQuerySignalFn(firstOnly, required) {
    const node = Object.create(QUERY_SIGNAL_NODE);
    function signalFn() {
        // Check if the value needs updating before returning it.
        producerUpdateValueVersion(node);
        // Mark this producer as accessed.
        producerAccessed(node);
        if (firstOnly) {
            const firstValue = node._queryList?.first;
            if (firstValue === undefined && required) {
                // TODO: add error code
                // TODO: add proper message
                throw new RuntimeError(0, 'no query results yet!');
            }
            return firstValue;
        }
        else {
            // TODO(perf): make sure that I'm not creating new arrays when returning results. The other
            // consideration here is the referential stability of results.
            return node._queryList?.toArray() ?? EMPTY_ARRAY;
        }
    }
    signalFn[SIGNAL] = node;
    signalFn.toString = querySignalToString;
    return signalFn;
}
export function createSingleResultOptionalQuerySignalFn() {
    return createQuerySignalFn(/* firstOnly */ true, /* required */ false);
}
export function createSingleResultRequiredQuerySignalFn() {
    return createQuerySignalFn(/* firstOnly */ true, /* required */ true);
}
export function createMultiResultQuerySignalFn() {
    return createQuerySignalFn(/* firstOnly */ false, /* required */ false);
}
// Note: Using an IIFE here to ensure that the spread assignment is not considered
// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.
// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.
export const QUERY_SIGNAL_NODE = /* @__PURE__ */ (() => {
    return {
        ...REACTIVE_NODE,
        // Base reactive node.overrides
        producerMustRecompute: (node) => {
            return !!node._queryList?.dirty;
        },
        producerRecomputeValue: (node) => {
            // The current value is stale. Check whether we need to produce a new one.
            // TODO: assert: I've got both the lView and queryIndex stored
            // TODO(perf): I'm assuming that the signal value changes when the list of matches changes.
            // But this is not correct for the single-element queries since we should also compare (===)
            // the value of the first element.
            // TODO: error handling - should we guard against exceptions thrown from refreshSignalQuery -
            // normally it should never
            if (refreshSignalQuery(node._lView, node._queryIndex)) {
                node.version++;
            }
        }
    };
})();
export function bindQueryToSignal(target, queryIndex) {
    const node = target[SIGNAL];
    node._lView = getLView();
    node._queryIndex = queryIndex;
    node._queryList = loadQueryInternal(node._lView, queryIndex);
    node._queryList.onDirty(() => {
        // Mark this producer as dirty and notify live consumer about the potential change. Note
        // that the onDirty callback will fire only on the initial dirty marking (that is,
        // subsequent dirty notifications are not fired- until the QueryList becomes clean again).
        consumerMarkDirty(node);
    });
}
// TODO(refactor): some code duplication with queryRefresh
export function refreshSignalQuery(lView, queryIndex) {
    const queryList = loadQueryInternal(lView, queryIndex);
    const tView = lView[TVIEW];
    const tQuery = getTQuery(tView, queryIndex);
    // TODO(test): operation of refreshing a signal query could be invoked during the first
    // creation pass, while results are still being collected; we should NOT mark such query as
    // "clean" as we might not have any view add / remove operations that would make it dirty again.
    // Leaning towards exiting early for calls to refreshSignalQuery before the first creation pass
    // finished
    if (queryList.dirty && tQuery.matches !== null) {
        const result = tQuery.crossesNgTemplate ?
            collectQueryResults(tView, lView, queryIndex, []) :
            materializeViewResults(tView, lView, tQuery, queryIndex);
        queryList.reset(result, unwrapElementRef);
        // TODO(test): don't mark signal as dirty when a query was marked as dirty but there
        // was no actual change
        // TODO: change the reset logic so it returns the value
        return true;
    }
    return false;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicXVlcnlfcmVhY3RpdmUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9jb3JlL3NyYy9yZW5kZXIzL3F1ZXJ5X3JlYWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7R0FNRztBQUVILE9BQU8sRUFBQyxpQkFBaUIsRUFBRSxnQkFBZ0IsRUFBRSwwQkFBMEIsRUFBRSxhQUFhLEVBQWdCLE1BQU0sRUFBQyxNQUFNLGtDQUFrQyxDQUFDO0FBRXRKLE9BQU8sRUFBQyxZQUFZLEVBQUMsTUFBTSxXQUFXLENBQUM7QUFDdkMsT0FBTyxFQUFDLGdCQUFnQixFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFFdkQsT0FBTyxFQUFDLFdBQVcsRUFBQyxNQUFNLGVBQWUsQ0FBQztBQUUxQyxPQUFPLEVBQVEsS0FBSyxFQUFDLE1BQU0sbUJBQW1CLENBQUM7QUFDL0MsT0FBTyxFQUFDLG1CQUFtQixFQUFFLFNBQVMsRUFBRSxpQkFBaUIsRUFBRSxzQkFBc0IsRUFBQyxNQUFNLFNBQVMsQ0FBQztBQUVsRyxPQUFPLEVBQUMsUUFBUSxFQUFDLE1BQU0sU0FBUyxDQUFDO0FBRWpDLHVFQUF1RTtBQUN2RSxNQUFNLG1CQUFtQixHQUFHLEdBQUcsRUFBRSxDQUFDLGdCQUFnQixDQUFDO0FBS25ELFNBQVMsbUJBQW1CLENBQUksU0FBa0IsRUFBRSxRQUFpQjtJQUNuRSxNQUFNLElBQUksR0FBdUIsTUFBTSxDQUFDLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO0lBQ2xFLFNBQVMsUUFBUTtRQUNmLHlEQUF5RDtRQUN6RCwwQkFBMEIsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUVqQyxrQ0FBa0M7UUFDbEMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFdkIsSUFBSSxTQUFTLEVBQUUsQ0FBQztZQUNkLE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxVQUFVLEVBQUUsS0FBSyxDQUFDO1lBQzFDLElBQUksVUFBVSxLQUFLLFNBQVMsSUFBSSxRQUFRLEVBQUUsQ0FBQztnQkFDekMsdUJBQXVCO2dCQUN2QiwyQkFBMkI7Z0JBQzNCLE1BQU0sSUFBSSxZQUFZLENBQUMsQ0FBQyxFQUFFLHVCQUF1QixDQUFDLENBQUM7WUFDckQsQ0FBQztZQUNELE9BQU8sVUFBVSxDQUFDO1FBQ3BCLENBQUM7YUFBTSxDQUFDO1lBQ04sMkZBQTJGO1lBQzNGLDhEQUE4RDtZQUM5RCxPQUFPLElBQUksQ0FBQyxVQUFVLEVBQUUsT0FBTyxFQUFFLElBQUksV0FBVyxDQUFDO1FBQ25ELENBQUM7SUFDSCxDQUFDO0lBQ0EsUUFBZ0IsQ0FBQyxNQUFNLENBQUMsR0FBRyxJQUFJLENBQUM7SUFDakMsUUFBUSxDQUFDLFFBQVEsR0FBRyxtQkFBbUIsQ0FBQztJQUV4QyxPQUFPLFFBQVEsQ0FBQztBQUNsQixDQUFDO0FBRUQsTUFBTSxVQUFVLHVDQUF1QztJQUNyRCxPQUFPLG1CQUFtQixDQUFDLGVBQWUsQ0FBQyxJQUFJLEVBQUUsY0FBYyxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ3pFLENBQUM7QUFFRCxNQUFNLFVBQVUsdUNBQXVDO0lBQ3JELE9BQU8sbUJBQW1CLENBQUMsZUFBZSxDQUFDLElBQUksRUFBRSxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDeEUsQ0FBQztBQUVELE1BQU0sVUFBVSw4QkFBOEI7SUFDNUMsT0FBTyxtQkFBbUIsQ0FBQyxlQUFlLENBQUMsS0FBSyxFQUFFLGNBQWMsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUMxRSxDQUFDO0FBUUQsa0ZBQWtGO0FBQ2xGLDJFQUEyRTtBQUMzRSw4RUFBOEU7QUFDOUUsTUFBTSxDQUFDLE1BQU0saUJBQWlCLEdBQTZCLGVBQWUsQ0FBQyxDQUFDLEdBQUcsRUFBRTtJQUMvRSxPQUFPO1FBQ0wsR0FBRyxhQUFhO1FBRWhCLCtCQUErQjtRQUMvQixxQkFBcUIsRUFBRSxDQUFDLElBQThCLEVBQUUsRUFBRTtZQUN4RCxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLEtBQUssQ0FBQztRQUNsQyxDQUFDO1FBRUQsc0JBQXNCLEVBQUUsQ0FBQyxJQUE4QixFQUFFLEVBQUU7WUFDekQsMEVBQTBFO1lBQzFFLDhEQUE4RDtZQUM5RCwyRkFBMkY7WUFDM0YsNEZBQTRGO1lBQzVGLGtDQUFrQztZQUNsQyw2RkFBNkY7WUFDN0YsMkJBQTJCO1lBQzNCLElBQUksa0JBQWtCLENBQUMsSUFBSSxDQUFDLE1BQU8sRUFBRSxJQUFJLENBQUMsV0FBWSxDQUFDLEVBQUUsQ0FBQztnQkFDeEQsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQ2pCLENBQUM7UUFDSCxDQUFDO0tBQ0YsQ0FBQztBQUNKLENBQUMsQ0FBQyxFQUFFLENBQUM7QUFFTCxNQUFNLFVBQVUsaUJBQWlCLENBQUMsTUFBdUIsRUFBRSxVQUFrQjtJQUMzRSxNQUFNLElBQUksR0FBRyxNQUFNLENBQUMsTUFBTSxDQUE2QixDQUFDO0lBQ3hELElBQUksQ0FBQyxNQUFNLEdBQUcsUUFBUSxFQUFFLENBQUM7SUFDekIsSUFBSSxDQUFDLFdBQVcsR0FBRyxVQUFVLENBQUM7SUFDOUIsSUFBSSxDQUFDLFVBQVUsR0FBRyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLFVBQVUsQ0FBQyxDQUFDO0lBQzdELElBQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRTtRQUMzQix3RkFBd0Y7UUFDeEYsa0ZBQWtGO1FBQ2xGLDBGQUEwRjtRQUMxRixpQkFBaUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUMxQixDQUFDLENBQUMsQ0FBQztBQUNMLENBQUM7QUFFRCwwREFBMEQ7QUFDMUQsTUFBTSxVQUFVLGtCQUFrQixDQUFDLEtBQXFCLEVBQUUsVUFBa0I7SUFDMUUsTUFBTSxTQUFTLEdBQUcsaUJBQWlCLENBQVUsS0FBSyxFQUFFLFVBQVUsQ0FBQyxDQUFDO0lBQ2hFLE1BQU0sS0FBSyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUMzQixNQUFNLE1BQU0sR0FBRyxTQUFTLENBQUMsS0FBSyxFQUFFLFVBQVUsQ0FBQyxDQUFDO0lBRTVDLHVGQUF1RjtJQUN2RiwyRkFBMkY7SUFDM0YsZ0dBQWdHO0lBQ2hHLCtGQUErRjtJQUMvRixXQUFXO0lBQ1gsSUFBSSxTQUFTLENBQUMsS0FBSyxJQUFJLE1BQU0sQ0FBQyxPQUFPLEtBQUssSUFBSSxFQUFFLENBQUM7UUFDL0MsTUFBTSxNQUFNLEdBQUcsTUFBTSxDQUFDLGlCQUFpQixDQUFDLENBQUM7WUFDckMsbUJBQW1CLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxVQUFVLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQztZQUNuRCxzQkFBc0IsQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxVQUFVLENBQUMsQ0FBQztRQUU3RCxTQUFTLENBQUMsS0FBSyxDQUFDLE1BQU0sRUFBRSxnQkFBZ0IsQ0FBQyxDQUFDO1FBRTFDLG9GQUFvRjtRQUNwRix1QkFBdUI7UUFDdkIsdURBQXVEO1FBQ3ZELE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUNELE9BQU8sS0FBSyxDQUFDO0FBQ2YsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG5pbXBvcnQge2NvbnN1bWVyTWFya0RpcnR5LCBwcm9kdWNlckFjY2Vzc2VkLCBwcm9kdWNlclVwZGF0ZVZhbHVlVmVyc2lvbiwgUkVBQ1RJVkVfTk9ERSwgUmVhY3RpdmVOb2RlLCBTSUdOQUx9IGZyb20gJ0Bhbmd1bGFyL2NvcmUvcHJpbWl0aXZlcy9zaWduYWxzJztcblxuaW1wb3J0IHtSdW50aW1lRXJyb3J9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQge3Vud3JhcEVsZW1lbnRSZWZ9IGZyb20gJy4uL2xpbmtlci9lbGVtZW50X3JlZic7XG5pbXBvcnQge1F1ZXJ5TGlzdH0gZnJvbSAnLi4vbGlua2VyL3F1ZXJ5X2xpc3QnO1xuaW1wb3J0IHtFTVBUWV9BUlJBWX0gZnJvbSAnLi4vdXRpbC9lbXB0eSc7XG5cbmltcG9ydCB7TFZpZXcsIFRWSUVXfSBmcm9tICcuL2ludGVyZmFjZXMvdmlldyc7XG5pbXBvcnQge2NvbGxlY3RRdWVyeVJlc3VsdHMsIGdldFRRdWVyeSwgbG9hZFF1ZXJ5SW50ZXJuYWwsIG1hdGVyaWFsaXplVmlld1Jlc3VsdHN9IGZyb20gJy4vcXVlcnknO1xuaW1wb3J0IHtTaWduYWx9IGZyb20gJy4vcmVhY3Rpdml0eS9hcGknO1xuaW1wb3J0IHtnZXRMVmlld30gZnJvbSAnLi9zdGF0ZSc7XG5cbi8qKiBGdW5jdGlvbiB1c2VkIGFzIHRoZSBgdG9TdHJpbmdgIGltcGxlbWVudGF0aW9uIG9mIHF1ZXJ5IHNpZ25hbHMuICovXG5jb25zdCBxdWVyeVNpZ25hbFRvU3RyaW5nID0gKCkgPT4gJ1tRVUVSWV9TSUdOQUxdJztcblxuZnVuY3Rpb24gY3JlYXRlUXVlcnlTaWduYWxGbjxWPihmaXJzdE9ubHk6IHRydWUsIHJlcXVpcmVkOiB0cnVlKTogU2lnbmFsPFY+O1xuZnVuY3Rpb24gY3JlYXRlUXVlcnlTaWduYWxGbjxWPihmaXJzdE9ubHk6IHRydWUsIHJlcXVpcmVkOiBmYWxzZSk6IFNpZ25hbDxWfHVuZGVmaW5lZD47XG5mdW5jdGlvbiBjcmVhdGVRdWVyeVNpZ25hbEZuPFY+KGZpcnN0T25seTogZmFsc2UsIHJlcXVpcmVkOiBmYWxzZSk6IFNpZ25hbDxSZWFkb25seUFycmF5PFY+PjtcbmZ1bmN0aW9uIGNyZWF0ZVF1ZXJ5U2lnbmFsRm48Vj4oZmlyc3RPbmx5OiBib29sZWFuLCByZXF1aXJlZDogYm9vbGVhbikge1xuICBjb25zdCBub2RlOiBRdWVyeVNpZ25hbE5vZGU8Vj4gPSBPYmplY3QuY3JlYXRlKFFVRVJZX1NJR05BTF9OT0RFKTtcbiAgZnVuY3Rpb24gc2lnbmFsRm4oKSB7XG4gICAgLy8gQ2hlY2sgaWYgdGhlIHZhbHVlIG5lZWRzIHVwZGF0aW5nIGJlZm9yZSByZXR1cm5pbmcgaXQuXG4gICAgcHJvZHVjZXJVcGRhdGVWYWx1ZVZlcnNpb24obm9kZSk7XG5cbiAgICAvLyBNYXJrIHRoaXMgcHJvZHVjZXIgYXMgYWNjZXNzZWQuXG4gICAgcHJvZHVjZXJBY2Nlc3NlZChub2RlKTtcblxuICAgIGlmIChmaXJzdE9ubHkpIHtcbiAgICAgIGNvbnN0IGZpcnN0VmFsdWUgPSBub2RlLl9xdWVyeUxpc3Q/LmZpcnN0O1xuICAgICAgaWYgKGZpcnN0VmFsdWUgPT09IHVuZGVmaW5lZCAmJiByZXF1aXJlZCkge1xuICAgICAgICAvLyBUT0RPOiBhZGQgZXJyb3IgY29kZVxuICAgICAgICAvLyBUT0RPOiBhZGQgcHJvcGVyIG1lc3NhZ2VcbiAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcigwLCAnbm8gcXVlcnkgcmVzdWx0cyB5ZXQhJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmlyc3RWYWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVE9ETyhwZXJmKTogbWFrZSBzdXJlIHRoYXQgSSdtIG5vdCBjcmVhdGluZyBuZXcgYXJyYXlzIHdoZW4gcmV0dXJuaW5nIHJlc3VsdHMuIFRoZSBvdGhlclxuICAgICAgLy8gY29uc2lkZXJhdGlvbiBoZXJlIGlzIHRoZSByZWZlcmVudGlhbCBzdGFiaWxpdHkgb2YgcmVzdWx0cy5cbiAgICAgIHJldHVybiBub2RlLl9xdWVyeUxpc3Q/LnRvQXJyYXkoKSA/PyBFTVBUWV9BUlJBWTtcbiAgICB9XG4gIH1cbiAgKHNpZ25hbEZuIGFzIGFueSlbU0lHTkFMXSA9IG5vZGU7XG4gIHNpZ25hbEZuLnRvU3RyaW5nID0gcXVlcnlTaWduYWxUb1N0cmluZztcblxuICByZXR1cm4gc2lnbmFsRm47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTaW5nbGVSZXN1bHRPcHRpb25hbFF1ZXJ5U2lnbmFsRm48UmVhZFQ+KCk6IFNpZ25hbDxSZWFkVHx1bmRlZmluZWQ+IHtcbiAgcmV0dXJuIGNyZWF0ZVF1ZXJ5U2lnbmFsRm4oLyogZmlyc3RPbmx5ICovIHRydWUsIC8qIHJlcXVpcmVkICovIGZhbHNlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNpbmdsZVJlc3VsdFJlcXVpcmVkUXVlcnlTaWduYWxGbjxSZWFkVD4oKTogU2lnbmFsPFJlYWRUPiB7XG4gIHJldHVybiBjcmVhdGVRdWVyeVNpZ25hbEZuKC8qIGZpcnN0T25seSAqLyB0cnVlLCAvKiByZXF1aXJlZCAqLyB0cnVlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU11bHRpUmVzdWx0UXVlcnlTaWduYWxGbjxSZWFkVD4oKTogU2lnbmFsPFJlYWRvbmx5QXJyYXk8UmVhZFQ+PiB7XG4gIHJldHVybiBjcmVhdGVRdWVyeVNpZ25hbEZuKC8qIGZpcnN0T25seSAqLyBmYWxzZSwgLyogcmVxdWlyZWQgKi8gZmFsc2UpO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFF1ZXJ5U2lnbmFsTm9kZTxUPiBleHRlbmRzIFJlYWN0aXZlTm9kZSB7XG4gIF9sVmlldz86IExWaWV3O1xuICBfcXVlcnlJbmRleD86IG51bWJlcjtcbiAgX3F1ZXJ5TGlzdD86IFF1ZXJ5TGlzdDxUPjtcbn1cblxuLy8gTm90ZTogVXNpbmcgYW4gSUlGRSBoZXJlIHRvIGVuc3VyZSB0aGF0IHRoZSBzcHJlYWQgYXNzaWdubWVudCBpcyBub3QgY29uc2lkZXJlZFxuLy8gYSBzaWRlLWVmZmVjdCwgZW5kaW5nIHVwIHByZXNlcnZpbmcgYENPTVBVVEVEX05PREVgIGFuZCBgUkVBQ1RJVkVfTk9ERWAuXG4vLyBUT0RPOiByZW1vdmUgd2hlbiBodHRwczovL2dpdGh1Yi5jb20vZXZhbncvZXNidWlsZC9pc3N1ZXMvMzM5MiBpcyByZXNvbHZlZC5cbmV4cG9ydCBjb25zdCBRVUVSWV9TSUdOQUxfTk9ERTogUXVlcnlTaWduYWxOb2RlPHVua25vd24+ID0gLyogQF9fUFVSRV9fICovICgoKSA9PiB7XG4gIHJldHVybiB7XG4gICAgLi4uUkVBQ1RJVkVfTk9ERSxcblxuICAgIC8vIEJhc2UgcmVhY3RpdmUgbm9kZS5vdmVycmlkZXNcbiAgICBwcm9kdWNlck11c3RSZWNvbXB1dGU6IChub2RlOiBRdWVyeVNpZ25hbE5vZGU8dW5rbm93bj4pID0+IHtcbiAgICAgIHJldHVybiAhIW5vZGUuX3F1ZXJ5TGlzdD8uZGlydHk7XG4gICAgfSxcblxuICAgIHByb2R1Y2VyUmVjb21wdXRlVmFsdWU6IChub2RlOiBRdWVyeVNpZ25hbE5vZGU8dW5rbm93bj4pID0+IHtcbiAgICAgIC8vIFRoZSBjdXJyZW50IHZhbHVlIGlzIHN0YWxlLiBDaGVjayB3aGV0aGVyIHdlIG5lZWQgdG8gcHJvZHVjZSBhIG5ldyBvbmUuXG4gICAgICAvLyBUT0RPOiBhc3NlcnQ6IEkndmUgZ290IGJvdGggdGhlIGxWaWV3IGFuZCBxdWVyeUluZGV4IHN0b3JlZFxuICAgICAgLy8gVE9ETyhwZXJmKTogSSdtIGFzc3VtaW5nIHRoYXQgdGhlIHNpZ25hbCB2YWx1ZSBjaGFuZ2VzIHdoZW4gdGhlIGxpc3Qgb2YgbWF0Y2hlcyBjaGFuZ2VzLlxuICAgICAgLy8gQnV0IHRoaXMgaXMgbm90IGNvcnJlY3QgZm9yIHRoZSBzaW5nbGUtZWxlbWVudCBxdWVyaWVzIHNpbmNlIHdlIHNob3VsZCBhbHNvIGNvbXBhcmUgKD09PSlcbiAgICAgIC8vIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudC5cbiAgICAgIC8vIFRPRE86IGVycm9yIGhhbmRsaW5nIC0gc2hvdWxkIHdlIGd1YXJkIGFnYWluc3QgZXhjZXB0aW9ucyB0aHJvd24gZnJvbSByZWZyZXNoU2lnbmFsUXVlcnkgLVxuICAgICAgLy8gbm9ybWFsbHkgaXQgc2hvdWxkIG5ldmVyXG4gICAgICBpZiAocmVmcmVzaFNpZ25hbFF1ZXJ5KG5vZGUuX2xWaWV3ISwgbm9kZS5fcXVlcnlJbmRleCEpKSB7XG4gICAgICAgIG5vZGUudmVyc2lvbisrO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn0pKCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBiaW5kUXVlcnlUb1NpZ25hbCh0YXJnZXQ6IFNpZ25hbDx1bmtub3duPiwgcXVlcnlJbmRleDogbnVtYmVyKTogdm9pZCB7XG4gIGNvbnN0IG5vZGUgPSB0YXJnZXRbU0lHTkFMXSBhcyBRdWVyeVNpZ25hbE5vZGU8dW5rbm93bj47XG4gIG5vZGUuX2xWaWV3ID0gZ2V0TFZpZXcoKTtcbiAgbm9kZS5fcXVlcnlJbmRleCA9IHF1ZXJ5SW5kZXg7XG4gIG5vZGUuX3F1ZXJ5TGlzdCA9IGxvYWRRdWVyeUludGVybmFsKG5vZGUuX2xWaWV3LCBxdWVyeUluZGV4KTtcbiAgbm9kZS5fcXVlcnlMaXN0Lm9uRGlydHkoKCkgPT4ge1xuICAgIC8vIE1hcmsgdGhpcyBwcm9kdWNlciBhcyBkaXJ0eSBhbmQgbm90aWZ5IGxpdmUgY29uc3VtZXIgYWJvdXQgdGhlIHBvdGVudGlhbCBjaGFuZ2UuIE5vdGVcbiAgICAvLyB0aGF0IHRoZSBvbkRpcnR5IGNhbGxiYWNrIHdpbGwgZmlyZSBvbmx5IG9uIHRoZSBpbml0aWFsIGRpcnR5IG1hcmtpbmcgKHRoYXQgaXMsXG4gICAgLy8gc3Vic2VxdWVudCBkaXJ0eSBub3RpZmljYXRpb25zIGFyZSBub3QgZmlyZWQtIHVudGlsIHRoZSBRdWVyeUxpc3QgYmVjb21lcyBjbGVhbiBhZ2FpbikuXG4gICAgY29uc3VtZXJNYXJrRGlydHkobm9kZSk7XG4gIH0pO1xufVxuXG4vLyBUT0RPKHJlZmFjdG9yKTogc29tZSBjb2RlIGR1cGxpY2F0aW9uIHdpdGggcXVlcnlSZWZyZXNoXG5leHBvcnQgZnVuY3Rpb24gcmVmcmVzaFNpZ25hbFF1ZXJ5KGxWaWV3OiBMVmlldzx1bmtub3duPiwgcXVlcnlJbmRleDogbnVtYmVyKTogYm9vbGVhbiB7XG4gIGNvbnN0IHF1ZXJ5TGlzdCA9IGxvYWRRdWVyeUludGVybmFsPHVua25vd24+KGxWaWV3LCBxdWVyeUluZGV4KTtcbiAgY29uc3QgdFZpZXcgPSBsVmlld1tUVklFV107XG4gIGNvbnN0IHRRdWVyeSA9IGdldFRRdWVyeSh0VmlldywgcXVlcnlJbmRleCk7XG5cbiAgLy8gVE9ETyh0ZXN0KTogb3BlcmF0aW9uIG9mIHJlZnJlc2hpbmcgYSBzaWduYWwgcXVlcnkgY291bGQgYmUgaW52b2tlZCBkdXJpbmcgdGhlIGZpcnN0XG4gIC8vIGNyZWF0aW9uIHBhc3MsIHdoaWxlIHJlc3VsdHMgYXJlIHN0aWxsIGJlaW5nIGNvbGxlY3RlZDsgd2Ugc2hvdWxkIE5PVCBtYXJrIHN1Y2ggcXVlcnkgYXNcbiAgLy8gXCJjbGVhblwiIGFzIHdlIG1pZ2h0IG5vdCBoYXZlIGFueSB2aWV3IGFkZCAvIHJlbW92ZSBvcGVyYXRpb25zIHRoYXQgd291bGQgbWFrZSBpdCBkaXJ0eSBhZ2Fpbi5cbiAgLy8gTGVhbmluZyB0b3dhcmRzIGV4aXRpbmcgZWFybHkgZm9yIGNhbGxzIHRvIHJlZnJlc2hTaWduYWxRdWVyeSBiZWZvcmUgdGhlIGZpcnN0IGNyZWF0aW9uIHBhc3NcbiAgLy8gZmluaXNoZWRcbiAgaWYgKHF1ZXJ5TGlzdC5kaXJ0eSAmJiB0UXVlcnkubWF0Y2hlcyAhPT0gbnVsbCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRRdWVyeS5jcm9zc2VzTmdUZW1wbGF0ZSA/XG4gICAgICAgIGNvbGxlY3RRdWVyeVJlc3VsdHModFZpZXcsIGxWaWV3LCBxdWVyeUluZGV4LCBbXSkgOlxuICAgICAgICBtYXRlcmlhbGl6ZVZpZXdSZXN1bHRzKHRWaWV3LCBsVmlldywgdFF1ZXJ5LCBxdWVyeUluZGV4KTtcblxuICAgIHF1ZXJ5TGlzdC5yZXNldChyZXN1bHQsIHVud3JhcEVsZW1lbnRSZWYpO1xuXG4gICAgLy8gVE9ETyh0ZXN0KTogZG9uJ3QgbWFyayBzaWduYWwgYXMgZGlydHkgd2hlbiBhIHF1ZXJ5IHdhcyBtYXJrZWQgYXMgZGlydHkgYnV0IHRoZXJlXG4gICAgLy8gd2FzIG5vIGFjdHVhbCBjaGFuZ2VcbiAgICAvLyBUT0RPOiBjaGFuZ2UgdGhlIHJlc2V0IGxvZ2ljIHNvIGl0IHJldHVybnMgdGhlIHZhbHVlXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuIl19
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { createComputed, SIGNAL } from '@angular/core/primitives/signals';
import { RuntimeError } from '../errors';
import { unwrapElementRef } from '../linker/element_ref';
import { EMPTY_ARRAY } from '../util/empty';
import { FLAGS } from './interfaces/view';
import { getQueryResults, loadQueryInternal } from './query';
import { signal } from './reactivity/signal';
import { getLView } from './state';
/**
 * A signal factory function in charge of creating a new computed signal capturing query
 * results. This centralized creation function is used by all types of queries (child / children,
 * required / optional).
 *
 * @param firstOnly indicates if all or only the first result should be returned
 * @param required indicates if at least one result is required
 * @returns a read-only signal with query results
 */
function createQuerySignalFn(firstOnly, required) {
    let node;
    const signalFn = createComputed(() => {
        // A dedicated signal that increments its value every time a query changes its dirty status. By
        // using this signal we can implement a query as computed and avoid creation of a specialized
        // reactive node type. Please note that a query gets marked dirty under the following
        // circumstances:
        // - a view (where a query is active) finished its first creation pass;
        // - a new view is inserted / deleted and it impacts query results.
        node._dirtyCounter();
        const value = refreshSignalQuery(node, firstOnly);
        if (required && value === undefined) {
            throw new RuntimeError(-951 /* RuntimeErrorCode.REQUIRED_QUERY_NO_VALUE */, ngDevMode && 'Child query result is required but no value is available.');
        }
        return value;
    });
    node = signalFn[SIGNAL];
    node._dirtyCounter = signal(0);
    if (ngDevMode) {
        signalFn.toString = () => `[Query Signal]`;
    }
    return signalFn;
}
export function createSingleResultOptionalQuerySignalFn() {
    return createQuerySignalFn(/* firstOnly */ true, /* required */ false);
}
export function createSingleResultRequiredQuerySignalFn() {
    return createQuerySignalFn(/* firstOnly */ true, /* required */ true);
}
export function createMultiResultQuerySignalFn() {
    return createQuerySignalFn(/* firstOnly */ false, /* required */ false);
}
export function bindQueryToSignal(target, queryIndex) {
    const node = target[SIGNAL];
    node._lView = getLView();
    node._queryIndex = queryIndex;
    node._queryList = loadQueryInternal(node._lView, queryIndex);
    node._queryList.onDirty(() => node._dirtyCounter.update(v => v + 1));
}
function refreshSignalQuery(node, firstOnly) {
    const lView = node._lView;
    const queryIndex = node._queryIndex;
    // There are 2 conditions under which we want to return "empty" results instead of the ones
    // collected by a query:
    //
    // 1) a given query wasn't created yet (this is a period of time between the directive creation
    // and execution of the query creation function) - in this case a query doesn't exist yet and we
    // don't have any results to return.
    //
    // 2) we are in the process of constructing a view (the first
    // creation pass didn't finish) and a query might have partial results, but we don't want to
    // return those - instead we do delay results collection until all nodes had a chance of matching
    // and we can present consistent, "atomic" (on a view level) results.
    if (lView === undefined || queryIndex === undefined || (lView[FLAGS] & 4 /* LViewFlags.CreationMode */)) {
        return (firstOnly ? undefined : EMPTY_ARRAY);
    }
    const queryList = loadQueryInternal(lView, queryIndex);
    const results = getQueryResults(lView, queryIndex);
    queryList.reset(results, unwrapElementRef);
    return firstOnly ? queryList.first : queryList.toArray();
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicXVlcnlfcmVhY3RpdmUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9jb3JlL3NyYy9yZW5kZXIzL3F1ZXJ5X3JlYWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7R0FNRztBQUVILE9BQU8sRUFBZSxjQUFjLEVBQUUsTUFBTSxFQUFDLE1BQU0sa0NBQWtDLENBQUM7QUFFdEYsT0FBTyxFQUFDLFlBQVksRUFBbUIsTUFBTSxXQUFXLENBQUM7QUFDekQsT0FBTyxFQUFDLGdCQUFnQixFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFFdkQsT0FBTyxFQUFDLFdBQVcsRUFBQyxNQUFNLGVBQWUsQ0FBQztBQUUxQyxPQUFPLEVBQUMsS0FBSyxFQUFvQixNQUFNLG1CQUFtQixDQUFDO0FBQzNELE9BQU8sRUFBQyxlQUFlLEVBQUUsaUJBQWlCLEVBQUMsTUFBTSxTQUFTLENBQUM7QUFFM0QsT0FBTyxFQUFDLE1BQU0sRUFBaUIsTUFBTSxxQkFBcUIsQ0FBQztBQUMzRCxPQUFPLEVBQUMsUUFBUSxFQUFDLE1BQU0sU0FBUyxDQUFDO0FBU2pDOzs7Ozs7OztHQVFHO0FBQ0gsU0FBUyxtQkFBbUIsQ0FBSSxTQUFrQixFQUFFLFFBQWlCO0lBQ25FLElBQUksSUFBd0IsQ0FBQztJQUM3QixNQUFNLFFBQVEsR0FBRyxjQUFjLENBQUMsR0FBRyxFQUFFO1FBQ25DLCtGQUErRjtRQUMvRiw2RkFBNkY7UUFDN0YscUZBQXFGO1FBQ3JGLGlCQUFpQjtRQUNqQix1RUFBdUU7UUFDdkUsbUVBQW1FO1FBQ25FLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztRQUVyQixNQUFNLEtBQUssR0FBRyxrQkFBa0IsQ0FBSSxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7UUFFckQsSUFBSSxRQUFRLElBQUksS0FBSyxLQUFLLFNBQVMsRUFBRSxDQUFDO1lBQ3BDLE1BQU0sSUFBSSxZQUFZLHNEQUVsQixTQUFTLElBQUksMkRBQTJELENBQUMsQ0FBQztRQUNoRixDQUFDO1FBRUQsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDLENBQUMsQ0FBQztJQUNILElBQUksR0FBRyxRQUFRLENBQUMsTUFBTSxDQUF1QixDQUFDO0lBQzlDLElBQUksQ0FBQyxhQUFhLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBRS9CLElBQUksU0FBUyxFQUFFLENBQUM7UUFDZCxRQUFRLENBQUMsUUFBUSxHQUFHLEdBQUcsRUFBRSxDQUFDLGdCQUFnQixDQUFDO0lBQzdDLENBQUM7SUFFRCxPQUFPLFFBQVEsQ0FBQztBQUNsQixDQUFDO0FBRUQsTUFBTSxVQUFVLHVDQUF1QztJQUNyRCxPQUFPLG1CQUFtQixDQUFDLGVBQWUsQ0FBQyxJQUFJLEVBQUUsY0FBYyxDQUFDLEtBQUssQ0FBNEIsQ0FBQztBQUNwRyxDQUFDO0FBRUQsTUFBTSxVQUFVLHVDQUF1QztJQUNyRCxPQUFPLG1CQUFtQixDQUFDLGVBQWUsQ0FBQyxJQUFJLEVBQUUsY0FBYyxDQUFDLElBQUksQ0FBa0IsQ0FBQztBQUN6RixDQUFDO0FBRUQsTUFBTSxVQUFVLDhCQUE4QjtJQUM1QyxPQUFPLG1CQUFtQixDQUFDLGVBQWUsQ0FBQyxLQUFLLEVBQUUsY0FBYyxDQUFDLEtBQUssQ0FDdEMsQ0FBQztBQUNuQyxDQUFDO0FBRUQsTUFBTSxVQUFVLGlCQUFpQixDQUFDLE1BQXVCLEVBQUUsVUFBa0I7SUFDM0UsTUFBTSxJQUFJLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBNkIsQ0FBQztJQUN4RCxJQUFJLENBQUMsTUFBTSxHQUFHLFFBQVEsRUFBRSxDQUFDO0lBQ3pCLElBQUksQ0FBQyxXQUFXLEdBQUcsVUFBVSxDQUFDO0lBQzlCLElBQUksQ0FBQyxVQUFVLEdBQUcsaUJBQWlCLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxVQUFVLENBQUMsQ0FBQztJQUM3RCxJQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3ZFLENBQUM7QUFFRCxTQUFTLGtCQUFrQixDQUFJLElBQXdCLEVBQUUsU0FBa0I7SUFDekUsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQztJQUMxQixNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDO0lBRXBDLDJGQUEyRjtJQUMzRix3QkFBd0I7SUFDeEIsRUFBRTtJQUNGLCtGQUErRjtJQUMvRixnR0FBZ0c7SUFDaEcsb0NBQW9DO0lBQ3BDLEVBQUU7SUFDRiw2REFBNkQ7SUFDN0QsNEZBQTRGO0lBQzVGLGlHQUFpRztJQUNqRyxxRUFBcUU7SUFDckUsSUFBSSxLQUFLLEtBQUssU0FBUyxJQUFJLFVBQVUsS0FBSyxTQUFTLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLGtDQUEwQixDQUFDLEVBQUUsQ0FBQztRQUNoRyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBTSxDQUFDO0lBQ3BELENBQUM7SUFFRCxNQUFNLFNBQVMsR0FBRyxpQkFBaUIsQ0FBSSxLQUFLLEVBQUUsVUFBVSxDQUFDLENBQUM7SUFDMUQsTUFBTSxPQUFPLEdBQUcsZUFBZSxDQUFJLEtBQUssRUFBRSxVQUFVLENBQUMsQ0FBQztJQUV0RCxTQUFTLENBQUMsS0FBSyxDQUFDLE9BQU8sRUFBRSxnQkFBZ0IsQ0FBQyxDQUFDO0lBRTNDLE9BQU8sU0FBUyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsT0FBTyxFQUFFLENBQUM7QUFDM0QsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG5pbXBvcnQge0NvbXB1dGVkTm9kZSwgY3JlYXRlQ29tcHV0ZWQsIFNJR05BTH0gZnJvbSAnQGFuZ3VsYXIvY29yZS9wcmltaXRpdmVzL3NpZ25hbHMnO1xuXG5pbXBvcnQge1J1bnRpbWVFcnJvciwgUnVudGltZUVycm9yQ29kZX0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7dW53cmFwRWxlbWVudFJlZn0gZnJvbSAnLi4vbGlua2VyL2VsZW1lbnRfcmVmJztcbmltcG9ydCB7UXVlcnlMaXN0fSBmcm9tICcuLi9saW5rZXIvcXVlcnlfbGlzdCc7XG5pbXBvcnQge0VNUFRZX0FSUkFZfSBmcm9tICcuLi91dGlsL2VtcHR5JztcblxuaW1wb3J0IHtGTEFHUywgTFZpZXcsIExWaWV3RmxhZ3N9IGZyb20gJy4vaW50ZXJmYWNlcy92aWV3JztcbmltcG9ydCB7Z2V0UXVlcnlSZXN1bHRzLCBsb2FkUXVlcnlJbnRlcm5hbH0gZnJvbSAnLi9xdWVyeSc7XG5pbXBvcnQge1NpZ25hbH0gZnJvbSAnLi9yZWFjdGl2aXR5L2FwaSc7XG5pbXBvcnQge3NpZ25hbCwgV3JpdGFibGVTaWduYWx9IGZyb20gJy4vcmVhY3Rpdml0eS9zaWduYWwnO1xuaW1wb3J0IHtnZXRMVmlld30gZnJvbSAnLi9zdGF0ZSc7XG5cbmludGVyZmFjZSBRdWVyeVNpZ25hbE5vZGU8VD4gZXh0ZW5kcyBDb21wdXRlZE5vZGU8VHxSZWFkb25seUFycmF5PFQ+PiB7XG4gIF9sVmlldz86IExWaWV3O1xuICBfcXVlcnlJbmRleD86IG51bWJlcjtcbiAgX3F1ZXJ5TGlzdD86IFF1ZXJ5TGlzdDxUPjtcbiAgX2RpcnR5Q291bnRlcjogV3JpdGFibGVTaWduYWw8bnVtYmVyPjtcbn1cblxuLyoqXG4gKiBBIHNpZ25hbCBmYWN0b3J5IGZ1bmN0aW9uIGluIGNoYXJnZSBvZiBjcmVhdGluZyBhIG5ldyBjb21wdXRlZCBzaWduYWwgY2FwdHVyaW5nIHF1ZXJ5XG4gKiByZXN1bHRzLiBUaGlzIGNlbnRyYWxpemVkIGNyZWF0aW9uIGZ1bmN0aW9uIGlzIHVzZWQgYnkgYWxsIHR5cGVzIG9mIHF1ZXJpZXMgKGNoaWxkIC8gY2hpbGRyZW4sXG4gKiByZXF1aXJlZCAvIG9wdGlvbmFsKS5cbiAqXG4gKiBAcGFyYW0gZmlyc3RPbmx5IGluZGljYXRlcyBpZiBhbGwgb3Igb25seSB0aGUgZmlyc3QgcmVzdWx0IHNob3VsZCBiZSByZXR1cm5lZFxuICogQHBhcmFtIHJlcXVpcmVkIGluZGljYXRlcyBpZiBhdCBsZWFzdCBvbmUgcmVzdWx0IGlzIHJlcXVpcmVkXG4gKiBAcmV0dXJucyBhIHJlYWQtb25seSBzaWduYWwgd2l0aCBxdWVyeSByZXN1bHRzXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVF1ZXJ5U2lnbmFsRm48Vj4oZmlyc3RPbmx5OiBib29sZWFuLCByZXF1aXJlZDogYm9vbGVhbikge1xuICBsZXQgbm9kZTogUXVlcnlTaWduYWxOb2RlPFY+O1xuICBjb25zdCBzaWduYWxGbiA9IGNyZWF0ZUNvbXB1dGVkKCgpID0+IHtcbiAgICAvLyBBIGRlZGljYXRlZCBzaWduYWwgdGhhdCBpbmNyZW1lbnRzIGl0cyB2YWx1ZSBldmVyeSB0aW1lIGEgcXVlcnkgY2hhbmdlcyBpdHMgZGlydHkgc3RhdHVzLiBCeVxuICAgIC8vIHVzaW5nIHRoaXMgc2lnbmFsIHdlIGNhbiBpbXBsZW1lbnQgYSBxdWVyeSBhcyBjb21wdXRlZCBhbmQgYXZvaWQgY3JlYXRpb24gb2YgYSBzcGVjaWFsaXplZFxuICAgIC8vIHJlYWN0aXZlIG5vZGUgdHlwZS4gUGxlYXNlIG5vdGUgdGhhdCBhIHF1ZXJ5IGdldHMgbWFya2VkIGRpcnR5IHVuZGVyIHRoZSBmb2xsb3dpbmdcbiAgICAvLyBjaXJjdW1zdGFuY2VzOlxuICAgIC8vIC0gYSB2aWV3ICh3aGVyZSBhIHF1ZXJ5IGlzIGFjdGl2ZSkgZmluaXNoZWQgaXRzIGZpcnN0IGNyZWF0aW9uIHBhc3M7XG4gICAgLy8gLSBhIG5ldyB2aWV3IGlzIGluc2VydGVkIC8gZGVsZXRlZCBhbmQgaXQgaW1wYWN0cyBxdWVyeSByZXN1bHRzLlxuICAgIG5vZGUuX2RpcnR5Q291bnRlcigpO1xuXG4gICAgY29uc3QgdmFsdWUgPSByZWZyZXNoU2lnbmFsUXVlcnk8Vj4obm9kZSwgZmlyc3RPbmx5KTtcblxuICAgIGlmIChyZXF1aXJlZCAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgUnVudGltZUVycm9yKFxuICAgICAgICAgIFJ1bnRpbWVFcnJvckNvZGUuUkVRVUlSRURfUVVFUllfTk9fVkFMVUUsXG4gICAgICAgICAgbmdEZXZNb2RlICYmICdDaGlsZCBxdWVyeSByZXN1bHQgaXMgcmVxdWlyZWQgYnV0IG5vIHZhbHVlIGlzIGF2YWlsYWJsZS4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH0pO1xuICBub2RlID0gc2lnbmFsRm5bU0lHTkFMXSBhcyBRdWVyeVNpZ25hbE5vZGU8Vj47XG4gIG5vZGUuX2RpcnR5Q291bnRlciA9IHNpZ25hbCgwKTtcblxuICBpZiAobmdEZXZNb2RlKSB7XG4gICAgc2lnbmFsRm4udG9TdHJpbmcgPSAoKSA9PiBgW1F1ZXJ5IFNpZ25hbF1gO1xuICB9XG5cbiAgcmV0dXJuIHNpZ25hbEZuO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2luZ2xlUmVzdWx0T3B0aW9uYWxRdWVyeVNpZ25hbEZuPFJlYWRUPigpOiBTaWduYWw8UmVhZFR8dW5kZWZpbmVkPiB7XG4gIHJldHVybiBjcmVhdGVRdWVyeVNpZ25hbEZuKC8qIGZpcnN0T25seSAqLyB0cnVlLCAvKiByZXF1aXJlZCAqLyBmYWxzZSkgYXMgU2lnbmFsPFJlYWRUfHVuZGVmaW5lZD47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTaW5nbGVSZXN1bHRSZXF1aXJlZFF1ZXJ5U2lnbmFsRm48UmVhZFQ+KCk6IFNpZ25hbDxSZWFkVD4ge1xuICByZXR1cm4gY3JlYXRlUXVlcnlTaWduYWxGbigvKiBmaXJzdE9ubHkgKi8gdHJ1ZSwgLyogcmVxdWlyZWQgKi8gdHJ1ZSkgYXMgU2lnbmFsPFJlYWRUPjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU11bHRpUmVzdWx0UXVlcnlTaWduYWxGbjxSZWFkVD4oKTogU2lnbmFsPFJlYWRvbmx5QXJyYXk8UmVhZFQ+PiB7XG4gIHJldHVybiBjcmVhdGVRdWVyeVNpZ25hbEZuKC8qIGZpcnN0T25seSAqLyBmYWxzZSwgLyogcmVxdWlyZWQgKi8gZmFsc2UpIGFzXG4gICAgICBTaWduYWw8UmVhZG9ubHlBcnJheTxSZWFkVD4+O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYmluZFF1ZXJ5VG9TaWduYWwodGFyZ2V0OiBTaWduYWw8dW5rbm93bj4sIHF1ZXJ5SW5kZXg6IG51bWJlcik6IHZvaWQge1xuICBjb25zdCBub2RlID0gdGFyZ2V0W1NJR05BTF0gYXMgUXVlcnlTaWduYWxOb2RlPHVua25vd24+O1xuICBub2RlLl9sVmlldyA9IGdldExWaWV3KCk7XG4gIG5vZGUuX3F1ZXJ5SW5kZXggPSBxdWVyeUluZGV4O1xuICBub2RlLl9xdWVyeUxpc3QgPSBsb2FkUXVlcnlJbnRlcm5hbChub2RlLl9sVmlldywgcXVlcnlJbmRleCk7XG4gIG5vZGUuX3F1ZXJ5TGlzdC5vbkRpcnR5KCgpID0+IG5vZGUuX2RpcnR5Q291bnRlci51cGRhdGUodiA9PiB2ICsgMSkpO1xufVxuXG5mdW5jdGlvbiByZWZyZXNoU2lnbmFsUXVlcnk8Vj4obm9kZTogUXVlcnlTaWduYWxOb2RlPFY+LCBmaXJzdE9ubHk6IGJvb2xlYW4pOiBWfFJlYWRvbmx5QXJyYXk8Vj4ge1xuICBjb25zdCBsVmlldyA9IG5vZGUuX2xWaWV3O1xuICBjb25zdCBxdWVyeUluZGV4ID0gbm9kZS5fcXVlcnlJbmRleDtcblxuICAvLyBUaGVyZSBhcmUgMiBjb25kaXRpb25zIHVuZGVyIHdoaWNoIHdlIHdhbnQgdG8gcmV0dXJuIFwiZW1wdHlcIiByZXN1bHRzIGluc3RlYWQgb2YgdGhlIG9uZXNcbiAgLy8gY29sbGVjdGVkIGJ5IGEgcXVlcnk6XG4gIC8vXG4gIC8vIDEpIGEgZ2l2ZW4gcXVlcnkgd2Fzbid0IGNyZWF0ZWQgeWV0ICh0aGlzIGlzIGEgcGVyaW9kIG9mIHRpbWUgYmV0d2VlbiB0aGUgZGlyZWN0aXZlIGNyZWF0aW9uXG4gIC8vIGFuZCBleGVjdXRpb24gb2YgdGhlIHF1ZXJ5IGNyZWF0aW9uIGZ1bmN0aW9uKSAtIGluIHRoaXMgY2FzZSBhIHF1ZXJ5IGRvZXNuJ3QgZXhpc3QgeWV0IGFuZCB3ZVxuICAvLyBkb24ndCBoYXZlIGFueSByZXN1bHRzIHRvIHJldHVybi5cbiAgLy9cbiAgLy8gMikgd2UgYXJlIGluIHRoZSBwcm9jZXNzIG9mIGNvbnN0cnVjdGluZyBhIHZpZXcgKHRoZSBmaXJzdFxuICAvLyBjcmVhdGlvbiBwYXNzIGRpZG4ndCBmaW5pc2gpIGFuZCBhIHF1ZXJ5IG1pZ2h0IGhhdmUgcGFydGlhbCByZXN1bHRzLCBidXQgd2UgZG9uJ3Qgd2FudCB0b1xuICAvLyByZXR1cm4gdGhvc2UgLSBpbnN0ZWFkIHdlIGRvIGRlbGF5IHJlc3VsdHMgY29sbGVjdGlvbiB1bnRpbCBhbGwgbm9kZXMgaGFkIGEgY2hhbmNlIG9mIG1hdGNoaW5nXG4gIC8vIGFuZCB3ZSBjYW4gcHJlc2VudCBjb25zaXN0ZW50LCBcImF0b21pY1wiIChvbiBhIHZpZXcgbGV2ZWwpIHJlc3VsdHMuXG4gIGlmIChsVmlldyA9PT0gdW5kZWZpbmVkIHx8IHF1ZXJ5SW5kZXggPT09IHVuZGVmaW5lZCB8fCAobFZpZXdbRkxBR1NdICYgTFZpZXdGbGFncy5DcmVhdGlvbk1vZGUpKSB7XG4gICAgcmV0dXJuIChmaXJzdE9ubHkgPyB1bmRlZmluZWQgOiBFTVBUWV9BUlJBWSkgYXMgVjtcbiAgfVxuXG4gIGNvbnN0IHF1ZXJ5TGlzdCA9IGxvYWRRdWVyeUludGVybmFsPFY+KGxWaWV3LCBxdWVyeUluZGV4KTtcbiAgY29uc3QgcmVzdWx0cyA9IGdldFF1ZXJ5UmVzdWx0czxWPihsVmlldywgcXVlcnlJbmRleCk7XG5cbiAgcXVlcnlMaXN0LnJlc2V0KHJlc3VsdHMsIHVud3JhcEVsZW1lbnRSZWYpO1xuXG4gIHJldHVybiBmaXJzdE9ubHkgPyBxdWVyeUxpc3QuZmlyc3QgOiBxdWVyeUxpc3QudG9BcnJheSgpO1xufVxuIl19
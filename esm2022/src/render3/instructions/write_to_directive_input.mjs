/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { setActiveConsumer, SIGNAL } from '@angular/core/primitives/signals';
import { applyValueToInputField } from '../apply_value_input_field';
import { InputFlags } from '../interfaces/definition';
export function writeToDirectiveInput(def, instance, publicName, privateName, flags, value) {
    const prevConsumer = setActiveConsumer(null);
    try {
        // If we know we are dealing with a signal input, we cache its reference
        // in a tree-shakable way. The input signal node can then be used for
        // value transform execution or actual value updates without introducing
        // additional megamorphic accesses for accessing the instance field.
        let inputSignalNode = null;
        if ((flags & InputFlags.SignalBased) !== 0) {
            const field = instance[privateName];
            inputSignalNode = field[SIGNAL];
        }
        // If there is a signal node and a transform, run it before potentially
        // delegating to features like `NgOnChanges`.
        if (inputSignalNode !== null && inputSignalNode.transformFn !== undefined) {
            value = inputSignalNode.transformFn(value);
        }
        // If there is a decorator input transform, run it.
        if ((flags & InputFlags.HasDecoratorInputTransform) !== 0) {
            value = def.inputTransforms[privateName].call(instance, value);
        }
        if (def.setInput !== null) {
            def.setInput(instance, inputSignalNode, value, publicName, privateName);
        }
        else {
            applyValueToInputField(instance, inputSignalNode, privateName, value);
        }
    }
    finally {
        setActiveConsumer(prevConsumer);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid3JpdGVfdG9fZGlyZWN0aXZlX2lucHV0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvY29yZS9zcmMvcmVuZGVyMy9pbnN0cnVjdGlvbnMvd3JpdGVfdG9fZGlyZWN0aXZlX2lucHV0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7R0FNRztBQUVILE9BQU8sRUFBQyxpQkFBaUIsRUFBRSxNQUFNLEVBQUMsTUFBTSxrQ0FBa0MsQ0FBQztBQUkzRSxPQUFPLEVBQUMsc0JBQXNCLEVBQUMsTUFBTSw0QkFBNEIsQ0FBQztBQUNsRSxPQUFPLEVBQWUsVUFBVSxFQUFDLE1BQU0sMEJBQTBCLENBQUM7QUFFbEUsTUFBTSxVQUFVLHFCQUFxQixDQUNqQyxHQUFvQixFQUFFLFFBQVcsRUFBRSxVQUFrQixFQUFFLFdBQW1CLEVBQUUsS0FBaUIsRUFDN0YsS0FBYztJQUNoQixNQUFNLFlBQVksR0FBRyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUM3QyxJQUFJLENBQUM7UUFDSCx3RUFBd0U7UUFDeEUscUVBQXFFO1FBQ3JFLHdFQUF3RTtRQUN4RSxvRUFBb0U7UUFDcEUsSUFBSSxlQUFlLEdBQTJDLElBQUksQ0FBQztRQUNuRSxJQUFJLENBQUMsS0FBSyxHQUFHLFVBQVUsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQztZQUMzQyxNQUFNLEtBQUssR0FBSSxRQUFnQixDQUFDLFdBQVcsQ0FBa0MsQ0FBQztZQUM5RSxlQUFlLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ2xDLENBQUM7UUFFRCx1RUFBdUU7UUFDdkUsNkNBQTZDO1FBQzdDLElBQUksZUFBZSxLQUFLLElBQUksSUFBSSxlQUFlLENBQUMsV0FBVyxLQUFLLFNBQVMsRUFBRSxDQUFDO1lBQzFFLEtBQUssR0FBRyxlQUFlLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzdDLENBQUM7UUFDRCxtREFBbUQ7UUFDbkQsSUFBSSxDQUFDLEtBQUssR0FBRyxVQUFVLENBQUMsMEJBQTBCLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQztZQUMxRCxLQUFLLEdBQUcsR0FBRyxDQUFDLGVBQWdCLENBQUMsV0FBVyxDQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxLQUFLLENBQUMsQ0FBQztRQUNuRSxDQUFDO1FBRUQsSUFBSSxHQUFHLENBQUMsUUFBUSxLQUFLLElBQUksRUFBRSxDQUFDO1lBQzFCLEdBQUcsQ0FBQyxRQUFRLENBQUMsUUFBUSxFQUFFLGVBQWUsRUFBRSxLQUFLLEVBQUUsVUFBVSxFQUFFLFdBQVcsQ0FBQyxDQUFDO1FBQzFFLENBQUM7YUFBTSxDQUFDO1lBQ04sc0JBQXNCLENBQUMsUUFBUSxFQUFFLGVBQWUsRUFBRSxXQUFXLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDeEUsQ0FBQztJQUNILENBQUM7WUFBUyxDQUFDO1FBQ1QsaUJBQWlCLENBQUMsWUFBWSxDQUFDLENBQUM7SUFDbEMsQ0FBQztBQUNILENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuaW1wb3J0IHtzZXRBY3RpdmVDb25zdW1lciwgU0lHTkFMfSBmcm9tICdAYW5ndWxhci9jb3JlL3ByaW1pdGl2ZXMvc2lnbmFscyc7XG5cbmltcG9ydCB7SW5wdXRTaWduYWx9IGZyb20gJy4uLy4uL2F1dGhvcmluZy9pbnB1dF9zaWduYWwnO1xuaW1wb3J0IHtJbnB1dFNpZ25hbE5vZGV9IGZyb20gJy4uLy4uL2F1dGhvcmluZy9pbnB1dF9zaWduYWxfbm9kZSc7XG5pbXBvcnQge2FwcGx5VmFsdWVUb0lucHV0RmllbGR9IGZyb20gJy4uL2FwcGx5X3ZhbHVlX2lucHV0X2ZpZWxkJztcbmltcG9ydCB7RGlyZWN0aXZlRGVmLCBJbnB1dEZsYWdzfSBmcm9tICcuLi9pbnRlcmZhY2VzL2RlZmluaXRpb24nO1xuXG5leHBvcnQgZnVuY3Rpb24gd3JpdGVUb0RpcmVjdGl2ZUlucHV0PFQ+KFxuICAgIGRlZjogRGlyZWN0aXZlRGVmPFQ+LCBpbnN0YW5jZTogVCwgcHVibGljTmFtZTogc3RyaW5nLCBwcml2YXRlTmFtZTogc3RyaW5nLCBmbGFnczogSW5wdXRGbGFncyxcbiAgICB2YWx1ZTogdW5rbm93bikge1xuICBjb25zdCBwcmV2Q29uc3VtZXIgPSBzZXRBY3RpdmVDb25zdW1lcihudWxsKTtcbiAgdHJ5IHtcbiAgICAvLyBJZiB3ZSBrbm93IHdlIGFyZSBkZWFsaW5nIHdpdGggYSBzaWduYWwgaW5wdXQsIHdlIGNhY2hlIGl0cyByZWZlcmVuY2VcbiAgICAvLyBpbiBhIHRyZWUtc2hha2FibGUgd2F5LiBUaGUgaW5wdXQgc2lnbmFsIG5vZGUgY2FuIHRoZW4gYmUgdXNlZCBmb3JcbiAgICAvLyB2YWx1ZSB0cmFuc2Zvcm0gZXhlY3V0aW9uIG9yIGFjdHVhbCB2YWx1ZSB1cGRhdGVzIHdpdGhvdXQgaW50cm9kdWNpbmdcbiAgICAvLyBhZGRpdGlvbmFsIG1lZ2Ftb3JwaGljIGFjY2Vzc2VzIGZvciBhY2Nlc3NpbmcgdGhlIGluc3RhbmNlIGZpZWxkLlxuICAgIGxldCBpbnB1dFNpZ25hbE5vZGU6IElucHV0U2lnbmFsTm9kZTx1bmtub3duLCB1bmtub3duPnxudWxsID0gbnVsbDtcbiAgICBpZiAoKGZsYWdzICYgSW5wdXRGbGFncy5TaWduYWxCYXNlZCkgIT09IDApIHtcbiAgICAgIGNvbnN0IGZpZWxkID0gKGluc3RhbmNlIGFzIGFueSlbcHJpdmF0ZU5hbWVdIGFzIElucHV0U2lnbmFsPHVua25vd24sIHVua25vd24+O1xuICAgICAgaW5wdXRTaWduYWxOb2RlID0gZmllbGRbU0lHTkFMXTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGVyZSBpcyBhIHNpZ25hbCBub2RlIGFuZCBhIHRyYW5zZm9ybSwgcnVuIGl0IGJlZm9yZSBwb3RlbnRpYWxseVxuICAgIC8vIGRlbGVnYXRpbmcgdG8gZmVhdHVyZXMgbGlrZSBgTmdPbkNoYW5nZXNgLlxuICAgIGlmIChpbnB1dFNpZ25hbE5vZGUgIT09IG51bGwgJiYgaW5wdXRTaWduYWxOb2RlLnRyYW5zZm9ybUZuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhbHVlID0gaW5wdXRTaWduYWxOb2RlLnRyYW5zZm9ybUZuKHZhbHVlKTtcbiAgICB9XG4gICAgLy8gSWYgdGhlcmUgaXMgYSBkZWNvcmF0b3IgaW5wdXQgdHJhbnNmb3JtLCBydW4gaXQuXG4gICAgaWYgKChmbGFncyAmIElucHV0RmxhZ3MuSGFzRGVjb3JhdG9ySW5wdXRUcmFuc2Zvcm0pICE9PSAwKSB7XG4gICAgICB2YWx1ZSA9IGRlZi5pbnB1dFRyYW5zZm9ybXMhW3ByaXZhdGVOYW1lXSEuY2FsbChpbnN0YW5jZSwgdmFsdWUpO1xuICAgIH1cblxuICAgIGlmIChkZWYuc2V0SW5wdXQgIT09IG51bGwpIHtcbiAgICAgIGRlZi5zZXRJbnB1dChpbnN0YW5jZSwgaW5wdXRTaWduYWxOb2RlLCB2YWx1ZSwgcHVibGljTmFtZSwgcHJpdmF0ZU5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcHBseVZhbHVlVG9JbnB1dEZpZWxkKGluc3RhbmNlLCBpbnB1dFNpZ25hbE5vZGUsIHByaXZhdGVOYW1lLCB2YWx1ZSk7XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHNldEFjdGl2ZUNvbnN1bWVyKHByZXZDb25zdW1lcik7XG4gIH1cbn1cbiJdfQ==
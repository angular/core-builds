/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { isRootView } from '../interfaces/type_checks';
import { ENVIRONMENT, FLAGS } from '../interfaces/view';
import { isRefreshingViews } from '../state';
import { getLViewParent } from '../util/view_utils';
/**
 * Marks current view and all ancestors dirty.
 *
 * Returns the root view because it is found as a byproduct of marking the view tree
 * dirty, and can be used by methods that consume markViewDirty() to easily schedule
 * change detection. Otherwise, such methods would need to traverse up the view tree
 * an additional time to get the root view and schedule a tick on it.
 *
 * @param lView The starting LView to mark dirty
 * @returns the root LView
 */
export function markViewDirty(lView) {
    const dirtyBitsToUse = isRefreshingViews() ?
        64 /* LViewFlags.Dirty */ :
        // When we are not actively refreshing a view tree, it is absolutely
        // valid to update state and mark views dirty. We use the `RefreshView` flag in this
        // case to allow synchronously rerunning change detection. This applies today to
        // afterRender hooks as well as animation listeners which execute after detecting
        // changes in a view when the render factory flushes.
        1024 /* LViewFlags.RefreshView */ | 64 /* LViewFlags.Dirty */;
    lView[ENVIRONMENT].changeDetectionScheduler?.notify(0 /* NotificationType.RefreshViews */);
    while (lView) {
        lView[FLAGS] |= dirtyBitsToUse;
        const parent = getLViewParent(lView);
        // Stop traversing up as soon as you find a root view that wasn't attached to any container
        if (isRootView(lView) && !parent) {
            return lView;
        }
        // continue otherwise
        lView = parent;
    }
    return null;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFya192aWV3X2RpcnR5LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvY29yZS9zcmMvcmVuZGVyMy9pbnN0cnVjdGlvbnMvbWFya192aWV3X2RpcnR5LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7R0FNRztBQUdILE9BQU8sRUFBQyxVQUFVLEVBQUMsTUFBTSwyQkFBMkIsQ0FBQztBQUNyRCxPQUFPLEVBQUMsV0FBVyxFQUFFLEtBQUssRUFBb0IsTUFBTSxvQkFBb0IsQ0FBQztBQUN6RSxPQUFPLEVBQUMsaUJBQWlCLEVBQUMsTUFBTSxVQUFVLENBQUM7QUFDM0MsT0FBTyxFQUFDLGNBQWMsRUFBQyxNQUFNLG9CQUFvQixDQUFDO0FBRWxEOzs7Ozs7Ozs7O0dBVUc7QUFDSCxNQUFNLFVBQVUsYUFBYSxDQUFDLEtBQVk7SUFDeEMsTUFBTSxjQUFjLEdBQUcsaUJBQWlCLEVBQUUsQ0FBQyxDQUFDO2tDQU12QixDQUFDO1FBQ2xCLG9FQUFvRTtRQUNwRSxvRkFBb0Y7UUFDcEYsZ0ZBQWdGO1FBQ2hGLGlGQUFpRjtRQUNqRixxREFBcUQ7UUFDckQsNkRBQXlDLENBQUM7SUFDOUMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxDQUFDLHdCQUF3QixFQUFFLE1BQU0sdUNBQStCLENBQUM7SUFDbkYsT0FBTyxLQUFLLEVBQUUsQ0FBQztRQUNiLEtBQUssQ0FBQyxLQUFLLENBQUMsSUFBSSxjQUFjLENBQUM7UUFDL0IsTUFBTSxNQUFNLEdBQUcsY0FBYyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ3JDLDJGQUEyRjtRQUMzRixJQUFJLFVBQVUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO1lBQ2pDLE9BQU8sS0FBSyxDQUFDO1FBQ2YsQ0FBQztRQUNELHFCQUFxQjtRQUNyQixLQUFLLEdBQUcsTUFBTyxDQUFDO0lBQ2xCLENBQUM7SUFDRCxPQUFPLElBQUksQ0FBQztBQUNkLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuaW1wb3J0IHtOb3RpZmljYXRpb25UeXBlfSBmcm9tICcuLi8uLi9jaGFuZ2VfZGV0ZWN0aW9uL3NjaGVkdWxpbmcvem9uZWxlc3Nfc2NoZWR1bGluZyc7XG5pbXBvcnQge2lzUm9vdFZpZXd9IGZyb20gJy4uL2ludGVyZmFjZXMvdHlwZV9jaGVja3MnO1xuaW1wb3J0IHtFTlZJUk9OTUVOVCwgRkxBR1MsIExWaWV3LCBMVmlld0ZsYWdzfSBmcm9tICcuLi9pbnRlcmZhY2VzL3ZpZXcnO1xuaW1wb3J0IHtpc1JlZnJlc2hpbmdWaWV3c30gZnJvbSAnLi4vc3RhdGUnO1xuaW1wb3J0IHtnZXRMVmlld1BhcmVudH0gZnJvbSAnLi4vdXRpbC92aWV3X3V0aWxzJztcblxuLyoqXG4gKiBNYXJrcyBjdXJyZW50IHZpZXcgYW5kIGFsbCBhbmNlc3RvcnMgZGlydHkuXG4gKlxuICogUmV0dXJucyB0aGUgcm9vdCB2aWV3IGJlY2F1c2UgaXQgaXMgZm91bmQgYXMgYSBieXByb2R1Y3Qgb2YgbWFya2luZyB0aGUgdmlldyB0cmVlXG4gKiBkaXJ0eSwgYW5kIGNhbiBiZSB1c2VkIGJ5IG1ldGhvZHMgdGhhdCBjb25zdW1lIG1hcmtWaWV3RGlydHkoKSB0byBlYXNpbHkgc2NoZWR1bGVcbiAqIGNoYW5nZSBkZXRlY3Rpb24uIE90aGVyd2lzZSwgc3VjaCBtZXRob2RzIHdvdWxkIG5lZWQgdG8gdHJhdmVyc2UgdXAgdGhlIHZpZXcgdHJlZVxuICogYW4gYWRkaXRpb25hbCB0aW1lIHRvIGdldCB0aGUgcm9vdCB2aWV3IGFuZCBzY2hlZHVsZSBhIHRpY2sgb24gaXQuXG4gKlxuICogQHBhcmFtIGxWaWV3IFRoZSBzdGFydGluZyBMVmlldyB0byBtYXJrIGRpcnR5XG4gKiBAcmV0dXJucyB0aGUgcm9vdCBMVmlld1xuICovXG5leHBvcnQgZnVuY3Rpb24gbWFya1ZpZXdEaXJ0eShsVmlldzogTFZpZXcpOiBMVmlld3xudWxsIHtcbiAgY29uc3QgZGlydHlCaXRzVG9Vc2UgPSBpc1JlZnJlc2hpbmdWaWV3cygpID9cbiAgICAgIC8vIFdoZW4gd2UgYXJlIGFjdGl2ZWx5IHJlZnJlc2hpbmcgdmlld3MsIHdlIG9ubHkgdXNlIHRoZSBgRGlydHlgIGJpdCB0byBtYXJrIGEgdmlld1xuICAgICAgLy8gZm9yIGNoZWNrLiBUaGlzIGJpdCBpcyBpZ25vcmVkIGluIENoYW5nZURldGVjdGlvbk1vZGUuVGFyZ2V0ZWQsIHdoaWNoIGlzIHVzZWQgdG9cbiAgICAgIC8vIHN5bmNocm9ub3VzbHkgcmVydW4gY2hhbmdlIGRldGVjdGlvbiBvbiBhIHNwZWNpZmljIHNldCBvZiB2aWV3cyAodGhvc2Ugd2hpY2ggaGF2ZVxuICAgICAgLy8gdGhlIGBSZWZyZXNoVmlld2AgZmxhZyBhbmQgdGhvc2Ugd2l0aCBkaXJ0eSBzaWduYWwgY29uc3VtZXJzKS4gYExWaWV3RmxhZ3MuRGlydHlgXG4gICAgICAvLyBkb2VzIG5vdCBzdXBwb3J0IHJlLWVudHJhbnQgY2hhbmdlIGRldGVjdGlvbiBvbiBpdHMgb3duLlxuICAgICAgTFZpZXdGbGFncy5EaXJ0eSA6XG4gICAgICAvLyBXaGVuIHdlIGFyZSBub3QgYWN0aXZlbHkgcmVmcmVzaGluZyBhIHZpZXcgdHJlZSwgaXQgaXMgYWJzb2x1dGVseVxuICAgICAgLy8gdmFsaWQgdG8gdXBkYXRlIHN0YXRlIGFuZCBtYXJrIHZpZXdzIGRpcnR5LiBXZSB1c2UgdGhlIGBSZWZyZXNoVmlld2AgZmxhZyBpbiB0aGlzXG4gICAgICAvLyBjYXNlIHRvIGFsbG93IHN5bmNocm9ub3VzbHkgcmVydW5uaW5nIGNoYW5nZSBkZXRlY3Rpb24uIFRoaXMgYXBwbGllcyB0b2RheSB0b1xuICAgICAgLy8gYWZ0ZXJSZW5kZXIgaG9va3MgYXMgd2VsbCBhcyBhbmltYXRpb24gbGlzdGVuZXJzIHdoaWNoIGV4ZWN1dGUgYWZ0ZXIgZGV0ZWN0aW5nXG4gICAgICAvLyBjaGFuZ2VzIGluIGEgdmlldyB3aGVuIHRoZSByZW5kZXIgZmFjdG9yeSBmbHVzaGVzLlxuICAgICAgTFZpZXdGbGFncy5SZWZyZXNoVmlldyB8IExWaWV3RmxhZ3MuRGlydHk7XG4gIGxWaWV3W0VOVklST05NRU5UXS5jaGFuZ2VEZXRlY3Rpb25TY2hlZHVsZXI/Lm5vdGlmeShOb3RpZmljYXRpb25UeXBlLlJlZnJlc2hWaWV3cyk7XG4gIHdoaWxlIChsVmlldykge1xuICAgIGxWaWV3W0ZMQUdTXSB8PSBkaXJ0eUJpdHNUb1VzZTtcbiAgICBjb25zdCBwYXJlbnQgPSBnZXRMVmlld1BhcmVudChsVmlldyk7XG4gICAgLy8gU3RvcCB0cmF2ZXJzaW5nIHVwIGFzIHNvb24gYXMgeW91IGZpbmQgYSByb290IHZpZXcgdGhhdCB3YXNuJ3QgYXR0YWNoZWQgdG8gYW55IGNvbnRhaW5lclxuICAgIGlmIChpc1Jvb3RWaWV3KGxWaWV3KSAmJiAhcGFyZW50KSB7XG4gICAgICByZXR1cm4gbFZpZXc7XG4gICAgfVxuICAgIC8vIGNvbnRpbnVlIG90aGVyd2lzZVxuICAgIGxWaWV3ID0gcGFyZW50ITtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbiJdfQ==
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { assertLContainer, assertTNode } from '../assert';
import { bindingUpdated } from '../bindings';
import { CONTEXT, HEADER_OFFSET, TVIEW } from '../interfaces/view';
import { getLView, nextBindingIndex } from '../state';
import { getTNode } from '../util/view_utils';
import { addLViewToLContainer, createAndRenderEmbeddedLView, getLViewFromLContainer, removeLViewFromLContainer } from '../view_manipulation';
/**
 * The conditional instruction represents the basic building block on the runtime side to support
 * built-in "if" and "switch". On the high level this instruction is responsible for adding and
 * removing views selected by a conditional expression.
 *
 * @param containerIndex index of a container in a host view (indexed from HEADER_OFFSET) where
 *     conditional views should be inserted.
 * @param matchingTemplateIndex index of a template TNode representing a conditional view to be
 *     inserted; -1 represents a special case when there is no view to insert.
 * @codeGenApi
 */
export function ɵɵconditional(containerIndex, matchingTemplateIndex, value) {
    const hostLView = getLView();
    const bindingIndex = nextBindingIndex();
    const lContainer = getLContainer(hostLView, HEADER_OFFSET + containerIndex);
    const viewInContainerIdx = 0;
    if (bindingUpdated(hostLView, bindingIndex, matchingTemplateIndex)) {
        // The index of the view to show changed - remove the previously displayed one
        // (it is a noop if there are no active views in a container).
        removeLViewFromLContainer(lContainer, viewInContainerIdx);
        // Index -1 is a special case where none of the conditions evaluates to
        // a truthy value and as the consequence we've got no view to show.
        if (matchingTemplateIndex !== -1) {
            const templateTNode = getExistingTNode(hostLView[TVIEW], matchingTemplateIndex);
            const embeddedLView = createAndRenderEmbeddedLView(hostLView, templateTNode, value);
            addLViewToLContainer(lContainer, embeddedLView, viewInContainerIdx);
        }
    }
    else {
        // We might keep displaying the same template but the actual value of the expression could have
        // changed - re-bind in context.
        const lView = getLViewFromLContainer(lContainer, viewInContainerIdx);
        if (lView !== undefined) {
            lView[CONTEXT] = value;
        }
    }
}
function getLContainer(lView, index) {
    const lContainer = lView[index];
    ngDevMode && assertLContainer(lContainer);
    return lContainer;
}
function getExistingTNode(tView, index) {
    const tNode = getTNode(tView, index + HEADER_OFFSET);
    ngDevMode && assertTNode(tNode);
    return tNode;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udHJvbF9mbG93LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvY29yZS9zcmMvcmVuZGVyMy9pbnN0cnVjdGlvbnMvY29udHJvbF9mbG93LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7R0FNRztBQUVILE9BQU8sRUFBQyxnQkFBZ0IsRUFBRSxXQUFXLEVBQUMsTUFBTSxXQUFXLENBQUM7QUFDeEQsT0FBTyxFQUFDLGNBQWMsRUFBQyxNQUFNLGFBQWEsQ0FBQztBQUczQyxPQUFPLEVBQUMsT0FBTyxFQUFFLGFBQWEsRUFBUyxLQUFLLEVBQVEsTUFBTSxvQkFBb0IsQ0FBQztBQUMvRSxPQUFPLEVBQUMsUUFBUSxFQUFFLGdCQUFnQixFQUFDLE1BQU0sVUFBVSxDQUFDO0FBQ3BELE9BQU8sRUFBQyxRQUFRLEVBQUMsTUFBTSxvQkFBb0IsQ0FBQztBQUM1QyxPQUFPLEVBQUMsb0JBQW9CLEVBQUUsNEJBQTRCLEVBQUUsc0JBQXNCLEVBQUUseUJBQXlCLEVBQUMsTUFBTSxzQkFBc0IsQ0FBQztBQUUzSTs7Ozs7Ozs7OztHQVVHO0FBQ0gsTUFBTSxVQUFVLGFBQWEsQ0FBSSxjQUFzQixFQUFFLHFCQUE2QixFQUFFLEtBQVM7SUFDL0YsTUFBTSxTQUFTLEdBQUcsUUFBUSxFQUFFLENBQUM7SUFDN0IsTUFBTSxZQUFZLEdBQUcsZ0JBQWdCLEVBQUUsQ0FBQztJQUN4QyxNQUFNLFVBQVUsR0FBRyxhQUFhLENBQUMsU0FBUyxFQUFFLGFBQWEsR0FBRyxjQUFjLENBQUMsQ0FBQztJQUM1RSxNQUFNLGtCQUFrQixHQUFHLENBQUMsQ0FBQztJQUU3QixJQUFJLGNBQWMsQ0FBQyxTQUFTLEVBQUUsWUFBWSxFQUFFLHFCQUFxQixDQUFDLEVBQUU7UUFDbEUsOEVBQThFO1FBQzlFLDhEQUE4RDtRQUM5RCx5QkFBeUIsQ0FBQyxVQUFVLEVBQUUsa0JBQWtCLENBQUMsQ0FBQztRQUUxRCx1RUFBdUU7UUFDdkUsbUVBQW1FO1FBQ25FLElBQUkscUJBQXFCLEtBQUssQ0FBQyxDQUFDLEVBQUU7WUFDaEMsTUFBTSxhQUFhLEdBQUcsZ0JBQWdCLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxFQUFFLHFCQUFxQixDQUFDLENBQUM7WUFDaEYsTUFBTSxhQUFhLEdBQUcsNEJBQTRCLENBQUMsU0FBUyxFQUFFLGFBQWEsRUFBRSxLQUFLLENBQUMsQ0FBQztZQUVwRixvQkFBb0IsQ0FBQyxVQUFVLEVBQUUsYUFBYSxFQUFFLGtCQUFrQixDQUFDLENBQUM7U0FDckU7S0FDRjtTQUFNO1FBQ0wsK0ZBQStGO1FBQy9GLGdDQUFnQztRQUNoQyxNQUFNLEtBQUssR0FBRyxzQkFBc0IsQ0FBYyxVQUFVLEVBQUUsa0JBQWtCLENBQUMsQ0FBQztRQUNsRixJQUFJLEtBQUssS0FBSyxTQUFTLEVBQUU7WUFDdkIsS0FBSyxDQUFDLE9BQU8sQ0FBQyxHQUFHLEtBQUssQ0FBQztTQUN4QjtLQUNGO0FBQ0gsQ0FBQztBQUVELFNBQVMsYUFBYSxDQUFDLEtBQVksRUFBRSxLQUFhO0lBQ2hELE1BQU0sVUFBVSxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNoQyxTQUFTLElBQUksZ0JBQWdCLENBQUMsVUFBVSxDQUFDLENBQUM7SUFFMUMsT0FBTyxVQUFVLENBQUM7QUFDcEIsQ0FBQztBQUVELFNBQVMsZ0JBQWdCLENBQUMsS0FBWSxFQUFFLEtBQWE7SUFDbkQsTUFBTSxLQUFLLEdBQUcsUUFBUSxDQUFDLEtBQUssRUFBRSxLQUFLLEdBQUcsYUFBYSxDQUFDLENBQUM7SUFDckQsU0FBUyxJQUFJLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUVoQyxPQUFPLEtBQUssQ0FBQztBQUNmLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuaW1wb3J0IHthc3NlcnRMQ29udGFpbmVyLCBhc3NlcnRUTm9kZX0gZnJvbSAnLi4vYXNzZXJ0JztcbmltcG9ydCB7YmluZGluZ1VwZGF0ZWR9IGZyb20gJy4uL2JpbmRpbmdzJztcbmltcG9ydCB7TENvbnRhaW5lcn0gZnJvbSAnLi4vaW50ZXJmYWNlcy9jb250YWluZXInO1xuaW1wb3J0IHtUTm9kZX0gZnJvbSAnLi4vaW50ZXJmYWNlcy9ub2RlJztcbmltcG9ydCB7Q09OVEVYVCwgSEVBREVSX09GRlNFVCwgTFZpZXcsIFRWSUVXLCBUVmlld30gZnJvbSAnLi4vaW50ZXJmYWNlcy92aWV3JztcbmltcG9ydCB7Z2V0TFZpZXcsIG5leHRCaW5kaW5nSW5kZXh9IGZyb20gJy4uL3N0YXRlJztcbmltcG9ydCB7Z2V0VE5vZGV9IGZyb20gJy4uL3V0aWwvdmlld191dGlscyc7XG5pbXBvcnQge2FkZExWaWV3VG9MQ29udGFpbmVyLCBjcmVhdGVBbmRSZW5kZXJFbWJlZGRlZExWaWV3LCBnZXRMVmlld0Zyb21MQ29udGFpbmVyLCByZW1vdmVMVmlld0Zyb21MQ29udGFpbmVyfSBmcm9tICcuLi92aWV3X21hbmlwdWxhdGlvbic7XG5cbi8qKlxuICogVGhlIGNvbmRpdGlvbmFsIGluc3RydWN0aW9uIHJlcHJlc2VudHMgdGhlIGJhc2ljIGJ1aWxkaW5nIGJsb2NrIG9uIHRoZSBydW50aW1lIHNpZGUgdG8gc3VwcG9ydFxuICogYnVpbHQtaW4gXCJpZlwiIGFuZCBcInN3aXRjaFwiLiBPbiB0aGUgaGlnaCBsZXZlbCB0aGlzIGluc3RydWN0aW9uIGlzIHJlc3BvbnNpYmxlIGZvciBhZGRpbmcgYW5kXG4gKiByZW1vdmluZyB2aWV3cyBzZWxlY3RlZCBieSBhIGNvbmRpdGlvbmFsIGV4cHJlc3Npb24uXG4gKlxuICogQHBhcmFtIGNvbnRhaW5lckluZGV4IGluZGV4IG9mIGEgY29udGFpbmVyIGluIGEgaG9zdCB2aWV3IChpbmRleGVkIGZyb20gSEVBREVSX09GRlNFVCkgd2hlcmVcbiAqICAgICBjb25kaXRpb25hbCB2aWV3cyBzaG91bGQgYmUgaW5zZXJ0ZWQuXG4gKiBAcGFyYW0gbWF0Y2hpbmdUZW1wbGF0ZUluZGV4IGluZGV4IG9mIGEgdGVtcGxhdGUgVE5vZGUgcmVwcmVzZW50aW5nIGEgY29uZGl0aW9uYWwgdmlldyB0byBiZVxuICogICAgIGluc2VydGVkOyAtMSByZXByZXNlbnRzIGEgc3BlY2lhbCBjYXNlIHdoZW4gdGhlcmUgaXMgbm8gdmlldyB0byBpbnNlcnQuXG4gKiBAY29kZUdlbkFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gybXJtWNvbmRpdGlvbmFsPFQ+KGNvbnRhaW5lckluZGV4OiBudW1iZXIsIG1hdGNoaW5nVGVtcGxhdGVJbmRleDogbnVtYmVyLCB2YWx1ZT86IFQpIHtcbiAgY29uc3QgaG9zdExWaWV3ID0gZ2V0TFZpZXcoKTtcbiAgY29uc3QgYmluZGluZ0luZGV4ID0gbmV4dEJpbmRpbmdJbmRleCgpO1xuICBjb25zdCBsQ29udGFpbmVyID0gZ2V0TENvbnRhaW5lcihob3N0TFZpZXcsIEhFQURFUl9PRkZTRVQgKyBjb250YWluZXJJbmRleCk7XG4gIGNvbnN0IHZpZXdJbkNvbnRhaW5lcklkeCA9IDA7XG5cbiAgaWYgKGJpbmRpbmdVcGRhdGVkKGhvc3RMVmlldywgYmluZGluZ0luZGV4LCBtYXRjaGluZ1RlbXBsYXRlSW5kZXgpKSB7XG4gICAgLy8gVGhlIGluZGV4IG9mIHRoZSB2aWV3IHRvIHNob3cgY2hhbmdlZCAtIHJlbW92ZSB0aGUgcHJldmlvdXNseSBkaXNwbGF5ZWQgb25lXG4gICAgLy8gKGl0IGlzIGEgbm9vcCBpZiB0aGVyZSBhcmUgbm8gYWN0aXZlIHZpZXdzIGluIGEgY29udGFpbmVyKS5cbiAgICByZW1vdmVMVmlld0Zyb21MQ29udGFpbmVyKGxDb250YWluZXIsIHZpZXdJbkNvbnRhaW5lcklkeCk7XG5cbiAgICAvLyBJbmRleCAtMSBpcyBhIHNwZWNpYWwgY2FzZSB3aGVyZSBub25lIG9mIHRoZSBjb25kaXRpb25zIGV2YWx1YXRlcyB0b1xuICAgIC8vIGEgdHJ1dGh5IHZhbHVlIGFuZCBhcyB0aGUgY29uc2VxdWVuY2Ugd2UndmUgZ290IG5vIHZpZXcgdG8gc2hvdy5cbiAgICBpZiAobWF0Y2hpbmdUZW1wbGF0ZUluZGV4ICE9PSAtMSkge1xuICAgICAgY29uc3QgdGVtcGxhdGVUTm9kZSA9IGdldEV4aXN0aW5nVE5vZGUoaG9zdExWaWV3W1RWSUVXXSwgbWF0Y2hpbmdUZW1wbGF0ZUluZGV4KTtcbiAgICAgIGNvbnN0IGVtYmVkZGVkTFZpZXcgPSBjcmVhdGVBbmRSZW5kZXJFbWJlZGRlZExWaWV3KGhvc3RMVmlldywgdGVtcGxhdGVUTm9kZSwgdmFsdWUpO1xuXG4gICAgICBhZGRMVmlld1RvTENvbnRhaW5lcihsQ29udGFpbmVyLCBlbWJlZGRlZExWaWV3LCB2aWV3SW5Db250YWluZXJJZHgpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBXZSBtaWdodCBrZWVwIGRpc3BsYXlpbmcgdGhlIHNhbWUgdGVtcGxhdGUgYnV0IHRoZSBhY3R1YWwgdmFsdWUgb2YgdGhlIGV4cHJlc3Npb24gY291bGQgaGF2ZVxuICAgIC8vIGNoYW5nZWQgLSByZS1iaW5kIGluIGNvbnRleHQuXG4gICAgY29uc3QgbFZpZXcgPSBnZXRMVmlld0Zyb21MQ29udGFpbmVyPFR8dW5kZWZpbmVkPihsQ29udGFpbmVyLCB2aWV3SW5Db250YWluZXJJZHgpO1xuICAgIGlmIChsVmlldyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBsVmlld1tDT05URVhUXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRMQ29udGFpbmVyKGxWaWV3OiBMVmlldywgaW5kZXg6IG51bWJlcik6IExDb250YWluZXIge1xuICBjb25zdCBsQ29udGFpbmVyID0gbFZpZXdbaW5kZXhdO1xuICBuZ0Rldk1vZGUgJiYgYXNzZXJ0TENvbnRhaW5lcihsQ29udGFpbmVyKTtcblxuICByZXR1cm4gbENvbnRhaW5lcjtcbn1cblxuZnVuY3Rpb24gZ2V0RXhpc3RpbmdUTm9kZSh0VmlldzogVFZpZXcsIGluZGV4OiBudW1iZXIpOiBUTm9kZSB7XG4gIGNvbnN0IHROb2RlID0gZ2V0VE5vZGUodFZpZXcsIGluZGV4ICsgSEVBREVSX09GRlNFVCk7XG4gIG5nRGV2TW9kZSAmJiBhc3NlcnRUTm9kZSh0Tm9kZSk7XG5cbiAgcmV0dXJuIHROb2RlO1xufVxuIl19
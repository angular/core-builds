/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { DefaultIterableDiffer } from '../../change_detection';
import { assertDefined } from '../../util/assert';
import { assertLContainer, assertLView, assertTNode } from '../assert';
import { bindingUpdated } from '../bindings';
import { CONTAINER_HEADER_OFFSET } from '../interfaces/container';
import { CONTEXT, HEADER_OFFSET, TVIEW } from '../interfaces/view';
import { detachView } from '../node_manipulation';
import { getLView, nextBindingIndex } from '../state';
import { getTNode } from '../util/view_utils';
import { addLViewToLContainer, createAndRenderEmbeddedLView, getLViewFromLContainer, removeLViewFromLContainer } from '../view_manipulation';
import { ɵɵtemplate } from './template';
/**
 * The conditional instruction represents the basic building block on the runtime side to support
 * built-in "if" and "switch". On the high level this instruction is responsible for adding and
 * removing views selected by a conditional expression.
 *
 * @param containerIndex index of a container in a host view (indexed from HEADER_OFFSET) where
 *     conditional views should be inserted.
 * @param matchingTemplateIndex index of a template TNode representing a conditional view to be
 *     inserted; -1 represents a special case when there is no view to insert.
 * @codeGenApi
 */
export function ɵɵconditional(containerIndex, matchingTemplateIndex, value) {
    const hostLView = getLView();
    const bindingIndex = nextBindingIndex();
    const lContainer = getLContainer(hostLView, HEADER_OFFSET + containerIndex);
    const viewInContainerIdx = 0;
    if (bindingUpdated(hostLView, bindingIndex, matchingTemplateIndex)) {
        // The index of the view to show changed - remove the previously displayed one
        // (it is a noop if there are no active views in a container).
        removeLViewFromLContainer(lContainer, viewInContainerIdx);
        // Index -1 is a special case where none of the conditions evaluates to
        // a truthy value and as the consequence we've got no view to show.
        if (matchingTemplateIndex !== -1) {
            const templateTNode = getExistingTNode(hostLView[TVIEW], matchingTemplateIndex);
            const embeddedLView = createAndRenderEmbeddedLView(hostLView, templateTNode, value);
            addLViewToLContainer(lContainer, embeddedLView, viewInContainerIdx);
        }
    }
    else {
        // We might keep displaying the same template but the actual value of the expression could have
        // changed - re-bind in context.
        const lView = getLViewFromLContainer(lContainer, viewInContainerIdx);
        if (lView !== undefined) {
            lView[CONTEXT] = value;
        }
    }
}
export class RepeaterContext {
    constructor(lContainer, $implicit, $index) {
        this.lContainer = lContainer;
        this.$implicit = $implicit;
        this.$index = $index;
    }
    get $count() {
        return this.lContainer.length - CONTAINER_HEADER_OFFSET;
    }
}
/**
 * A built-in trackBy function used for situations where users specified collection index as a
 * tracking expression. Having this function body in the runtime avoids unnecessary code generation.
 *
 * @param index
 * @returns
 */
export function ɵɵrepeaterTrackByIndex(index) {
    return index;
}
/**
 * A built-in trackBy function used for situations where users specified collection item reference
 * as a tracking expression. Having this function body in the runtime avoids unnecessary code
 * generation.
 *
 * @param index
 * @returns
 */
export function ɵɵrepeaterTrackByIdentity(_, value) {
    return value;
}
class RepeaterMetadata {
    constructor(hasEmptyBlock, differ) {
        this.hasEmptyBlock = hasEmptyBlock;
        this.differ = differ;
    }
}
/**
 * The repeaterCreate instruction runs in the creation part of the template pass and initializes
 * internal data structures required by the update pass of the built-in repeater logic. Repeater
 * metadata are allocated in the data part of LView with the following layout:
 * - LView[HEADER_OFFSET + index] - metadata
 * - LView[HEADER_OFFSET + index + 1] - reference to a template function rendering an item
 * - LView[HEADER_OFFSET + index + 2] - optional reference to a template function rendering an empty
 * block
 *
 * @codeGenApi
 */
export function ɵɵrepeaterCreate(index, templateFn, decls, vars, trackByFn, emptyTemplateFn, emptyDecls, emptyVars) {
    const hasEmptyBlock = emptyTemplateFn !== undefined;
    const hostLView = getLView();
    const metadata = new RepeaterMetadata(hasEmptyBlock, new DefaultIterableDiffer(trackByFn));
    hostLView[HEADER_OFFSET + index] = metadata;
    ɵɵtemplate(index + 1, templateFn, decls, vars);
    if (hasEmptyBlock) {
        ngDevMode &&
            assertDefined(emptyDecls, 'Missing number of declarations for the empty repeater block.');
        ngDevMode &&
            assertDefined(emptyVars, 'Missing number of bindings for the empty repeater block.');
        ɵɵtemplate(index + 2, emptyTemplateFn, emptyDecls, emptyVars);
    }
}
/**
 * The repeater instruction does update-time diffing of a provided collection (against the
 * collection seen previously) and maps changes in the collection to views structure (by adding,
 * removing or moving views as needed).
 * @param metadataSlotIdx - index in data where we can find an instance of RepeaterMetadata with
 *     additional information (ex. differ) needed to process collection diffing and view
 *     manipulation
 * @param collection - the collection instance to be checked for changes
 * @codeGenApi
 */
export function ɵɵrepeater(metadataSlotIdx, collection) {
    const hostLView = getLView();
    const hostTView = hostLView[TVIEW];
    const metadata = hostLView[HEADER_OFFSET + metadataSlotIdx];
    const differ = metadata.differ;
    const changes = differ.diff(collection);
    // handle repeater changes
    if (changes !== null) {
        const containerIndex = metadataSlotIdx + 1;
        const itemTemplateTNode = getExistingTNode(hostTView, containerIndex);
        const lContainer = getLContainer(hostLView, HEADER_OFFSET + containerIndex);
        let needsIndexUpdate = false;
        changes.forEachOperation((item, adjustedPreviousIndex, currentIndex) => {
            if (item.previousIndex === null) {
                // add
                const newViewIdx = adjustToLastLContainerIndex(lContainer, currentIndex);
                const embeddedLView = createAndRenderEmbeddedLView(hostLView, itemTemplateTNode, new RepeaterContext(lContainer, item.item, newViewIdx));
                addLViewToLContainer(lContainer, embeddedLView, newViewIdx);
                needsIndexUpdate = true;
            }
            else if (currentIndex === null) {
                // remove
                adjustedPreviousIndex = adjustToLastLContainerIndex(lContainer, adjustedPreviousIndex);
                removeLViewFromLContainer(lContainer, adjustedPreviousIndex);
                needsIndexUpdate = true;
            }
            else if (adjustedPreviousIndex !== null) {
                // move
                const existingLView = detachExistingView(lContainer, adjustedPreviousIndex);
                addLViewToLContainer(lContainer, existingLView, currentIndex);
                needsIndexUpdate = true;
            }
        });
        // A trackBy function might return the same value even if the underlying item changed - re-bind
        // it in the context.
        changes.forEachIdentityChange((record) => {
            const viewIdx = adjustToLastLContainerIndex(lContainer, record.currentIndex);
            const lView = getExistingLViewFromLContainer(lContainer, viewIdx);
            lView[CONTEXT].$implicit = record.item;
        });
        // moves in the container might caused context's index to get out of order, re-adjust
        if (needsIndexUpdate) {
            for (let i = 0; i < lContainer.length - CONTAINER_HEADER_OFFSET; i++) {
                const lView = getExistingLViewFromLContainer(lContainer, i);
                lView[CONTEXT].$index = i;
            }
        }
    }
    // handle empty blocks
    const bindingIndex = nextBindingIndex();
    if (metadata.hasEmptyBlock) {
        const hasItemsInCollection = differ.length > 0;
        if (bindingUpdated(hostLView, bindingIndex, hasItemsInCollection)) {
            const emptyTemplateIndex = metadataSlotIdx + 2;
            const lContainer = getLContainer(hostLView, HEADER_OFFSET + emptyTemplateIndex);
            if (hasItemsInCollection) {
                removeLViewFromLContainer(lContainer, 0);
            }
            else {
                const emptyTemplateTNode = getExistingTNode(hostTView, emptyTemplateIndex);
                const embeddedLView = createAndRenderEmbeddedLView(hostLView, emptyTemplateTNode, undefined);
                addLViewToLContainer(lContainer, embeddedLView, 0);
            }
        }
    }
}
function getLContainer(lView, index) {
    const lContainer = lView[index];
    ngDevMode && assertLContainer(lContainer);
    return lContainer;
}
function adjustToLastLContainerIndex(lContainer, index) {
    return index !== null ? index : lContainer.length - CONTAINER_HEADER_OFFSET;
}
function detachExistingView(lContainer, index) {
    const existingLView = detachView(lContainer, index);
    ngDevMode && assertLView(existingLView);
    return existingLView;
}
function getExistingLViewFromLContainer(lContainer, index) {
    const existingLView = getLViewFromLContainer(lContainer, index);
    ngDevMode && assertLView(existingLView);
    return existingLView;
}
function getExistingTNode(tView, index) {
    const tNode = getTNode(tView, index + HEADER_OFFSET);
    ngDevMode && assertTNode(tNode);
    return tNode;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udHJvbF9mbG93LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvY29yZS9zcmMvcmVuZGVyMy9pbnN0cnVjdGlvbnMvY29udHJvbF9mbG93LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7R0FNRztBQUVILE9BQU8sRUFBQyxxQkFBcUIsRUFBd0MsTUFBTSx3QkFBd0IsQ0FBQztBQUNwRyxPQUFPLEVBQUMsYUFBYSxFQUFDLE1BQU0sbUJBQW1CLENBQUM7QUFDaEQsT0FBTyxFQUFDLGdCQUFnQixFQUFFLFdBQVcsRUFBRSxXQUFXLEVBQUMsTUFBTSxXQUFXLENBQUM7QUFDckUsT0FBTyxFQUFDLGNBQWMsRUFBQyxNQUFNLGFBQWEsQ0FBQztBQUMzQyxPQUFPLEVBQUMsdUJBQXVCLEVBQWEsTUFBTSx5QkFBeUIsQ0FBQztBQUc1RSxPQUFPLEVBQUMsT0FBTyxFQUFFLGFBQWEsRUFBUyxLQUFLLEVBQVEsTUFBTSxvQkFBb0IsQ0FBQztBQUMvRSxPQUFPLEVBQUMsVUFBVSxFQUFDLE1BQU0sc0JBQXNCLENBQUM7QUFDaEQsT0FBTyxFQUFDLFFBQVEsRUFBRSxnQkFBZ0IsRUFBQyxNQUFNLFVBQVUsQ0FBQztBQUNwRCxPQUFPLEVBQUMsUUFBUSxFQUFDLE1BQU0sb0JBQW9CLENBQUM7QUFDNUMsT0FBTyxFQUFDLG9CQUFvQixFQUFFLDRCQUE0QixFQUFFLHNCQUFzQixFQUFFLHlCQUF5QixFQUFDLE1BQU0sc0JBQXNCLENBQUM7QUFFM0ksT0FBTyxFQUFDLFVBQVUsRUFBQyxNQUFNLFlBQVksQ0FBQztBQUV0Qzs7Ozs7Ozs7OztHQVVHO0FBQ0gsTUFBTSxVQUFVLGFBQWEsQ0FBSSxjQUFzQixFQUFFLHFCQUE2QixFQUFFLEtBQVM7SUFDL0YsTUFBTSxTQUFTLEdBQUcsUUFBUSxFQUFFLENBQUM7SUFDN0IsTUFBTSxZQUFZLEdBQUcsZ0JBQWdCLEVBQUUsQ0FBQztJQUN4QyxN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QUksQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsTUFBTSxHQUFHLHVCQUF1QixDQUFDO0FBQzlFLENBQUM7QUFFRCxTQUFTLGtCQUFrQixDQUFJLFVBQXNCLEVBQUUsS0FBYTtJQUNsRSxNQUFNLGFBQWEsR0FBRyxVQUFVLENBQUMsVUFBVSxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQ3BELFNBQVMsSUFBSSxXQUFXLENBQUMsYUFBYSxDQUFDLENBQUM7SUFFeEMsT0FBTyxhQUF5QixDQUFDO0FBQ25DLENBQUM7QUFFRCxTQUFTLDhCQUE4QixDQUFJLFVBQXNCLEVBQUUsS0FBYTtJQUM5RSxNQUFNLGFBQWEsR0FBRyxzQkFBc0IsQ0FBSSxVQUFVLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFDbkUsU0FBUyxJQUFJLFdBQVcsQ0FBQyxhQUFhLENBQUMsQ0FBQztJQUV4QyxPQUFPLGFBQWMsQ0FBQztBQUN4QixDQUFDO0FBRUQsU0FBUyxnQkFBZ0IsQ0FBQyxLQUFZLEVBQUUsS0FBYTtJQUNuRCxNQUFNLEtBQUssR0FBRyxRQUFRLENBQUMsS0FBSyxFQUFFLEtBQUssR0FBRyxhQUFhLENBQUMsQ0FBQztJQUNyRCxTQUFTLElBQUksV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBRWhDLE9BQU8sS0FBSyxDQUFDO0FBQ2YsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG5pbXBvcnQge0RlZmF1bHRJdGVyYWJsZURpZmZlciwgSXRlcmFibGVDaGFuZ2VSZWNvcmQsIFRyYWNrQnlGdW5jdGlvbn0gZnJvbSAnLi4vLi4vY2hhbmdlX2RldGVjdGlvbic7XG5pbXBvcnQge2Fzc2VydERlZmluZWR9IGZyb20gJy4uLy4uL3V0aWwvYXNzZXJ0JztcbmltcG9ydCB7YXNzZXJ0TENvbnRhaW5lciwgYXNzZXJ0TFZpZXcsIGFzc2VydFROb2RlfSBmcm9tICcuLi9hc3NlcnQnO1xuaW1wb3J0IHtiaW5kaW5nVXBkYXRlZH0gZnJvbSAnLi4vYmluZGluZ3MnO1xuaW1wb3J0IHtDT05UQUlORVJfSEVBREVSX09GRlNFVCwgTENvbnRhaW5lcn0gZnJvbSAnLi4vaW50ZXJmYWNlcy9jb250YWluZXInO1xuaW1wb3J0IHtDb21wb25lbnRUZW1wbGF0ZX0gZnJvbSAnLi4vaW50ZXJmYWNlcy9kZWZpbml0aW9uJztcbmltcG9ydCB7VE5vZGV9IGZyb20gJy4uL2ludGVyZmFjZXMvbm9kZSc7XG5pbXBvcnQge0NPTlRFWFQsIEhFQURFUl9PRkZTRVQsIExWaWV3LCBUVklFVywgVFZpZXd9IGZyb20gJy4uL2ludGVyZmFjZXMvdmlldyc7XG5pbXBvcnQge2RldGFjaFZpZXd9IGZyb20gJy4uL25vZGVfbWFuaXB1bGF0aW9uJztcbmltcG9ydCB7Z2V0TFZpZXcsIG5leHRCaW5kaW5nSW5kZXh9IGZyb20gJy4uL3N0YXRlJztcbmltcG9ydCB7Z2V0VE5vZGV9IGZyb20gJy4uL3V0aWwvdmlld191dGlscyc7XG5pbXBvcnQge2FkZExWaWV3VG9MQ29udGFpbmVyLCBjcmVhdGVBbmRSZW5kZXJFbWJlZGRlZExWaWV3LCBnZXRMVmlld0Zyb21MQ29udGFpbmVyLCByZW1vdmVMVmlld0Zyb21MQ29udGFpbmVyfSBmcm9tICcuLi92aWV3X21hbmlwdWxhdGlvbic7XG5cbmltcG9ydCB7ybXJtXRlbXBsYXRlfSBmcm9tICcuL3RlbXBsYXRlJztcblxuLyoqXG4gKiBUaGUgY29uZGl0aW9uYWwgaW5zdHJ1Y3Rpb24gcmVwcmVzZW50cyB0aGUgYmFzaWMgYnVpbGRpbmcgYmxvY2sgb24gdGhlIHJ1bnRpbWUgc2lkZSB0byBzdXBwb3J0XG4gKiBidWlsdC1pbiBcImlmXCIgYW5kIFwic3dpdGNoXCIuIE9uIHRoZSBoaWdoIGxldmVsIHRoaXMgaW5zdHJ1Y3Rpb24gaXMgcmVzcG9uc2libGUgZm9yIGFkZGluZyBhbmRcbiAqIHJlbW92aW5nIHZpZXdzIHNlbGVjdGVkIGJ5IGEgY29uZGl0aW9uYWwgZXhwcmVzc2lvbi5cbiAqXG4gKiBAcGFyYW0gY29udGFpbmVySW5kZXggaW5kZXggb2YgYSBjb250YWluZXIgaW4gYSBob3N0IHZpZXcgKGluZGV4ZWQgZnJvbSBIRUFERVJfT0ZGU0VUKSB3aGVyZVxuICogICAgIGNvbmRpdGlvbmFsIHZpZXdzIHNob3VsZCBiZSBpbnNlcnRlZC5cbiAqIEBwYXJhbSBtYXRjaGluZ1RlbXBsYXRlSW5kZXggaW5kZXggb2YgYSB0ZW1wbGF0ZSBUTm9kZSByZXByZXNlbnRpbmcgYSBjb25kaXRpb25hbCB2aWV3IHRvIGJlXG4gKiAgICAgaW5zZXJ0ZWQ7IC0xIHJlcHJlc2VudHMgYSBzcGVjaWFsIGNhc2Ugd2hlbiB0aGVyZSBpcyBubyB2aWV3IHRvIGluc2VydC5cbiAqIEBjb2RlR2VuQXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiDJtcm1Y29uZGl0aW9uYWw8VD4oY29udGFpbmVySW5kZXg6IG51bWJlciwgbWF0Y2hpbmdUZW1wbGF0ZUluZGV4OiBudW1iZXIsIHZhbHVlPzogVCkge1xuICBjb25zdCBob3N0TFZpZXcgPSBnZXRMVmlldygpO1xuICBjb25zdCBiaW5kaW5nSW5kZXggPSBuZXh0QmluZGluZ0luZGV4KCk7XG4gIGNvbnN0IGxDb250YWluZXIgPSBnZXRMQ29udGFpbmVyKGhvc3RMVmlldywgSEVBREVSX09GRlNFVCArIGNvbnRhaW5lckluZGV4KTtcbiAgY29uc3Qgdmlld0luQ29udGFpbmVySWR4ID0gMDtcblxuICBpZiAoYmluZGluZ1VwZGF0ZWQoaG9zdExWaWV3LCBiaW5kaW5nSW5kZXgsIG1hdGNoaW5nVGVtcGxhdGVJbmRleCkpIHtcbiAgICAvLyBUaGUgaW5kZXggb2YgdGhlIHZpZXcgdG8gc2hvdyBjaGFuZ2VkIC0gcmVtb3ZlIHRoZSBwcmV2aW91c2x5IGRpc3BsYXllZCBvbmVcbiAgICAvLyAoaXQgaXMgYSBub29wIGlmIHRoZXJlIGFyZSBubyBhY3RpdmUgdmlld3MgaW4gYSBjb250YWluZXIpLlxuICAgIHJlbW92ZUxWaWV3RnJvbUxDb250YWluZXIobENvbnRhaW5lciwgdmlld0luQ29udGFpbmVySWR4KTtcblxuICAgIC8vIEluZGV4IC0xIGlzIGEgc3BlY2lhbCBjYXNlIHdoZXJlIG5vbmUgb2YgdGhlIGNvbmRpdGlvbnMgZXZhbHVhdGVzIHRvXG4gICAgLy8gYSB0cnV0aHkgdmFsdWUgYW5kIGFzIHRoZSBjb25zZXF1ZW5jZSB3ZSd2ZSBnb3Qgbm8gdmlldyB0byBzaG93LlxuICAgIGlmIChtYXRjaGluZ1RlbXBsYXRlSW5kZXggIT09IC0xKSB7XG4gICAgICBjb25zdCB0ZW1wbGF0ZVROb2RlID0gZ2V0RXhpc3RpbmdUTm9kZShob3N0TFZpZXdbVFZJRVddLCBtYXRjaGluZ1RlbXBsYXRlSW5kZXgpO1xuICAgICAgY29uc3QgZW1iZWRkZWRMVmlldyA9IGNyZWF0ZUFuZFJlbmRlckVtYmVkZGVkTFZpZXcoaG9zdExWaWV3LCB0ZW1wbGF0ZVROb2RlLCB2YWx1ZSk7XG5cbiAgICAgIGFkZExWaWV3VG9MQ29udGFpbmVyKGxDb250YWluZXIsIGVtYmVkZGVkTFZpZXcsIHZpZXdJbkNvbnRhaW5lcklkeCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFdlIG1pZ2h0IGtlZXAgZGlzcGxheWluZyB0aGUgc2FtZSB0ZW1wbGF0ZSBidXQgdGhlIGFjdHVhbCB2YWx1ZSBvZiB0aGUgZXhwcmVzc2lvbiBjb3VsZCBoYXZlXG4gICAgLy8gY2hhbmdlZCAtIHJlLWJpbmQgaW4gY29udGV4dC5cbiAgICBjb25zdCBsVmlldyA9IGdldExWaWV3RnJvbUxDb250YWluZXI8VHx1bmRlZmluZWQ+KGxDb250YWluZXIsIHZpZXdJbkNvbnRhaW5lcklkeCk7XG4gICAgaWYgKGxWaWV3ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGxWaWV3W0NPTlRFWFRdID0gdmFsdWU7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBSZXBlYXRlckNvbnRleHQ8VD4ge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGxDb250YWluZXI6IExDb250YWluZXIsIHB1YmxpYyAkaW1wbGljaXQ6IFQsIHB1YmxpYyAkaW5kZXg6IG51bWJlcikge31cblxuICBnZXQgJGNvdW50KCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMubENvbnRhaW5lci5sZW5ndGggLSBDT05UQUlORVJfSEVBREVSX09GRlNFVDtcbiAgfVxufVxuXG4vKipcbiAqIEEgYnVpbHQtaW4gdHJhY2tCeSBmdW5jdGlvbiB1c2VkIGZvciBzaXR1YXRpb25zIHdoZXJlIHVzZXJzIHNwZWNpZmllZCBjb2xsZWN0aW9uIGluZGV4IGFzIGFcbiAqIHRyYWNraW5nIGV4cHJlc3Npb24uIEhhdmluZyB0aGlzIGZ1bmN0aW9uIGJvZHkgaW4gdGhlIHJ1bnRpbWUgYXZvaWRzIHVubmVjZXNzYXJ5IGNvZGUgZ2VuZXJhdGlvbi5cbiAqXG4gKiBAcGFyYW0gaW5kZXhcbiAqIEByZXR1cm5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiDJtcm1cmVwZWF0ZXJUcmFja0J5SW5kZXgoaW5kZXg6IG51bWJlcikge1xuICByZXR1cm4gaW5kZXg7XG59XG5cbi8qKlxuICogQSBidWlsdC1pbiB0cmFja0J5IGZ1bmN0aW9uIHVzZWQgZm9yIHNpdHVhdGlvbnMgd2hlcmUgdXNlcnMgc3BlY2lmaWVkIGNvbGxlY3Rpb24gaXRlbSByZWZlcmVuY2VcbiAqIGFzIGEgdHJhY2tpbmcgZXhwcmVzc2lvbi4gSGF2aW5nIHRoaXMgZnVuY3Rpb24gYm9keSBpbiB0aGUgcnVudGltZSBhdm9pZHMgdW5uZWNlc3NhcnkgY29kZVxuICogZ2VuZXJhdGlvbi5cbiAqXG4gKiBAcGFyYW0gaW5kZXhcbiAqIEByZXR1cm5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiDJtcm1cmVwZWF0ZXJUcmFja0J5SWRlbnRpdHk8VD4oXzogbnVtYmVyLCB2YWx1ZTogVCkge1xuICByZXR1cm4gdmFsdWU7XG59XG5cbmNsYXNzIFJlcGVhdGVyTWV0YWRhdGEge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgaGFzRW1wdHlCbG9jazogYm9vbGVhbiwgcHVibGljIGRpZmZlcjogRGVmYXVsdEl0ZXJhYmxlRGlmZmVyPHVua25vd24+KSB7fVxufVxuXG4vKipcbiAqIFRoZSByZXBlYXRlckNyZWF0ZSBpbnN0cnVjdGlvbiBydW5zIGluIHRoZSBjcmVhdGlvbiBwYXJ0IG9mIHRoZSB0ZW1wbGF0ZSBwYXNzIGFuZCBpbml0aWFsaXplc1xuICogaW50ZXJuYWwgZGF0YSBzdHJ1Y3R1cmVzIHJlcXVpcmVkIGJ5IHRoZSB1cGRhdGUgcGFzcyBvZiB0aGUgYnVpbHQtaW4gcmVwZWF0ZXIgbG9naWMuIFJlcGVhdGVyXG4gKiBtZXRhZGF0YSBhcmUgYWxsb2NhdGVkIGluIHRoZSBkYXRhIHBhcnQgb2YgTFZpZXcgd2l0aCB0aGUgZm9sbG93aW5nIGxheW91dDpcbiAqIC0gTFZpZXdbSEVBREVSX09GRlNFVCArIGluZGV4XSAtIG1ldGFkYXRhXG4gKiAtIExWaWV3W0hFQURFUl9PRkZTRVQgKyBpbmRleCArIDFdIC0gcmVmZXJlbmNlIHRvIGEgdGVtcGxhdGUgZnVuY3Rpb24gcmVuZGVyaW5nIGFuIGl0ZW1cbiAqIC0gTFZpZXdbSEVBREVSX09GRlNFVCArIGluZGV4ICsgMl0gLSBvcHRpb25hbCByZWZlcmVuY2UgdG8gYSB0ZW1wbGF0ZSBmdW5jdGlvbiByZW5kZXJpbmcgYW4gZW1wdHlcbiAqIGJsb2NrXG4gKlxuICogQGNvZGVHZW5BcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIMm1ybVyZXBlYXRlckNyZWF0ZShcbiAgICBpbmRleDogbnVtYmVyLCB0ZW1wbGF0ZUZuOiBDb21wb25lbnRUZW1wbGF0ZTx1bmtub3duPiwgZGVjbHM6IG51bWJlciwgdmFyczogbnVtYmVyLFxuICAgIHRyYWNrQnlGbjogVHJhY2tCeUZ1bmN0aW9uPHVua25vd24+LCBlbXB0eVRlbXBsYXRlRm4/OiBDb21wb25lbnRUZW1wbGF0ZTx1bmtub3duPixcbiAgICBlbXB0eURlY2xzPzogbnVtYmVyLCBlbXB0eVZhcnM/OiBudW1iZXIpOiB2b2lkIHtcbiAgY29uc3QgaGFzRW1wdHlCbG9jayA9IGVtcHR5VGVtcGxhdGVGbiAhPT0gdW5kZWZpbmVkO1xuICBjb25zdCBob3N0TFZpZXcgPSBnZXRMVmlldygpO1xuICBjb25zdCBtZXRhZGF0YSA9IG5ldyBSZXBlYXRlck1ldGFkYXRhKGhhc0VtcHR5QmxvY2ssIG5ldyBEZWZhdWx0SXRlcmFibGVEaWZmZXIodHJhY2tCeUZuKSk7XG4gIGhvc3RMVmlld1tIRUFERVJfT0ZGU0VUICsgaW5kZXhdID0gbWV0YWRhdGE7XG5cbiAgybXJtXRlbXBsYXRlKGluZGV4ICsgMSwgdGVtcGxhdGVGbiwgZGVjbHMsIHZhcnMpO1xuXG4gIGlmIChoYXNFbXB0eUJsb2NrKSB7XG4gICAgbmdEZXZNb2RlICYmXG4gICAgICAgIGFzc2VydERlZmluZWQoZW1wdHlEZWNscywgJ01pc3NpbmcgbnVtYmVyIG9mIGRlY2xhcmF0aW9ucyBmb3IgdGhlIGVtcHR5IHJlcGVhdGVyIGJsb2NrLicpO1xuICAgIG5nRGV2TW9kZSAmJlxuICAgICAgICBhc3NlcnREZWZpbmVkKGVtcHR5VmFycywgJ01pc3NpbmcgbnVtYmVyIG9mIGJpbmRpbmdzIGZvciB0aGUgZW1wdHkgcmVwZWF0ZXIgYmxvY2suJyk7XG5cbiAgICDJtcm1dGVtcGxhdGUoaW5kZXggKyAyLCBlbXB0eVRlbXBsYXRlRm4sIGVtcHR5RGVjbHMhLCBlbXB0eVZhcnMhKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSByZXBlYXRlciBpbnN0cnVjdGlvbiBkb2VzIHVwZGF0ZS10aW1lIGRpZmZpbmcgb2YgYSBwcm92aWRlZCBjb2xsZWN0aW9uIChhZ2FpbnN0IHRoZVxuICogY29sbGVjdGlvbiBzZWVuIHByZXZpb3VzbHkpIGFuZCBtYXBzIGNoYW5nZXMgaW4gdGhlIGNvbGxlY3Rpb24gdG8gdmlld3Mgc3RydWN0dXJlIChieSBhZGRpbmcsXG4gKiByZW1vdmluZyBvciBtb3Zpbmcgdmlld3MgYXMgbmVlZGVkKS5cbiAqIEBwYXJhbSBtZXRhZGF0YVNsb3RJZHggLSBpbmRleCBpbiBkYXRhIHdoZXJlIHdlIGNhbiBmaW5kIGFuIGluc3RhbmNlIG9mIFJlcGVhdGVyTWV0YWRhdGEgd2l0aFxuICogICAgIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gKGV4LiBkaWZmZXIpIG5lZWRlZCB0byBwcm9jZXNzIGNvbGxlY3Rpb24gZGlmZmluZyBhbmQgdmlld1xuICogICAgIG1hbmlwdWxhdGlvblxuICogQHBhcmFtIGNvbGxlY3Rpb24gLSB0aGUgY29sbGVjdGlvbiBpbnN0YW5jZSB0byBiZSBjaGVja2VkIGZvciBjaGFuZ2VzXG4gKiBAY29kZUdlbkFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gybXJtXJlcGVhdGVyKFxuICAgIG1ldGFkYXRhU2xvdElkeDogbnVtYmVyLCBjb2xsZWN0aW9uOiBJdGVyYWJsZTx1bmtub3duPnx1bmRlZmluZWR8bnVsbCk6IHZvaWQge1xuICBjb25zdCBob3N0TFZpZXcgPSBnZXRMVmlldygpO1xuICBjb25zdCBob3N0VFZpZXcgPSBob3N0TFZpZXdbVFZJRVddO1xuICBjb25zdCBtZXRhZGF0YSA9IGhvc3RMVmlld1tIRUFERVJfT0ZGU0VUICsgbWV0YWRhdGFTbG90SWR4XSBhcyBSZXBlYXRlck1ldGFkYXRhO1xuXG4gIGNvbnN0IGRpZmZlciA9IG1ldGFkYXRhLmRpZmZlcjtcbiAgY29uc3QgY2hhbmdlcyA9IGRpZmZlci5kaWZmKGNvbGxlY3Rpb24pO1xuXG4gIC8vIGhhbmRsZSByZXBlYXRlciBjaGFuZ2VzXG4gIGlmIChjaGFuZ2VzICE9PSBudWxsKSB7XG4gICAgY29uc3QgY29udGFpbmVySW5kZXggPSBtZXRhZGF0YVNsb3RJZHggKyAxO1xuICAgIGNvbnN0IGl0ZW1UZW1wbGF0ZVROb2RlID0gZ2V0RXhpc3RpbmdUTm9kZShob3N0VFZpZXcsIGNvbnRhaW5lckluZGV4KTtcbiAgICBjb25zdCBsQ29udGFpbmVyID0gZ2V0TENvbnRhaW5lcihob3N0TFZpZXcsIEhFQURFUl9PRkZTRVQgKyBjb250YWluZXJJbmRleCk7XG4gICAgbGV0IG5lZWRzSW5kZXhVcGRhdGUgPSBmYWxzZTtcbiAgICBjaGFuZ2VzLmZvckVhY2hPcGVyYXRpb24oXG4gICAgICAgIChpdGVtOiBJdGVyYWJsZUNoYW5nZVJlY29yZDx1bmtub3duPiwgYWRqdXN0ZWRQcmV2aW91c0luZGV4OiBudW1iZXJ8bnVsbCxcbiAgICAgICAgIGN1cnJlbnRJbmRleDogbnVtYmVyfG51bGwpID0+IHtcbiAgICAgICAgICBpZiAoaXRlbS5wcmV2aW91c0luZGV4ID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBhZGRcbiAgICAgICAgICAgIGNvbnN0IG5ld1ZpZXdJZHggPSBhZGp1c3RUb0xhc3RMQ29udGFpbmVySW5kZXgobENvbnRhaW5lciwgY3VycmVudEluZGV4KTtcbiAgICAgICAgICAgIGNvbnN0IGVtYmVkZGVkTFZpZXcgPSBjcmVhdGVBbmRSZW5kZXJFbWJlZGRlZExWaWV3KFxuICAgICAgICAgICAgICAgIGhvc3RMVmlldywgaXRlbVRlbXBsYXRlVE5vZGUsXG4gICAgICAgICAgICAgICAgbmV3IFJlcGVhdGVyQ29udGV4dChsQ29udGFpbmVyLCBpdGVtLml0ZW0sIG5ld1ZpZXdJZHgpKTtcbiAgICAgICAgICAgIGFkZExWaWV3VG9MQ29udGFpbmVyKGxDb250YWluZXIsIGVtYmVkZGVkTFZpZXcsIG5ld1ZpZXdJZHgpO1xuICAgICAgICAgICAgbmVlZHNJbmRleFVwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50SW5kZXggPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZVxuICAgICAgICAgICAgYWRqdXN0ZWRQcmV2aW91c0luZGV4ID0gYWRqdXN0VG9MYXN0TENvbnRhaW5lckluZGV4KGxDb250YWluZXIsIGFkanVzdGVkUHJldmlvdXNJbmRleCk7XG4gICAgICAgICAgICByZW1vdmVMVmlld0Zyb21MQ29udGFpbmVyKGxDb250YWluZXIsIGFkanVzdGVkUHJldmlvdXNJbmRleCk7XG4gICAgICAgICAgICBuZWVkc0luZGV4VXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGFkanVzdGVkUHJldmlvdXNJbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gbW92ZVxuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdMVmlldyA9XG4gICAgICAgICAgICAgICAgZGV0YWNoRXhpc3RpbmdWaWV3PFJlcGVhdGVyQ29udGV4dDx1bmtub3duPj4obENvbnRhaW5lciwgYWRqdXN0ZWRQcmV2aW91c0luZGV4KTtcbiAgICAgICAgICAgIGFkZExWaWV3VG9MQ29udGFpbmVyKGxDb250YWluZXIsIGV4aXN0aW5nTFZpZXcsIGN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICBuZWVkc0luZGV4VXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgLy8gQSB0cmFja0J5IGZ1bmN0aW9uIG1pZ2h0IHJldHVybiB0aGUgc2FtZSB2YWx1ZSBldmVuIGlmIHRoZSB1bmRlcmx5aW5nIGl0ZW0gY2hhbmdlZCAtIHJlLWJpbmRcbiAgICAvLyBpdCBpbiB0aGUgY29udGV4dC5cbiAgICBjaGFuZ2VzLmZvckVhY2hJZGVudGl0eUNoYW5nZSgocmVjb3JkOiBJdGVyYWJsZUNoYW5nZVJlY29yZDx1bmtub3duPikgPT4ge1xuICAgICAgY29uc3Qgdmlld0lkeCA9IGFkanVzdFRvTGFzdExDb250YWluZXJJbmRleChsQ29udGFpbmVyLCByZWNvcmQuY3VycmVudEluZGV4KTtcbiAgICAgIGNvbnN0IGxWaWV3ID0gZ2V0RXhpc3RpbmdMVmlld0Zyb21MQ29udGFpbmVyPFJlcGVhdGVyQ29udGV4dDx1bmtub3duPj4obENvbnRhaW5lciwgdmlld0lkeCk7XG4gICAgICBsVmlld1tDT05URVhUXS4kaW1wbGljaXQgPSByZWNvcmQuaXRlbTtcbiAgICB9KTtcblxuICAgIC8vIG1vdmVzIGluIHRoZSBjb250YWluZXIgbWlnaHQgY2F1c2VkIGNvbnRleHQncyBpbmRleCB0byBnZXQgb3V0IG9mIG9yZGVyLCByZS1hZGp1c3RcbiAgICBpZiAobmVlZHNJbmRleFVwZGF0ZSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsQ29udGFpbmVyLmxlbmd0aCAtIENPTlRBSU5FUl9IRUFERVJfT0ZGU0VUOyBpKyspIHtcbiAgICAgICAgY29uc3QgbFZpZXcgPSBnZXRFeGlzdGluZ0xWaWV3RnJvbUxDb250YWluZXI8UmVwZWF0ZXJDb250ZXh0PHVua25vd24+PihsQ29udGFpbmVyLCBpKTtcbiAgICAgICAgbFZpZXdbQ09OVEVYVF0uJGluZGV4ID0gaTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBoYW5kbGUgZW1wdHkgYmxvY2tzXG4gIGNvbnN0IGJpbmRpbmdJbmRleCA9IG5leHRCaW5kaW5nSW5kZXgoKTtcbiAgaWYgKG1ldGFkYXRhLmhhc0VtcHR5QmxvY2spIHtcbiAgICBjb25zdCBoYXNJdGVtc0luQ29sbGVjdGlvbiA9IGRpZmZlci5sZW5ndGggPiAwO1xuICAgIGlmIChiaW5kaW5nVXBkYXRlZChob3N0TFZpZXcsIGJpbmRpbmdJbmRleCwgaGFzSXRlbXNJbkNvbGxlY3Rpb24pKSB7XG4gICAgICBjb25zdCBlbXB0eVRlbXBsYXRlSW5kZXggPSBtZXRhZGF0YVNsb3RJZHggKyAyO1xuICAgICAgY29uc3QgbENvbnRhaW5lciA9IGdldExDb250YWluZXIoaG9zdExWaWV3LCBIRUFERVJfT0ZGU0VUICsgZW1wdHlUZW1wbGF0ZUluZGV4KTtcbiAgICAgIGlmIChoYXNJdGVtc0luQ29sbGVjdGlvbikge1xuICAgICAgICByZW1vdmVMVmlld0Zyb21MQ29udGFpbmVyKGxDb250YWluZXIsIDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZW1wdHlUZW1wbGF0ZVROb2RlID0gZ2V0RXhpc3RpbmdUTm9kZShob3N0VFZpZXcsIGVtcHR5VGVtcGxhdGVJbmRleCk7XG4gICAgICAgIGNvbnN0IGVtYmVkZGVkTFZpZXcgPVxuICAgICAgICAgICAgY3JlYXRlQW5kUmVuZGVyRW1iZWRkZWRMVmlldyhob3N0TFZpZXcsIGVtcHR5VGVtcGxhdGVUTm9kZSwgdW5kZWZpbmVkKTtcbiAgICAgICAgYWRkTFZpZXdUb0xDb250YWluZXIobENvbnRhaW5lciwgZW1iZWRkZWRMVmlldywgMCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldExDb250YWluZXIobFZpZXc6IExWaWV3LCBpbmRleDogbnVtYmVyKTogTENvbnRhaW5lciB7XG4gIGNvbnN0IGxDb250YWluZXIgPSBsVmlld1tpbmRleF07XG4gIG5nRGV2TW9kZSAmJiBhc3NlcnRMQ29udGFpbmVyKGxDb250YWluZXIpO1xuXG4gIHJldHVybiBsQ29udGFpbmVyO1xufVxuXG5mdW5jdGlvbiBhZGp1c3RUb0xhc3RMQ29udGFpbmVySW5kZXgobENvbnRhaW5lcjogTENvbnRhaW5lciwgaW5kZXg6IG51bWJlcnxudWxsKTogbnVtYmVyIHtcbiAgcmV0dXJuIGluZGV4ICE9PSBudWxsID8gaW5kZXggOiBsQ29udGFpbmVyLmxlbmd0aCAtIENPTlRBSU5FUl9IRUFERVJfT0ZGU0VUO1xufVxuXG5mdW5jdGlvbiBkZXRhY2hFeGlzdGluZ1ZpZXc8VD4obENvbnRhaW5lcjogTENvbnRhaW5lciwgaW5kZXg6IG51bWJlcik6IExWaWV3PFQ+IHtcbiAgY29uc3QgZXhpc3RpbmdMVmlldyA9IGRldGFjaFZpZXcobENvbnRhaW5lciwgaW5kZXgpO1xuICBuZ0Rldk1vZGUgJiYgYXNzZXJ0TFZpZXcoZXhpc3RpbmdMVmlldyk7XG5cbiAgcmV0dXJuIGV4aXN0aW5nTFZpZXcgYXMgTFZpZXc8VD47XG59XG5cbmZ1bmN0aW9uIGdldEV4aXN0aW5nTFZpZXdGcm9tTENvbnRhaW5lcjxUPihsQ29udGFpbmVyOiBMQ29udGFpbmVyLCBpbmRleDogbnVtYmVyKTogTFZpZXc8VD4ge1xuICBjb25zdCBleGlzdGluZ0xWaWV3ID0gZ2V0TFZpZXdGcm9tTENvbnRhaW5lcjxUPihsQ29udGFpbmVyLCBpbmRleCk7XG4gIG5nRGV2TW9kZSAmJiBhc3NlcnRMVmlldyhleGlzdGluZ0xWaWV3KTtcblxuICByZXR1cm4gZXhpc3RpbmdMVmlldyE7XG59XG5cbmZ1bmN0aW9uIGdldEV4aXN0aW5nVE5vZGUodFZpZXc6IFRWaWV3LCBpbmRleDogbnVtYmVyKTogVE5vZGUge1xuICBjb25zdCB0Tm9kZSA9IGdldFROb2RlKHRWaWV3LCBpbmRleCArIEhFQURFUl9PRkZTRVQpO1xuICBuZ0Rldk1vZGUgJiYgYXNzZXJ0VE5vZGUodE5vZGUpO1xuXG4gIHJldHVybiB0Tm9kZTtcbn1cbiJdfQ==
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { DefaultIterableDiffer } from '../../change_detection';
import { findMatchingDehydratedView } from '../../hydration/views';
import { assertDefined } from '../../util/assert';
import { assertLContainer, assertLView, assertTNode } from '../assert';
import { bindingUpdated } from '../bindings';
import { CONTAINER_HEADER_OFFSET } from '../interfaces/container';
import { CONTEXT, DECLARATION_COMPONENT_VIEW, HEADER_OFFSET, TVIEW } from '../interfaces/view';
import { detachView } from '../node_manipulation';
import { getLView, nextBindingIndex } from '../state';
import { getTNode } from '../util/view_utils';
import { addLViewToLContainer, createAndRenderEmbeddedLView, getLViewFromLContainer, removeLViewFromLContainer, shouldAddViewToDom } from '../view_manipulation';
import { ɵɵtemplate } from './template';
/**
 * The conditional instruction represents the basic building block on the runtime side to support
 * built-in "if" and "switch". On the high level this instruction is responsible for adding and
 * removing views selected by a conditional expression.
 *
 * @param containerIndex index of a container in a host view (indexed from HEADER_OFFSET) where
 *     conditional views should be inserted.
 * @param matchingTemplateIndex index of a template TNode representing a conditional view to be
 *     inserted; -1 represents a special case when there is no view to insert.
 * @codeGenApi
 */
export function ɵɵconditional(containerIndex, matchingTemplateIndex, value) {
    const hostLView = getLView();
    const bindingIndex = nextBindingIndex();
    const lContainer = getLContainer(hostLView, HEADER_OFFSET + containerIndex);
    const viewInContainerIdx = 0;
    if (bindingUpdated(hostLView, bindingIndex, matchingTemplateIndex)) {
        // The index of the view to show changed - remove the previously displayed one
        // (it is a noop if there are no active views in a container).
        removeLViewFromLContainer(lContainer, viewInContainerIdx);
        // Index -1 is a special case where none of the conditions evaluates to
        // a truthy value and as the consequence we've got no view to show.
        if (matchingTemplateIndex !== -1) {
            const templateTNode = getExistingTNode(hostLView[TVIEW], matchingTemplateIndex);
            const dehydratedView = findMatchingDehydratedView(lContainer, templateTNode.tView.ssrId);
            const embeddedLView = createAndRenderEmbeddedLView(hostLView, templateTNode, value, { dehydratedView });
            addLViewToLContainer(lContainer, embeddedLView, viewInContainerIdx, shouldAddViewToDom(templateTNode, dehydratedView));
        }
    }
    else {
        // We might keep displaying the same template but the actual value of the expression could have
        // changed - re-bind in context.
        const lView = getLViewFromLContainer(lContainer, viewInContainerIdx);
        if (lView !== undefined) {
            lView[CONTEXT] = value;
        }
    }
}
export class RepeaterContext {
    constructor(lContainer, $implicit, $index) {
        this.lContainer = lContainer;
        this.$implicit = $implicit;
        this.$index = $index;
    }
    get $count() {
        return this.lContainer.length - CONTAINER_HEADER_OFFSET;
    }
}
/**
 * A built-in trackBy function used for situations where users specified collection index as a
 * tracking expression. Having this function body in the runtime avoids unnecessary code generation.
 *
 * @param index
 * @returns
 */
export function ɵɵrepeaterTrackByIndex(index) {
    return index;
}
/**
 * A built-in trackBy function used for situations where users specified collection item reference
 * as a tracking expression. Having this function body in the runtime avoids unnecessary code
 * generation.
 *
 * @param index
 * @returns
 */
export function ɵɵrepeaterTrackByIdentity(_, value) {
    return value;
}
class RepeaterMetadata {
    constructor(hasEmptyBlock, differ) {
        this.hasEmptyBlock = hasEmptyBlock;
        this.differ = differ;
    }
}
/**
 * The repeaterCreate instruction runs in the creation part of the template pass and initializes
 * internal data structures required by the update pass of the built-in repeater logic. Repeater
 * metadata are allocated in the data part of LView with the following layout:
 * - LView[HEADER_OFFSET + index] - metadata
 * - LView[HEADER_OFFSET + index + 1] - reference to a template function rendering an item
 * - LView[HEADER_OFFSET + index + 2] - optional reference to a template function rendering an empty
 * block
 *
 * @param index Index at which to store the metadata of the repeater.
 * @param templateFn Reference to the template of the main repeater block.
 * @param decls The number of nodes, local refs, and pipes for the main block.
 * @param vars The number of bindings for the main block.
 * @param trackByFn Reference to the tracking function.
 * @param trackByUsesComponentInstance Whether the tracking function has any references to the
 *  component instance. If it doesn't, we can avoid rebinding it.
 * @param emptyTemplateFn Reference to the template function of the empty block.
 * @param emptyDecls The number of nodes, local refs, and pipes for the empty block.
 * @param emptyVars The number of bindings for the empty block.
 *
 * @codeGenApi
 */
export function ɵɵrepeaterCreate(index, templateFn, decls, vars, trackByFn, trackByUsesComponentInstance, emptyTemplateFn, emptyDecls, emptyVars) {
    const hasEmptyBlock = emptyTemplateFn !== undefined;
    const hostLView = getLView();
    const boundTrackBy = trackByUsesComponentInstance ?
        // We only want to bind when necessary, because it produces a
        // new function. For pure functions it's not necessary.
        trackByFn.bind(hostLView[DECLARATION_COMPONENT_VIEW][CONTEXT]) :
        trackByFn;
    const metadata = new RepeaterMetadata(hasEmptyBlock, new DefaultIterableDiffer(boundTrackBy));
    hostLView[HEADER_OFFSET + index] = metadata;
    ɵɵtemplate(index + 1, templateFn, decls, vars);
    if (hasEmptyBlock) {
        ngDevMode &&
            assertDefined(emptyDecls, 'Missing number of declarations for the empty repeater block.');
        ngDevMode &&
            assertDefined(emptyVars, 'Missing number of bindings for the empty repeater block.');
        ɵɵtemplate(index + 2, emptyTemplateFn, emptyDecls, emptyVars);
    }
}
/**
 * The repeater instruction does update-time diffing of a provided collection (against the
 * collection seen previously) and maps changes in the collection to views structure (by adding,
 * removing or moving views as needed).
 * @param metadataSlotIdx - index in data where we can find an instance of RepeaterMetadata with
 *     additional information (ex. differ) needed to process collection diffing and view
 *     manipulation
 * @param collection - the collection instance to be checked for changes
 * @codeGenApi
 */
export function ɵɵrepeater(metadataSlotIdx, collection) {
    const hostLView = getLView();
    const hostTView = hostLView[TVIEW];
    const metadata = hostLView[HEADER_OFFSET + metadataSlotIdx];
    const differ = metadata.differ;
    const changes = differ.diff(collection);
    // handle repeater changes
    if (changes !== null) {
        const containerIndex = metadataSlotIdx + 1;
        const itemTemplateTNode = getExistingTNode(hostTView, containerIndex);
        const lContainer = getLContainer(hostLView, HEADER_OFFSET + containerIndex);
        let needsIndexUpdate = false;
        changes.forEachOperation((item, adjustedPreviousIndex, currentIndex) => {
            if (item.previousIndex === null) {
                // add
                const newViewIdx = adjustToLastLContainerIndex(lContainer, currentIndex);
                const dehydratedView = findMatchingDehydratedView(lContainer, itemTemplateTNode.tView.ssrId);
                const embeddedLView = createAndRenderEmbeddedLView(hostLView, itemTemplateTNode, new RepeaterContext(lContainer, item.item, newViewIdx), { dehydratedView });
                addLViewToLContainer(lContainer, embeddedLView, newViewIdx, shouldAddViewToDom(itemTemplateTNode, dehydratedView));
                needsIndexUpdate = true;
            }
            else if (currentIndex === null) {
                // remove
                adjustedPreviousIndex = adjustToLastLContainerIndex(lContainer, adjustedPreviousIndex);
                removeLViewFromLContainer(lContainer, adjustedPreviousIndex);
                needsIndexUpdate = true;
            }
            else if (adjustedPreviousIndex !== null) {
                // move
                const existingLView = detachExistingView(lContainer, adjustedPreviousIndex);
                addLViewToLContainer(lContainer, existingLView, currentIndex);
                needsIndexUpdate = true;
            }
        });
        // A trackBy function might return the same value even if the underlying item changed - re-bind
        // it in the context.
        changes.forEachIdentityChange((record) => {
            const viewIdx = adjustToLastLContainerIndex(lContainer, record.currentIndex);
            const lView = getExistingLViewFromLContainer(lContainer, viewIdx);
            lView[CONTEXT].$implicit = record.item;
        });
        // moves in the container might caused context's index to get out of order, re-adjust
        if (needsIndexUpdate) {
            for (let i = 0; i < lContainer.length - CONTAINER_HEADER_OFFSET; i++) {
                const lView = getExistingLViewFromLContainer(lContainer, i);
                lView[CONTEXT].$index = i;
            }
        }
    }
    // handle empty blocks
    const bindingIndex = nextBindingIndex();
    if (metadata.hasEmptyBlock) {
        const hasItemsInCollection = differ.length > 0;
        if (bindingUpdated(hostLView, bindingIndex, hasItemsInCollection)) {
            const emptyTemplateIndex = metadataSlotIdx + 2;
            const lContainer = getLContainer(hostLView, HEADER_OFFSET + emptyTemplateIndex);
            if (hasItemsInCollection) {
                removeLViewFromLContainer(lContainer, 0);
            }
            else {
                const emptyTemplateTNode = getExistingTNode(hostTView, emptyTemplateIndex);
                const dehydratedView = findMatchingDehydratedView(lContainer, emptyTemplateTNode.tView.ssrId);
                const embeddedLView = createAndRenderEmbeddedLView(hostLView, emptyTemplateTNode, undefined, { dehydratedView });
                addLViewToLContainer(lContainer, embeddedLView, 0, shouldAddViewToDom(emptyTemplateTNode, dehydratedView));
            }
        }
    }
}
function getLContainer(lView, index) {
    const lContainer = lView[index];
    ngDevMode && assertLContainer(lContainer);
    return lContainer;
}
function adjustToLastLContainerIndex(lContainer, index) {
    return index !== null ? index : lContainer.length - CONTAINER_HEADER_OFFSET;
}
function detachExistingView(lContainer, index) {
    const existingLView = detachView(lContainer, index);
    ngDevMode && assertLView(existingLView);
    return existingLView;
}
function getExistingLViewFromLContainer(lContainer, index) {
    const existingLView = getLViewFromLContainer(lContainer, index);
    ngDevMode && assertLView(existingLView);
    return existingLView;
}
function getExistingTNode(tView, index) {
    const tNode = getTNode(tView, index + HEADER_OFFSET);
    ngDevMode && assertTNode(tNode);
    return tNode;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udHJvbF9mbG93LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvY29yZS9zcmMvcmVuZGVyMy9pbnN0cnVjdGlvbnMvY29udHJvbF9mbG93LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7R0FNRztBQUVILE9BQU8sRUFBQyxxQkFBcUIsRUFBd0MsTUFBTSx3QkFBd0IsQ0FBQztBQUNwRyxPQUFPLEVBQUMsMEJBQTBCLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUNqRSxPQUFPLEVBQUMsYUFBYSxFQUFDLE1BQU0sbUJBQW1CLENBQUM7QUFDaEQsT0FBTyxFQUFDLGdCQUFnQixFQUFFLFdBQVcsRUFBRSxXQUFXLEVBQUMsTUFBTSxXQUFXLENBQUM7QUFDckUsT0FBTyxFQUFDLGNBQWMsRUFBQyxNQUFNLGFBQWEsQ0FBQztBQUMzQyxPQUFPLEVBQUMsdUJBQXVCLEVBQWEsTUFBTSx5QkFBeUIsQ0FBQztBQUc1RSxPQUFPLEVBQUMsT0FBTyxFQUFFLDBCQUEwQixFQUFFLGFBQWEsRUFBUyxLQUFLLEVBQVEsTUFBTSxvQkFBb0IsQ0FBQztBQUMzRyxPQUFPLEVBQUMsVUFBVSxFQUFDLE1BQU0sc0JBQXNCLENBQUM7QUFDaEQsT0FBTyxFQUFDLFFBQVEsRUFBRSxnQkFBZ0IsRUFBQyxNQUFNLFVBQVUsQ0FBQztBQUNwRCxPQUFPLEVBQUMsUUFBUSxFQUFDLE1BQU0sb0JBQW9CLENBQUM7QUFDNUMsT0FBTyxFQUFDLG9CQUFvQixFQUFFLDRCQUE0QixFQUFFLHNCQUFzQixFQUFFLHlCQUF5QixFQUFFLGtCQUFrQixFQUFDLE1BQU0sc0JBQXNCLENBQUM7QUFFL0osT0FBTyxFQUFDLFVBQVUsRUFBQyxNQUFNLFlBQVksQ0FBQztBQUV0Qzs7Ozs7Ozs7OztHQVVHO0FBQ0gsTUFBTSxVQUFVLGFBQWEsQ0FBSSxjQUFzQixFQUFFLHFCQUE2QixFQUFFLEtBQVM7SUFDL0YsTUFBTSxTQUFTLEdBQUcsUUFBUSxFQUFFLENBQUM7SUFDN0IsTUFBTSxZQUFZLEdBQUcsZ0JBQWdCLEVBQUUsQ0FBQztJQUN4QyxNQUFNLFVBQVUsR0FBRyxhQUFhLENBQUMsU0FBUyxFQUFFLGFBQWEsR0FBRyxjQUFjLENBQUMsQ0FBQztJQUM1RSxNQUFNLGtCQUFrQixHQUFHLENBQUMsQ0FBQztJQUU3QixJQUFJLGNBQWMsQ0FBQyxTQUFTLEVBQUUsWUFBWSxFQUFFLHFCQUFxQixDQUFDLEVBQUU7UUFDbEUsOEVBQThFO1FBQzlFLDhEQUE4RDtRQUM5RCx5QkFBeUIsQ0FBQyxVQUFVLEVBQUUsa0JBQWtCLENBQUMsQ0FBQztRQUUxRCx1RUFBdUU7UUFDdkUsbUVBQW1FO1FBQ25FLElBQUkscUJBQXFCLEtBQUssQ0FBQyxDQUFDLEVBQUU7WUFDaEMsTUFBTSxhQUFhLEdBQUcsZ0JBQWdCLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxFQUFFLHFCQUFxQixDQUFDLENBQUM7WUFFaEYsTUFBTSxjQUFjLEdBQUcsMEJBQTBCLENBQUMsVUFBVSxFQUFFLGFBQWEsQ0FBQyxLQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDMUYsTUFBTSxhQUFhLEdBQ2YsNEJBQTRCLENBQUMsU0FBUyxFQUFFLGFBQWEsRUFBRSxLQUFLLEVBQUUsRUFBQyxjQUFjLEVBQUMsQ0FBQyxDQUFDO1lBRXBGLG9CQUFvQixDQUNoQixVQUFVLEVBQUUsYUFBYSxFQUFFLGtCQUFrQixFQUM3QyxrQkFBa0IsQ0FBQyxhQUFhLEVBQUUsY0FBYyxDQUFDLENBQUMsQ0FBQztTQUN4RDtLQUNGO1NBQU07UUFDTCwrRkFBK0Y7UUFDL0YsZ0NBQWdDO1FBQ2hDLE1BQU0sS0FBSyxHQUFHLHNCQUFzQixDQUFjLFVBQVUsRUFBRSxrQkFBa0IsQ0FBQyxDQUFDO1FBQ2xGLElBQUksS0FBSyxLQUFLLFNBQVMsRUFBRTtZQUN2QixLQUFLLENBQUMsT0FBTyxDQUFDLEdBQUcsS0FBSyxDQUFDO1NBQ3hCO0tBQ0Y7QUFDSCxDQUFDO0FBRUQsTUFBTSxPQUFPLGVBQWU7SUFDMUIsWUFBb0IsVUFBc0IsRUFBUyxTQUFZLEVBQVMsTUFBYztRQUFsRSxlQUFVLEdBQVYsVUFBVSxDQUFZO1FBQVMsY0FBUyxHQUFULFNBQVMsQ0FBRztRQUFTLFdBQU0sR0FBTixNQUFNLENBQVE7SUFBRyxDQUFDO0lBRTFGLElBQUksTUFBTTtRQUNSLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLEdBQUcsdUJBQXVCLENBQUM7SUFDMUQsQ0FBQztDQUNGO0FBRUQ7Ozs7OztHQU1HO0FBQ0gsTUFBTSxVQUFVLHNCQUFzQixDQUFDLEtBQWE7SUFDbEQsT0FBTyxLQUFLLENBQUM7QUFDZixDQUFDO0FBRUQ7Ozs7Ozs7R0FPRztBQUNILE1BQU0sVUFBVSx5QkFBeUIsQ0FBSSxDQUFTLEVBQUUsS0FBUTtJQUM5RCxPQUFPLEtBQUssQ0FBQztBQUNmLENBQUM7QUFFRCxNQUFNLGdCQUFnQjtJQUNwQixZQUFtQixhQUFzQixFQUFTLE1BQXNDO1FBQXJFLGtCQUFhLEdBQWIsYUFBYSxDQUFTO1FBQVMsV0FBTSxHQUFOLE1BQU0sQ0FBZ0M7SUFBRyxDQUFDO0NBQzdGO0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXFCRztBQUNILE1BQU0sVUFBVSxnQkFBZ0IsQ0FDNUIsS0FBYSxFQUFFLFVBQXNDLEVBQUUsS0FBYSxFQUFFLElBQVksRUFDbEYsU0FBbUMsRUFBRSw0QkFBc0MsRUFDM0UsZUFBNEMsRUFBRSxVQUFtQixFQUFFLFNBQWtCO0lBQ3ZGLE1BQU0sYUFBYSxHQUFHLGVBQWUsS0FBSyxTQUFTLENBQUM7SUFDcEQsTUFBTSxTQUFTLEdBQUcsUUFBUSxFQUFFLENBQUM7SUFDN0IsTUFBTSxZQUFZLEdBQUcsNEJBQTRCLENBQUMsQ0FBQztRQUMvQyw2REFBNkQ7UUFDN0QsdURBQXVEO1FBQ3ZELFNBQVMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLDBCQUEwQixDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ2hFLFNBQVMsQ0FBQztJQUNkLE1BQU0sUUFBUSxHQUFHLElBQUksZ0JBQWdCLENBQUMsYUFBYSxFQUFFLElBQUkscUJBQXFCLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQztJQUM5RixTQUFTLENBQUMsYUFBYSxHQUFHLEtBQUssQ0FBQyxHQUFHLFFBQVEsQ0FBQztJQUU1QyxVQUFVLENBQUMsS0FBSyxHQUFHLENBQUMsRUFBRSxVQUFVLEVBQUUsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDO0lBRS9DLElBQUksYUFBYSxFQUFFO1FBQ2pCLFNBQVM7WUFDTCxhQUFhLENBQUMsVUFBVSxFQUFFLDhEQUE4RCxDQUFDLENBQUM7UUFDOUYsU0FBUztZQUNMLGFBQWEsQ0FBQyxTQUFTLEVBQUUsMERBQTBELENBQUMsQ0FBQztRQUV6RixVQUFVLENBQUMsS0FBSyxHQUFHLENBQUMsRUFBRSxlQUFlLEVBQUUsVUFBVyxFQUFFLFNBQVUsQ0FBQyxDQUFDO0tBQ2pFO0FBQ0gsQ0FBQztBQUVEOzs7Ozs7Ozs7R0FTRztBQUNILE1BQU0sVUFBVSxVQUFVLENBQ3RCLGVBQXVCLEVBQUUsVUFBNEM7SUFDdkUsTUFBTSxTQUFTLEdBQUcsUUFBUSxFQUFFLENBQUM7SUFDN0IsTUFBTSxTQUFTLEdBQUcsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ25DLE1BQU0sUUFBUSxHQUFHLFNBQVMsQ0FBQyxhQUFhLEdBQUcsZUFBZSxDQUFxQixDQUFDO0lBRWhGLE1BQU0sTUFBTSxHQUFHLFFBQVEsQ0FBQyxNQUFNLENBQUM7SUFDL0IsTUFBTSxPQUFPLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUV4QywwQkFBMEI7SUFDMUIsSUFBSSxPQUFPLEtBQUssSUFBSSxFQUFFO1FBQ3BCLE1BQU0sY0FBYyxHQUFHLGVBQWUsR0FBRyxDQUFDLENBQUM7UUFDM0MsTUFBTSxpQkFBaUIsR0FBRyxnQkFBZ0IsQ0FBQyxTQUFTLEVBQUUsY0FBYyxDQUFDLENBQUM7UUFDdEUsTUFBTSxVQUFVLEdBQUcsYUFBYSxDQUFDLFNBQVMsRUFBRSxhQUFhLEdBQUcsY0FBYyxDQUFDLENBQUM7UUFDNUUsSUFBSSxnQkFBZ0IsR0FBRyxLQUFLLENBQUM7UUFDN0IsT0FBTyxDQUFDLGdCQUFnQixDQUNwQixDQUFDLElBQW1DLEVBQUUscUJBQWtDLEVBQ3ZFLFlBQXlCLEVBQUUsRUFBRTtZQUM1QixJQUFJLElBQUksQ0FBQyxhQUFhLEtBQUssSUFBSSxFQUFFO2dCQUMvQixNQUFNO2dCQUNOLE1BQU0sVUFBVSxHQUFHLDJCQUEyQixDQUFDLFVBQVUsRUFBRSxZQUFZLENBQUMsQ0FBQztnQkFDekUsTUFBTSxjQUFjLEdBQ2hCLDBCQUEwQixDQUFDLFVBQVUsRUFBRSxpQkFBaUIsQ0FBQyxLQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7Z0JBQzNFLE1BQU0sYUFBYSxHQUFHLDRCQUE0QixDQUM5QyxTQUFTLEVBQUUsaUJBQWlCLEVBQzVCLElBQUksZUFBZSxDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsSUFBSSxFQUFFLFVBQVUsQ0FBQyxFQUFFLEVBQUMsY0FBYyxFQUFDLENBQUMsQ0FBQztnQkFDOUUsb0JBQW9CLENBQ2hCLFVBQVUsRUFBRSxhQUFhLEVBQUUsVUFBVSxFQUNyQyxrQkFBa0IsQ0FBQyxpQkFBaUIsRUFBRSxjQUFjLENBQUMsQ0FBQyxDQUFDO2dCQUMzRCxnQkFBZ0IsR0FBRyxJQUFJLENBQUM7YUFDekI7aUJBQU0sSUFBSSxZQUFZLEtBQUssSUFBSSxFQUFFO2dCQUNoQyxTQUFTO2dCQUNULHFCQUFxQixHQUFHLDJCQUEyQixDQUFDLFVBQVUsRUFBRSxxQkFBcUIsQ0FBQyxDQUFDO2dCQUN2Rix5QkFBeUIsQ0FBQyxVQUFVLEVBQUUscUJBQXFCLENBQUMsQ0FBQztnQkFDN0QsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDO2FBQ3pCO2lCQUFNLElBQUkscUJBQXFCLEtBQUssSUFBSSxFQUFFO2dCQUN6QyxPQUFPO2dCQUNQLE1BQU0sYUFBYSxHQUNmLGtCQUFrQixDQUEyQixVQUFVLEVBQUUscUJBQXFCLENBQUMsQ0FBQztnQkFDcEYsb0JBQW9CLENBQUMsVUFBVSxFQUFFLGFBQWEsRUFBRSxZQUFZLENBQUMsQ0FBQztnQkFDOUQsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDO2FBQ3pCO1FBQ0gsQ0FBQyxDQUFDLENBQUM7UUFFUCwrRkFBK0Y7UUFDL0YscUJBQXFCO1FBQ3JCLE9BQU8sQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDLE1BQXFDLEVBQUUsRUFBRTtZQUN0RSxNQUFNLE9BQU8sR0FBRywyQkFBMkIsQ0FBQyxVQUFVLEVBQUUsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDO1lBQzdFLE1BQU0sS0FBSyxHQUFHLDhCQUE4QixDQUEyQixVQUFVLEVBQUUsT0FBTyxDQUFDLENBQUM7WUFDNUYsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLFNBQVMsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDO1FBQ3pDLENBQUMsQ0FBQyxDQUFDO1FBRUgscUZBQXFGO1FBQ3JGLElBQUksZ0JBQWdCLEVBQUU7WUFDcEIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFVBQVUsQ0FBQyxNQUFNLEdBQUcsdUJBQXVCLEVBQUUsQ0FBQyxFQUFFLEVBQUU7Z0JBQ3BFLE1BQU0sS0FBSyxHQUFHLDhCQUE4QixDQUEyQixVQUFVLEVBQUUsQ0FBQyxDQUFDLENBQUM7Z0JBQ3RGLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO2FBQzNCO1NBQ0Y7S0FDRjtJQUVELHNCQUFzQjtJQUN0QixNQUFNLFlBQVksR0FBRyxnQkFBZ0IsRUFBRSxDQUFDO0lBQ3hDLElBQUksUUFBUSxDQUFDLGFBQWEsRUFBRTtRQUMxQixNQUFNLG9CQUFvQixHQUFHLE1BQU0sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO1FBQy9DLElBQUksY0FBYyxDQUFDLFNBQVMsRUFBRSxZQUFZLEVBQUUsb0JBQW9CLENBQUMsRUFBRTtZQUNqRSxNQUFNLGtCQUFrQixHQUFHLGVBQWUsR0FBRyxDQUFDLENBQUM7WUFDL0MsTUFBTSxVQUFVLEdBQUcsYUFBYSxDQUFDLFNBQVMsRUFBRSxhQUFhLEdBQUcsa0JBQWtCLENBQUMsQ0FBQztZQUNoRixJQUFJLG9CQUFvQixFQUFFO2dCQUN4Qix5QkFBeUIsQ0FBQyxVQUFVLEVBQUUsQ0FBQyxDQUFDLENBQUM7YUFDMUM7aUJBQU07Z0JBQ0wsTUFBTSxrQkFBa0IsR0FBRyxnQkFBZ0IsQ0FBQyxTQUFTLEVBQUUsa0JBQWtCLENBQUMsQ0FBQztnQkFDM0UsTUFBTSxjQUFjLEdBQ2hCLDBCQUEwQixDQUFDLFVBQVUsRUFBRSxrQkFBa0IsQ0FBQyxLQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7Z0JBQzVFLE1BQU0sYUFBYSxHQUFHLDRCQUE0QixDQUM5QyxTQUFTLEVBQUUsa0JBQWtCLEVBQUUsU0FBUyxFQUFFLEVBQUMsY0FBYyxFQUFDLENBQUMsQ0FBQztnQkFDaEUsb0JBQW9CLENBQ2hCLFVBQVUsRUFBRSxhQUFhLEVBQUUsQ0FBQyxFQUFFLGtCQUFrQixDQUFDLGtCQUFrQixFQUFFLGNBQWMsQ0FBQyxDQUFDLENBQUM7YUFDM0Y7U0FDRjtLQUNGO0FBQ0gsQ0FBQztBQUVELFNBQVMsYUFBYSxDQUFDLEtBQVksRUFBRSxLQUFhO0lBQ2hELE1BQU0sVUFBVSxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNoQyxTQUFTLElBQUksZ0JBQWdCLENBQUMsVUFBVSxDQUFDLENBQUM7SUFFMUMsT0FBTyxVQUFVLENBQUM7QUFDcEIsQ0FBQztBQUVELFNBQVMsMkJBQTJCLENBQUMsVUFBc0IsRUFBRSxLQUFrQjtJQUM3RSxPQUFPLEtBQUssS0FBSyxJQUFJLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLE1BQU0sR0FBRyx1QkFBdUIsQ0FBQztBQUM5RSxDQUFDO0FBRUQsU0FBUyxrQkFBa0IsQ0FBSSxVQUFzQixFQUFFLEtBQWE7SUFDbEUsTUFBTSxhQUFhLEdBQUcsVUFBVSxDQUFDLFVBQVUsRUFBRSxLQUFLLENBQUMsQ0FBQztJQUNwRCxTQUFTLElBQUksV0FBVyxDQUFDLGFBQWEsQ0FBQyxDQUFDO0lBRXhDLE9BQU8sYUFBeUIsQ0FBQztBQUNuQyxDQUFDO0FBRUQsU0FBUyw4QkFBOEIsQ0FBSSxVQUFzQixFQUFFLEtBQWE7SUFDOUUsTUFBTSxhQUFhLEdBQUcsc0JBQXNCLENBQUksVUFBVSxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQ25FLFNBQVMsSUFBSSxXQUFXLENBQUMsYUFBYSxDQUFDLENBQUM7SUFFeEMsT0FBTyxhQUFjLENBQUM7QUFDeEIsQ0FBQztBQUVELFNBQVMsZ0JBQWdCLENBQUMsS0FBWSxFQUFFLEtBQWE7SUFDbkQsTUFBTSxLQUFLLEdBQUcsUUFBUSxDQUFDLEtBQUssRUFBRSxLQUFLLEdBQUcsYUFBYSxDQUFDLENBQUM7SUFDckQsU0FBUyxJQUFJLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUVoQyxPQUFPLEtBQUssQ0FBQztBQUNmLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuaW1wb3J0IHtEZWZhdWx0SXRlcmFibGVEaWZmZXIsIEl0ZXJhYmxlQ2hhbmdlUmVjb3JkLCBUcmFja0J5RnVuY3Rpb259IGZyb20gJy4uLy4uL2NoYW5nZV9kZXRlY3Rpb24nO1xuaW1wb3J0IHtmaW5kTWF0Y2hpbmdEZWh5ZHJhdGVkVmlld30gZnJvbSAnLi4vLi4vaHlkcmF0aW9uL3ZpZXdzJztcbmltcG9ydCB7YXNzZXJ0RGVmaW5lZH0gZnJvbSAnLi4vLi4vdXRpbC9hc3NlcnQnO1xuaW1wb3J0IHthc3NlcnRMQ29udGFpbmVyLCBhc3NlcnRMVmlldywgYXNzZXJ0VE5vZGV9IGZyb20gJy4uL2Fzc2VydCc7XG5pbXBvcnQge2JpbmRpbmdVcGRhdGVkfSBmcm9tICcuLi9iaW5kaW5ncyc7XG5pbXBvcnQge0NPTlRBSU5FUl9IRUFERVJfT0ZGU0VULCBMQ29udGFpbmVyfSBmcm9tICcuLi9pbnRlcmZhY2VzL2NvbnRhaW5lcic7XG5pbXBvcnQge0NvbXBvbmVudFRlbXBsYXRlfSBmcm9tICcuLi9pbnRlcmZhY2VzL2RlZmluaXRpb24nO1xuaW1wb3J0IHtUTm9kZX0gZnJvbSAnLi4vaW50ZXJmYWNlcy9ub2RlJztcbmltcG9ydCB7Q09OVEVYVCwgREVDTEFSQVRJT05fQ09NUE9ORU5UX1ZJRVcsIEhFQURFUl9PRkZTRVQsIExWaWV3LCBUVklFVywgVFZpZXd9IGZyb20gJy4uL2ludGVyZmFjZXMvdmlldyc7XG5pbXBvcnQge2RldGFjaFZpZXd9IGZyb20gJy4uL25vZGVfbWFuaXB1bGF0aW9uJztcbmltcG9ydCB7Z2V0TFZpZXcsIG5leHRCaW5kaW5nSW5kZXh9IGZyb20gJy4uL3N0YXRlJztcbmltcG9ydCB7Z2V0VE5vZGV9IGZyb20gJy4uL3V0aWwvdmlld191dGlscyc7XG5pbXBvcnQge2FkZExWaWV3VG9MQ29udGFpbmVyLCBjcmVhdGVBbmRSZW5kZXJFbWJlZGRlZExWaWV3LCBnZXRMVmlld0Zyb21MQ29udGFpbmVyLCByZW1vdmVMVmlld0Zyb21MQ29udGFpbmVyLCBzaG91bGRBZGRWaWV3VG9Eb219IGZyb20gJy4uL3ZpZXdfbWFuaXB1bGF0aW9uJztcblxuaW1wb3J0IHvJtcm1dGVtcGxhdGV9IGZyb20gJy4vdGVtcGxhdGUnO1xuXG4vKipcbiAqIFRoZSBjb25kaXRpb25hbCBpbnN0cnVjdGlvbiByZXByZXNlbnRzIHRoZSBiYXNpYyBidWlsZGluZyBibG9jayBvbiB0aGUgcnVudGltZSBzaWRlIHRvIHN1cHBvcnRcbiAqIGJ1aWx0LWluIFwiaWZcIiBhbmQgXCJzd2l0Y2hcIi4gT24gdGhlIGhpZ2ggbGV2ZWwgdGhpcyBpbnN0cnVjdGlvbiBpcyByZXNwb25zaWJsZSBmb3IgYWRkaW5nIGFuZFxuICogcmVtb3Zpbmcgdmlld3Mgc2VsZWN0ZWQgYnkgYSBjb25kaXRpb25hbCBleHByZXNzaW9uLlxuICpcbiAqIEBwYXJhbSBjb250YWluZXJJbmRleCBpbmRleCBvZiBhIGNvbnRhaW5lciBpbiBhIGhvc3QgdmlldyAoaW5kZXhlZCBmcm9tIEhFQURFUl9PRkZTRVQpIHdoZXJlXG4gKiAgICAgY29uZGl0aW9uYWwgdmlld3Mgc2hvdWxkIGJlIGluc2VydGVkLlxuICogQHBhcmFtIG1hdGNoaW5nVGVtcGxhdGVJbmRleCBpbmRleCBvZiBhIHRlbXBsYXRlIFROb2RlIHJlcHJlc2VudGluZyBhIGNvbmRpdGlvbmFsIHZpZXcgdG8gYmVcbiAqICAgICBpbnNlcnRlZDsgLTEgcmVwcmVzZW50cyBhIHNwZWNpYWwgY2FzZSB3aGVuIHRoZXJlIGlzIG5vIHZpZXcgdG8gaW5zZXJ0LlxuICogQGNvZGVHZW5BcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIMm1ybVjb25kaXRpb25hbDxUPihjb250YWluZXJJbmRleDogbnVtYmVyLCBtYXRjaGluZ1RlbXBsYXRlSW5kZXg6IG51bWJlciwgdmFsdWU/OiBUKSB7XG4gIGNvbnN0IGhvc3RMVmlldyA9IGdldExWaWV3KCk7XG4gIGNvbnN0IGJpbmRpbmdJbmRleCA9IG5leHRCaW5kaW5nSW5kZXgoKTtcbiAgY29uc3QgbENvbnRhaW5lciA9IGdldExDb250YWluZXIoaG9zdExWaWV3LCBIRUFERVJfT0ZGU0VUICsgY29udGFpbmVySW5kZXgpO1xuICBjb25zdCB2aWV3SW5Db250YWluZXJJZHggPSAwO1xuXG4gIGlmIChiaW5kaW5nVXBkYXRlZChob3N0TFZpZXcsIGJpbmRpbmdJbmRleCwgbWF0Y2hpbmdUZW1wbGF0ZUluZGV4KSkge1xuICAgIC8vIFRoZSBpbmRleCBvZiB0aGUgdmlldyB0byBzaG93IGNoYW5nZWQgLSByZW1vdmUgdGhlIHByZXZpb3VzbHkgZGlzcGxheWVkIG9uZVxuICAgIC8vIChpdCBpcyBhIG5vb3AgaWYgdGhlcmUgYXJlIG5vIGFjdGl2ZSB2aWV3cyBpbiBhIGNvbnRhaW5lcikuXG4gICAgcmVtb3ZlTFZpZXdGcm9tTENvbnRhaW5lcihsQ29udGFpbmVyLCB2aWV3SW5Db250YWluZXJJZHgpO1xuXG4gICAgLy8gSW5kZXggLTEgaXMgYSBzcGVjaWFsIGNhc2Ugd2hlcmUgbm9uZSBvZiB0aGUgY29uZGl0aW9ucyBldmFsdWF0ZXMgdG9cbiAgICAvLyBhIHRydXRoeSB2YWx1ZSBhbmQgYXMgdGhlIGNvbnNlcXVlbmNlIHdlJ3ZlIGdvdCBubyB2aWV3IHRvIHNob3cuXG4gICAgaWYgKG1hdGNoaW5nVGVtcGxhdGVJbmRleCAhPT0gLTEpIHtcbiAgICAgIGNvbnN0IHRlbXBsYXRlVE5vZGUgPSBnZXRFeGlzdGluZ1ROb2RlKGhvc3RMVmlld1tUVklFV10sIG1hdGNoaW5nVGVtcGxhdGVJbmRleCk7XG5cbiAgICAgIGNvbnN0IGRlaHlkcmF0ZWRWaWV3ID0gZmluZE1hdGNoaW5nRGVoeWRyYXRlZFZpZXcobENvbnRhaW5lciwgdGVtcGxhdGVUTm9kZS50VmlldyEuc3NySWQpO1xuICAgICAgY29uc3QgZW1iZWRkZWRMVmlldyA9XG4gICAgICAgICAgY3JlYXRlQW5kUmVuZGVyRW1iZWRkZWRMVmlldyhob3N0TFZpZXcsIHRlbXBsYXRlVE5vZGUsIHZhbHVlLCB7ZGVoeWRyYXRlZFZpZXd9KTtcblxuICAgICAgYWRkTFZpZXdUb0xDb250YWluZXIoXG4gICAgICAgICAgbENvbnRhaW5lciwgZW1iZWRkZWRMVmlldywgdmlld0luQ29udGFpbmVySWR4LFxuICAgICAgICAgIHNob3VsZEFkZFZpZXdUb0RvbSh0ZW1wbGF0ZVROb2RlLCBkZWh5ZHJhdGVkVmlldykpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBXZSBtaWdodCBrZWVwIGRpc3BsYXlpbmcgdGhlIHNhbWUgdGVtcGxhdGUgYnV0IHRoZSBhY3R1YWwgdmFsdWUgb2YgdGhlIGV4cHJlc3Npb24gY291bGQgaGF2ZVxuICAgIC8vIGNoYW5nZWQgLSByZS1iaW5kIGluIGNvbnRleHQuXG4gICAgY29uc3QgbFZpZXcgPSBnZXRMVmlld0Zyb21MQ29udGFpbmVyPFR8dW5kZWZpbmVkPihsQ29udGFpbmVyLCB2aWV3SW5Db250YWluZXJJZHgpO1xuICAgIGlmIChsVmlldyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBsVmlld1tDT05URVhUXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgUmVwZWF0ZXJDb250ZXh0PFQ+IHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBsQ29udGFpbmVyOiBMQ29udGFpbmVyLCBwdWJsaWMgJGltcGxpY2l0OiBULCBwdWJsaWMgJGluZGV4OiBudW1iZXIpIHt9XG5cbiAgZ2V0ICRjb3VudCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmxDb250YWluZXIubGVuZ3RoIC0gQ09OVEFJTkVSX0hFQURFUl9PRkZTRVQ7XG4gIH1cbn1cblxuLyoqXG4gKiBBIGJ1aWx0LWluIHRyYWNrQnkgZnVuY3Rpb24gdXNlZCBmb3Igc2l0dWF0aW9ucyB3aGVyZSB1c2VycyBzcGVjaWZpZWQgY29sbGVjdGlvbiBpbmRleCBhcyBhXG4gKiB0cmFja2luZyBleHByZXNzaW9uLiBIYXZpbmcgdGhpcyBmdW5jdGlvbiBib2R5IGluIHRoZSBydW50aW1lIGF2b2lkcyB1bm5lY2Vzc2FyeSBjb2RlIGdlbmVyYXRpb24uXG4gKlxuICogQHBhcmFtIGluZGV4XG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gybXJtXJlcGVhdGVyVHJhY2tCeUluZGV4KGluZGV4OiBudW1iZXIpIHtcbiAgcmV0dXJuIGluZGV4O1xufVxuXG4vKipcbiAqIEEgYnVpbHQtaW4gdHJhY2tCeSBmdW5jdGlvbiB1c2VkIGZvciBzaXR1YXRpb25zIHdoZXJlIHVzZXJzIHNwZWNpZmllZCBjb2xsZWN0aW9uIGl0ZW0gcmVmZXJlbmNlXG4gKiBhcyBhIHRyYWNraW5nIGV4cHJlc3Npb24uIEhhdmluZyB0aGlzIGZ1bmN0aW9uIGJvZHkgaW4gdGhlIHJ1bnRpbWUgYXZvaWRzIHVubmVjZXNzYXJ5IGNvZGVcbiAqIGdlbmVyYXRpb24uXG4gKlxuICogQHBhcmFtIGluZGV4XG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gybXJtXJlcGVhdGVyVHJhY2tCeUlkZW50aXR5PFQ+KF86IG51bWJlciwgdmFsdWU6IFQpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5jbGFzcyBSZXBlYXRlck1ldGFkYXRhIHtcbiAgY29uc3RydWN0b3IocHVibGljIGhhc0VtcHR5QmxvY2s6IGJvb2xlYW4sIHB1YmxpYyBkaWZmZXI6IERlZmF1bHRJdGVyYWJsZURpZmZlcjx1bmtub3duPikge31cbn1cblxuLyoqXG4gKiBUaGUgcmVwZWF0ZXJDcmVhdGUgaW5zdHJ1Y3Rpb24gcnVucyBpbiB0aGUgY3JlYXRpb24gcGFydCBvZiB0aGUgdGVtcGxhdGUgcGFzcyBhbmQgaW5pdGlhbGl6ZXNcbiAqIGludGVybmFsIGRhdGEgc3RydWN0dXJlcyByZXF1aXJlZCBieSB0aGUgdXBkYXRlIHBhc3Mgb2YgdGhlIGJ1aWx0LWluIHJlcGVhdGVyIGxvZ2ljLiBSZXBlYXRlclxuICogbWV0YWRhdGEgYXJlIGFsbG9jYXRlZCBpbiB0aGUgZGF0YSBwYXJ0IG9mIExWaWV3IHdpdGggdGhlIGZvbGxvd2luZyBsYXlvdXQ6XG4gKiAtIExWaWV3W0hFQURFUl9PRkZTRVQgKyBpbmRleF0gLSBtZXRhZGF0YVxuICogLSBMVmlld1tIRUFERVJfT0ZGU0VUICsgaW5kZXggKyAxXSAtIHJlZmVyZW5jZSB0byBhIHRlbXBsYXRlIGZ1bmN0aW9uIHJlbmRlcmluZyBhbiBpdGVtXG4gKiAtIExWaWV3W0hFQURFUl9PRkZTRVQgKyBpbmRleCArIDJdIC0gb3B0aW9uYWwgcmVmZXJlbmNlIHRvIGEgdGVtcGxhdGUgZnVuY3Rpb24gcmVuZGVyaW5nIGFuIGVtcHR5XG4gKiBibG9ja1xuICpcbiAqIEBwYXJhbSBpbmRleCBJbmRleCBhdCB3aGljaCB0byBzdG9yZSB0aGUgbWV0YWRhdGEgb2YgdGhlIHJlcGVhdGVyLlxuICogQHBhcmFtIHRlbXBsYXRlRm4gUmVmZXJlbmNlIHRvIHRoZSB0ZW1wbGF0ZSBvZiB0aGUgbWFpbiByZXBlYXRlciBibG9jay5cbiAqIEBwYXJhbSBkZWNscyBUaGUgbnVtYmVyIG9mIG5vZGVzLCBsb2NhbCByZWZzLCBhbmQgcGlwZXMgZm9yIHRoZSBtYWluIGJsb2NrLlxuICogQHBhcmFtIHZhcnMgVGhlIG51bWJlciBvZiBiaW5kaW5ncyBmb3IgdGhlIG1haW4gYmxvY2suXG4gKiBAcGFyYW0gdHJhY2tCeUZuIFJlZmVyZW5jZSB0byB0aGUgdHJhY2tpbmcgZnVuY3Rpb24uXG4gKiBAcGFyYW0gdHJhY2tCeVVzZXNDb21wb25lbnRJbnN0YW5jZSBXaGV0aGVyIHRoZSB0cmFja2luZyBmdW5jdGlvbiBoYXMgYW55IHJlZmVyZW5jZXMgdG8gdGhlXG4gKiAgY29tcG9uZW50IGluc3RhbmNlLiBJZiBpdCBkb2Vzbid0LCB3ZSBjYW4gYXZvaWQgcmViaW5kaW5nIGl0LlxuICogQHBhcmFtIGVtcHR5VGVtcGxhdGVGbiBSZWZlcmVuY2UgdG8gdGhlIHRlbXBsYXRlIGZ1bmN0aW9uIG9mIHRoZSBlbXB0eSBibG9jay5cbiAqIEBwYXJhbSBlbXB0eURlY2xzIFRoZSBudW1iZXIgb2Ygbm9kZXMsIGxvY2FsIHJlZnMsIGFuZCBwaXBlcyBmb3IgdGhlIGVtcHR5IGJsb2NrLlxuICogQHBhcmFtIGVtcHR5VmFycyBUaGUgbnVtYmVyIG9mIGJpbmRpbmdzIGZvciB0aGUgZW1wdHkgYmxvY2suXG4gKlxuICogQGNvZGVHZW5BcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIMm1ybVyZXBlYXRlckNyZWF0ZShcbiAgICBpbmRleDogbnVtYmVyLCB0ZW1wbGF0ZUZuOiBDb21wb25lbnRUZW1wbGF0ZTx1bmtub3duPiwgZGVjbHM6IG51bWJlciwgdmFyczogbnVtYmVyLFxuICAgIHRyYWNrQnlGbjogVHJhY2tCeUZ1bmN0aW9uPHVua25vd24+LCB0cmFja0J5VXNlc0NvbXBvbmVudEluc3RhbmNlPzogYm9vbGVhbixcbiAgICBlbXB0eVRlbXBsYXRlRm4/OiBDb21wb25lbnRUZW1wbGF0ZTx1bmtub3duPiwgZW1wdHlEZWNscz86IG51bWJlciwgZW1wdHlWYXJzPzogbnVtYmVyKTogdm9pZCB7XG4gIGNvbnN0IGhhc0VtcHR5QmxvY2sgPSBlbXB0eVRlbXBsYXRlRm4gIT09IHVuZGVmaW5lZDtcbiAgY29uc3QgaG9zdExWaWV3ID0gZ2V0TFZpZXcoKTtcbiAgY29uc3QgYm91bmRUcmFja0J5ID0gdHJhY2tCeVVzZXNDb21wb25lbnRJbnN0YW5jZSA/XG4gICAgICAvLyBXZSBvbmx5IHdhbnQgdG8gYmluZCB3aGVuIG5lY2Vzc2FyeSwgYmVjYXVzZSBpdCBwcm9kdWNlcyBhXG4gICAgICAvLyBuZXcgZnVuY3Rpb24uIEZvciBwdXJlIGZ1bmN0aW9ucyBpdCdzIG5vdCBuZWNlc3NhcnkuXG4gICAgICB0cmFja0J5Rm4uYmluZChob3N0TFZpZXdbREVDTEFSQVRJT05fQ09NUE9ORU5UX1ZJRVddW0NPTlRFWFRdKSA6XG4gICAgICB0cmFja0J5Rm47XG4gIGNvbnN0IG1ldGFkYXRhID0gbmV3IFJlcGVhdGVyTWV0YWRhdGEoaGFzRW1wdHlCbG9jaywgbmV3IERlZmF1bHRJdGVyYWJsZURpZmZlcihib3VuZFRyYWNrQnkpKTtcbiAgaG9zdExWaWV3W0hFQURFUl9PRkZTRVQgKyBpbmRleF0gPSBtZXRhZGF0YTtcblxuICDJtcm1dGVtcGxhdGUoaW5kZXggKyAxLCB0ZW1wbGF0ZUZuLCBkZWNscywgdmFycyk7XG5cbiAgaWYgKGhhc0VtcHR5QmxvY2spIHtcbiAgICBuZ0Rldk1vZGUgJiZcbiAgICAgICAgYXNzZXJ0RGVmaW5lZChlbXB0eURlY2xzLCAnTWlzc2luZyBudW1iZXIgb2YgZGVjbGFyYXRpb25zIGZvciB0aGUgZW1wdHkgcmVwZWF0ZXIgYmxvY2suJyk7XG4gICAgbmdEZXZNb2RlICYmXG4gICAgICAgIGFzc2VydERlZmluZWQoZW1wdHlWYXJzLCAnTWlzc2luZyBudW1iZXIgb2YgYmluZGluZ3MgZm9yIHRoZSBlbXB0eSByZXBlYXRlciBibG9jay4nKTtcblxuICAgIMm1ybV0ZW1wbGF0ZShpbmRleCArIDIsIGVtcHR5VGVtcGxhdGVGbiwgZW1wdHlEZWNscyEsIGVtcHR5VmFycyEpO1xuICB9XG59XG5cbi8qKlxuICogVGhlIHJlcGVhdGVyIGluc3RydWN0aW9uIGRvZXMgdXBkYXRlLXRpbWUgZGlmZmluZyBvZiBhIHByb3ZpZGVkIGNvbGxlY3Rpb24gKGFnYWluc3QgdGhlXG4gKiBjb2xsZWN0aW9uIHNlZW4gcHJldmlvdXNseSkgYW5kIG1hcHMgY2hhbmdlcyBpbiB0aGUgY29sbGVjdGlvbiB0byB2aWV3cyBzdHJ1Y3R1cmUgKGJ5IGFkZGluZyxcbiAqIHJlbW92aW5nIG9yIG1vdmluZyB2aWV3cyBhcyBuZWVkZWQpLlxuICogQHBhcmFtIG1ldGFkYXRhU2xvdElkeCAtIGluZGV4IGluIGRhdGEgd2hlcmUgd2UgY2FuIGZpbmQgYW4gaW5zdGFuY2Ugb2YgUmVwZWF0ZXJNZXRhZGF0YSB3aXRoXG4gKiAgICAgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiAoZXguIGRpZmZlcikgbmVlZGVkIHRvIHByb2Nlc3MgY29sbGVjdGlvbiBkaWZmaW5nIGFuZCB2aWV3XG4gKiAgICAgbWFuaXB1bGF0aW9uXG4gKiBAcGFyYW0gY29sbGVjdGlvbiAtIHRoZSBjb2xsZWN0aW9uIGluc3RhbmNlIHRvIGJlIGNoZWNrZWQgZm9yIGNoYW5nZXNcbiAqIEBjb2RlR2VuQXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiDJtcm1cmVwZWF0ZXIoXG4gICAgbWV0YWRhdGFTbG90SWR4OiBudW1iZXIsIGNvbGxlY3Rpb246IEl0ZXJhYmxlPHVua25vd24+fHVuZGVmaW5lZHxudWxsKTogdm9pZCB7XG4gIGNvbnN0IGhvc3RMVmlldyA9IGdldExWaWV3KCk7XG4gIGNvbnN0IGhvc3RUVmlldyA9IGhvc3RMVmlld1tUVklFV107XG4gIGNvbnN0IG1ldGFkYXRhID0gaG9zdExWaWV3W0hFQURFUl9PRkZTRVQgKyBtZXRhZGF0YVNsb3RJZHhdIGFzIFJlcGVhdGVyTWV0YWRhdGE7XG5cbiAgY29uc3QgZGlmZmVyID0gbWV0YWRhdGEuZGlmZmVyO1xuICBjb25zdCBjaGFuZ2VzID0gZGlmZmVyLmRpZmYoY29sbGVjdGlvbik7XG5cbiAgLy8gaGFuZGxlIHJlcGVhdGVyIGNoYW5nZXNcbiAgaWYgKGNoYW5nZXMgIT09IG51bGwpIHtcbiAgICBjb25zdCBjb250YWluZXJJbmRleCA9IG1ldGFkYXRhU2xvdElkeCArIDE7XG4gICAgY29uc3QgaXRlbVRlbXBsYXRlVE5vZGUgPSBnZXRFeGlzdGluZ1ROb2RlKGhvc3RUVmlldywgY29udGFpbmVySW5kZXgpO1xuICAgIGNvbnN0IGxDb250YWluZXIgPSBnZXRMQ29udGFpbmVyKGhvc3RMVmlldywgSEVBREVSX09GRlNFVCArIGNvbnRhaW5lckluZGV4KTtcbiAgICBsZXQgbmVlZHNJbmRleFVwZGF0ZSA9IGZhbHNlO1xuICAgIGNoYW5nZXMuZm9yRWFjaE9wZXJhdGlvbihcbiAgICAgICAgKGl0ZW06IEl0ZXJhYmxlQ2hhbmdlUmVjb3JkPHVua25vd24+LCBhZGp1c3RlZFByZXZpb3VzSW5kZXg6IG51bWJlcnxudWxsLFxuICAgICAgICAgY3VycmVudEluZGV4OiBudW1iZXJ8bnVsbCkgPT4ge1xuICAgICAgICAgIGlmIChpdGVtLnByZXZpb3VzSW5kZXggPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIGFkZFxuICAgICAgICAgICAgY29uc3QgbmV3Vmlld0lkeCA9IGFkanVzdFRvTGFzdExDb250YWluZXJJbmRleChsQ29udGFpbmVyLCBjdXJyZW50SW5kZXgpO1xuICAgICAgICAgICAgY29uc3QgZGVoeWRyYXRlZFZpZXcgPVxuICAgICAgICAgICAgICAgIGZpbmRNYXRjaGluZ0RlaHlkcmF0ZWRWaWV3KGxDb250YWluZXIsIGl0ZW1UZW1wbGF0ZVROb2RlLnRWaWV3IS5zc3JJZCk7XG4gICAgICAgICAgICBjb25zdCBlbWJlZGRlZExWaWV3ID0gY3JlYXRlQW5kUmVuZGVyRW1iZWRkZWRMVmlldyhcbiAgICAgICAgICAgICAgICBob3N0TFZpZXcsIGl0ZW1UZW1wbGF0ZVROb2RlLFxuICAgICAgICAgICAgICAgIG5ldyBSZXBlYXRlckNvbnRleHQobENvbnRhaW5lciwgaXRlbS5pdGVtLCBuZXdWaWV3SWR4KSwge2RlaHlkcmF0ZWRWaWV3fSk7XG4gICAgICAgICAgICBhZGRMVmlld1RvTENvbnRhaW5lcihcbiAgICAgICAgICAgICAgICBsQ29udGFpbmVyLCBlbWJlZGRlZExWaWV3LCBuZXdWaWV3SWR4LFxuICAgICAgICAgICAgICAgIHNob3VsZEFkZFZpZXdUb0RvbShpdGVtVGVtcGxhdGVUTm9kZSwgZGVoeWRyYXRlZFZpZXcpKTtcbiAgICAgICAgICAgIG5lZWRzSW5kZXhVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudEluZGV4ID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyByZW1vdmVcbiAgICAgICAgICAgIGFkanVzdGVkUHJldmlvdXNJbmRleCA9IGFkanVzdFRvTGFzdExDb250YWluZXJJbmRleChsQ29udGFpbmVyLCBhZGp1c3RlZFByZXZpb3VzSW5kZXgpO1xuICAgICAgICAgICAgcmVtb3ZlTFZpZXdGcm9tTENvbnRhaW5lcihsQ29udGFpbmVyLCBhZGp1c3RlZFByZXZpb3VzSW5kZXgpO1xuICAgICAgICAgICAgbmVlZHNJbmRleFVwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChhZGp1c3RlZFByZXZpb3VzSW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIG1vdmVcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nTFZpZXcgPVxuICAgICAgICAgICAgICAgIGRldGFjaEV4aXN0aW5nVmlldzxSZXBlYXRlckNvbnRleHQ8dW5rbm93bj4+KGxDb250YWluZXIsIGFkanVzdGVkUHJldmlvdXNJbmRleCk7XG4gICAgICAgICAgICBhZGRMVmlld1RvTENvbnRhaW5lcihsQ29udGFpbmVyLCBleGlzdGluZ0xWaWV3LCBjdXJyZW50SW5kZXgpO1xuICAgICAgICAgICAgbmVlZHNJbmRleFVwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgIC8vIEEgdHJhY2tCeSBmdW5jdGlvbiBtaWdodCByZXR1cm4gdGhlIHNhbWUgdmFsdWUgZXZlbiBpZiB0aGUgdW5kZXJseWluZyBpdGVtIGNoYW5nZWQgLSByZS1iaW5kXG4gICAgLy8gaXQgaW4gdGhlIGNvbnRleHQuXG4gICAgY2hhbmdlcy5mb3JFYWNoSWRlbnRpdHlDaGFuZ2UoKHJlY29yZDogSXRlcmFibGVDaGFuZ2VSZWNvcmQ8dW5rbm93bj4pID0+IHtcbiAgICAgIGNvbnN0IHZpZXdJZHggPSBhZGp1c3RUb0xhc3RMQ29udGFpbmVySW5kZXgobENvbnRhaW5lciwgcmVjb3JkLmN1cnJlbnRJbmRleCk7XG4gICAgICBjb25zdCBsVmlldyA9IGdldEV4aXN0aW5nTFZpZXdGcm9tTENvbnRhaW5lcjxSZXBlYXRlckNvbnRleHQ8dW5rbm93bj4+KGxDb250YWluZXIsIHZpZXdJZHgpO1xuICAgICAgbFZpZXdbQ09OVEVYVF0uJGltcGxpY2l0ID0gcmVjb3JkLml0ZW07XG4gICAgfSk7XG5cbiAgICAvLyBtb3ZlcyBpbiB0aGUgY29udGFpbmVyIG1pZ2h0IGNhdXNlZCBjb250ZXh0J3MgaW5kZXggdG8gZ2V0IG91dCBvZiBvcmRlciwgcmUtYWRqdXN0XG4gICAgaWYgKG5lZWRzSW5kZXhVcGRhdGUpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbENvbnRhaW5lci5sZW5ndGggLSBDT05UQUlORVJfSEVBREVSX09GRlNFVDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGxWaWV3ID0gZ2V0RXhpc3RpbmdMVmlld0Zyb21MQ29udGFpbmVyPFJlcGVhdGVyQ29udGV4dDx1bmtub3duPj4obENvbnRhaW5lciwgaSk7XG4gICAgICAgIGxWaWV3W0NPTlRFWFRdLiRpbmRleCA9IGk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gaGFuZGxlIGVtcHR5IGJsb2Nrc1xuICBjb25zdCBiaW5kaW5nSW5kZXggPSBuZXh0QmluZGluZ0luZGV4KCk7XG4gIGlmIChtZXRhZGF0YS5oYXNFbXB0eUJsb2NrKSB7XG4gICAgY29uc3QgaGFzSXRlbXNJbkNvbGxlY3Rpb24gPSBkaWZmZXIubGVuZ3RoID4gMDtcbiAgICBpZiAoYmluZGluZ1VwZGF0ZWQoaG9zdExWaWV3LCBiaW5kaW5nSW5kZXgsIGhhc0l0ZW1zSW5Db2xsZWN0aW9uKSkge1xuICAgICAgY29uc3QgZW1wdHlUZW1wbGF0ZUluZGV4ID0gbWV0YWRhdGFTbG90SWR4ICsgMjtcbiAgICAgIGNvbnN0IGxDb250YWluZXIgPSBnZXRMQ29udGFpbmVyKGhvc3RMVmlldywgSEVBREVSX09GRlNFVCArIGVtcHR5VGVtcGxhdGVJbmRleCk7XG4gICAgICBpZiAoaGFzSXRlbXNJbkNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmVtb3ZlTFZpZXdGcm9tTENvbnRhaW5lcihsQ29udGFpbmVyLCAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGVtcHR5VGVtcGxhdGVUTm9kZSA9IGdldEV4aXN0aW5nVE5vZGUoaG9zdFRWaWV3LCBlbXB0eVRlbXBsYXRlSW5kZXgpO1xuICAgICAgICBjb25zdCBkZWh5ZHJhdGVkVmlldyA9XG4gICAgICAgICAgICBmaW5kTWF0Y2hpbmdEZWh5ZHJhdGVkVmlldyhsQ29udGFpbmVyLCBlbXB0eVRlbXBsYXRlVE5vZGUudFZpZXchLnNzcklkKTtcbiAgICAgICAgY29uc3QgZW1iZWRkZWRMVmlldyA9IGNyZWF0ZUFuZFJlbmRlckVtYmVkZGVkTFZpZXcoXG4gICAgICAgICAgICBob3N0TFZpZXcsIGVtcHR5VGVtcGxhdGVUTm9kZSwgdW5kZWZpbmVkLCB7ZGVoeWRyYXRlZFZpZXd9KTtcbiAgICAgICAgYWRkTFZpZXdUb0xDb250YWluZXIoXG4gICAgICAgICAgICBsQ29udGFpbmVyLCBlbWJlZGRlZExWaWV3LCAwLCBzaG91bGRBZGRWaWV3VG9Eb20oZW1wdHlUZW1wbGF0ZVROb2RlLCBkZWh5ZHJhdGVkVmlldykpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRMQ29udGFpbmVyKGxWaWV3OiBMVmlldywgaW5kZXg6IG51bWJlcik6IExDb250YWluZXIge1xuICBjb25zdCBsQ29udGFpbmVyID0gbFZpZXdbaW5kZXhdO1xuICBuZ0Rldk1vZGUgJiYgYXNzZXJ0TENvbnRhaW5lcihsQ29udGFpbmVyKTtcblxuICByZXR1cm4gbENvbnRhaW5lcjtcbn1cblxuZnVuY3Rpb24gYWRqdXN0VG9MYXN0TENvbnRhaW5lckluZGV4KGxDb250YWluZXI6IExDb250YWluZXIsIGluZGV4OiBudW1iZXJ8bnVsbCk6IG51bWJlciB7XG4gIHJldHVybiBpbmRleCAhPT0gbnVsbCA/IGluZGV4IDogbENvbnRhaW5lci5sZW5ndGggLSBDT05UQUlORVJfSEVBREVSX09GRlNFVDtcbn1cblxuZnVuY3Rpb24gZGV0YWNoRXhpc3RpbmdWaWV3PFQ+KGxDb250YWluZXI6IExDb250YWluZXIsIGluZGV4OiBudW1iZXIpOiBMVmlldzxUPiB7XG4gIGNvbnN0IGV4aXN0aW5nTFZpZXcgPSBkZXRhY2hWaWV3KGxDb250YWluZXIsIGluZGV4KTtcbiAgbmdEZXZNb2RlICYmIGFzc2VydExWaWV3KGV4aXN0aW5nTFZpZXcpO1xuXG4gIHJldHVybiBleGlzdGluZ0xWaWV3IGFzIExWaWV3PFQ+O1xufVxuXG5mdW5jdGlvbiBnZXRFeGlzdGluZ0xWaWV3RnJvbUxDb250YWluZXI8VD4obENvbnRhaW5lcjogTENvbnRhaW5lciwgaW5kZXg6IG51bWJlcik6IExWaWV3PFQ+IHtcbiAgY29uc3QgZXhpc3RpbmdMVmlldyA9IGdldExWaWV3RnJvbUxDb250YWluZXI8VD4obENvbnRhaW5lciwgaW5kZXgpO1xuICBuZ0Rldk1vZGUgJiYgYXNzZXJ0TFZpZXcoZXhpc3RpbmdMVmlldyk7XG5cbiAgcmV0dXJuIGV4aXN0aW5nTFZpZXchO1xufVxuXG5mdW5jdGlvbiBnZXRFeGlzdGluZ1ROb2RlKHRWaWV3OiBUVmlldywgaW5kZXg6IG51bWJlcik6IFROb2RlIHtcbiAgY29uc3QgdE5vZGUgPSBnZXRUTm9kZSh0VmlldywgaW5kZXggKyBIRUFERVJfT0ZGU0VUKTtcbiAgbmdEZXZNb2RlICYmIGFzc2VydFROb2RlKHROb2RlKTtcblxuICByZXR1cm4gdE5vZGU7XG59XG4iXX0=
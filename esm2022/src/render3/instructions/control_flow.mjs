/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { DefaultIterableDiffer } from '../../change_detection';
import { assertDefined } from '../../util/assert';
import { assertLContainer, assertLView, assertTNode } from '../assert';
import { bindingUpdated } from '../bindings';
import { CONTAINER_HEADER_OFFSET } from '../interfaces/container';
import { CONTEXT, DECLARATION_COMPONENT_VIEW, HEADER_OFFSET, TVIEW } from '../interfaces/view';
import { detachView } from '../node_manipulation';
import { getLView, nextBindingIndex } from '../state';
import { getTNode } from '../util/view_utils';
import { addLViewToLContainer, createAndRenderEmbeddedLView, getLViewFromLContainer, removeLViewFromLContainer } from '../view_manipulation';
import { ɵɵtemplate } from './template';
/**
 * The conditional instruction represents the basic building block on the runtime side to support
 * built-in "if" and "switch". On the high level this instruction is responsible for adding and
 * removing views selected by a conditional expression.
 *
 * @param containerIndex index of a container in a host view (indexed from HEADER_OFFSET) where
 *     conditional views should be inserted.
 * @param matchingTemplateIndex index of a template TNode representing a conditional view to be
 *     inserted; -1 represents a special case when there is no view to insert.
 * @codeGenApi
 */
export function ɵɵconditional(containerIndex, matchingTemplateIndex, value) {
    const hostLView = getLView();
    const bindingIndex = nextBindingIndex();
    const lContainer = getLContainer(hostLView, HEADER_OFFSET + containerIndex);
    const viewInContainerIdx = 0;
    if (bindingUpdated(hostLView, bindingIndex, matchingTemplateIndex)) {
        // The index of the view to show changed - remove the previously displayed one
        // (it is a noop if there are no active views in a container).
        removeLViewFromLContainer(lContainer, viewInContainerIdx);
        // Index -1 is a special case where none of the conditions evaluates to
        // a truthy value and as the consequence we've got no view to show.
        if (matchingTemplateIndex !== -1) {
            const templateTNode = getExistingTNode(hostLView[TVIEW], matchingTemplateIndex);
            const embeddedLView = createAndRenderEmbeddedLView(hostLView, templateTNode, value);
            addLViewToLContainer(lContainer, embeddedLView, viewInContainerIdx);
        }
    }
    else {
        // We might keep displaying the same template but the actual value of the expression could have
        // changed - re-bind in context.
        const lView = getLViewFromLContainer(lContainer, viewInContainerIdx);
        if (lView !== undefined) {
            lView[CONTEXT] = value;
        }
    }
}
export class RepeaterContext {
    constructor(lContainer, $implicit, $index) {
        this.lContainer = lContainer;
        this.$implicit = $implicit;
        this.$index = $index;
    }
    get $count() {
        return this.lContainer.length - CONTAINER_HEADER_OFFSET;
    }
}
/**
 * A built-in trackBy function used for situations where users specified collection index as a
 * tracking expression. Having this function body in the runtime avoids unnecessary code generation.
 *
 * @param index
 * @returns
 */
export function ɵɵrepeaterTrackByIndex(index) {
    return index;
}
/**
 * A built-in trackBy function used for situations where users specified collection item reference
 * as a tracking expression. Having this function body in the runtime avoids unnecessary code
 * generation.
 *
 * @param index
 * @returns
 */
export function ɵɵrepeaterTrackByIdentity(_, value) {
    return value;
}
class RepeaterMetadata {
    constructor(hasEmptyBlock, differ) {
        this.hasEmptyBlock = hasEmptyBlock;
        this.differ = differ;
    }
}
/**
 * The repeaterCreate instruction runs in the creation part of the template pass and initializes
 * internal data structures required by the update pass of the built-in repeater logic. Repeater
 * metadata are allocated in the data part of LView with the following layout:
 * - LView[HEADER_OFFSET + index] - metadata
 * - LView[HEADER_OFFSET + index + 1] - reference to a template function rendering an item
 * - LView[HEADER_OFFSET + index + 2] - optional reference to a template function rendering an empty
 * block
 *
 * @param index Index at which to store the metadata of the repeater.
 * @param templateFn Reference to the template of the main repeater block.
 * @param decls The number of nodes, local refs, and pipes for the main block.
 * @param vars The number of bindings for the main block.
 * @param trackByFn Reference to the tracking function.
 * @param trackByUsesComponentInstance Whether the tracking function has any references to the
 *  component instance. If it doesn't, we can avoid rebinding it.
 * @param emptyTemplateFn Reference to the template function of the empty block.
 * @param emptyDecls The number of nodes, local refs, and pipes for the empty block.
 * @param emptyVars The number of bindings for the empty block.
 *
 * @codeGenApi
 */
export function ɵɵrepeaterCreate(index, templateFn, decls, vars, trackByFn, trackByUsesComponentInstance, emptyTemplateFn, emptyDecls, emptyVars) {
    const hasEmptyBlock = emptyTemplateFn !== undefined;
    const hostLView = getLView();
    const boundTrackBy = trackByUsesComponentInstance ?
        // We only want to bind when necessary, because it produces a
        // new function. For pure functions it's not necessary.
        trackByFn.bind(hostLView[DECLARATION_COMPONENT_VIEW][CONTEXT]) :
        trackByFn;
    const metadata = new RepeaterMetadata(hasEmptyBlock, new DefaultIterableDiffer(boundTrackBy));
    hostLView[HEADER_OFFSET + index] = metadata;
    ɵɵtemplate(index + 1, templateFn, decls, vars);
    if (hasEmptyBlock) {
        ngDevMode &&
            assertDefined(emptyDecls, 'Missing number of declarations for the empty repeater block.');
        ngDevMode &&
            assertDefined(emptyVars, 'Missing number of bindings for the empty repeater block.');
        ɵɵtemplate(index + 2, emptyTemplateFn, emptyDecls, emptyVars);
    }
}
/**
 * The repeater instruction does update-time diffing of a provided collection (against the
 * collection seen previously) and maps changes in the collection to views structure (by adding,
 * removing or moving views as needed).
 * @param metadataSlotIdx - index in data where we can find an instance of RepeaterMetadata with
 *     additional information (ex. differ) needed to process collection diffing and view
 *     manipulation
 * @param collection - the collection instance to be checked for changes
 * @codeGenApi
 */
export function ɵɵrepeater(metadataSlotIdx, collection) {
    const hostLView = getLView();
    const hostTView = hostLView[TVIEW];
    const metadata = hostLView[HEADER_OFFSET + metadataSlotIdx];
    const differ = metadata.differ;
    const changes = differ.diff(collection);
    // handle repeater changes
    if (changes !== null) {
        const containerIndex = metadataSlotIdx + 1;
        const itemTemplateTNode = getExistingTNode(hostTView, containerIndex);
        const lContainer = getLContainer(hostLView, HEADER_OFFSET + containerIndex);
        let needsIndexUpdate = false;
        changes.forEachOperation((item, adjustedPreviousIndex, currentIndex) => {
            if (item.previousIndex === null) {
                // add
                const newViewIdx = adjustToLastLContainerIndex(lContainer, currentIndex);
                const embeddedLView = createAndRenderEmbeddedLView(hostLView, itemTemplateTNode, new RepeaterContext(lContainer, item.item, newViewIdx));
                addLViewToLContainer(lContainer, embeddedLView, newViewIdx);
                needsIndexUpdate = true;
            }
            else if (currentIndex === null) {
                // remove
                adjustedPreviousIndex = adjustToLastLContainerIndex(lContainer, adjustedPreviousIndex);
                removeLViewFromLContainer(lContainer, adjustedPreviousIndex);
                needsIndexUpdate = true;
            }
            else if (adjustedPreviousIndex !== null) {
                // move
                const existingLView = detachExistingView(lContainer, adjustedPreviousIndex);
                addLViewToLContainer(lContainer, existingLView, currentIndex);
                needsIndexUpdate = true;
            }
        });
        // A trackBy function might return the same value even if the underlying item changed - re-bind
        // it in the context.
        changes.forEachIdentityChange((record) => {
            const viewIdx = adjustToLastLContainerIndex(lContainer, record.currentIndex);
            const lView = getExistingLViewFromLContainer(lContainer, viewIdx);
            lView[CONTEXT].$implicit = record.item;
        });
        // moves in the container might caused context's index to get out of order, re-adjust
        if (needsIndexUpdate) {
            for (let i = 0; i < lContainer.length - CONTAINER_HEADER_OFFSET; i++) {
                const lView = getExistingLViewFromLContainer(lContainer, i);
                lView[CONTEXT].$index = i;
            }
        }
    }
    // handle empty blocks
    const bindingIndex = nextBindingIndex();
    if (metadata.hasEmptyBlock) {
        const hasItemsInCollection = differ.length > 0;
        if (bindingUpdated(hostLView, bindingIndex, hasItemsInCollection)) {
            const emptyTemplateIndex = metadataSlotIdx + 2;
            const lContainer = getLContainer(hostLView, HEADER_OFFSET + emptyTemplateIndex);
            if (hasItemsInCollection) {
                removeLViewFromLContainer(lContainer, 0);
            }
            else {
                const emptyTemplateTNode = getExistingTNode(hostTView, emptyTemplateIndex);
                const embeddedLView = createAndRenderEmbeddedLView(hostLView, emptyTemplateTNode, undefined);
                addLViewToLContainer(lContainer, embeddedLView, 0);
            }
        }
    }
}
function getLContainer(lView, index) {
    const lContainer = lView[index];
    ngDevMode && assertLContainer(lContainer);
    return lContainer;
}
function adjustToLastLContainerIndex(lContainer, index) {
    return index !== null ? index : lContainer.length - CONTAINER_HEADER_OFFSET;
}
function detachExistingView(lContainer, index) {
    const existingLView = detachView(lContainer, index);
    ngDevMode && assertLView(existingLView);
    return existingLView;
}
function getExistingLViewFromLContainer(lContainer, index) {
    const existingLView = getLViewFromLContainer(lContainer, index);
    ngDevMode && assertLView(existingLView);
    return existingLView;
}
function getExistingTNode(tView, index) {
    const tNode = getTNode(tView, index + HEADER_OFFSET);
    ngDevMode && assertTNode(tNode);
    return tNode;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udHJvbF9mbG93LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvY29yZS9zcmMvcmVuZGVyMy9pbnN0cnVjdGlvbnMvY29udHJvbF9mbG93LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7R0FNRztBQUVILE9BQU8sRUFBQyxxQkFBcUIsRUFBd0MsTUFBTSx3QkFBd0IsQ0FBQztBQUNwRyxPQUFPLEVBQUMsYUFBYSxFQUFDLE1BQU0sbUJBQW1CLENBQUM7QUFDaEQsT0FBTyxFQUFDLGdCQUFnQixFQUFFLFdBQVcsRUFBRSxXQUFXLEVBQUMsTUFBTSxXQUFXLENBQUM7QUFDckUsT0FBTyxFQUFDLGNBQWMsRUFBQyxNQUFNLGFBQWEsQ0FBQztBQUMzQyxPQUFPLEVBQUMsdUJBQXVCLEVBQWEsTUFBTSx5QkFBeUIsQ0FBQztBQUc1RSxPQUFPLEVBQUMsT0FBTyxFQUFFLDBCQUEwQixFQUFFLGFBQWEsRUFBUyxLQUFLLEVBQVEsTUFBTSxvQkFBb0IsQ0FBQztBQUMzRyxPQUFPLEVBQUMsVUFBVSxFQUFDLE1BQU0sc0JBQXNCLENBQUM7QUFDaEQsT0FBTyxFQUFDLFFBQVEsRUFBRSxnQkFBZ0IsRUFBQyxNQUFNLFVBQVUsQ0FBQztBQUNwRCxPQUFPLEVBQUMsUUFBUSxFQUFDLE1BQU0sb0JBQW9CLENBQUM7QUFDNUMsT0FBTyxFQUFDLG9CQUFvQixFQUFFLDRCQUE0QixFQUFFLHNCQUFzQixFQUFFLHlCQUF5QixFQUFDLE1BQU0sc0JBQXNCLENBQUM7QUFFM0ksT0FBTyxFQUFDLFVBQVUsRUFBQyxNQUFNLFlBQVksQ0FBQztBQUV0Qzs7Ozs7Ozs7OztHQVVHO0FBQ0gsTUFBTSxVQUFVLGFBQWEsQ0FBSSxjQUFzQixFQUFFLHFCQUE2QixFQUFFLEtBQVM7SUFDL0YsTUFBTSxTQUFTLEdBQUcsUUFBUSxFQUFFLENBQUM7SUFDN0IsTUFBTSxZQUFZLEdBQUcsZ0JBQWdCLEVBQUUs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RUFBRSxLQUFhO0lBQ2hELE1BQU0sVUFBVSxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNoQyxTQUFTLElBQUksZ0JBQWdCLENBQUMsVUFBVSxDQUFDLENBQUM7SUFFMUMsT0FBTyxVQUFVLENBQUM7QUFDcEIsQ0FBQztBQUVELFNBQVMsMkJBQTJCLENBQUMsVUFBc0IsRUFBRSxLQUFrQjtJQUM3RSxPQUFPLEtBQUssS0FBSyxJQUFJLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLE1BQU0sR0FBRyx1QkFBdUIsQ0FBQztBQUM5RSxDQUFDO0FBRUQsU0FBUyxrQkFBa0IsQ0FBSSxVQUFzQixFQUFFLEtBQWE7SUFDbEUsTUFBTSxhQUFhLEdBQUcsVUFBVSxDQUFDLFVBQVUsRUFBRSxLQUFLLENBQUMsQ0FBQztJQUNwRCxTQUFTLElBQUksV0FBVyxDQUFDLGFBQWEsQ0FBQyxDQUFDO0lBRXhDLE9BQU8sYUFBeUIsQ0FBQztBQUNuQyxDQUFDO0FBRUQsU0FBUyw4QkFBOEIsQ0FBSSxVQUFzQixFQUFFLEtBQWE7SUFDOUUsTUFBTSxhQUFhLEdBQUcsc0JBQXNCLENBQUksVUFBVSxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQ25FLFNBQVMsSUFBSSxXQUFXLENBQUMsYUFBYSxDQUFDLENBQUM7SUFFeEMsT0FBTyxhQUFjLENBQUM7QUFDeEIsQ0FBQztBQUVELFNBQVMsZ0JBQWdCLENBQUMsS0FBWSxFQUFFLEtBQWE7SUFDbkQsTUFBTSxLQUFLLEdBQUcsUUFBUSxDQUFDLEtBQUssRUFBRSxLQUFLLEdBQUcsYUFBYSxDQUFDLENBQUM7SUFDckQsU0FBUyxJQUFJLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUVoQyxPQUFPLEtBQUssQ0FBQztBQUNmLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuaW1wb3J0IHtEZWZhdWx0SXRlcmFibGVEaWZmZXIsIEl0ZXJhYmxlQ2hhbmdlUmVjb3JkLCBUcmFja0J5RnVuY3Rpb259IGZyb20gJy4uLy4uL2NoYW5nZV9kZXRlY3Rpb24nO1xuaW1wb3J0IHthc3NlcnREZWZpbmVkfSBmcm9tICcuLi8uLi91dGlsL2Fzc2VydCc7XG5pbXBvcnQge2Fzc2VydExDb250YWluZXIsIGFzc2VydExWaWV3LCBhc3NlcnRUTm9kZX0gZnJvbSAnLi4vYXNzZXJ0JztcbmltcG9ydCB7YmluZGluZ1VwZGF0ZWR9IGZyb20gJy4uL2JpbmRpbmdzJztcbmltcG9ydCB7Q09OVEFJTkVSX0hFQURFUl9PRkZTRVQsIExDb250YWluZXJ9IGZyb20gJy4uL2ludGVyZmFjZXMvY29udGFpbmVyJztcbmltcG9ydCB7Q29tcG9uZW50VGVtcGxhdGV9IGZyb20gJy4uL2ludGVyZmFjZXMvZGVmaW5pdGlvbic7XG5pbXBvcnQge1ROb2RlfSBmcm9tICcuLi9pbnRlcmZhY2VzL25vZGUnO1xuaW1wb3J0IHtDT05URVhULCBERUNMQVJBVElPTl9DT01QT05FTlRfVklFVywgSEVBREVSX09GRlNFVCwgTFZpZXcsIFRWSUVXLCBUVmlld30gZnJvbSAnLi4vaW50ZXJmYWNlcy92aWV3JztcbmltcG9ydCB7ZGV0YWNoVmlld30gZnJvbSAnLi4vbm9kZV9tYW5pcHVsYXRpb24nO1xuaW1wb3J0IHtnZXRMVmlldywgbmV4dEJpbmRpbmdJbmRleH0gZnJvbSAnLi4vc3RhdGUnO1xuaW1wb3J0IHtnZXRUTm9kZX0gZnJvbSAnLi4vdXRpbC92aWV3X3V0aWxzJztcbmltcG9ydCB7YWRkTFZpZXdUb0xDb250YWluZXIsIGNyZWF0ZUFuZFJlbmRlckVtYmVkZGVkTFZpZXcsIGdldExWaWV3RnJvbUxDb250YWluZXIsIHJlbW92ZUxWaWV3RnJvbUxDb250YWluZXJ9IGZyb20gJy4uL3ZpZXdfbWFuaXB1bGF0aW9uJztcblxuaW1wb3J0IHvJtcm1dGVtcGxhdGV9IGZyb20gJy4vdGVtcGxhdGUnO1xuXG4vKipcbiAqIFRoZSBjb25kaXRpb25hbCBpbnN0cnVjdGlvbiByZXByZXNlbnRzIHRoZSBiYXNpYyBidWlsZGluZyBibG9jayBvbiB0aGUgcnVudGltZSBzaWRlIHRvIHN1cHBvcnRcbiAqIGJ1aWx0LWluIFwiaWZcIiBhbmQgXCJzd2l0Y2hcIi4gT24gdGhlIGhpZ2ggbGV2ZWwgdGhpcyBpbnN0cnVjdGlvbiBpcyByZXNwb25zaWJsZSBmb3IgYWRkaW5nIGFuZFxuICogcmVtb3Zpbmcgdmlld3Mgc2VsZWN0ZWQgYnkgYSBjb25kaXRpb25hbCBleHByZXNzaW9uLlxuICpcbiAqIEBwYXJhbSBjb250YWluZXJJbmRleCBpbmRleCBvZiBhIGNvbnRhaW5lciBpbiBhIGhvc3QgdmlldyAoaW5kZXhlZCBmcm9tIEhFQURFUl9PRkZTRVQpIHdoZXJlXG4gKiAgICAgY29uZGl0aW9uYWwgdmlld3Mgc2hvdWxkIGJlIGluc2VydGVkLlxuICogQHBhcmFtIG1hdGNoaW5nVGVtcGxhdGVJbmRleCBpbmRleCBvZiBhIHRlbXBsYXRlIFROb2RlIHJlcHJlc2VudGluZyBhIGNvbmRpdGlvbmFsIHZpZXcgdG8gYmVcbiAqICAgICBpbnNlcnRlZDsgLTEgcmVwcmVzZW50cyBhIHNwZWNpYWwgY2FzZSB3aGVuIHRoZXJlIGlzIG5vIHZpZXcgdG8gaW5zZXJ0LlxuICogQGNvZGVHZW5BcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIMm1ybVjb25kaXRpb25hbDxUPihjb250YWluZXJJbmRleDogbnVtYmVyLCBtYXRjaGluZ1RlbXBsYXRlSW5kZXg6IG51bWJlciwgdmFsdWU/OiBUKSB7XG4gIGNvbnN0IGhvc3RMVmlldyA9IGdldExWaWV3KCk7XG4gIGNvbnN0IGJpbmRpbmdJbmRleCA9IG5leHRCaW5kaW5nSW5kZXgoKTtcbiAgY29uc3QgbENvbnRhaW5lciA9IGdldExDb250YWluZXIoaG9zdExWaWV3LCBIRUFERVJfT0ZGU0VUICsgY29udGFpbmVySW5kZXgpO1xuICBjb25zdCB2aWV3SW5Db250YWluZXJJZHggPSAwO1xuXG4gIGlmIChiaW5kaW5nVXBkYXRlZChob3N0TFZpZXcsIGJpbmRpbmdJbmRleCwgbWF0Y2hpbmdUZW1wbGF0ZUluZGV4KSkge1xuICAgIC8vIFRoZSBpbmRleCBvZiB0aGUgdmlldyB0byBzaG93IGNoYW5nZWQgLSByZW1vdmUgdGhlIHByZXZpb3VzbHkgZGlzcGxheWVkIG9uZVxuICAgIC8vIChpdCBpcyBhIG5vb3AgaWYgdGhlcmUgYXJlIG5vIGFjdGl2ZSB2aWV3cyBpbiBhIGNvbnRhaW5lcikuXG4gICAgcmVtb3ZlTFZpZXdGcm9tTENvbnRhaW5lcihsQ29udGFpbmVyLCB2aWV3SW5Db250YWluZXJJZHgpO1xuXG4gICAgLy8gSW5kZXggLTEgaXMgYSBzcGVjaWFsIGNhc2Ugd2hlcmUgbm9uZSBvZiB0aGUgY29uZGl0aW9ucyBldmFsdWF0ZXMgdG9cbiAgICAvLyBhIHRydXRoeSB2YWx1ZSBhbmQgYXMgdGhlIGNvbnNlcXVlbmNlIHdlJ3ZlIGdvdCBubyB2aWV3IHRvIHNob3cuXG4gICAgaWYgKG1hdGNoaW5nVGVtcGxhdGVJbmRleCAhPT0gLTEpIHtcbiAgICAgIGNvbnN0IHRlbXBsYXRlVE5vZGUgPSBnZXRFeGlzdGluZ1ROb2RlKGhvc3RMVmlld1tUVklFV10sIG1hdGNoaW5nVGVtcGxhdGVJbmRleCk7XG4gICAgICBjb25zdCBlbWJlZGRlZExWaWV3ID0gY3JlYXRlQW5kUmVuZGVyRW1iZWRkZWRMVmlldyhob3N0TFZpZXcsIHRlbXBsYXRlVE5vZGUsIHZhbHVlKTtcblxuICAgICAgYWRkTFZpZXdUb0xDb250YWluZXIobENvbnRhaW5lciwgZW1iZWRkZWRMVmlldywgdmlld0luQ29udGFpbmVySWR4KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gV2UgbWlnaHQga2VlcCBkaXNwbGF5aW5nIHRoZSBzYW1lIHRlbXBsYXRlIGJ1dCB0aGUgYWN0dWFsIHZhbHVlIG9mIHRoZSBleHByZXNzaW9uIGNvdWxkIGhhdmVcbiAgICAvLyBjaGFuZ2VkIC0gcmUtYmluZCBpbiBjb250ZXh0LlxuICAgIGNvbnN0IGxWaWV3ID0gZ2V0TFZpZXdGcm9tTENvbnRhaW5lcjxUfHVuZGVmaW5lZD4obENvbnRhaW5lciwgdmlld0luQ29udGFpbmVySWR4KTtcbiAgICBpZiAobFZpZXcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbFZpZXdbQ09OVEVYVF0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFJlcGVhdGVyQ29udGV4dDxUPiB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgbENvbnRhaW5lcjogTENvbnRhaW5lciwgcHVibGljICRpbXBsaWNpdDogVCwgcHVibGljICRpbmRleDogbnVtYmVyKSB7fVxuXG4gIGdldCAkY291bnQoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5sQ29udGFpbmVyLmxlbmd0aCAtIENPTlRBSU5FUl9IRUFERVJfT0ZGU0VUO1xuICB9XG59XG5cbi8qKlxuICogQSBidWlsdC1pbiB0cmFja0J5IGZ1bmN0aW9uIHVzZWQgZm9yIHNpdHVhdGlvbnMgd2hlcmUgdXNlcnMgc3BlY2lmaWVkIGNvbGxlY3Rpb24gaW5kZXggYXMgYVxuICogdHJhY2tpbmcgZXhwcmVzc2lvbi4gSGF2aW5nIHRoaXMgZnVuY3Rpb24gYm9keSBpbiB0aGUgcnVudGltZSBhdm9pZHMgdW5uZWNlc3NhcnkgY29kZSBnZW5lcmF0aW9uLlxuICpcbiAqIEBwYXJhbSBpbmRleFxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIMm1ybVyZXBlYXRlclRyYWNrQnlJbmRleChpbmRleDogbnVtYmVyKSB7XG4gIHJldHVybiBpbmRleDtcbn1cblxuLyoqXG4gKiBBIGJ1aWx0LWluIHRyYWNrQnkgZnVuY3Rpb24gdXNlZCBmb3Igc2l0dWF0aW9ucyB3aGVyZSB1c2VycyBzcGVjaWZpZWQgY29sbGVjdGlvbiBpdGVtIHJlZmVyZW5jZVxuICogYXMgYSB0cmFja2luZyBleHByZXNzaW9uLiBIYXZpbmcgdGhpcyBmdW5jdGlvbiBib2R5IGluIHRoZSBydW50aW1lIGF2b2lkcyB1bm5lY2Vzc2FyeSBjb2RlXG4gKiBnZW5lcmF0aW9uLlxuICpcbiAqIEBwYXJhbSBpbmRleFxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIMm1ybVyZXBlYXRlclRyYWNrQnlJZGVudGl0eTxUPihfOiBudW1iZXIsIHZhbHVlOiBUKSB7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuY2xhc3MgUmVwZWF0ZXJNZXRhZGF0YSB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBoYXNFbXB0eUJsb2NrOiBib29sZWFuLCBwdWJsaWMgZGlmZmVyOiBEZWZhdWx0SXRlcmFibGVEaWZmZXI8dW5rbm93bj4pIHt9XG59XG5cbi8qKlxuICogVGhlIHJlcGVhdGVyQ3JlYXRlIGluc3RydWN0aW9uIHJ1bnMgaW4gdGhlIGNyZWF0aW9uIHBhcnQgb2YgdGhlIHRlbXBsYXRlIHBhc3MgYW5kIGluaXRpYWxpemVzXG4gKiBpbnRlcm5hbCBkYXRhIHN0cnVjdHVyZXMgcmVxdWlyZWQgYnkgdGhlIHVwZGF0ZSBwYXNzIG9mIHRoZSBidWlsdC1pbiByZXBlYXRlciBsb2dpYy4gUmVwZWF0ZXJcbiAqIG1ldGFkYXRhIGFyZSBhbGxvY2F0ZWQgaW4gdGhlIGRhdGEgcGFydCBvZiBMVmlldyB3aXRoIHRoZSBmb2xsb3dpbmcgbGF5b3V0OlxuICogLSBMVmlld1tIRUFERVJfT0ZGU0VUICsgaW5kZXhdIC0gbWV0YWRhdGFcbiAqIC0gTFZpZXdbSEVBREVSX09GRlNFVCArIGluZGV4ICsgMV0gLSByZWZlcmVuY2UgdG8gYSB0ZW1wbGF0ZSBmdW5jdGlvbiByZW5kZXJpbmcgYW4gaXRlbVxuICogLSBMVmlld1tIRUFERVJfT0ZGU0VUICsgaW5kZXggKyAyXSAtIG9wdGlvbmFsIHJlZmVyZW5jZSB0byBhIHRlbXBsYXRlIGZ1bmN0aW9uIHJlbmRlcmluZyBhbiBlbXB0eVxuICogYmxvY2tcbiAqXG4gKiBAcGFyYW0gaW5kZXggSW5kZXggYXQgd2hpY2ggdG8gc3RvcmUgdGhlIG1ldGFkYXRhIG9mIHRoZSByZXBlYXRlci5cbiAqIEBwYXJhbSB0ZW1wbGF0ZUZuIFJlZmVyZW5jZSB0byB0aGUgdGVtcGxhdGUgb2YgdGhlIG1haW4gcmVwZWF0ZXIgYmxvY2suXG4gKiBAcGFyYW0gZGVjbHMgVGhlIG51bWJlciBvZiBub2RlcywgbG9jYWwgcmVmcywgYW5kIHBpcGVzIGZvciB0aGUgbWFpbiBibG9jay5cbiAqIEBwYXJhbSB2YXJzIFRoZSBudW1iZXIgb2YgYmluZGluZ3MgZm9yIHRoZSBtYWluIGJsb2NrLlxuICogQHBhcmFtIHRyYWNrQnlGbiBSZWZlcmVuY2UgdG8gdGhlIHRyYWNraW5nIGZ1bmN0aW9uLlxuICogQHBhcmFtIHRyYWNrQnlVc2VzQ29tcG9uZW50SW5zdGFuY2UgV2hldGhlciB0aGUgdHJhY2tpbmcgZnVuY3Rpb24gaGFzIGFueSByZWZlcmVuY2VzIHRvIHRoZVxuICogIGNvbXBvbmVudCBpbnN0YW5jZS4gSWYgaXQgZG9lc24ndCwgd2UgY2FuIGF2b2lkIHJlYmluZGluZyBpdC5cbiAqIEBwYXJhbSBlbXB0eVRlbXBsYXRlRm4gUmVmZXJlbmNlIHRvIHRoZSB0ZW1wbGF0ZSBmdW5jdGlvbiBvZiB0aGUgZW1wdHkgYmxvY2suXG4gKiBAcGFyYW0gZW1wdHlEZWNscyBUaGUgbnVtYmVyIG9mIG5vZGVzLCBsb2NhbCByZWZzLCBhbmQgcGlwZXMgZm9yIHRoZSBlbXB0eSBibG9jay5cbiAqIEBwYXJhbSBlbXB0eVZhcnMgVGhlIG51bWJlciBvZiBiaW5kaW5ncyBmb3IgdGhlIGVtcHR5IGJsb2NrLlxuICpcbiAqIEBjb2RlR2VuQXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiDJtcm1cmVwZWF0ZXJDcmVhdGUoXG4gICAgaW5kZXg6IG51bWJlciwgdGVtcGxhdGVGbjogQ29tcG9uZW50VGVtcGxhdGU8dW5rbm93bj4sIGRlY2xzOiBudW1iZXIsIHZhcnM6IG51bWJlcixcbiAgICB0cmFja0J5Rm46IFRyYWNrQnlGdW5jdGlvbjx1bmtub3duPiwgdHJhY2tCeVVzZXNDb21wb25lbnRJbnN0YW5jZT86IGJvb2xlYW4sXG4gICAgZW1wdHlUZW1wbGF0ZUZuPzogQ29tcG9uZW50VGVtcGxhdGU8dW5rbm93bj4sIGVtcHR5RGVjbHM/OiBudW1iZXIsIGVtcHR5VmFycz86IG51bWJlcik6IHZvaWQge1xuICBjb25zdCBoYXNFbXB0eUJsb2NrID0gZW1wdHlUZW1wbGF0ZUZuICE9PSB1bmRlZmluZWQ7XG4gIGNvbnN0IGhvc3RMVmlldyA9IGdldExWaWV3KCk7XG4gIGNvbnN0IGJvdW5kVHJhY2tCeSA9IHRyYWNrQnlVc2VzQ29tcG9uZW50SW5zdGFuY2UgP1xuICAgICAgLy8gV2Ugb25seSB3YW50IHRvIGJpbmQgd2hlbiBuZWNlc3NhcnksIGJlY2F1c2UgaXQgcHJvZHVjZXMgYVxuICAgICAgLy8gbmV3IGZ1bmN0aW9uLiBGb3IgcHVyZSBmdW5jdGlvbnMgaXQncyBub3QgbmVjZXNzYXJ5LlxuICAgICAgdHJhY2tCeUZuLmJpbmQoaG9zdExWaWV3W0RFQ0xBUkFUSU9OX0NPTVBPTkVOVF9WSUVXXVtDT05URVhUXSkgOlxuICAgICAgdHJhY2tCeUZuO1xuICBjb25zdCBtZXRhZGF0YSA9IG5ldyBSZXBlYXRlck1ldGFkYXRhKGhhc0VtcHR5QmxvY2ssIG5ldyBEZWZhdWx0SXRlcmFibGVEaWZmZXIoYm91bmRUcmFja0J5KSk7XG4gIGhvc3RMVmlld1tIRUFERVJfT0ZGU0VUICsgaW5kZXhdID0gbWV0YWRhdGE7XG5cbiAgybXJtXRlbXBsYXRlKGluZGV4ICsgMSwgdGVtcGxhdGVGbiwgZGVjbHMsIHZhcnMpO1xuXG4gIGlmIChoYXNFbXB0eUJsb2NrKSB7XG4gICAgbmdEZXZNb2RlICYmXG4gICAgICAgIGFzc2VydERlZmluZWQoZW1wdHlEZWNscywgJ01pc3NpbmcgbnVtYmVyIG9mIGRlY2xhcmF0aW9ucyBmb3IgdGhlIGVtcHR5IHJlcGVhdGVyIGJsb2NrLicpO1xuICAgIG5nRGV2TW9kZSAmJlxuICAgICAgICBhc3NlcnREZWZpbmVkKGVtcHR5VmFycywgJ01pc3NpbmcgbnVtYmVyIG9mIGJpbmRpbmdzIGZvciB0aGUgZW1wdHkgcmVwZWF0ZXIgYmxvY2suJyk7XG5cbiAgICDJtcm1dGVtcGxhdGUoaW5kZXggKyAyLCBlbXB0eVRlbXBsYXRlRm4sIGVtcHR5RGVjbHMhLCBlbXB0eVZhcnMhKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSByZXBlYXRlciBpbnN0cnVjdGlvbiBkb2VzIHVwZGF0ZS10aW1lIGRpZmZpbmcgb2YgYSBwcm92aWRlZCBjb2xsZWN0aW9uIChhZ2FpbnN0IHRoZVxuICogY29sbGVjdGlvbiBzZWVuIHByZXZpb3VzbHkpIGFuZCBtYXBzIGNoYW5nZXMgaW4gdGhlIGNvbGxlY3Rpb24gdG8gdmlld3Mgc3RydWN0dXJlIChieSBhZGRpbmcsXG4gKiByZW1vdmluZyBvciBtb3Zpbmcgdmlld3MgYXMgbmVlZGVkKS5cbiAqIEBwYXJhbSBtZXRhZGF0YVNsb3RJZHggLSBpbmRleCBpbiBkYXRhIHdoZXJlIHdlIGNhbiBmaW5kIGFuIGluc3RhbmNlIG9mIFJlcGVhdGVyTWV0YWRhdGEgd2l0aFxuICogICAgIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gKGV4LiBkaWZmZXIpIG5lZWRlZCB0byBwcm9jZXNzIGNvbGxlY3Rpb24gZGlmZmluZyBhbmQgdmlld1xuICogICAgIG1hbmlwdWxhdGlvblxuICogQHBhcmFtIGNvbGxlY3Rpb24gLSB0aGUgY29sbGVjdGlvbiBpbnN0YW5jZSB0byBiZSBjaGVja2VkIGZvciBjaGFuZ2VzXG4gKiBAY29kZUdlbkFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gybXJtXJlcGVhdGVyKFxuICAgIG1ldGFkYXRhU2xvdElkeDogbnVtYmVyLCBjb2xsZWN0aW9uOiBJdGVyYWJsZTx1bmtub3duPnx1bmRlZmluZWR8bnVsbCk6IHZvaWQge1xuICBjb25zdCBob3N0TFZpZXcgPSBnZXRMVmlldygpO1xuICBjb25zdCBob3N0VFZpZXcgPSBob3N0TFZpZXdbVFZJRVddO1xuICBjb25zdCBtZXRhZGF0YSA9IGhvc3RMVmlld1tIRUFERVJfT0ZGU0VUICsgbWV0YWRhdGFTbG90SWR4XSBhcyBSZXBlYXRlck1ldGFkYXRhO1xuXG4gIGNvbnN0IGRpZmZlciA9IG1ldGFkYXRhLmRpZmZlcjtcbiAgY29uc3QgY2hhbmdlcyA9IGRpZmZlci5kaWZmKGNvbGxlY3Rpb24pO1xuXG4gIC8vIGhhbmRsZSByZXBlYXRlciBjaGFuZ2VzXG4gIGlmIChjaGFuZ2VzICE9PSBudWxsKSB7XG4gICAgY29uc3QgY29udGFpbmVySW5kZXggPSBtZXRhZGF0YVNsb3RJZHggKyAxO1xuICAgIGNvbnN0IGl0ZW1UZW1wbGF0ZVROb2RlID0gZ2V0RXhpc3RpbmdUTm9kZShob3N0VFZpZXcsIGNvbnRhaW5lckluZGV4KTtcbiAgICBjb25zdCBsQ29udGFpbmVyID0gZ2V0TENvbnRhaW5lcihob3N0TFZpZXcsIEhFQURFUl9PRkZTRVQgKyBjb250YWluZXJJbmRleCk7XG4gICAgbGV0IG5lZWRzSW5kZXhVcGRhdGUgPSBmYWxzZTtcbiAgICBjaGFuZ2VzLmZvckVhY2hPcGVyYXRpb24oXG4gICAgICAgIChpdGVtOiBJdGVyYWJsZUNoYW5nZVJlY29yZDx1bmtub3duPiwgYWRqdXN0ZWRQcmV2aW91c0luZGV4OiBudW1iZXJ8bnVsbCxcbiAgICAgICAgIGN1cnJlbnRJbmRleDogbnVtYmVyfG51bGwpID0+IHtcbiAgICAgICAgICBpZiAoaXRlbS5wcmV2aW91c0luZGV4ID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBhZGRcbiAgICAgICAgICAgIGNvbnN0IG5ld1ZpZXdJZHggPSBhZGp1c3RUb0xhc3RMQ29udGFpbmVySW5kZXgobENvbnRhaW5lciwgY3VycmVudEluZGV4KTtcbiAgICAgICAgICAgIGNvbnN0IGVtYmVkZGVkTFZpZXcgPSBjcmVhdGVBbmRSZW5kZXJFbWJlZGRlZExWaWV3KFxuICAgICAgICAgICAgICAgIGhvc3RMVmlldywgaXRlbVRlbXBsYXRlVE5vZGUsXG4gICAgICAgICAgICAgICAgbmV3IFJlcGVhdGVyQ29udGV4dChsQ29udGFpbmVyLCBpdGVtLml0ZW0sIG5ld1ZpZXdJZHgpKTtcbiAgICAgICAgICAgIGFkZExWaWV3VG9MQ29udGFpbmVyKGxDb250YWluZXIsIGVtYmVkZGVkTFZpZXcsIG5ld1ZpZXdJZHgpO1xuICAgICAgICAgICAgbmVlZHNJbmRleFVwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50SW5kZXggPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZVxuICAgICAgICAgICAgYWRqdXN0ZWRQcmV2aW91c0luZGV4ID0gYWRqdXN0VG9MYXN0TENvbnRhaW5lckluZGV4KGxDb250YWluZXIsIGFkanVzdGVkUHJldmlvdXNJbmRleCk7XG4gICAgICAgICAgICByZW1vdmVMVmlld0Zyb21MQ29udGFpbmVyKGxDb250YWluZXIsIGFkanVzdGVkUHJldmlvdXNJbmRleCk7XG4gICAgICAgICAgICBuZWVkc0luZGV4VXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGFkanVzdGVkUHJldmlvdXNJbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gbW92ZVxuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdMVmlldyA9XG4gICAgICAgICAgICAgICAgZGV0YWNoRXhpc3RpbmdWaWV3PFJlcGVhdGVyQ29udGV4dDx1bmtub3duPj4obENvbnRhaW5lciwgYWRqdXN0ZWRQcmV2aW91c0luZGV4KTtcbiAgICAgICAgICAgIGFkZExWaWV3VG9MQ29udGFpbmVyKGxDb250YWluZXIsIGV4aXN0aW5nTFZpZXcsIGN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICBuZWVkc0luZGV4VXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgLy8gQSB0cmFja0J5IGZ1bmN0aW9uIG1pZ2h0IHJldHVybiB0aGUgc2FtZSB2YWx1ZSBldmVuIGlmIHRoZSB1bmRlcmx5aW5nIGl0ZW0gY2hhbmdlZCAtIHJlLWJpbmRcbiAgICAvLyBpdCBpbiB0aGUgY29udGV4dC5cbiAgICBjaGFuZ2VzLmZvckVhY2hJZGVudGl0eUNoYW5nZSgocmVjb3JkOiBJdGVyYWJsZUNoYW5nZVJlY29yZDx1bmtub3duPikgPT4ge1xuICAgICAgY29uc3Qgdmlld0lkeCA9IGFkanVzdFRvTGFzdExDb250YWluZXJJbmRleChsQ29udGFpbmVyLCByZWNvcmQuY3VycmVudEluZGV4KTtcbiAgICAgIGNvbnN0IGxWaWV3ID0gZ2V0RXhpc3RpbmdMVmlld0Zyb21MQ29udGFpbmVyPFJlcGVhdGVyQ29udGV4dDx1bmtub3duPj4obENvbnRhaW5lciwgdmlld0lkeCk7XG4gICAgICBsVmlld1tDT05URVhUXS4kaW1wbGljaXQgPSByZWNvcmQuaXRlbTtcbiAgICB9KTtcblxuICAgIC8vIG1vdmVzIGluIHRoZSBjb250YWluZXIgbWlnaHQgY2F1c2VkIGNvbnRleHQncyBpbmRleCB0byBnZXQgb3V0IG9mIG9yZGVyLCByZS1hZGp1c3RcbiAgICBpZiAobmVlZHNJbmRleFVwZGF0ZSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsQ29udGFpbmVyLmxlbmd0aCAtIENPTlRBSU5FUl9IRUFERVJfT0ZGU0VUOyBpKyspIHtcbiAgICAgICAgY29uc3QgbFZpZXcgPSBnZXRFeGlzdGluZ0xWaWV3RnJvbUxDb250YWluZXI8UmVwZWF0ZXJDb250ZXh0PHVua25vd24+PihsQ29udGFpbmVyLCBpKTtcbiAgICAgICAgbFZpZXdbQ09OVEVYVF0uJGluZGV4ID0gaTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBoYW5kbGUgZW1wdHkgYmxvY2tzXG4gIGNvbnN0IGJpbmRpbmdJbmRleCA9IG5leHRCaW5kaW5nSW5kZXgoKTtcbiAgaWYgKG1ldGFkYXRhLmhhc0VtcHR5QmxvY2spIHtcbiAgICBjb25zdCBoYXNJdGVtc0luQ29sbGVjdGlvbiA9IGRpZmZlci5sZW5ndGggPiAwO1xuICAgIGlmIChiaW5kaW5nVXBkYXRlZChob3N0TFZpZXcsIGJpbmRpbmdJbmRleCwgaGFzSXRlbXNJbkNvbGxlY3Rpb24pKSB7XG4gICAgICBjb25zdCBlbXB0eVRlbXBsYXRlSW5kZXggPSBtZXRhZGF0YVNsb3RJZHggKyAyO1xuICAgICAgY29uc3QgbENvbnRhaW5lciA9IGdldExDb250YWluZXIoaG9zdExWaWV3LCBIRUFERVJfT0ZGU0VUICsgZW1wdHlUZW1wbGF0ZUluZGV4KTtcbiAgICAgIGlmIChoYXNJdGVtc0luQ29sbGVjdGlvbikge1xuICAgICAgICByZW1vdmVMVmlld0Zyb21MQ29udGFpbmVyKGxDb250YWluZXIsIDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZW1wdHlUZW1wbGF0ZVROb2RlID0gZ2V0RXhpc3RpbmdUTm9kZShob3N0VFZpZXcsIGVtcHR5VGVtcGxhdGVJbmRleCk7XG4gICAgICAgIGNvbnN0IGVtYmVkZGVkTFZpZXcgPVxuICAgICAgICAgICAgY3JlYXRlQW5kUmVuZGVyRW1iZWRkZWRMVmlldyhob3N0TFZpZXcsIGVtcHR5VGVtcGxhdGVUTm9kZSwgdW5kZWZpbmVkKTtcbiAgICAgICAgYWRkTFZpZXdUb0xDb250YWluZXIobENvbnRhaW5lciwgZW1iZWRkZWRMVmlldywgMCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldExDb250YWluZXIobFZpZXc6IExWaWV3LCBpbmRleDogbnVtYmVyKTogTENvbnRhaW5lciB7XG4gIGNvbnN0IGxDb250YWluZXIgPSBsVmlld1tpbmRleF07XG4gIG5nRGV2TW9kZSAmJiBhc3NlcnRMQ29udGFpbmVyKGxDb250YWluZXIpO1xuXG4gIHJldHVybiBsQ29udGFpbmVyO1xufVxuXG5mdW5jdGlvbiBhZGp1c3RUb0xhc3RMQ29udGFpbmVySW5kZXgobENvbnRhaW5lcjogTENvbnRhaW5lciwgaW5kZXg6IG51bWJlcnxudWxsKTogbnVtYmVyIHtcbiAgcmV0dXJuIGluZGV4ICE9PSBudWxsID8gaW5kZXggOiBsQ29udGFpbmVyLmxlbmd0aCAtIENPTlRBSU5FUl9IRUFERVJfT0ZGU0VUO1xufVxuXG5mdW5jdGlvbiBkZXRhY2hFeGlzdGluZ1ZpZXc8VD4obENvbnRhaW5lcjogTENvbnRhaW5lciwgaW5kZXg6IG51bWJlcik6IExWaWV3PFQ+IHtcbiAgY29uc3QgZXhpc3RpbmdMVmlldyA9IGRldGFjaFZpZXcobENvbnRhaW5lciwgaW5kZXgpO1xuICBuZ0Rldk1vZGUgJiYgYXNzZXJ0TFZpZXcoZXhpc3RpbmdMVmlldyk7XG5cbiAgcmV0dXJuIGV4aXN0aW5nTFZpZXcgYXMgTFZpZXc8VD47XG59XG5cbmZ1bmN0aW9uIGdldEV4aXN0aW5nTFZpZXdGcm9tTENvbnRhaW5lcjxUPihsQ29udGFpbmVyOiBMQ29udGFpbmVyLCBpbmRleDogbnVtYmVyKTogTFZpZXc8VD4ge1xuICBjb25zdCBleGlzdGluZ0xWaWV3ID0gZ2V0TFZpZXdGcm9tTENvbnRhaW5lcjxUPihsQ29udGFpbmVyLCBpbmRleCk7XG4gIG5nRGV2TW9kZSAmJiBhc3NlcnRMVmlldyhleGlzdGluZ0xWaWV3KTtcblxuICByZXR1cm4gZXhpc3RpbmdMVmlldyE7XG59XG5cbmZ1bmN0aW9uIGdldEV4aXN0aW5nVE5vZGUodFZpZXc6IFRWaWV3LCBpbmRleDogbnVtYmVyKTogVE5vZGUge1xuICBjb25zdCB0Tm9kZSA9IGdldFROb2RlKHRWaWV3LCBpbmRleCArIEhFQURFUl9PRkZTRVQpO1xuICBuZ0Rldk1vZGUgJiYgYXNzZXJ0VE5vZGUodE5vZGUpO1xuXG4gIHJldHVybiB0Tm9kZTtcbn1cbiJdfQ==
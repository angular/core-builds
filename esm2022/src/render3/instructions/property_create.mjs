/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { SIGNAL } from '@angular/core/primitives/signals';
import { validateAgainstEventProperties } from '../../sanitization/sanitization';
import { assertDefined, assertIndexInRange } from '../../util/assert';
import { EMPTY_ARRAY } from '../../util/empty';
import { bindingUpdated } from '../bindings';
import { isComponentHost } from '../interfaces/type_checks';
import { HEADER_OFFSET, RENDERER } from '../interfaces/view';
import { computed } from '../reactivity/computed';
import { getCurrentTNode, getLView, getTView, nextBindingIndex } from '../state';
import { renderStringify } from '../util/stringify_utils';
import { getNativeByTNode } from '../util/view_utils';
import { handleUnknownPropertyError, isPropertyValid } from './element_validation';
import { mapPropName, markDirtyIfOnPush, setNgReflectProperties, writeToDirectiveInput } from './shared';
/**
 * TODO
 *
 * @codeGenApi
 */
export function ɵɵpropertyCreate(slot, propName, expr, sanitizer) {
    const lView = getLView();
    const expressionSlot = HEADER_OFFSET + slot;
    const tView = getTView();
    const tNode = getCurrentTNode();
    assertDefined(tNode, `propertyCreate() must follow an actual element`);
    const inputData = tNode.inputs?.[propName] ?? EMPTY_ARRAY;
    let signalInputs = null;
    // PERF: the fact that we need to iterate over all the inputs here isn't great.
    // We might consider storing more info on TView
    let zoneTargets = null;
    for (let i = 0; i < inputData.length;) {
        const directiveIndex = inputData[i++];
        const privateName = inputData[i++];
        const def = tView.data[directiveIndex];
        if (!def.signals) {
            // TODO(pk): refactor - code flow with all those firstCreatePass checks becomes hard to follow
            if (tView.firstCreatePass) {
                (zoneTargets ??= []).push(directiveIndex, privateName);
            }
        }
        else {
            ngDevMode && assertIndexInRange(lView, directiveIndex);
            // PERF: megamorphic read on [privateName] access
            const inputSignal = lView[directiveIndex][privateName][SIGNAL];
            (signalInputs ??= []).push(inputSignal);
        }
    }
    zoneTargets ??= EMPTY_ARRAY;
    signalInputs ??= EMPTY_ARRAY;
    // PERF(pk): I could avoid wrapping into computed for the case of a single binding to a signal
    // based component
    expr = computed(expr);
    lView[expressionSlot] = expr;
    for (const inputSignal of signalInputs) {
        // TODO: Improve this by not allocating an object literal here. This exists just for testing.
        inputSignal.bind(inputSignal, { computation: expr });
        // TODO: figure out where to set `isInitialized`.
        inputSignal.isInitialized = true;
    }
    if (tView.firstCreatePass) {
        if (inputData.length === 0) {
            // Untargeted input -> DOM binding.
            (tView.virtualUpdate ??= []).push({
                slot: expressionSlot,
                instruction: () => propertyUpdateDom(tNode.index, propName, expressionSlot, sanitizer ?? null),
            });
        }
        else if (zoneTargets.length) {
            // Some binding targets were zone-based, so we need an update instruction to process them.
            (tView.virtualUpdate ??= []).push({
                slot: expressionSlot,
                instruction: () => propertyUpdateInput(tNode.index, propName, expressionSlot, zoneTargets),
            });
        }
        else {
            // The only target(s) were signal-based, so no update path is needed.
        }
    }
    return ɵɵpropertyCreate;
}
export function propertyUpdateDom(nodeSlot, propName, expressionSlot, sanitizer) {
    const lView = getLView();
    const expr = lView[expressionSlot];
    let value = expr();
    const bindingIndex = nextBindingIndex();
    if (!bindingUpdated(lView, bindingIndex, value)) {
        return;
    }
    const tView = getTView();
    const tNode = tView.data[nodeSlot];
    const element = getNativeByTNode(tNode, lView);
    propName = mapPropName(propName);
    if (ngDevMode) {
        validateAgainstEventProperties(propName);
        if (!isPropertyValid(element, propName, tNode.value, tView.schemas)) {
            handleUnknownPropertyError(propName, tNode.value, tNode.type, lView);
        }
        ngDevMode.rendererSetProperty++;
    }
    // It is assumed that the sanitizer is only added when the compiler determines that the
    // property is risky, so sanitization can be done without further checks.
    value = sanitizer != null ? sanitizer(value, tNode.value || '', propName) : value;
    lView[RENDERER].setProperty(element, propName, value);
}
export function propertyUpdateInput(nodeIndex, propName, expressionSlot, targets) {
    const lView = getLView();
    const expr = lView[expressionSlot];
    const value = expr();
    const tView = getTView();
    const tNode = tView.data[nodeIndex];
    ngDevMode && assertDefined(tNode.inputs, `Expected tNode to have inputs`);
    const bindingIndex = nextBindingIndex();
    if (!bindingUpdated(lView, bindingIndex, value)) {
        return;
    }
    for (let i = 0; i < targets.length;) {
        const index = targets[i++];
        const privateName = targets[i++];
        ngDevMode && assertIndexInRange(lView, index);
        const instance = lView[index];
        const def = tView.data[index];
        writeToDirectiveInput(def, instance, propName, privateName, value);
    }
    const element = getNativeByTNode(tNode, lView);
    if (isComponentHost(tNode)) {
        markDirtyIfOnPush(lView, tNode.index);
    }
    if (ngDevMode) {
        setNgReflectProperties(lView, element, tNode.type, targets, value);
    }
}
export function ɵɵstringifyInterpolation(staticStrings, ...expressionValues) {
    // Build the updated content
    let content = staticStrings[0];
    for (let i = 1; i < staticStrings.length; i++) {
        content += renderStringify(expressionValues[i - 1]) + staticStrings[i];
    }
    return content;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvcGVydHlfY3JlYXRlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvY29yZS9zcmMvcmVuZGVyMy9pbnN0cnVjdGlvbnMvcHJvcGVydHlfY3JlYXRlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7R0FNRztBQUdILE9BQU8sRUFBQyxNQUFNLEVBQUMsTUFBTSxrQ0FBa0MsQ0FBQztBQUV4RCxPQUFPLEVBQUMsOEJBQThCLEVBQUMsTUFBTSxpQ0FBaUMsQ0FBQztBQUMvRSxPQUFPLEVBQUMsYUFBYSxFQUFFLGtCQUFrQixFQUFDLE1BQU0sbUJBQW1CLENBQUM7QUFDcEUsT0FBTyxFQUFDLFdBQVcsRUFBQyxNQUFNLGtCQUFrQixDQUFDO0FBQzdDLE9BQU8sRUFBQyxjQUFjLEVBQUMsTUFBTSxhQUFhLENBQUM7QUFLM0MsT0FBTyxFQUFDLGVBQWUsRUFBQyxNQUFNLDJCQUEyQixDQUFDO0FBQzFELE9BQU8sRUFBQyxhQUFhLEVBQUUsUUFBUSxFQUFDLE1BQU0sb0JBQW9CLENBQUM7QUFDM0QsT0FBTyxFQUFDLFFBQVEsRUFBQyxNQUFNLHdCQUF3QixDQUFDO0FBRWhELE9BQU8sRUFBQyxlQUFlLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxnQkFBZ0IsRUFBQyxNQUFNLFVBQVUsQ0FBQztBQUMvRSxPQUFPLEVBQUMsZUFBZSxFQUFDLE1BQU0seUJBQXlCLENBQUM7QUFDeEQsT0FBTyxFQUFDLGdCQUFnQixFQUFDLE1BQU0sb0JBQW9CLENBQUM7QUFFcEQsT0FBTyxFQUFDLDBCQUEwQixFQUFFLGVBQWUsRUFBQyxNQUFNLHNCQUFzQixDQUFDO0FBQ2pGLE9BQU8sRUFBQyxXQUFXLEVBQUUsaUJBQWlCLEVBQUUsc0JBQXNCLEVBQUUscUJBQXFCLEVBQUMsTUFBTSxVQUFVLENBQUM7QUFFdkc7Ozs7R0FJRztBQUNILE1BQU0sVUFBVSxnQkFBZ0IsQ0FDNUIsSUFBWSxFQUFF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UUFBUSxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUM5QixNQUFNLEdBQUcsR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBc0IsQ0FBQztRQUVuRCxxQkFBcUIsQ0FBQyxHQUFHLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxXQUFXLEVBQUUsS0FBSyxDQUFDLENBQUM7S0FDcEU7SUFFRCxNQUFNLE9BQU8sR0FBRyxnQkFBZ0IsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUF3QixDQUFDO0lBQ3RFLElBQUksZUFBZSxDQUFDLEtBQUssQ0FBQyxFQUFFO1FBQzFCLGlCQUFpQixDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7S0FDdkM7SUFDRCxJQUFJLFNBQVMsRUFBRTtRQUNiLHNCQUFzQixDQUFDLEtBQUssRUFBRSxPQUFPLEVBQUUsS0FBSyxDQUFDLElBQUksRUFBRSxPQUFPLEVBQUUsS0FBSyxDQUFDLENBQUM7S0FDcEU7QUFDSCxDQUFDO0FBRUQsTUFBTSxVQUFVLHdCQUF3QixDQUNwQyxhQUFtQyxFQUFFLEdBQUcsZ0JBQXVCO0lBQ2pFLDRCQUE0QjtJQUM1QixJQUFJLE9BQU8sR0FBRyxhQUFhLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDL0IsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLGFBQWEsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7UUFDN0MsT0FBTyxJQUFJLGVBQWUsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxhQUFhLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDeEU7SUFDRCxPQUFPLE9BQU8sQ0FBQztBQUNqQixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cblxuaW1wb3J0IHtTSUdOQUx9IGZyb20gJ0Bhbmd1bGFyL2NvcmUvcHJpbWl0aXZlcy9zaWduYWxzJztcblxuaW1wb3J0IHt2YWxpZGF0ZUFnYWluc3RFdmVudFByb3BlcnRpZXN9IGZyb20gJy4uLy4uL3Nhbml0aXphdGlvbi9zYW5pdGl6YXRpb24nO1xuaW1wb3J0IHthc3NlcnREZWZpbmVkLCBhc3NlcnRJbmRleEluUmFuZ2V9IGZyb20gJy4uLy4uL3V0aWwvYXNzZXJ0JztcbmltcG9ydCB7RU1QVFlfQVJSQVl9IGZyb20gJy4uLy4uL3V0aWwvZW1wdHknO1xuaW1wb3J0IHtiaW5kaW5nVXBkYXRlZH0gZnJvbSAnLi4vYmluZGluZ3MnO1xuaW1wb3J0IHtEaXJlY3RpdmVEZWZ9IGZyb20gJy4uL2ludGVyZmFjZXMvZGVmaW5pdGlvbic7XG5pbXBvcnQge1Byb3BlcnR5QWxpYXNWYWx1ZSwgVE5vZGV9IGZyb20gJy4uL2ludGVyZmFjZXMvbm9kZSc7XG5pbXBvcnQge1JDb21tZW50LCBSRWxlbWVudH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9yZW5kZXJlcl9kb20nO1xuaW1wb3J0IHtTYW5pdGl6ZXJGbn0gZnJvbSAnLi4vaW50ZXJmYWNlcy9zYW5pdGl6YXRpb24nO1xuaW1wb3J0IHtpc0NvbXBvbmVudEhvc3R9IGZyb20gJy4uL2ludGVyZmFjZXMvdHlwZV9jaGVja3MnO1xuaW1wb3J0IHtIRUFERVJfT0ZGU0VULCBSRU5ERVJFUn0gZnJvbSAnLi4vaW50ZXJmYWNlcy92aWV3JztcbmltcG9ydCB7Y29tcHV0ZWR9IGZyb20gJy4uL3JlYWN0aXZpdHkvY29tcHV0ZWQnO1xuaW1wb3J0IHtJbnB1dFNpZ25hbE5vZGV9IGZyb20gJy4uL3JlYWN0aXZpdHkvaW5wdXRfc2lnbmFsJztcbmltcG9ydCB7Z2V0Q3VycmVudFROb2RlLCBnZXRMVmlldywgZ2V0VFZpZXcsIG5leHRCaW5kaW5nSW5kZXh9IGZyb20gJy4uL3N0YXRlJztcbmltcG9ydCB7cmVuZGVyU3RyaW5naWZ5fSBmcm9tICcuLi91dGlsL3N0cmluZ2lmeV91dGlscyc7XG5pbXBvcnQge2dldE5hdGl2ZUJ5VE5vZGV9IGZyb20gJy4uL3V0aWwvdmlld191dGlscyc7XG5cbmltcG9ydCB7aGFuZGxlVW5rbm93blByb3BlcnR5RXJyb3IsIGlzUHJvcGVydHlWYWxpZH0gZnJvbSAnLi9lbGVtZW50X3ZhbGlkYXRpb24nO1xuaW1wb3J0IHttYXBQcm9wTmFtZSwgbWFya0RpcnR5SWZPblB1c2gsIHNldE5nUmVmbGVjdFByb3BlcnRpZXMsIHdyaXRlVG9EaXJlY3RpdmVJbnB1dH0gZnJvbSAnLi9zaGFyZWQnO1xuXG4vKipcbiAqIFRPRE9cbiAqXG4gKiBAY29kZUdlbkFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gybXJtXByb3BlcnR5Q3JlYXRlPFQ+KFxuICAgIHNsb3Q6IG51bWJlciwgcHJvcE5hbWU6IHN0cmluZywgZXhwcjogKCkgPT4gVCxcbiAgICBzYW5pdGl6ZXI/OiBTYW5pdGl6ZXJGbnxudWxsKTogdHlwZW9mIMm1ybVwcm9wZXJ0eUNyZWF0ZSB7XG4gIGNvbnN0IGxWaWV3ID0gZ2V0TFZpZXcoKTtcbiAgY29uc3QgZXhwcmVzc2lvblNsb3QgPSBIRUFERVJfT0ZGU0VUICsgc2xvdDtcblxuICBjb25zdCB0VmlldyA9IGdldFRWaWV3KCk7XG4gIGNvbnN0IHROb2RlID0gZ2V0Q3VycmVudFROb2RlKCk7XG4gIGFzc2VydERlZmluZWQodE5vZGUsIGBwcm9wZXJ0eUNyZWF0ZSgpIG11c3QgZm9sbG93IGFuIGFjdHVhbCBlbGVtZW50YCk7XG5cbiAgY29uc3QgaW5wdXREYXRhID0gdE5vZGUuaW5wdXRzPy5bcHJvcE5hbWVdID8/IEVNUFRZX0FSUkFZO1xuXG4gIGxldCBzaWduYWxJbnB1dHM6IElucHV0U2lnbmFsTm9kZTx1bmtub3duLCB1bmtub3duPltdfG51bGwgPSBudWxsO1xuXG4gIC8vIFBFUkY6IHRoZSBmYWN0IHRoYXQgd2UgbmVlZCB0byBpdGVyYXRlIG92ZXIgYWxsIHRoZSBpbnB1dHMgaGVyZSBpc24ndCBncmVhdC5cbiAgLy8gV2UgbWlnaHQgY29uc2lkZXIgc3RvcmluZyBtb3JlIGluZm8gb24gVFZpZXdcbiAgbGV0IHpvbmVUYXJnZXRzOiBQcm9wZXJ0eUFsaWFzVmFsdWV8bnVsbCA9IG51bGw7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXREYXRhLmxlbmd0aDspIHtcbiAgICBjb25zdCBkaXJlY3RpdmVJbmRleCA9IGlucHV0RGF0YVtpKytdIGFzIG51bWJlcjtcbiAgICBjb25zdCBwcml2YXRlTmFtZSA9IGlucHV0RGF0YVtpKytdIGFzIHN0cmluZztcbiAgICBjb25zdCBkZWYgPSB0Vmlldy5kYXRhW2RpcmVjdGl2ZUluZGV4XSBhcyBEaXJlY3RpdmVEZWY8YW55PjtcbiAgICBpZiAoIWRlZi5zaWduYWxzKSB7XG4gICAgICAvLyBUT0RPKHBrKTogcmVmYWN0b3IgLSBjb2RlIGZsb3cgd2l0aCBhbGwgdGhvc2UgZmlyc3RDcmVhdGVQYXNzIGNoZWNrcyBiZWNvbWVzIGhhcmQgdG8gZm9sbG93XG4gICAgICBpZiAodFZpZXcuZmlyc3RDcmVhdGVQYXNzKSB7XG4gICAgICAgICh6b25lVGFyZ2V0cyA/Pz0gW10pLnB1c2goZGlyZWN0aXZlSW5kZXgsIHByaXZhdGVOYW1lKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbmdEZXZNb2RlICYmIGFzc2VydEluZGV4SW5SYW5nZShsVmlldywgZGlyZWN0aXZlSW5kZXgpO1xuICAgICAgLy8gUEVSRjogbWVnYW1vcnBoaWMgcmVhZCBvbiBbcHJpdmF0ZU5hbWVdIGFjY2Vzc1xuICAgICAgY29uc3QgaW5wdXRTaWduYWwgPVxuICAgICAgICAgIGxWaWV3W2RpcmVjdGl2ZUluZGV4XVtwcml2YXRlTmFtZV1bU0lHTkFMXSBhcyBJbnB1dFNpZ25hbE5vZGU8dW5rbm93biwgdW5rbm93bj47XG4gICAgICAoc2lnbmFsSW5wdXRzID8/PSBbXSkucHVzaChpbnB1dFNpZ25hbCk7XG4gICAgfVxuICB9XG5cbiAgem9uZVRhcmdldHMgPz89IEVNUFRZX0FSUkFZO1xuICBzaWduYWxJbnB1dHMgPz89IEVNUFRZX0FSUkFZO1xuXG4gIC8vIFBFUkYocGspOiBJIGNvdWxkIGF2b2lkIHdyYXBwaW5nIGludG8gY29tcHV0ZWQgZm9yIHRoZSBjYXNlIG9mIGEgc2luZ2xlIGJpbmRpbmcgdG8gYSBzaWduYWxcbiAgLy8gYmFzZWQgY29tcG9uZW50XG4gIGV4cHIgPSBjb21wdXRlZChleHByKTtcblxuICBsVmlld1tleHByZXNzaW9uU2xvdF0gPSBleHByO1xuICBmb3IgKGNvbnN0IGlucHV0U2lnbmFsIG9mIHNpZ25hbElucHV0cykge1xuICAgIC8vIFRPRE86IEltcHJvdmUgdGhpcyBieSBub3QgYWxsb2NhdGluZyBhbiBvYmplY3QgbGl0ZXJhbCBoZXJlLiBUaGlzIGV4aXN0cyBqdXN0IGZvciB0ZXN0aW5nLlxuICAgIGlucHV0U2lnbmFsLmJpbmQoaW5wdXRTaWduYWwsIHtjb21wdXRhdGlvbjogZXhwcn0pO1xuXG4gICAgLy8gVE9ETzogZmlndXJlIG91dCB3aGVyZSB0byBzZXQgYGlzSW5pdGlhbGl6ZWRgLlxuICAgIGlucHV0U2lnbmFsLmlzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICB9XG5cbiAgaWYgKHRWaWV3LmZpcnN0Q3JlYXRlUGFzcykge1xuICAgIGlmIChpbnB1dERhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBVbnRhcmdldGVkIGlucHV0IC0+IERPTSBiaW5kaW5nLlxuICAgICAgKHRWaWV3LnZpcnR1YWxVcGRhdGUgPz89IFtdKS5wdXNoKHtcbiAgICAgICAgc2xvdDogZXhwcmVzc2lvblNsb3QsXG4gICAgICAgIGluc3RydWN0aW9uOiAoKSA9PlxuICAgICAgICAgICAgcHJvcGVydHlVcGRhdGVEb20odE5vZGUuaW5kZXgsIHByb3BOYW1lLCBleHByZXNzaW9uU2xvdCwgc2FuaXRpemVyID8/IG51bGwpLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh6b25lVGFyZ2V0cy5sZW5ndGgpIHtcbiAgICAgIC8vIFNvbWUgYmluZGluZyB0YXJnZXRzIHdlcmUgem9uZS1iYXNlZCwgc28gd2UgbmVlZCBhbiB1cGRhdGUgaW5zdHJ1Y3Rpb24gdG8gcHJvY2VzcyB0aGVtLlxuICAgICAgKHRWaWV3LnZpcnR1YWxVcGRhdGUgPz89IFtdKS5wdXNoKHtcbiAgICAgICAgc2xvdDogZXhwcmVzc2lvblNsb3QsXG4gICAgICAgIGluc3RydWN0aW9uOiAoKSA9PiBwcm9wZXJ0eVVwZGF0ZUlucHV0KHROb2RlLmluZGV4LCBwcm9wTmFtZSwgZXhwcmVzc2lvblNsb3QsIHpvbmVUYXJnZXRzISksXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlIG9ubHkgdGFyZ2V0KHMpIHdlcmUgc2lnbmFsLWJhc2VkLCBzbyBubyB1cGRhdGUgcGF0aCBpcyBuZWVkZWQuXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIMm1ybVwcm9wZXJ0eUNyZWF0ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByb3BlcnR5VXBkYXRlRG9tKFxuICAgIG5vZGVTbG90OiBudW1iZXIsIHByb3BOYW1lOiBzdHJpbmcsIGV4cHJlc3Npb25TbG90OiBudW1iZXIsIHNhbml0aXplcjogU2FuaXRpemVyRm58bnVsbCk6IHZvaWQge1xuICBjb25zdCBsVmlldyA9IGdldExWaWV3KCk7XG4gIGNvbnN0IGV4cHIgPSBsVmlld1tleHByZXNzaW9uU2xvdF07XG5cbiAgbGV0IHZhbHVlID0gZXhwcigpO1xuICBjb25zdCBiaW5kaW5nSW5kZXggPSBuZXh0QmluZGluZ0luZGV4KCk7XG4gIGlmICghYmluZGluZ1VwZGF0ZWQobFZpZXcsIGJpbmRpbmdJbmRleCwgdmFsdWUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgdFZpZXcgPSBnZXRUVmlldygpO1xuICBjb25zdCB0Tm9kZSA9IHRWaWV3LmRhdGFbbm9kZVNsb3RdIGFzIFROb2RlO1xuICBjb25zdCBlbGVtZW50ID0gZ2V0TmF0aXZlQnlUTm9kZSh0Tm9kZSwgbFZpZXcpIGFzIFJFbGVtZW50IHwgUkNvbW1lbnQ7XG5cbiAgcHJvcE5hbWUgPSBtYXBQcm9wTmFtZShwcm9wTmFtZSk7XG5cbiAgaWYgKG5nRGV2TW9kZSkge1xuICAgIHZhbGlkYXRlQWdhaW5zdEV2ZW50UHJvcGVydGllcyhwcm9wTmFtZSk7XG4gICAgaWYgKCFpc1Byb3BlcnR5VmFsaWQoZWxlbWVudCwgcHJvcE5hbWUsIHROb2RlLnZhbHVlLCB0Vmlldy5zY2hlbWFzKSkge1xuICAgICAgaGFuZGxlVW5rbm93blByb3BlcnR5RXJyb3IocHJvcE5hbWUsIHROb2RlLnZhbHVlLCB0Tm9kZS50eXBlLCBsVmlldyk7XG4gICAgfVxuICAgIG5nRGV2TW9kZS5yZW5kZXJlclNldFByb3BlcnR5Kys7XG4gIH1cblxuICAvLyBJdCBpcyBhc3N1bWVkIHRoYXQgdGhlIHNhbml0aXplciBpcyBvbmx5IGFkZGVkIHdoZW4gdGhlIGNvbXBpbGVyIGRldGVybWluZXMgdGhhdCB0aGVcbiAgLy8gcHJvcGVydHkgaXMgcmlza3ksIHNvIHNhbml0aXphdGlvbiBjYW4gYmUgZG9uZSB3aXRob3V0IGZ1cnRoZXIgY2hlY2tzLlxuICB2YWx1ZSA9IHNhbml0aXplciAhPSBudWxsID8gKHNhbml0aXplcih2YWx1ZSwgdE5vZGUudmFsdWUgfHwgJycsIHByb3BOYW1lKSBhcyBhbnkpIDogdmFsdWU7XG4gIGxWaWV3W1JFTkRFUkVSXS5zZXRQcm9wZXJ0eShlbGVtZW50IGFzIFJFbGVtZW50LCBwcm9wTmFtZSwgdmFsdWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJvcGVydHlVcGRhdGVJbnB1dChcbiAgICBub2RlSW5kZXg6IG51bWJlciwgcHJvcE5hbWU6IHN0cmluZywgZXhwcmVzc2lvblNsb3Q6IG51bWJlcixcbiAgICB0YXJnZXRzOiBQcm9wZXJ0eUFsaWFzVmFsdWUpOiB2b2lkIHtcbiAgY29uc3QgbFZpZXcgPSBnZXRMVmlldygpO1xuICBjb25zdCBleHByID0gbFZpZXdbZXhwcmVzc2lvblNsb3RdO1xuICBjb25zdCB2YWx1ZSA9IGV4cHIoKTtcblxuICBjb25zdCB0VmlldyA9IGdldFRWaWV3KCk7XG4gIGNvbnN0IHROb2RlID0gdFZpZXcuZGF0YVtub2RlSW5kZXhdIGFzIFROb2RlO1xuXG4gIG5nRGV2TW9kZSAmJiBhc3NlcnREZWZpbmVkKHROb2RlLmlucHV0cywgYEV4cGVjdGVkIHROb2RlIHRvIGhhdmUgaW5wdXRzYCk7XG5cbiAgY29uc3QgYmluZGluZ0luZGV4ID0gbmV4dEJpbmRpbmdJbmRleCgpO1xuICBpZiAoIWJpbmRpbmdVcGRhdGVkKGxWaWV3LCBiaW5kaW5nSW5kZXgsIHZhbHVlKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGFyZ2V0cy5sZW5ndGg7KSB7XG4gICAgY29uc3QgaW5kZXggPSB0YXJnZXRzW2krK10gYXMgbnVtYmVyO1xuICAgIGNvbnN0IHByaXZhdGVOYW1lID0gdGFyZ2V0c1tpKytdIGFzIHN0cmluZztcbiAgICBuZ0Rldk1vZGUgJiYgYXNzZXJ0SW5kZXhJblJhbmdlKGxWaWV3LCBpbmRleCk7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBsVmlld1tpbmRleF07XG4gICAgY29uc3QgZGVmID0gdFZpZXcuZGF0YVtpbmRleF0gYXMgRGlyZWN0aXZlRGVmPGFueT47XG5cbiAgICB3cml0ZVRvRGlyZWN0aXZlSW5wdXQoZGVmLCBpbnN0YW5jZSwgcHJvcE5hbWUsIHByaXZhdGVOYW1lLCB2YWx1ZSk7XG4gIH1cblxuICBjb25zdCBlbGVtZW50ID0gZ2V0TmF0aXZlQnlUTm9kZSh0Tm9kZSwgbFZpZXcpIGFzIFJFbGVtZW50IHwgUkNvbW1lbnQ7XG4gIGlmIChpc0NvbXBvbmVudEhvc3QodE5vZGUpKSB7XG4gICAgbWFya0RpcnR5SWZPblB1c2gobFZpZXcsIHROb2RlLmluZGV4KTtcbiAgfVxuICBpZiAobmdEZXZNb2RlKSB7XG4gICAgc2V0TmdSZWZsZWN0UHJvcGVydGllcyhsVmlldywgZWxlbWVudCwgdE5vZGUudHlwZSwgdGFyZ2V0cywgdmFsdWUpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiDJtcm1c3RyaW5naWZ5SW50ZXJwb2xhdGlvbihcbiAgICBzdGF0aWNTdHJpbmdzOiBUZW1wbGF0ZVN0cmluZ3NBcnJheSwgLi4uZXhwcmVzc2lvblZhbHVlczogYW55W10pOiBzdHJpbmcge1xuICAvLyBCdWlsZCB0aGUgdXBkYXRlZCBjb250ZW50XG4gIGxldCBjb250ZW50ID0gc3RhdGljU3RyaW5nc1swXTtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBzdGF0aWNTdHJpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29udGVudCArPSByZW5kZXJTdHJpbmdpZnkoZXhwcmVzc2lvblZhbHVlc1tpIC0gMV0pICsgc3RhdGljU3RyaW5nc1tpXTtcbiAgfVxuICByZXR1cm4gY29udGVudDtcbn1cbiJdfQ==
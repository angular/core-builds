/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { createWatch } from '@angular/core/primitives/signals';
import { ChangeDetectorRef } from '../../change_detection';
import { assertInInjectionContext } from '../../di/contextual';
import { InjectionToken } from '../../di/injection_token';
import { Injector } from '../../di/injector';
import { inject } from '../../di/injector_compatibility';
import { ɵɵdefineInjectable } from '../../di/interface/defs';
import { ErrorHandler } from '../../error_handler';
import { DestroyRef } from '../../linker/destroy_ref';
import { FLAGS, EFFECTS_TO_SCHEDULE } from '../interfaces/view';
import { assertNotInReactiveContext } from './asserts';
/**
 * Not public API, which guarantees `EffectScheduler` only ever comes from the application root
 * injector.
 */
export const APP_EFFECT_SCHEDULER = new InjectionToken('', {
    providedIn: 'root',
    factory: () => inject(EffectScheduler),
});
/**
 * A scheduler which manages the execution of effects.
 */
export class EffectScheduler {
    /** @nocollapse */
    static { this.ɵprov = ɵɵdefineInjectable({
        token: EffectScheduler,
        providedIn: 'root',
        factory: () => new ZoneAwareMicrotaskScheduler(),
    }); }
}
/**
 * An `EffectScheduler` which is capable of queueing scheduled effects per-zone, and flushing them
 * as an explicit operation.
 */
export class ZoneAwareQueueingScheduler {
    constructor() {
        this.queuedEffectCount = 0;
        this.queues = new Map();
    }
    scheduleEffect(handle) {
        const zone = handle.creationZone;
        if (!this.queues.has(zone)) {
            this.queues.set(zone, new Set());
        }
        const queue = this.queues.get(zone);
        if (queue.has(handle)) {
            return;
        }
        this.queuedEffectCount++;
        queue.add(handle);
    }
    /**
     * Run all scheduled effects.
     *
     * Execution order of effects within the same zone is guaranteed to be FIFO, but there is no
     * ordering guarantee between effects scheduled in different zones.
     */
    flush() {
        while (this.queuedEffectCount > 0) {
            for (const [zone, queue] of this.queues) {
                // `zone` here must be defined.
                if (zone === null) {
                    this.flushQueue(queue);
                }
                else {
                    zone.run(() => this.flushQueue(queue));
                }
            }
        }
    }
    flushQueue(queue) {
        for (const handle of queue) {
            queue.delete(handle);
            this.queuedEffectCount--;
            // TODO: what happens if this throws an error?
            handle.run();
        }
    }
    /** @nocollapse */
    static { this.ɵprov = ɵɵdefineInjectable({
        token: ZoneAwareQueueingScheduler,
        providedIn: 'root',
        factory: () => new ZoneAwareQueueingScheduler(),
    }); }
}
/**
 * A wrapper around `ZoneAwareQueueingScheduler` that schedules flushing via the microtask queue
 * when.
 */
export class ZoneAwareMicrotaskScheduler {
    constructor() {
        this.hasQueuedFlush = false;
        this.delegate = new ZoneAwareQueueingScheduler();
        this.flushTask = () => {
            // Leave `hasQueuedFlush` as `true` so we don't queue another microtask if more effects are
            // scheduled during flushing. The flush of the `ZoneAwareQueueingScheduler` delegate is
            // guaranteed to empty the queue.
            this.delegate.flush();
            this.hasQueuedFlush = false;
            // This is a variable initialization, not a method.
            // tslint:disable-next-line:semicolon
        };
    }
    scheduleEffect(handle) {
        this.delegate.scheduleEffect(handle);
        if (!this.hasQueuedFlush) {
            queueMicrotask(this.flushTask);
            this.hasQueuedFlush = true;
        }
    }
}
/**
 * Core reactive node for an Angular effect.
 *
 * `EffectHandle` combines the reactive graph's `Watch` base node for effects with the framework's
 * scheduling abstraction (`EffectScheduler`) as well as automatic cleanup via `DestroyRef` if
 * available/requested.
 */
class EffectHandle {
    constructor(scheduler, effectFn, creationZone, destroyRef, errorHandler, allowSignalWrites) {
        this.scheduler = scheduler;
        this.effectFn = effectFn;
        this.creationZone = creationZone;
        this.errorHandler = errorHandler;
        this.watcher = createWatch((onCleanup) => this.runEffect(onCleanup), () => this.schedule(), allowSignalWrites);
        this.unregisterOnDestroy = destroyRef?.onDestroy(() => this.destroy());
    }
    runEffect(onCleanup) {
        try {
            this.effectFn(onCleanup);
        }
        catch (err) {
            this.errorHandler?.handleError(err);
        }
    }
    run() {
        this.watcher.run();
    }
    schedule() {
        this.scheduler.scheduleEffect(this);
    }
    destroy() {
        this.watcher.destroy();
        this.unregisterOnDestroy?.();
        // Note: if the effect is currently scheduled, it's not un-scheduled, and so the scheduler will
        // retain a reference to it. Attempting to execute it will be a no-op.
    }
}
/**
 * Create a global `Effect` for the given reactive function.
 */
export function effect(effectFn, options) {
    ngDevMode &&
        assertNotInReactiveContext(effect, 'Call `effect` outside of a reactive context. For example, schedule the ' +
            'effect inside the component constructor.');
    !options?.injector && assertInInjectionContext(effect);
    const injector = options?.injector ?? inject(Injector);
    const errorHandler = injector.get(ErrorHandler, null, { optional: true });
    const destroyRef = options?.manualCleanup !== true ? injector.get(DestroyRef) : null;
    const handle = new EffectHandle(injector.get(APP_EFFECT_SCHEDULER), effectFn, (typeof Zone === 'undefined') ? null : Zone.current, destroyRef, errorHandler, options?.allowSignalWrites ?? false);
    // Effects need to be marked dirty manually to trigger their initial run. The timing of this
    // marking matters, because the effects may read signals that track component inputs, which are
    // only available after those components have had their first update pass.
    //
    // We inject `ChangeDetectorRef` optionally, to determine whether this effect is being created in
    // the context of a component or not. If it is, then we check whether the component has already
    // run its update pass, and defer the effect's initial scheduling until the update pass if it
    // hasn't already run.
    const cdr = injector.get(ChangeDetectorRef, null, { optional: true });
    if (!cdr || !(cdr._lView[FLAGS] & 8 /* LViewFlags.FirstLViewPass */)) {
        // This effect is either not running in a view injector, or the view has already
        // undergone its first change detection pass, which is necessary for any required inputs to be
        // set.
        handle.watcher.notify();
    }
    else {
        // Delay the initialization of the effect until the view is fully initialized.
        (cdr._lView[EFFECTS_TO_SCHEDULE] ??= []).push(handle.watcher.notify);
    }
    return handle;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWZmZWN0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvY29yZS9zcmMvcmVuZGVyMy9yZWFjdGl2aXR5L2VmZmVjdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0dBTUc7QUFFSCxPQUFPLEVBQUMsV0FBVyxFQUFnQyxNQUFNLGtDQUFrQyxDQUFDO0FBRTVGLE9BQU8sRUFBQyxpQkFBaUIsRUFBQyxNQUFNLHdCQUF3QixDQUFDO0FBQ3pELE9BQU8sRUFBQyx3QkFBd0IsRUFBQyxNQUFNLHFCQUFxQixDQUFDO0FBQzdELE9BQU8sRUFBQyxjQUFjLEVBQUMsTUFBTSwwQkFBMEIsQ0FBQztBQUN4RCxPQUFPLEVBQUMsUUFBUSxFQUFDLE1BQU0sbUJBQW1CLENBQUM7QUFDM0MsT0FBTyxFQUFDLE1BQU0sRUFBQyxNQUFNLGlDQUFpQyxDQUFDO0FBQ3ZELE9BQU8sRUFBQyxrQkFBa0IsRUFBQyxNQUFNLHlCQUF5QixDQUFDO0FBQzNELE9BQU8sRUFBQyxZQUFZLEVBQUMsTUFBTSxxQkFBcUIsQ0FBQztBQUVqRCxPQUFPLEVBQUMsVUFBVSxFQUFDLE1BQU0sMEJBQTBCLENBQUM7QUFDcEQsT0FBTyxFQUFDLEtBQUssRUFBYyxtQkFBbUIsRUFBQyxNQUFNLG9CQUFvQixDQUFDO0FBRTFFLE9BQU8sRUFBQywwQkFBMEIsRUFBQyxNQUFNLFdBQVcsQ0FBQztBQW9CckQ7OztHQUdHO0FBQ0gsTUFBTSxDQUFDLE1BQU0sb0JBQW9CLEdBQUcsSUFBSSxjQUFjLENBQUMsRUFBRSxFQUFFO0lBQ3pELFVBQVUsRUFBRSxNQUFNO0lBQ2xCLE9BQU8sRUFBRSxHQUFHLEVBQUUsQ0FBQyxNQUFNLENBQUMsZUFBZSxDQUFDO0NBQ3ZDLENBQUMsQ0FBQztBQUVIOztHQUVHO0FBQ0gsTUFBTSxPQUFnQixlQUFlO0lBUW5DLGtCQUFrQjthQUNYLFVBQUssR0FBNkIsa0JBQWtCLENBQUM7UUFDMUQs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QyxDQUFDO0lBQzlGLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLG9DQUE0QixDQUFDLEVBQUU7UUFDNUQsZ0ZBQWdGO1FBQ2hGLDhGQUE4RjtRQUM5RixPQUFPO1FBQ1AsTUFBTSxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsQ0FBQztLQUN6QjtTQUFNO1FBQ0wsOEVBQThFO1FBQzlFLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0tBQ3RFO0lBRUQsT0FBTyxNQUFNLENBQUM7QUFDaEIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG5pbXBvcnQge2NyZWF0ZVdhdGNoLCBXYXRjaCwgV2F0Y2hDbGVhbnVwUmVnaXN0ZXJGbn0gZnJvbSAnQGFuZ3VsYXIvY29yZS9wcmltaXRpdmVzL3NpZ25hbHMnO1xuXG5pbXBvcnQge0NoYW5nZURldGVjdG9yUmVmfSBmcm9tICcuLi8uLi9jaGFuZ2VfZGV0ZWN0aW9uJztcbmltcG9ydCB7YXNzZXJ0SW5JbmplY3Rpb25Db250ZXh0fSBmcm9tICcuLi8uLi9kaS9jb250ZXh0dWFsJztcbmltcG9ydCB7SW5qZWN0aW9uVG9rZW59IGZyb20gJy4uLy4uL2RpL2luamVjdGlvbl90b2tlbic7XG5pbXBvcnQge0luamVjdG9yfSBmcm9tICcuLi8uLi9kaS9pbmplY3Rvcic7XG5pbXBvcnQge2luamVjdH0gZnJvbSAnLi4vLi4vZGkvaW5qZWN0b3JfY29tcGF0aWJpbGl0eSc7XG5pbXBvcnQge8m1ybVkZWZpbmVJbmplY3RhYmxlfSBmcm9tICcuLi8uLi9kaS9pbnRlcmZhY2UvZGVmcyc7XG5pbXBvcnQge0Vycm9ySGFuZGxlcn0gZnJvbSAnLi4vLi4vZXJyb3JfaGFuZGxlcic7XG5pbXBvcnQgdHlwZSB7SW50ZXJuYWxWaWV3UmVmfSBmcm9tICcuLi92aWV3X3JlZic7XG5pbXBvcnQge0Rlc3Ryb3lSZWZ9IGZyb20gJy4uLy4uL2xpbmtlci9kZXN0cm95X3JlZic7XG5pbXBvcnQge0ZMQUdTLCBMVmlld0ZsYWdzLCBFRkZFQ1RTX1RPX1NDSEVEVUxFfSBmcm9tICcuLi9pbnRlcmZhY2VzL3ZpZXcnO1xuXG5pbXBvcnQge2Fzc2VydE5vdEluUmVhY3RpdmVDb250ZXh0fSBmcm9tICcuL2Fzc2VydHMnO1xuXG5cbi8qKlxuICogQW4gZWZmZWN0IGNhbiwgb3B0aW9uYWxseSwgcmVnaXN0ZXIgYSBjbGVhbnVwIGZ1bmN0aW9uLiBJZiByZWdpc3RlcmVkLCB0aGUgY2xlYW51cCBpcyBleGVjdXRlZFxuICogYmVmb3JlIHRoZSBuZXh0IGVmZmVjdCBydW4uIFRoZSBjbGVhbnVwIGZ1bmN0aW9uIG1ha2VzIGl0IHBvc3NpYmxlIHRvIFwiY2FuY2VsXCIgYW55IHdvcmsgdGhhdCB0aGVcbiAqIHByZXZpb3VzIGVmZmVjdCBydW4gbWlnaHQgaGF2ZSBzdGFydGVkLlxuICovXG5leHBvcnQgdHlwZSBFZmZlY3RDbGVhbnVwRm4gPSAoKSA9PiB2b2lkO1xuXG4vKipcbiAqIEEgY2FsbGJhY2sgcGFzc2VkIHRvIHRoZSBlZmZlY3QgZnVuY3Rpb24gdGhhdCBtYWtlcyBpdCBwb3NzaWJsZSB0byByZWdpc3RlciBjbGVhbnVwIGxvZ2ljLlxuICovXG5leHBvcnQgdHlwZSBFZmZlY3RDbGVhbnVwUmVnaXN0ZXJGbiA9IChjbGVhbnVwRm46IEVmZmVjdENsZWFudXBGbikgPT4gdm9pZDtcblxuZXhwb3J0IGludGVyZmFjZSBTY2hlZHVsYWJsZUVmZmVjdCB7XG4gIHJ1bigpOiB2b2lkO1xuICBjcmVhdGlvblpvbmU6IHVua25vd247XG59XG5cbi8qKlxuICogTm90IHB1YmxpYyBBUEksIHdoaWNoIGd1YXJhbnRlZXMgYEVmZmVjdFNjaGVkdWxlcmAgb25seSBldmVyIGNvbWVzIGZyb20gdGhlIGFwcGxpY2F0aW9uIHJvb3RcbiAqIGluamVjdG9yLlxuICovXG5leHBvcnQgY29uc3QgQVBQX0VGRkVDVF9TQ0hFRFVMRVIgPSBuZXcgSW5qZWN0aW9uVG9rZW4oJycsIHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnLFxuICBmYWN0b3J5OiAoKSA9PiBpbmplY3QoRWZmZWN0U2NoZWR1bGVyKSxcbn0pO1xuXG4vKipcbiAqIEEgc2NoZWR1bGVyIHdoaWNoIG1hbmFnZXMgdGhlIGV4ZWN1dGlvbiBvZiBlZmZlY3RzLlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgRWZmZWN0U2NoZWR1bGVyIHtcbiAgLyoqXG4gICAqIFNjaGVkdWxlIHRoZSBnaXZlbiBlZmZlY3QgdG8gYmUgZXhlY3V0ZWQgYXQgYSBsYXRlciB0aW1lLlxuICAgKlxuICAgKiBJdCBpcyBhbiBlcnJvciB0byBhdHRlbXB0IHRvIGV4ZWN1dGUgYW55IGVmZmVjdHMgc3luY2hyb25vdXNseSBkdXJpbmcgYSBzY2hlZHVsaW5nIG9wZXJhdGlvbi5cbiAgICovXG4gIGFic3RyYWN0IHNjaGVkdWxlRWZmZWN0KGU6IFNjaGVkdWxhYmxlRWZmZWN0KTogdm9pZDtcblxuICAvKiogQG5vY29sbGFwc2UgKi9cbiAgc3RhdGljIMm1cHJvdiA9IC8qKiBAcHVyZU9yQnJlYWtNeUNvZGUgKi8gybXJtWRlZmluZUluamVjdGFibGUoe1xuICAgIHRva2VuOiBFZmZlY3RTY2hlZHVsZXIsXG4gICAgcHJvdmlkZWRJbjogJ3Jvb3QnLFxuICAgIGZhY3Rvcnk6ICgpID0+IG5ldyBab25lQXdhcmVNaWNyb3Rhc2tTY2hlZHVsZXIoKSxcbiAgfSk7XG59XG5cbi8qKlxuICogSW50ZXJmYWNlIHRvIGFuIGBFZmZlY3RTY2hlZHVsZXJgIGNhcGFibGUgb2YgcnVubmluZyBzY2hlZHVsZWQgZWZmZWN0cyBzeW5jaHJvbm91c2x5LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEZsdXNoYWJsZUVmZmVjdFJ1bm5lciB7XG4gIC8qKlxuICAgKiBSdW4gYW55IHNjaGVkdWxlZCBlZmZlY3RzLlxuICAgKi9cbiAgZmx1c2goKTogdm9pZDtcbn1cblxuLyoqXG4gKiBBbiBgRWZmZWN0U2NoZWR1bGVyYCB3aGljaCBpcyBjYXBhYmxlIG9mIHF1ZXVlaW5nIHNjaGVkdWxlZCBlZmZlY3RzIHBlci16b25lLCBhbmQgZmx1c2hpbmcgdGhlbVxuICogYXMgYW4gZXhwbGljaXQgb3BlcmF0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgWm9uZUF3YXJlUXVldWVpbmdTY2hlZHVsZXIgaW1wbGVtZW50cyBFZmZlY3RTY2hlZHVsZXIsIEZsdXNoYWJsZUVmZmVjdFJ1bm5lciB7XG4gIHByaXZhdGUgcXVldWVkRWZmZWN0Q291bnQgPSAwO1xuICBwcml2YXRlIHF1ZXVlcyA9IG5ldyBNYXA8Wm9uZXxudWxsLCBTZXQ8U2NoZWR1bGFibGVFZmZlY3Q+PigpO1xuXG4gIHNjaGVkdWxlRWZmZWN0KGhhbmRsZTogU2NoZWR1bGFibGVFZmZlY3QpOiB2b2lkIHtcbiAgICBjb25zdCB6b25lID0gaGFuZGxlLmNyZWF0aW9uWm9uZSBhcyBab25lIHwgbnVsbDtcbiAgICBpZiAoIXRoaXMucXVldWVzLmhhcyh6b25lKSkge1xuICAgICAgdGhpcy5xdWV1ZXMuc2V0KHpvbmUsIG5ldyBTZXQoKSk7XG4gICAgfVxuXG4gICAgY29uc3QgcXVldWUgPSB0aGlzLnF1ZXVlcy5nZXQoem9uZSkhO1xuICAgIGlmIChxdWV1ZS5oYXMoaGFuZGxlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnF1ZXVlZEVmZmVjdENvdW50Kys7XG4gICAgcXVldWUuYWRkKGhhbmRsZSk7XG4gIH1cblxuICAvKipcbiAgICogUnVuIGFsbCBzY2hlZHVsZWQgZWZmZWN0cy5cbiAgICpcbiAgICogRXhlY3V0aW9uIG9yZGVyIG9mIGVmZmVjdHMgd2l0aGluIHRoZSBzYW1lIHpvbmUgaXMgZ3VhcmFudGVlZCB0byBiZSBGSUZPLCBidXQgdGhlcmUgaXMgbm9cbiAgICogb3JkZXJpbmcgZ3VhcmFudGVlIGJldHdlZW4gZWZmZWN0cyBzY2hlZHVsZWQgaW4gZGlmZmVyZW50IHpvbmVzLlxuICAgKi9cbiAgZmx1c2goKTogdm9pZCB7XG4gICAgd2hpbGUgKHRoaXMucXVldWVkRWZmZWN0Q291bnQgPiAwKSB7XG4gICAgICBmb3IgKGNvbnN0IFt6b25lLCBxdWV1ZV0gb2YgdGhpcy5xdWV1ZXMpIHtcbiAgICAgICAgLy8gYHpvbmVgIGhlcmUgbXVzdCBiZSBkZWZpbmVkLlxuICAgICAgICBpZiAoem9uZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuZmx1c2hRdWV1ZShxdWV1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgem9uZS5ydW4oKCkgPT4gdGhpcy5mbHVzaFF1ZXVlKHF1ZXVlKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGZsdXNoUXVldWUocXVldWU6IFNldDxTY2hlZHVsYWJsZUVmZmVjdD4pOiB2b2lkIHtcbiAgICBmb3IgKGNvbnN0IGhhbmRsZSBvZiBxdWV1ZSkge1xuICAgICAgcXVldWUuZGVsZXRlKGhhbmRsZSk7XG4gICAgICB0aGlzLnF1ZXVlZEVmZmVjdENvdW50LS07XG5cbiAgICAgIC8vIFRPRE86IHdoYXQgaGFwcGVucyBpZiB0aGlzIHRocm93cyBhbiBlcnJvcj9cbiAgICAgIGhhbmRsZS5ydW4oKTtcbiAgICB9XG4gIH1cblxuICAvKiogQG5vY29sbGFwc2UgKi9cbiAgc3RhdGljIMm1cHJvdiA9IC8qKiBAcHVyZU9yQnJlYWtNeUNvZGUgKi8gybXJtWRlZmluZUluamVjdGFibGUoe1xuICAgIHRva2VuOiBab25lQXdhcmVRdWV1ZWluZ1NjaGVkdWxlcixcbiAgICBwcm92aWRlZEluOiAncm9vdCcsXG4gICAgZmFjdG9yeTogKCkgPT4gbmV3IFpvbmVBd2FyZVF1ZXVlaW5nU2NoZWR1bGVyKCksXG4gIH0pO1xufVxuXG4vKipcbiAqIEEgd3JhcHBlciBhcm91bmQgYFpvbmVBd2FyZVF1ZXVlaW5nU2NoZWR1bGVyYCB0aGF0IHNjaGVkdWxlcyBmbHVzaGluZyB2aWEgdGhlIG1pY3JvdGFzayBxdWV1ZVxuICogd2hlbi5cbiAqL1xuZXhwb3J0IGNsYXNzIFpvbmVBd2FyZU1pY3JvdGFza1NjaGVkdWxlciBpbXBsZW1lbnRzIEVmZmVjdFNjaGVkdWxlciB7XG4gIHByaXZhdGUgaGFzUXVldWVkRmx1c2ggPSBmYWxzZTtcbiAgcHJpdmF0ZSBkZWxlZ2F0ZSA9IG5ldyBab25lQXdhcmVRdWV1ZWluZ1NjaGVkdWxlcigpO1xuICBwcml2YXRlIGZsdXNoVGFzayA9ICgpID0+IHtcbiAgICAvLyBMZWF2ZSBgaGFzUXVldWVkRmx1c2hgIGFzIGB0cnVlYCBzbyB3ZSBkb24ndCBxdWV1ZSBhbm90aGVyIG1pY3JvdGFzayBpZiBtb3JlIGVmZmVjdHMgYXJlXG4gICAgLy8gc2NoZWR1bGVkIGR1cmluZyBmbHVzaGluZy4gVGhlIGZsdXNoIG9mIHRoZSBgWm9uZUF3YXJlUXVldWVpbmdTY2hlZHVsZXJgIGRlbGVnYXRlIGlzXG4gICAgLy8gZ3VhcmFudGVlZCB0byBlbXB0eSB0aGUgcXVldWUuXG4gICAgdGhpcy5kZWxlZ2F0ZS5mbHVzaCgpO1xuICAgIHRoaXMuaGFzUXVldWVkRmx1c2ggPSBmYWxzZTtcblxuICAgIC8vIFRoaXMgaXMgYSB2YXJpYWJsZSBpbml0aWFsaXphdGlvbiwgbm90IGEgbWV0aG9kLlxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpzZW1pY29sb25cbiAgfTtcblxuICBzY2hlZHVsZUVmZmVjdChoYW5kbGU6IFNjaGVkdWxhYmxlRWZmZWN0KTogdm9pZCB7XG4gICAgdGhpcy5kZWxlZ2F0ZS5zY2hlZHVsZUVmZmVjdChoYW5kbGUpO1xuXG4gICAgaWYgKCF0aGlzLmhhc1F1ZXVlZEZsdXNoKSB7XG4gICAgICBxdWV1ZU1pY3JvdGFzayh0aGlzLmZsdXNoVGFzayk7XG4gICAgICB0aGlzLmhhc1F1ZXVlZEZsdXNoID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDb3JlIHJlYWN0aXZlIG5vZGUgZm9yIGFuIEFuZ3VsYXIgZWZmZWN0LlxuICpcbiAqIGBFZmZlY3RIYW5kbGVgIGNvbWJpbmVzIHRoZSByZWFjdGl2ZSBncmFwaCdzIGBXYXRjaGAgYmFzZSBub2RlIGZvciBlZmZlY3RzIHdpdGggdGhlIGZyYW1ld29yaydzXG4gKiBzY2hlZHVsaW5nIGFic3RyYWN0aW9uIChgRWZmZWN0U2NoZWR1bGVyYCkgYXMgd2VsbCBhcyBhdXRvbWF0aWMgY2xlYW51cCB2aWEgYERlc3Ryb3lSZWZgIGlmXG4gKiBhdmFpbGFibGUvcmVxdWVzdGVkLlxuICovXG5jbGFzcyBFZmZlY3RIYW5kbGUgaW1wbGVtZW50cyBFZmZlY3RSZWYsIFNjaGVkdWxhYmxlRWZmZWN0IHtcbiAgdW5yZWdpc3Rlck9uRGVzdHJveTogKCgpID0+IHZvaWQpfHVuZGVmaW5lZDtcbiAgcmVhZG9ubHkgd2F0Y2hlcjogV2F0Y2g7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgICBwcml2YXRlIHNjaGVkdWxlcjogRWZmZWN0U2NoZWR1bGVyLFxuICAgICAgcHJpdmF0ZSBlZmZlY3RGbjogKG9uQ2xlYW51cDogRWZmZWN0Q2xlYW51cFJlZ2lzdGVyRm4pID0+IHZvaWQsXG4gICAgICBwdWJsaWMgY3JlYXRpb25ab25lOiBab25lfG51bGwsIGRlc3Ryb3lSZWY6IERlc3Ryb3lSZWZ8bnVsbCxcbiAgICAgIHByaXZhdGUgZXJyb3JIYW5kbGVyOiBFcnJvckhhbmRsZXJ8bnVsbCwgYWxsb3dTaWduYWxXcml0ZXM6IGJvb2xlYW4pIHtcbiAgICB0aGlzLndhdGNoZXIgPSBjcmVhdGVXYXRjaChcbiAgICAgICAgKG9uQ2xlYW51cCkgPT4gdGhpcy5ydW5FZmZlY3Qob25DbGVhbnVwKSwgKCkgPT4gdGhpcy5zY2hlZHVsZSgpLCBhbGxvd1NpZ25hbFdyaXRlcyk7XG4gICAgdGhpcy51bnJlZ2lzdGVyT25EZXN0cm95ID0gZGVzdHJveVJlZj8ub25EZXN0cm95KCgpID0+IHRoaXMuZGVzdHJveSgpKTtcbiAgfVxuXG4gIHByaXZhdGUgcnVuRWZmZWN0KG9uQ2xlYW51cDogV2F0Y2hDbGVhbnVwUmVnaXN0ZXJGbik6IHZvaWQge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmVmZmVjdEZuKG9uQ2xlYW51cCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLmVycm9ySGFuZGxlcj8uaGFuZGxlRXJyb3IoZXJyKTtcbiAgICB9XG4gIH1cblxuICBydW4oKTogdm9pZCB7XG4gICAgdGhpcy53YXRjaGVyLnJ1bigpO1xuICB9XG5cbiAgcHJpdmF0ZSBzY2hlZHVsZSgpOiB2b2lkIHtcbiAgICB0aGlzLnNjaGVkdWxlci5zY2hlZHVsZUVmZmVjdCh0aGlzKTtcbiAgfVxuXG4gIGRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy53YXRjaGVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLnVucmVnaXN0ZXJPbkRlc3Ryb3k/LigpO1xuXG4gICAgLy8gTm90ZTogaWYgdGhlIGVmZmVjdCBpcyBjdXJyZW50bHkgc2NoZWR1bGVkLCBpdCdzIG5vdCB1bi1zY2hlZHVsZWQsIGFuZCBzbyB0aGUgc2NoZWR1bGVyIHdpbGxcbiAgICAvLyByZXRhaW4gYSByZWZlcmVuY2UgdG8gaXQuIEF0dGVtcHRpbmcgdG8gZXhlY3V0ZSBpdCB3aWxsIGJlIGEgbm8tb3AuXG4gIH1cbn1cblxuLyoqXG4gKiBBIGdsb2JhbCByZWFjdGl2ZSBlZmZlY3QsIHdoaWNoIGNhbiBiZSBtYW51YWxseSBkZXN0cm95ZWQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRWZmZWN0UmVmIHtcbiAgLyoqXG4gICAqIFNodXQgZG93biB0aGUgZWZmZWN0LCByZW1vdmluZyBpdCBmcm9tIGFueSB1cGNvbWluZyBzY2hlZHVsZWQgZXhlY3V0aW9ucy5cbiAgICovXG4gIGRlc3Ryb3koKTogdm9pZDtcbn1cblxuLyoqXG4gKiBPcHRpb25zIHBhc3NlZCB0byB0aGUgYGVmZmVjdGAgZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ3JlYXRlRWZmZWN0T3B0aW9ucyB7XG4gIC8qKlxuICAgKiBUaGUgYEluamVjdG9yYCBpbiB3aGljaCB0byBjcmVhdGUgdGhlIGVmZmVjdC5cbiAgICpcbiAgICogSWYgdGhpcyBpcyBub3QgcHJvdmlkZWQsIHRoZSBjdXJyZW50IFtpbmplY3Rpb24gY29udGV4dF0oZ3VpZGUvZGVwZW5kZW5jeS1pbmplY3Rpb24tY29udGV4dClcbiAgICogd2lsbCBiZSB1c2VkIGluc3RlYWQgKHZpYSBgaW5qZWN0YCkuXG4gICAqL1xuICBpbmplY3Rvcj86IEluamVjdG9yO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBgZWZmZWN0YCBzaG91bGQgcmVxdWlyZSBtYW51YWwgY2xlYW51cC5cbiAgICpcbiAgICogSWYgdGhpcyBpcyBgZmFsc2VgICh0aGUgZGVmYXVsdCkgdGhlIGVmZmVjdCB3aWxsIGF1dG9tYXRpY2FsbHkgcmVnaXN0ZXIgaXRzZWxmIHRvIGJlIGNsZWFuZWQgdXBcbiAgICogd2l0aCB0aGUgY3VycmVudCBgRGVzdHJveVJlZmAuXG4gICAqL1xuICBtYW51YWxDbGVhbnVwPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogV2hldGhlciB0aGUgYGVmZmVjdGAgc2hvdWxkIGFsbG93IHdyaXRpbmcgdG8gc2lnbmFscy5cbiAgICpcbiAgICogVXNpbmcgZWZmZWN0cyB0byBzeW5jaHJvbml6ZSBkYXRhIGJ5IHdyaXRpbmcgdG8gc2lnbmFscyBjYW4gbGVhZCB0byBjb25mdXNpbmcgYW5kIHBvdGVudGlhbGx5XG4gICAqIGluY29ycmVjdCBiZWhhdmlvciwgYW5kIHNob3VsZCBiZSBlbmFibGVkIG9ubHkgd2hlbiBuZWNlc3NhcnkuXG4gICAqL1xuICBhbGxvd1NpZ25hbFdyaXRlcz86IGJvb2xlYW47XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgZ2xvYmFsIGBFZmZlY3RgIGZvciB0aGUgZ2l2ZW4gcmVhY3RpdmUgZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlZmZlY3QoXG4gICAgZWZmZWN0Rm46IChvbkNsZWFudXA6IEVmZmVjdENsZWFudXBSZWdpc3RlckZuKSA9PiB2b2lkLFxuICAgIG9wdGlvbnM/OiBDcmVhdGVFZmZlY3RPcHRpb25zKTogRWZmZWN0UmVmIHtcbiAgbmdEZXZNb2RlICYmXG4gICAgICBhc3NlcnROb3RJblJlYWN0aXZlQ29udGV4dChcbiAgICAgICAgICBlZmZlY3QsXG4gICAgICAgICAgJ0NhbGwgYGVmZmVjdGAgb3V0c2lkZSBvZiBhIHJlYWN0aXZlIGNvbnRleHQuIEZvciBleGFtcGxlLCBzY2hlZHVsZSB0aGUgJyArXG4gICAgICAgICAgICAgICdlZmZlY3QgaW5zaWRlIHRoZSBjb21wb25lbnQgY29uc3RydWN0b3IuJyk7XG5cbiAgIW9wdGlvbnM/LmluamVjdG9yICYmIGFzc2VydEluSW5qZWN0aW9uQ29udGV4dChlZmZlY3QpO1xuICBjb25zdCBpbmplY3RvciA9IG9wdGlvbnM/LmluamVjdG9yID8/IGluamVjdChJbmplY3Rvcik7XG4gIGNvbnN0IGVycm9ySGFuZGxlciA9IGluamVjdG9yLmdldChFcnJvckhhbmRsZXIsIG51bGwsIHtvcHRpb25hbDogdHJ1ZX0pO1xuICBjb25zdCBkZXN0cm95UmVmID0gb3B0aW9ucz8ubWFudWFsQ2xlYW51cCAhPT0gdHJ1ZSA/IGluamVjdG9yLmdldChEZXN0cm95UmVmKSA6IG51bGw7XG5cbiAgY29uc3QgaGFuZGxlID0gbmV3IEVmZmVjdEhhbmRsZShcbiAgICAgIGluamVjdG9yLmdldChBUFBfRUZGRUNUX1NDSEVEVUxFUiksIGVmZmVjdEZuLFxuICAgICAgKHR5cGVvZiBab25lID09PSAndW5kZWZpbmVkJykgPyBudWxsIDogWm9uZS5jdXJyZW50LCBkZXN0cm95UmVmLCBlcnJvckhhbmRsZXIsXG4gICAgICBvcHRpb25zPy5hbGxvd1NpZ25hbFdyaXRlcyA/PyBmYWxzZSk7XG5cbiAgLy8gRWZmZWN0cyBuZWVkIHRvIGJlIG1hcmtlZCBkaXJ0eSBtYW51YWxseSB0byB0cmlnZ2VyIHRoZWlyIGluaXRpYWwgcnVuLiBUaGUgdGltaW5nIG9mIHRoaXNcbiAgLy8gbWFya2luZyBtYXR0ZXJzLCBiZWNhdXNlIHRoZSBlZmZlY3RzIG1heSByZWFkIHNpZ25hbHMgdGhhdCB0cmFjayBjb21wb25lbnQgaW5wdXRzLCB3aGljaCBhcmVcbiAgLy8gb25seSBhdmFpbGFibGUgYWZ0ZXIgdGhvc2UgY29tcG9uZW50cyBoYXZlIGhhZCB0aGVpciBmaXJzdCB1cGRhdGUgcGFzcy5cbiAgLy9cbiAgLy8gV2UgaW5qZWN0IGBDaGFuZ2VEZXRlY3RvclJlZmAgb3B0aW9uYWxseSwgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBlZmZlY3QgaXMgYmVpbmcgY3JlYXRlZCBpblxuICAvLyB0aGUgY29udGV4dCBvZiBhIGNvbXBvbmVudCBvciBub3QuIElmIGl0IGlzLCB0aGVuIHdlIGNoZWNrIHdoZXRoZXIgdGhlIGNvbXBvbmVudCBoYXMgYWxyZWFkeVxuICAvLyBydW4gaXRzIHVwZGF0ZSBwYXNzLCBhbmQgZGVmZXIgdGhlIGVmZmVjdCdzIGluaXRpYWwgc2NoZWR1bGluZyB1bnRpbCB0aGUgdXBkYXRlIHBhc3MgaWYgaXRcbiAgLy8gaGFzbid0IGFscmVhZHkgcnVuLlxuICBjb25zdCBjZHIgPVxuICAgICAgaW5qZWN0b3IuZ2V0KENoYW5nZURldGVjdG9yUmVmLCBudWxsLCB7b3B0aW9uYWw6IHRydWV9KSBhcyBJbnRlcm5hbFZpZXdSZWY8dW5rbm93bj58IG51bGw7XG4gIGlmICghY2RyIHx8ICEoY2RyLl9sVmlld1tGTEFHU10gJiBMVmlld0ZsYWdzLkZpcnN0TFZpZXdQYXNzKSkge1xuICAgIC8vIFRoaXMgZWZmZWN0IGlzIGVpdGhlciBub3QgcnVubmluZyBpbiBhIHZpZXcgaW5qZWN0b3IsIG9yIHRoZSB2aWV3IGhhcyBhbHJlYWR5XG4gICAgLy8gdW5kZXJnb25lIGl0cyBmaXJzdCBjaGFuZ2UgZGV0ZWN0aW9uIHBhc3MsIHdoaWNoIGlzIG5lY2Vzc2FyeSBmb3IgYW55IHJlcXVpcmVkIGlucHV0cyB0byBiZVxuICAgIC8vIHNldC5cbiAgICBoYW5kbGUud2F0Y2hlci5ub3RpZnkoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBEZWxheSB0aGUgaW5pdGlhbGl6YXRpb24gb2YgdGhlIGVmZmVjdCB1bnRpbCB0aGUgdmlldyBpcyBmdWxseSBpbml0aWFsaXplZC5cbiAgICAoY2RyLl9sVmlld1tFRkZFQ1RTX1RPX1NDSEVEVUxFXSA/Pz0gW10pLnB1c2goaGFuZGxlLndhdGNoZXIubm90aWZ5KTtcbiAgfVxuXG4gIHJldHVybiBoYW5kbGU7XG59XG4iXX0=
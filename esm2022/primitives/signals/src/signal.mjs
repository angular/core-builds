/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { defaultEquals } from './equality';
import { throwInvalidWriteToSignalError } from './errors';
import { producerAccessed, producerIncrementEpoch, producerNotifyConsumers, producerUpdatesAllowed, REACTIVE_NODE, SIGNAL } from './graph';
/**
 * If set, called after `WritableSignal`s are updated.
 *
 * This hook can be used to achieve various effects, such as running effects synchronously as part
 * of setting a signal.
 */
let postSignalSetFn = null;
/**
 * Create a `Signal` that can be set or updated directly.
 */
export function createSignal(initialValue) {
    const node = Object.create(SIGNAL_NODE);
    node.value = initialValue;
    const getter = (() => {
        producerAccessed(node);
        return node.value;
    });
    getter[SIGNAL] = node;
    return getter;
}
export function setPostSignalSetFn(fn) {
    const prev = postSignalSetFn;
    postSignalSetFn = fn;
    return prev;
}
export function signalGetFn() {
    producerAccessed(this);
    return this.value;
}
export function signalSetFn(node, newValue) {
    if (!producerUpdatesAllowed()) {
        throwInvalidWriteToSignalError();
    }
    if (!node.equal(node.value, newValue)) {
        node.value = newValue;
        signalValueChanged(node);
    }
}
export function signalUpdateFn(node, updater) {
    if (!producerUpdatesAllowed()) {
        throwInvalidWriteToSignalError();
    }
    signalSetFn(node, updater(node.value));
}
export function signalMutateFn(node, mutator) {
    if (!producerUpdatesAllowed()) {
        throwInvalidWriteToSignalError();
    }
    // Mutate bypasses equality checks as it's by definition changing the value.
    mutator(node.value);
    signalValueChanged(node);
}
// Note: Using an IIFE here to ensure that the spread assignment is not considered
// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.
// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.
export const SIGNAL_NODE = /* @__PURE__ */ (() => {
    return {
        ...REACTIVE_NODE,
        equal: defaultEquals,
        value: undefined,
    };
})();
function signalValueChanged(node) {
    node.version++;
    producerIncrementEpoch();
    producerNotifyConsumers(node);
    postSignalSetFn?.();
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2lnbmFsLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvY29yZS9wcmltaXRpdmVzL3NpZ25hbHMvc3JjL3NpZ25hbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0dBTUc7QUFFSCxPQUFPLEVBQUMsYUFBYSxFQUFrQixNQUFNLFlBQVksQ0FBQztBQUMxRCxPQUFPLEVBQUMsOEJBQThCLEVBQUMsTUFBTSxVQUFVLENBQUM7QUFDeEQsT0FBTyxFQUFDLGdCQUFnQixFQUFFLHNCQUFzQixFQUFFLHVCQUF1QixFQUFFLHNCQUFzQixFQUFFLGFBQWEsRUFBZ0IsTUFBTSxFQUFDLE1BQU0sU0FBUyxDQUFDO0FBTXZKOzs7OztHQUtHO0FBQ0gsSUFBSSxlQUFlLEdBQXNCLElBQUksQ0FBQztBQWU5Qzs7R0FFRztBQUNILE1BQU0sVUFBVSxZQUFZLENBQUksWUFBZTtJQUM3QyxNQUFNLElBQUksR0FBa0IsTUFBTSxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUN2RCxJQUFJLENBQUMsS0FBSyxHQUFHLFlBQVksQ0FBQztJQUMxQixNQUFNLE1BQU0sR0FBRyxDQUFDLEdBQUcsRUFBRTtRQUNKLGdCQUFnQixDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3ZCLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQztJQUNwQixDQUFDLENBQW9CLENBQUM7SUFDcEMsTUFBYyxDQUFDLE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQztJQUMvQixPQUFPLE1BQU0sQ0FBQztBQUNoQixDQUFDO0FBRUQsTUFBTSxVQUFVLGtCQUFrQixDQUFDLEVBQXFCO0lBQ3RELE1BQU0sSUFBSSxHQUFHLGVBQWUsQ0FBQztJQUM3QixlQUFlLEdBQUcsRUFBRSxDQUFDO0lBQ3JCLE9BQU8sSUFBSSxDQUFDO0FBQ2QsQ0FBQztBQUVELE1BQU0sVUFBVSxXQUFXO0lBQ3pCLGdCQUFnQixDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3ZCLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQztBQUNwQixDQUFDO0FBRUQsTUFBTSxVQUFVLFdBQVcsQ0FBSSxJQUFtQixFQUFFLFFBQVc7SUFDN0QsSUFBSSxDQUFDLHNCQUFzQixFQUFFLEVBQUUsQ0FBQztRQUM5Qiw4QkFBOEIsRUFBRSxDQUFDO0lBQ25DLENBQUM7SUFFRCxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLFFBQVEsQ0FBQyxFQUFFLENBQUM7UUFDdEMsSUFBSSxDQUFDLEtBQUssR0FBRyxRQUFRLENBQUM7UUFDdEIsa0JBQWtCLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDM0IsQ0FBQztBQUNILENBQUM7QUFFRCxNQUFNLFVBQVUsY0FBYyxDQUFJLElBQW1CLEVBQUUsT0FBd0I7SUFDN0UsSUFBSSxDQUFDLHNCQUFzQixFQUFFLEVBQUUsQ0FBQztRQUM5Qiw4QkFBOEIsRUFBRSxDQUFDO0lBQ25DLENBQUM7SUFFRCxXQUFXLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztBQUN6QyxDQUFDO0FBRUQsTUFBTSxVQUFVLGNBQWMsQ0FBSSxJQUFtQixFQUFFLE9BQTJCO0lBQ2hGLElBQUksQ0FBQyxzQkFBc0IsRUFBRSxFQUFFLENBQUM7UUFDOUIsOEJBQThCLEVBQUUsQ0FBQztJQUNuQyxDQUFDO0lBQ0QsNEVBQTRFO0lBQzVFLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDcEIsa0JBQWtCLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDM0IsQ0FBQztBQUVELGtGQUFrRjtBQUNsRiwyRUFBMkU7QUFDM0UsOEVBQThFO0FBQzlFLE1BQU0sQ0FBQyxNQUFNLFdBQVcsR0FBd0IsZUFBZSxDQUFDLENBQUMsR0FBRyxFQUFFO0lBQ3BFLE9BQU87UUFDTCxHQUFHLGFBQWE7UUFDaEIsS0FBSyxFQUFFLGFBQWE7UUFDcEIsS0FBSyxFQUFFLFNBQVM7S0FDakIsQ0FBQztBQUNKLENBQUMsQ0FBQyxFQUFFLENBQUM7QUFFTCxTQUFTLGtCQUFrQixDQUFJLElBQW1CO0lBQ2hELElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztJQUNmLHNCQUFzQixFQUFFLENBQUM7SUFDekIsdUJBQXVCLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDOUIsZUFBZSxFQUFFLEVBQUUsQ0FBQztBQUN0QixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbmltcG9ydCB7ZGVmYXVsdEVxdWFscywgVmFsdWVFcXVhbGl0eUZufSBmcm9tICcuL2VxdWFsaXR5JztcbmltcG9ydCB7dGhyb3dJbnZhbGlkV3JpdGVUb1NpZ25hbEVycm9yfSBmcm9tICcuL2Vycm9ycyc7XG5pbXBvcnQge3Byb2R1Y2VyQWNjZXNzZWQsIHByb2R1Y2VySW5jcmVtZW50RXBvY2gsIHByb2R1Y2VyTm90aWZ5Q29uc3VtZXJzLCBwcm9kdWNlclVwZGF0ZXNBbGxvd2VkLCBSRUFDVElWRV9OT0RFLCBSZWFjdGl2ZU5vZGUsIFNJR05BTH0gZnJvbSAnLi9ncmFwaCc7XG5cbi8vIFJlcXVpcmVkIGFzIHRoZSBzaWduYWxzIGxpYnJhcnkgaXMgaW4gYSBzZXBhcmF0ZSBwYWNrYWdlLCBzbyB3ZSBuZWVkIHRvIGV4cGxpY2l0bHkgZW5zdXJlIHRoZVxuLy8gZ2xvYmFsIGBuZ0Rldk1vZGVgIHR5cGUgaXMgZGVmaW5lZC5cbmRlY2xhcmUgY29uc3QgbmdEZXZNb2RlOiBib29sZWFufHVuZGVmaW5lZDtcblxuLyoqXG4gKiBJZiBzZXQsIGNhbGxlZCBhZnRlciBgV3JpdGFibGVTaWduYWxgcyBhcmUgdXBkYXRlZC5cbiAqXG4gKiBUaGlzIGhvb2sgY2FuIGJlIHVzZWQgdG8gYWNoaWV2ZSB2YXJpb3VzIGVmZmVjdHMsIHN1Y2ggYXMgcnVubmluZyBlZmZlY3RzIHN5bmNocm9ub3VzbHkgYXMgcGFydFxuICogb2Ygc2V0dGluZyBhIHNpZ25hbC5cbiAqL1xubGV0IHBvc3RTaWduYWxTZXRGbjogKCgpID0+IHZvaWQpfG51bGwgPSBudWxsO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNpZ25hbE5vZGU8VD4gZXh0ZW5kcyBSZWFjdGl2ZU5vZGUge1xuICB2YWx1ZTogVDtcbiAgZXF1YWw6IFZhbHVlRXF1YWxpdHlGbjxUPjtcbn1cblxuZXhwb3J0IHR5cGUgU2lnbmFsQmFzZUdldHRlcjxUPiA9ICgoKSA9PiBUKSZ7cmVhZG9ubHlbU0lHTkFMXTogdW5rbm93bn07XG5cbi8vIE5vdGU6IENsb3N1cmUgKnJlcXVpcmVzKiB0aGlzIHRvIGJlIGFuIGBpbnRlcmZhY2VgIGFuZCBub3QgYSB0eXBlLCB3aGljaCBpcyB3aHkgdGhlXG4vLyBgU2lnbmFsQmFzZUdldHRlcmAgdHlwZSBleGlzdHMgdG8gcHJvdmlkZSB0aGUgY29ycmVjdCBzaGFwZS5cbmV4cG9ydCBpbnRlcmZhY2UgU2lnbmFsR2V0dGVyPFQ+IGV4dGVuZHMgU2lnbmFsQmFzZUdldHRlcjxUPiB7XG4gIHJlYWRvbmx5W1NJR05BTF06IFNpZ25hbE5vZGU8VD47XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgYFNpZ25hbGAgdGhhdCBjYW4gYmUgc2V0IG9yIHVwZGF0ZWQgZGlyZWN0bHkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTaWduYWw8VD4oaW5pdGlhbFZhbHVlOiBUKTogU2lnbmFsR2V0dGVyPFQ+IHtcbiAgY29uc3Qgbm9kZTogU2lnbmFsTm9kZTxUPiA9IE9iamVjdC5jcmVhdGUoU0lHTkFMX05PREUpO1xuICBub2RlLnZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICBjb25zdCBnZXR0ZXIgPSAoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgIHByb2R1Y2VyQWNjZXNzZWQobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUudmFsdWU7XG4gICAgICAgICAgICAgICAgIH0pIGFzIFNpZ25hbEdldHRlcjxUPjtcbiAgKGdldHRlciBhcyBhbnkpW1NJR05BTF0gPSBub2RlO1xuICByZXR1cm4gZ2V0dGVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0UG9zdFNpZ25hbFNldEZuKGZuOiAoKCkgPT4gdm9pZCl8bnVsbCk6ICgoKSA9PiB2b2lkKXxudWxsIHtcbiAgY29uc3QgcHJldiA9IHBvc3RTaWduYWxTZXRGbjtcbiAgcG9zdFNpZ25hbFNldEZuID0gZm47XG4gIHJldHVybiBwcmV2O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2lnbmFsR2V0Rm48VD4odGhpczogU2lnbmFsTm9kZTxUPik6IFQge1xuICBwcm9kdWNlckFjY2Vzc2VkKHRoaXMpO1xuICByZXR1cm4gdGhpcy52YWx1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNpZ25hbFNldEZuPFQ+KG5vZGU6IFNpZ25hbE5vZGU8VD4sIG5ld1ZhbHVlOiBUKSB7XG4gIGlmICghcHJvZHVjZXJVcGRhdGVzQWxsb3dlZCgpKSB7XG4gICAgdGhyb3dJbnZhbGlkV3JpdGVUb1NpZ25hbEVycm9yKCk7XG4gIH1cblxuICBpZiAoIW5vZGUuZXF1YWwobm9kZS52YWx1ZSwgbmV3VmFsdWUpKSB7XG4gICAgbm9kZS52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgIHNpZ25hbFZhbHVlQ2hhbmdlZChub2RlKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2lnbmFsVXBkYXRlRm48VD4obm9kZTogU2lnbmFsTm9kZTxUPiwgdXBkYXRlcjogKHZhbHVlOiBUKSA9PiBUKTogdm9pZCB7XG4gIGlmICghcHJvZHVjZXJVcGRhdGVzQWxsb3dlZCgpKSB7XG4gICAgdGhyb3dJbnZhbGlkV3JpdGVUb1NpZ25hbEVycm9yKCk7XG4gIH1cblxuICBzaWduYWxTZXRGbihub2RlLCB1cGRhdGVyKG5vZGUudmFsdWUpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNpZ25hbE11dGF0ZUZuPFQ+KG5vZGU6IFNpZ25hbE5vZGU8VD4sIG11dGF0b3I6ICh2YWx1ZTogVCkgPT4gdm9pZCk6IHZvaWQge1xuICBpZiAoIXByb2R1Y2VyVXBkYXRlc0FsbG93ZWQoKSkge1xuICAgIHRocm93SW52YWxpZFdyaXRlVG9TaWduYWxFcnJvcigpO1xuICB9XG4gIC8vIE11dGF0ZSBieXBhc3NlcyBlcXVhbGl0eSBjaGVja3MgYXMgaXQncyBieSBkZWZpbml0aW9uIGNoYW5naW5nIHRoZSB2YWx1ZS5cbiAgbXV0YXRvcihub2RlLnZhbHVlKTtcbiAgc2lnbmFsVmFsdWVDaGFuZ2VkKG5vZGUpO1xufVxuXG4vLyBOb3RlOiBVc2luZyBhbiBJSUZFIGhlcmUgdG8gZW5zdXJlIHRoYXQgdGhlIHNwcmVhZCBhc3NpZ25tZW50IGlzIG5vdCBjb25zaWRlcmVkXG4vLyBhIHNpZGUtZWZmZWN0LCBlbmRpbmcgdXAgcHJlc2VydmluZyBgQ09NUFVURURfTk9ERWAgYW5kIGBSRUFDVElWRV9OT0RFYC5cbi8vIFRPRE86IHJlbW92ZSB3aGVuIGh0dHBzOi8vZ2l0aHViLmNvbS9ldmFudy9lc2J1aWxkL2lzc3Vlcy8zMzkyIGlzIHJlc29sdmVkLlxuZXhwb3J0IGNvbnN0IFNJR05BTF9OT0RFOiBTaWduYWxOb2RlPHVua25vd24+ID0gLyogQF9fUFVSRV9fICovICgoKSA9PiB7XG4gIHJldHVybiB7XG4gICAgLi4uUkVBQ1RJVkVfTk9ERSxcbiAgICBlcXVhbDogZGVmYXVsdEVxdWFscyxcbiAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICB9O1xufSkoKTtcblxuZnVuY3Rpb24gc2lnbmFsVmFsdWVDaGFuZ2VkPFQ+KG5vZGU6IFNpZ25hbE5vZGU8VD4pOiB2b2lkIHtcbiAgbm9kZS52ZXJzaW9uKys7XG4gIHByb2R1Y2VySW5jcmVtZW50RXBvY2goKTtcbiAgcHJvZHVjZXJOb3RpZnlDb25zdW1lcnMobm9kZSk7XG4gIHBvc3RTaWduYWxTZXRGbj8uKCk7XG59XG4iXX0=
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { assertInInjectionContext, assertNotInReactiveContext, computed, DestroyRef, inject, signal, ɵRuntimeError, } from '@angular/core';
/**
 * Get the current value of an `Observable` as a reactive `Signal`.
 *
 * `toSignal` returns a `Signal` which provides synchronous reactive access to values produced
 * by the given `Observable`, by subscribing to that `Observable`. The returned `Signal` will always
 * have the most recent value emitted by the subscription, and will throw an error if the
 * `Observable` errors.
 *
 * With `requireSync` set to `true`, `toSignal` will assert that the `Observable` produces a value
 * immediately upon subscription. No `initialValue` is needed in this case, and the returned signal
 * does not include an `undefined` type.
 *
 * By default, the subscription will be automatically cleaned up when the current [injection
 * context](guide/di/dependency-injection-context) is destroyed. For example, when `toSignal` is
 * called during the construction of a component, the subscription will be cleaned up when the
 * component is destroyed. If an injection context is not available, an explicit `Injector` can be
 * passed instead.
 *
 * If the subscription should persist until the `Observable` itself completes, the `manualCleanup`
 * option can be specified instead, which disables the automatic subscription teardown. No injection
 * context is needed in this configuration as well.
 *
 * @developerPreview
 */
export function toSignal(source, options) {
    ngDevMode &&
        assertNotInReactiveContext(toSignal, 'Invoking `toSignal` causes new subscriptions every time. ' +
            'Consider moving `toSignal` outside of the reactive context and read the signal value where needed.');
    const requiresCleanup = !options?.manualCleanup;
    requiresCleanup && !options?.injector && assertInInjectionContext(toSignal);
    const cleanupRef = requiresCleanup
        ? options?.injector?.get(DestroyRef) ?? inject(DestroyRef)
        : null;
    const equal = makeToSignalEqual(options?.equal);
    // Note: T is the Observable value type, and U is the initial value type. They don't have to be
    // the same - the returned signal gives values of type `T`.
    let state;
    if (options?.requireSync) {
        // Initially the signal is in a `NoValue` state.
        state = signal({ kind: 0 /* StateKind.NoValue */ }, { equal });
    }
    else {
        // If an initial value was passed, use it. Otherwise, use `undefined` as the initial value.
        state = signal({ kind: 1 /* StateKind.Value */, value: options?.initialValue }, { equal });
    }
    // Note: This code cannot run inside a reactive context (see assertion above). If we'd support
    // this, we would subscribe to the observable outside of the current reactive context, avoiding
    // that side-effect signal reads/writes are attribute to the current consumer. The current
    // consumer only needs to be notified when the `state` signal changes through the observable
    // subscription. Additional context (related to async pipe):
    // https://github.com/angular/angular/pull/50522.
    const sub = source.subscribe({
        next: (value) => state.set({ kind: 1 /* StateKind.Value */, value }),
        error: (error) => {
            if (options?.rejectErrors) {
                // Kick the error back to RxJS. It will be caught and rethrown in a macrotask, which causes
                // the error to end up as an uncaught exception.
                throw error;
            }
            state.set({ kind: 2 /* StateKind.Error */, error });
        },
        // Completion of the Observable is meaningless to the signal. Signals don't have a concept of
        // "complete".
    });
    if (ngDevMode && options?.requireSync && state().kind === 0 /* StateKind.NoValue */) {
        throw new ɵRuntimeError(601 /* ɵRuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT */, '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');
    }
    // Unsubscribe when the current context is destroyed, if requested.
    cleanupRef?.onDestroy(sub.unsubscribe.bind(sub));
    // The actual returned signal is a `computed` of the `State` signal, which maps the various states
    // to either values or errors.
    return computed(() => {
        const current = state();
        switch (current.kind) {
            case 1 /* StateKind.Value */:
                return current.value;
            case 2 /* StateKind.Error */:
                throw current.error;
            case 0 /* StateKind.NoValue */:
                // This shouldn't really happen because the error is thrown on creation.
                // TODO(alxhub): use a RuntimeError when we finalize the error semantics
                throw new ɵRuntimeError(601 /* ɵRuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT */, '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');
        }
    });
}
function makeToSignalEqual(userEquality = Object.is) {
    return (a, b) => a.kind === 1 /* StateKind.Value */ && b.kind === 1 /* StateKind.Value */ && userEquality(a.value, b.value);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9fc2lnbmFsLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvY29yZS9yeGpzLWludGVyb3Avc3JjL3RvX3NpZ25hbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0dBTUc7QUFFSCxPQUFPLEVBQ0wsd0JBQXdCLEVBQ3hCLDBCQUEwQixFQUMxQixRQUFRLEVBQ1IsVUFBVSxFQUNWLE1BQU0sRUFFTixNQUFNLEVBR04sYUFBYSxHQUVkLE1BQU0sZUFBZSxDQUFDO0FBd0Z2Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0F1Qkc7QUFDSCxNQUFNLFVBQVUsUUFBUSxDQUN0QixNQUF1QyxFQUN2QyxPQUFxRDtJQUVyRCxTQUFTO1FBQ1AsMEJBQTBCLENBQ3hCLFFBQVEsRUFDUiwyREFBMkQ7WUFDekQsb0dBQW9HLENBQ3ZHLENBQUM7SUFFSixNQUFNLGVBQWUsR0FBRyxDQUFDLE9BQU8sRUFBRSxhQUFhLENBQUM7SUFDaEQsZUFBZSxJQUFJLENBQUMsT0FBTyxFQUFFLFFBQVEsSUFBSSx3QkFBd0IsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUM1RSxNQUFNLFVBQVUsR0FBRyxlQUFlO1FBQ2hDLENBQUMsQ0FBQyxPQUFPLEVBQUUsUUFBUSxFQUFFLEdBQUcsQ0FBQyxVQUFVLENBQUMsSUFBSSxNQUFNLENBQUMsVUFBVSxDQUFDO1FBQzFELENBQUMsQ0FBQyxJQUFJLENBQUM7SUFFVCxNQUFNLEtBQUssR0FBRyxpQkFBaUIsQ0FBQyxPQUFPLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFFaEQsK0ZBQStGO0lBQy9GLDJEQUEyRDtJQUMzRCxJQUFJLEtBQW1DLENBQUM7SUFDeEMsSUFBSSxPQUFPLEVBQUUsV0FBVyxFQUFFLENBQUM7UUFDekIsZ0RBQWdEO1FBQ2hELEtBQUssR0FBRyxNQUFNLENBQUMsRUFBQyxJQUFJLDJCQUFtQixFQUFDLEVBQUUsRUFBQyxLQUFLLEVBQUMsQ0FBQyxDQUFDO0lBQ3JELENBQUM7U0FBTSxDQUFDO1FBQ04sMkZBQTJGO1FBQzNGLEtBQUssR0FBRyxNQUFNLENBQ1osRUFBQyxJQUFJLHlCQUFpQixFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUUsWUFBaUIsRUFBQyxFQUMxRCxFQUFDLEtBQUssRUFBQyxDQUNSLENBQUM7SUFDSixDQUFDO0lBRUQsOEZBQThGO0lBQzlGLCtGQUErRjtJQUMvRiwwRkFBMEY7SUFDMUYsNEZBQTRGO0lBQzVGLDREQUE0RDtJQUM1RCxpREFBaUQ7SUFDakQsTUFBTSxHQUFHLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FBQztRQUMzQixJQUFJLEVBQUUsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsRUFBQyxJQUFJLHlCQUFpQixFQUFFLEtBQUssRUFBQyxDQUFDO1FBQzFELEtBQUssRUFBRSxDQUFDLEtBQUssRUFBRSxFQUFFO1lBQ2YsSUFBSSxPQUFPLEVBQUUsWUFBWSxFQUFFLENBQUM7Z0JBQzFCLDJGQUEyRjtnQkFDM0YsZ0RBQWdEO2dCQUNoRCxNQUFNLEtBQUssQ0FBQztZQUNkLENBQUM7WUFDRCxLQUFLLENBQUMsR0FBRyxDQUFDLEVBQUMsSUFBSSx5QkFBaUIsRUFBRSxLQUFLLEVBQUMsQ0FBQyxDQUFDO1FBQzVDLENBQUM7UUFDRCw2RkFBNkY7UUFDN0YsY0FBYztLQUNmLENBQUMsQ0FBQztJQUVILElBQUksU0FBUyxJQUFJLE9BQU8sRUFBRSxXQUFXLElBQUksS0FBSyxFQUFFLENBQUMsSUFBSSw4QkFBc0IsRUFBRSxDQUFDO1FBQzVFLE1BQU0sSUFBSSxhQUFhLDZEQUVyQixxRkFBcUYsQ0FDdEYsQ0FBQztJQUNKLENBQUM7SUFFRCxtRUFBbUU7SUFDbkUsVUFBVSxFQUFFLFNBQVMsQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBRWpELGtHQUFrRztJQUNsRyw4QkFBOEI7SUFDOUIsT0FBTyxRQUFRLENBQUMsR0FBRyxFQUFFO1FBQ25CLE1BQU0sT0FBTyxHQUFHLEtBQUssRUFBRSxDQUFDO1FBQ3hCLFFBQVEsT0FBTyxDQUFDLElBQUksRUFBRSxDQUFDO1lBQ3JCO2dCQUNFLE9BQU8sT0FBTyxDQUFDLEtBQUssQ0FBQztZQUN2QjtnQkFDRSxNQUFNLE9BQU8sQ0FBQyxLQUFLLENBQUM7WUFDdEI7Z0JBQ0Usd0VBQXdFO2dCQUN4RSx3RUFBd0U7Z0JBQ3hFLE1BQU0sSUFBSSxhQUFhLDZEQUVyQixxRkFBcUYsQ0FDdEYsQ0FBQztRQUNOLENBQUM7SUFDSCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUM7QUFFRCxTQUFTLGlCQUFpQixDQUN4QixlQUFtQyxNQUFNLENBQUMsRUFBRTtJQUU1QyxPQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQ2QsQ0FBQyxDQUFDLElBQUksNEJBQW9CLElBQUksQ0FBQyxDQUFDLElBQUksNEJBQW9CLElBQUksWUFBWSxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQy9GLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuaW1wb3J0IHtcbiAgYXNzZXJ0SW5JbmplY3Rpb25Db250ZXh0LFxuICBhc3NlcnROb3RJblJlYWN0aXZlQ29udGV4dCxcbiAgY29tcHV0ZWQsXG4gIERlc3Ryb3lSZWYsXG4gIGluamVjdCxcbiAgSW5qZWN0b3IsXG4gIHNpZ25hbCxcbiAgU2lnbmFsLFxuICBXcml0YWJsZVNpZ25hbCxcbiAgybVSdW50aW1lRXJyb3IsXG4gIMm1UnVudGltZUVycm9yQ29kZSxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1ZhbHVlRXF1YWxpdHlGbn0gZnJvbSAnQGFuZ3VsYXIvY29yZS9wcmltaXRpdmVzL3NpZ25hbHMnO1xuaW1wb3J0IHtPYnNlcnZhYmxlLCBTdWJzY3JpYmFibGV9IGZyb20gJ3J4anMnO1xuXG4vKipcbiAqIE9wdGlvbnMgZm9yIGB0b1NpZ25hbGAuXG4gKlxuICogQHB1YmxpY0FwaVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRvU2lnbmFsT3B0aW9uczxUPiB7XG4gIC8qKlxuICAgKiBJbml0aWFsIHZhbHVlIGZvciB0aGUgc2lnbmFsIHByb2R1Y2VkIGJ5IGB0b1NpZ25hbGAuXG4gICAqXG4gICAqIFRoaXMgd2lsbCBiZSB0aGUgdmFsdWUgb2YgdGhlIHNpZ25hbCB1bnRpbCB0aGUgb2JzZXJ2YWJsZSBlbWl0cyBpdHMgZmlyc3QgdmFsdWUuXG4gICAqL1xuICBpbml0aWFsVmFsdWU/OiB1bmtub3duO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHJlcXVpcmUgdGhhdCB0aGUgb2JzZXJ2YWJsZSBlbWl0cyBzeW5jaHJvbm91c2x5IHdoZW4gYHRvU2lnbmFsYCBzdWJzY3JpYmVzLlxuICAgKlxuICAgKiBJZiB0aGlzIGlzIGB0cnVlYCwgYHRvU2lnbmFsYCB3aWxsIGFzc2VydCB0aGF0IHRoZSBvYnNlcnZhYmxlIHByb2R1Y2VzIGEgdmFsdWUgaW1tZWRpYXRlbHkgdXBvblxuICAgKiBzdWJzY3JpcHRpb24uIFNldHRpbmcgdGhpcyBvcHRpb24gcmVtb3ZlcyB0aGUgbmVlZCB0byBlaXRoZXIgZGVhbCB3aXRoIGB1bmRlZmluZWRgIGluIHRoZVxuICAgKiBzaWduYWwgdHlwZSBvciBwcm92aWRlIGFuIGBpbml0aWFsVmFsdWVgLCBhdCB0aGUgY29zdCBvZiBhIHJ1bnRpbWUgZXJyb3IgaWYgdGhpcyByZXF1aXJlbWVudCBpc1xuICAgKiBub3QgbWV0LlxuICAgKi9cbiAgcmVxdWlyZVN5bmM/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBgSW5qZWN0b3JgIHdoaWNoIHdpbGwgcHJvdmlkZSB0aGUgYERlc3Ryb3lSZWZgIHVzZWQgdG8gY2xlYW4gdXAgdGhlIE9ic2VydmFibGUgc3Vic2NyaXB0aW9uLlxuICAgKlxuICAgKiBJZiB0aGlzIGlzIG5vdCBwcm92aWRlZCwgYSBgRGVzdHJveVJlZmAgd2lsbCBiZSByZXRyaWV2ZWQgZnJvbSB0aGUgY3VycmVudCBbaW5qZWN0aW9uXG4gICAqIGNvbnRleHRdKGd1aWRlL2RpL2RlcGVuZGVuY3ktaW5qZWN0aW9uLWNvbnRleHQpLCB1bmxlc3MgbWFudWFsIGNsZWFudXAgaXMgcmVxdWVzdGVkLlxuICAgKi9cbiAgaW5qZWN0b3I/OiBJbmplY3RvcjtcblxuICAvKipcbiAgICogV2hldGhlciB0aGUgc3Vic2NyaXB0aW9uIHNob3VsZCBiZSBhdXRvbWF0aWNhbGx5IGNsZWFuZWQgdXAgKHZpYSBgRGVzdHJveVJlZmApIHdoZW5cbiAgICogYHRvU2lnbmFsYCdzIGNyZWF0aW9uIGNvbnRleHQgaXMgZGVzdHJveWVkLlxuICAgKlxuICAgKiBJZiBtYW51YWwgY2xlYW51cCBpcyBlbmFibGVkLCB0aGVuIGBEZXN0cm95UmVmYCBpcyBub3QgdXNlZCwgYW5kIHRoZSBzdWJzY3JpcHRpb24gd2lsbCBwZXJzaXN0XG4gICAqIHVudGlsIHRoZSBgT2JzZXJ2YWJsZWAgaXRzZWxmIGNvbXBsZXRlcy5cbiAgICovXG4gIG1hbnVhbENsZWFudXA/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIGB0b1NpZ25hbGAgc2hvdWxkIHRocm93IGVycm9ycyBmcm9tIHRoZSBPYnNlcnZhYmxlIGVycm9yIGNoYW5uZWwgYmFjayB0byBSeEpTLCB3aGVyZVxuICAgKiB0aGV5J2xsIGJlIHByb2Nlc3NlZCBhcyB1bmNhdWdodCBleGNlcHRpb25zLlxuICAgKlxuICAgKiBJbiBwcmFjdGljZSwgdGhpcyBtZWFucyB0aGF0IHRoZSBzaWduYWwgcmV0dXJuZWQgYnkgYHRvU2lnbmFsYCB3aWxsIGtlZXAgcmV0dXJuaW5nIHRoZSBsYXN0XG4gICAqIGdvb2QgdmFsdWUgZm9yZXZlciwgYXMgT2JzZXJ2YWJsZXMgd2hpY2ggZXJyb3IgcHJvZHVjZSBubyBmdXJ0aGVyIHZhbHVlcy4gVGhpcyBvcHRpb24gZW11bGF0ZXNcbiAgICogdGhlIGJlaGF2aW9yIG9mIHRoZSBgYXN5bmNgIHBpcGUuXG4gICAqL1xuICByZWplY3RFcnJvcnM/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBBIGNvbXBhcmlzb24gZnVuY3Rpb24gd2hpY2ggZGVmaW5lcyBlcXVhbGl0eSBmb3IgdmFsdWVzIGVtaXR0ZWQgYnkgdGhlIG9ic2VydmFibGUuXG4gICAqXG4gICAqIEVxdWFsaXR5IGNvbXBhcmlzb25zIGFyZSBleGVjdXRlZCBhZ2FpbnN0IHRoZSBpbml0aWFsIHZhbHVlIGlmIG9uZSBpcyBwcm92aWRlZC5cbiAgICovXG4gIGVxdWFsPzogVmFsdWVFcXVhbGl0eUZuPFQ+O1xufVxuXG4vLyBCYXNlIGNhc2U6IG5vIG9wdGlvbnMgLT4gYHVuZGVmaW5lZGAgaW4gdGhlIHJlc3VsdCB0eXBlLlxuZXhwb3J0IGZ1bmN0aW9uIHRvU2lnbmFsPFQ+KHNvdXJjZTogT2JzZXJ2YWJsZTxUPiB8IFN1YnNjcmliYWJsZTxUPik6IFNpZ25hbDxUIHwgdW5kZWZpbmVkPjtcbi8vIE9wdGlvbnMgd2l0aCBgdW5kZWZpbmVkYCBpbml0aWFsIHZhbHVlIGFuZCBubyBgcmVxdWlyZWRTeW5jYCAtPiBgdW5kZWZpbmVkYC5cbmV4cG9ydCBmdW5jdGlvbiB0b1NpZ25hbDxUPihcbiAgc291cmNlOiBPYnNlcnZhYmxlPFQ+IHwgU3Vic2NyaWJhYmxlPFQ+LFxuICBvcHRpb25zOiBOb0luZmVyPFRvU2lnbmFsT3B0aW9uczxUIHwgdW5kZWZpbmVkPj4gJiB7XG4gICAgaW5pdGlhbFZhbHVlPzogdW5kZWZpbmVkO1xuICAgIHJlcXVpcmVTeW5jPzogZmFsc2U7XG4gIH0sXG4pOiBTaWduYWw8VCB8IHVuZGVmaW5lZD47XG4vLyBPcHRpb25zIHdpdGggYG51bGxgIGluaXRpYWwgdmFsdWUgLT4gYG51bGxgLlxuZXhwb3J0IGZ1bmN0aW9uIHRvU2lnbmFsPFQ+KFxuICBzb3VyY2U6IE9ic2VydmFibGU8VD4gfCBTdWJzY3JpYmFibGU8VD4sXG4gIG9wdGlvbnM6IE5vSW5mZXI8VG9TaWduYWxPcHRpb25zPFQgfCBudWxsPj4gJiB7aW5pdGlhbFZhbHVlPzogbnVsbDsgcmVxdWlyZVN5bmM/OiBmYWxzZX0sXG4pOiBTaWduYWw8VCB8IG51bGw+O1xuLy8gT3B0aW9ucyB3aXRoIGB1bmRlZmluZWRgIGluaXRpYWwgdmFsdWUgYW5kIGByZXF1aXJlZFN5bmNgIC0+IHN0cmljdCByZXN1bHQgdHlwZS5cbmV4cG9ydCBmdW5jdGlvbiB0b1NpZ25hbDxUPihcbiAgc291cmNlOiBPYnNlcnZhYmxlPFQ+IHwgU3Vic2NyaWJhYmxlPFQ+LFxuICBvcHRpb25zOiBOb0luZmVyPFRvU2lnbmFsT3B0aW9uczxUPj4gJiB7aW5pdGlhbFZhbHVlPzogdW5kZWZpbmVkOyByZXF1aXJlU3luYzogdHJ1ZX0sXG4pOiBTaWduYWw8VD47XG4vLyBPcHRpb25zIHdpdGggYSBtb3JlIHNwZWNpZmljIGluaXRpYWwgdmFsdWUgdHlwZS5cbmV4cG9ydCBmdW5jdGlvbiB0b1NpZ25hbDxULCBjb25zdCBVIGV4dGVuZHMgVD4oXG4gIHNvdXJjZTogT2JzZXJ2YWJsZTxUPiB8IFN1YnNjcmliYWJsZTxUPixcbiAgb3B0aW9uczogTm9JbmZlcjxUb1NpZ25hbE9wdGlvbnM8VCB8IFU+PiAmIHtpbml0aWFsVmFsdWU6IFU7IHJlcXVpcmVTeW5jPzogZmFsc2V9LFxuKTogU2lnbmFsPFQgfCBVPjtcblxuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgdmFsdWUgb2YgYW4gYE9ic2VydmFibGVgIGFzIGEgcmVhY3RpdmUgYFNpZ25hbGAuXG4gKlxuICogYHRvU2lnbmFsYCByZXR1cm5zIGEgYFNpZ25hbGAgd2hpY2ggcHJvdmlkZXMgc3luY2hyb25vdXMgcmVhY3RpdmUgYWNjZXNzIHRvIHZhbHVlcyBwcm9kdWNlZFxuICogYnkgdGhlIGdpdmVuIGBPYnNlcnZhYmxlYCwgYnkgc3Vic2NyaWJpbmcgdG8gdGhhdCBgT2JzZXJ2YWJsZWAuIFRoZSByZXR1cm5lZCBgU2lnbmFsYCB3aWxsIGFsd2F5c1xuICogaGF2ZSB0aGUgbW9zdCByZWNlbnQgdmFsdWUgZW1pdHRlZCBieSB0aGUgc3Vic2NyaXB0aW9uLCBhbmQgd2lsbCB0aHJvdyBhbiBlcnJvciBpZiB0aGVcbiAqIGBPYnNlcnZhYmxlYCBlcnJvcnMuXG4gKlxuICogV2l0aCBgcmVxdWlyZVN5bmNgIHNldCB0byBgdHJ1ZWAsIGB0b1NpZ25hbGAgd2lsbCBhc3NlcnQgdGhhdCB0aGUgYE9ic2VydmFibGVgIHByb2R1Y2VzIGEgdmFsdWVcbiAqIGltbWVkaWF0ZWx5IHVwb24gc3Vic2NyaXB0aW9uLiBObyBgaW5pdGlhbFZhbHVlYCBpcyBuZWVkZWQgaW4gdGhpcyBjYXNlLCBhbmQgdGhlIHJldHVybmVkIHNpZ25hbFxuICogZG9lcyBub3QgaW5jbHVkZSBhbiBgdW5kZWZpbmVkYCB0eXBlLlxuICpcbiAqIEJ5IGRlZmF1bHQsIHRoZSBzdWJzY3JpcHRpb24gd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGNsZWFuZWQgdXAgd2hlbiB0aGUgY3VycmVudCBbaW5qZWN0aW9uXG4gKiBjb250ZXh0XShndWlkZS9kaS9kZXBlbmRlbmN5LWluamVjdGlvbi1jb250ZXh0KSBpcyBkZXN0cm95ZWQuIEZvciBleGFtcGxlLCB3aGVuIGB0b1NpZ25hbGAgaXNcbiAqIGNhbGxlZCBkdXJpbmcgdGhlIGNvbnN0cnVjdGlvbiBvZiBhIGNvbXBvbmVudCwgdGhlIHN1YnNjcmlwdGlvbiB3aWxsIGJlIGNsZWFuZWQgdXAgd2hlbiB0aGVcbiAqIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQuIElmIGFuIGluamVjdGlvbiBjb250ZXh0IGlzIG5vdCBhdmFpbGFibGUsIGFuIGV4cGxpY2l0IGBJbmplY3RvcmAgY2FuIGJlXG4gKiBwYXNzZWQgaW5zdGVhZC5cbiAqXG4gKiBJZiB0aGUgc3Vic2NyaXB0aW9uIHNob3VsZCBwZXJzaXN0IHVudGlsIHRoZSBgT2JzZXJ2YWJsZWAgaXRzZWxmIGNvbXBsZXRlcywgdGhlIGBtYW51YWxDbGVhbnVwYFxuICogb3B0aW9uIGNhbiBiZSBzcGVjaWZpZWQgaW5zdGVhZCwgd2hpY2ggZGlzYWJsZXMgdGhlIGF1dG9tYXRpYyBzdWJzY3JpcHRpb24gdGVhcmRvd24uIE5vIGluamVjdGlvblxuICogY29udGV4dCBpcyBuZWVkZWQgaW4gdGhpcyBjb25maWd1cmF0aW9uIGFzIHdlbGwuXG4gKlxuICogQGRldmVsb3BlclByZXZpZXdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvU2lnbmFsPFQsIFUgPSB1bmRlZmluZWQ+KFxuICBzb3VyY2U6IE9ic2VydmFibGU8VD4gfCBTdWJzY3JpYmFibGU8VD4sXG4gIG9wdGlvbnM/OiBUb1NpZ25hbE9wdGlvbnM8VCB8IFU+ICYge2luaXRpYWxWYWx1ZT86IFV9LFxuKTogU2lnbmFsPFQgfCBVPiB7XG4gIG5nRGV2TW9kZSAmJlxuICAgIGFzc2VydE5vdEluUmVhY3RpdmVDb250ZXh0KFxuICAgICAgdG9TaWduYWwsXG4gICAgICAnSW52b2tpbmcgYHRvU2lnbmFsYCBjYXVzZXMgbmV3IHN1YnNjcmlwdGlvbnMgZXZlcnkgdGltZS4gJyArXG4gICAgICAgICdDb25zaWRlciBtb3ZpbmcgYHRvU2lnbmFsYCBvdXRzaWRlIG9mIHRoZSByZWFjdGl2ZSBjb250ZXh0IGFuZCByZWFkIHRoZSBzaWduYWwgdmFsdWUgd2hlcmUgbmVlZGVkLicsXG4gICAgKTtcblxuICBjb25zdCByZXF1aXJlc0NsZWFudXAgPSAhb3B0aW9ucz8ubWFudWFsQ2xlYW51cDtcbiAgcmVxdWlyZXNDbGVhbnVwICYmICFvcHRpb25zPy5pbmplY3RvciAmJiBhc3NlcnRJbkluamVjdGlvbkNvbnRleHQodG9TaWduYWwpO1xuICBjb25zdCBjbGVhbnVwUmVmID0gcmVxdWlyZXNDbGVhbnVwXG4gICAgPyBvcHRpb25zPy5pbmplY3Rvcj8uZ2V0KERlc3Ryb3lSZWYpID8/IGluamVjdChEZXN0cm95UmVmKVxuICAgIDogbnVsbDtcblxuICBjb25zdCBlcXVhbCA9IG1ha2VUb1NpZ25hbEVxdWFsKG9wdGlvbnM/LmVxdWFsKTtcblxuICAvLyBOb3RlOiBUIGlzIHRoZSBPYnNlcnZhYmxlIHZhbHVlIHR5cGUsIGFuZCBVIGlzIHRoZSBpbml0aWFsIHZhbHVlIHR5cGUuIFRoZXkgZG9uJ3QgaGF2ZSB0byBiZVxuICAvLyB0aGUgc2FtZSAtIHRoZSByZXR1cm5lZCBzaWduYWwgZ2l2ZXMgdmFsdWVzIG9mIHR5cGUgYFRgLlxuICBsZXQgc3RhdGU6IFdyaXRhYmxlU2lnbmFsPFN0YXRlPFQgfCBVPj47XG4gIGlmIChvcHRpb25zPy5yZXF1aXJlU3luYykge1xuICAgIC8vIEluaXRpYWxseSB0aGUgc2lnbmFsIGlzIGluIGEgYE5vVmFsdWVgIHN0YXRlLlxuICAgIHN0YXRlID0gc2lnbmFsKHtraW5kOiBTdGF0ZUtpbmQuTm9WYWx1ZX0sIHtlcXVhbH0pO1xuICB9IGVsc2Uge1xuICAgIC8vIElmIGFuIGluaXRpYWwgdmFsdWUgd2FzIHBhc3NlZCwgdXNlIGl0LiBPdGhlcndpc2UsIHVzZSBgdW5kZWZpbmVkYCBhcyB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAgICBzdGF0ZSA9IHNpZ25hbDxTdGF0ZTxUIHwgVT4+KFxuICAgICAge2tpbmQ6IFN0YXRlS2luZC5WYWx1ZSwgdmFsdWU6IG9wdGlvbnM/LmluaXRpYWxWYWx1ZSBhcyBVfSxcbiAgICAgIHtlcXVhbH0sXG4gICAgKTtcbiAgfVxuXG4gIC8vIE5vdGU6IFRoaXMgY29kZSBjYW5ub3QgcnVuIGluc2lkZSBhIHJlYWN0aXZlIGNvbnRleHQgKHNlZSBhc3NlcnRpb24gYWJvdmUpLiBJZiB3ZSdkIHN1cHBvcnRcbiAgLy8gdGhpcywgd2Ugd291bGQgc3Vic2NyaWJlIHRvIHRoZSBvYnNlcnZhYmxlIG91dHNpZGUgb2YgdGhlIGN1cnJlbnQgcmVhY3RpdmUgY29udGV4dCwgYXZvaWRpbmdcbiAgLy8gdGhhdCBzaWRlLWVmZmVjdCBzaWduYWwgcmVhZHMvd3JpdGVzIGFyZSBhdHRyaWJ1dGUgdG8gdGhlIGN1cnJlbnQgY29uc3VtZXIuIFRoZSBjdXJyZW50XG4gIC8vIGNvbnN1bWVyIG9ubHkgbmVlZHMgdG8gYmUgbm90aWZpZWQgd2hlbiB0aGUgYHN0YXRlYCBzaWduYWwgY2hhbmdlcyB0aHJvdWdoIHRoZSBvYnNlcnZhYmxlXG4gIC8vIHN1YnNjcmlwdGlvbi4gQWRkaXRpb25hbCBjb250ZXh0IChyZWxhdGVkIHRvIGFzeW5jIHBpcGUpOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL3B1bGwvNTA1MjIuXG4gIGNvbnN0IHN1YiA9IHNvdXJjZS5zdWJzY3JpYmUoe1xuICAgIG5leHQ6ICh2YWx1ZSkgPT4gc3RhdGUuc2V0KHtraW5kOiBTdGF0ZUtpbmQuVmFsdWUsIHZhbHVlfSksXG4gICAgZXJyb3I6IChlcnJvcikgPT4ge1xuICAgICAgaWYgKG9wdGlvbnM/LnJlamVjdEVycm9ycykge1xuICAgICAgICAvLyBLaWNrIHRoZSBlcnJvciBiYWNrIHRvIFJ4SlMuIEl0IHdpbGwgYmUgY2F1Z2h0IGFuZCByZXRocm93biBpbiBhIG1hY3JvdGFzaywgd2hpY2ggY2F1c2VzXG4gICAgICAgIC8vIHRoZSBlcnJvciB0byBlbmQgdXAgYXMgYW4gdW5jYXVnaHQgZXhjZXB0aW9uLlxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnNldCh7a2luZDogU3RhdGVLaW5kLkVycm9yLCBlcnJvcn0pO1xuICAgIH0sXG4gICAgLy8gQ29tcGxldGlvbiBvZiB0aGUgT2JzZXJ2YWJsZSBpcyBtZWFuaW5nbGVzcyB0byB0aGUgc2lnbmFsLiBTaWduYWxzIGRvbid0IGhhdmUgYSBjb25jZXB0IG9mXG4gICAgLy8gXCJjb21wbGV0ZVwiLlxuICB9KTtcblxuICBpZiAobmdEZXZNb2RlICYmIG9wdGlvbnM/LnJlcXVpcmVTeW5jICYmIHN0YXRlKCkua2luZCA9PT0gU3RhdGVLaW5kLk5vVmFsdWUpIHtcbiAgICB0aHJvdyBuZXcgybVSdW50aW1lRXJyb3IoXG4gICAgICDJtVJ1bnRpbWVFcnJvckNvZGUuUkVRVUlSRV9TWU5DX1dJVEhPVVRfU1lOQ19FTUlULFxuICAgICAgJ2B0b1NpZ25hbCgpYCBjYWxsZWQgd2l0aCBgcmVxdWlyZVN5bmNgIGJ1dCBgT2JzZXJ2YWJsZWAgZGlkIG5vdCBlbWl0IHN5bmNocm9ub3VzbHkuJyxcbiAgICApO1xuICB9XG5cbiAgLy8gVW5zdWJzY3JpYmUgd2hlbiB0aGUgY3VycmVudCBjb250ZXh0IGlzIGRlc3Ryb3llZCwgaWYgcmVxdWVzdGVkLlxuICBjbGVhbnVwUmVmPy5vbkRlc3Ryb3koc3ViLnVuc3Vic2NyaWJlLmJpbmQoc3ViKSk7XG5cbiAgLy8gVGhlIGFjdHVhbCByZXR1cm5lZCBzaWduYWwgaXMgYSBgY29tcHV0ZWRgIG9mIHRoZSBgU3RhdGVgIHNpZ25hbCwgd2hpY2ggbWFwcyB0aGUgdmFyaW91cyBzdGF0ZXNcbiAgLy8gdG8gZWl0aGVyIHZhbHVlcyBvciBlcnJvcnMuXG4gIHJldHVybiBjb21wdXRlZCgoKSA9PiB7XG4gICAgY29uc3QgY3VycmVudCA9IHN0YXRlKCk7XG4gICAgc3dpdGNoIChjdXJyZW50LmtpbmQpIHtcbiAgICAgIGNhc2UgU3RhdGVLaW5kLlZhbHVlOlxuICAgICAgICByZXR1cm4gY3VycmVudC52YWx1ZTtcbiAgICAgIGNhc2UgU3RhdGVLaW5kLkVycm9yOlxuICAgICAgICB0aHJvdyBjdXJyZW50LmVycm9yO1xuICAgICAgY2FzZSBTdGF0ZUtpbmQuTm9WYWx1ZTpcbiAgICAgICAgLy8gVGhpcyBzaG91bGRuJ3QgcmVhbGx5IGhhcHBlbiBiZWNhdXNlIHRoZSBlcnJvciBpcyB0aHJvd24gb24gY3JlYXRpb24uXG4gICAgICAgIC8vIFRPRE8oYWx4aHViKTogdXNlIGEgUnVudGltZUVycm9yIHdoZW4gd2UgZmluYWxpemUgdGhlIGVycm9yIHNlbWFudGljc1xuICAgICAgICB0aHJvdyBuZXcgybVSdW50aW1lRXJyb3IoXG4gICAgICAgICAgybVSdW50aW1lRXJyb3JDb2RlLlJFUVVJUkVfU1lOQ19XSVRIT1VUX1NZTkNfRU1JVCxcbiAgICAgICAgICAnYHRvU2lnbmFsKClgIGNhbGxlZCB3aXRoIGByZXF1aXJlU3luY2AgYnV0IGBPYnNlcnZhYmxlYCBkaWQgbm90IGVtaXQgc3luY2hyb25vdXNseS4nLFxuICAgICAgICApO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIG1ha2VUb1NpZ25hbEVxdWFsPFQ+KFxuICB1c2VyRXF1YWxpdHk6IFZhbHVlRXF1YWxpdHlGbjxUPiA9IE9iamVjdC5pcyxcbik6IFZhbHVlRXF1YWxpdHlGbjxTdGF0ZTxUPj4ge1xuICByZXR1cm4gKGEsIGIpID0+XG4gICAgYS5raW5kID09PSBTdGF0ZUtpbmQuVmFsdWUgJiYgYi5raW5kID09PSBTdGF0ZUtpbmQuVmFsdWUgJiYgdXNlckVxdWFsaXR5KGEudmFsdWUsIGIudmFsdWUpO1xufVxuXG5jb25zdCBlbnVtIFN0YXRlS2luZCB7XG4gIE5vVmFsdWUsXG4gIFZhbHVlLFxuICBFcnJvcixcbn1cblxuaW50ZXJmYWNlIE5vVmFsdWVTdGF0ZSB7XG4gIGtpbmQ6IFN0YXRlS2luZC5Ob1ZhbHVlO1xufVxuXG5pbnRlcmZhY2UgVmFsdWVTdGF0ZTxUPiB7XG4gIGtpbmQ6IFN0YXRlS2luZC5WYWx1ZTtcbiAgdmFsdWU6IFQ7XG59XG5cbmludGVyZmFjZSBFcnJvclN0YXRlIHtcbiAga2luZDogU3RhdGVLaW5kLkVycm9yO1xuICBlcnJvcjogdW5rbm93bjtcbn1cblxudHlwZSBTdGF0ZTxUPiA9IE5vVmFsdWVTdGF0ZSB8IFZhbHVlU3RhdGU8VD4gfCBFcnJvclN0YXRlO1xuIl19
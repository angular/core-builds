/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { assertInInjectionContext, assertNotInReactiveContext, computed, DestroyRef, inject, signal, ɵRuntimeError, } from '@angular/core';
/**
 * Get the current value of an `Observable` as a reactive `Signal`.
 *
 * `toSignal` returns a `Signal` which provides synchronous reactive access to values produced
 * by the given `Observable`, by subscribing to that `Observable`. The returned `Signal` will always
 * have the most recent value emitted by the subscription, and will throw an error if the
 * `Observable` errors.
 *
 * With `requireSync` set to `true`, `toSignal` will assert that the `Observable` produces a value
 * immediately upon subscription. No `initialValue` is needed in this case, and the returned signal
 * does not include an `undefined` type.
 *
 * By default, the subscription will be automatically cleaned up when the current [injection
 * context](guide/di/dependency-injection-context) is destroyed. For example, when `toSignal` is
 * called during the construction of a component, the subscription will be cleaned up when the
 * component is destroyed. If an injection context is not available, an explicit `Injector` can be
 * passed instead.
 *
 * If the subscription should persist until the `Observable` itself completes, the `manualCleanup`
 * option can be specified instead, which disables the automatic subscription teardown. No injection
 * context is needed in this configuration as well.
 *
 * @developerPreview
 */
export function toSignal(source, options) {
    ngDevMode &&
        assertNotInReactiveContext(toSignal, 'Invoking `toSignal` causes new subscriptions every time. ' +
            'Consider moving `toSignal` outside of the reactive context and read the signal value where needed.');
    const requiresCleanup = !options?.manualCleanup;
    requiresCleanup && !options?.injector && assertInInjectionContext(toSignal);
    const cleanupRef = requiresCleanup
        ? options?.injector?.get(DestroyRef) ?? inject(DestroyRef)
        : null;
    const equal = makeToSignalEquals(options?.equals);
    // Note: T is the Observable value type, and U is the initial value type. They don't have to be
    // the same - the returned signal gives values of type `T`.
    let state;
    if (options?.requireSync) {
        // Initially the signal is in a `NoValue` state.
        state = signal({ kind: 0 /* StateKind.NoValue */ }, { equal });
    }
    else {
        // If an initial value was passed, use it. Otherwise, use `undefined` as the initial value.
        state = signal({ kind: 1 /* StateKind.Value */, value: options?.initialValue }, { equal });
    }
    // Note: This code cannot run inside a reactive context (see assertion above). If we'd support
    // this, we would subscribe to the observable outside of the current reactive context, avoiding
    // that side-effect signal reads/writes are attribute to the current consumer. The current
    // consumer only needs to be notified when the `state` signal changes through the observable
    // subscription. Additional context (related to async pipe):
    // https://github.com/angular/angular/pull/50522.
    const sub = source.subscribe({
        next: (value) => state.set({ kind: 1 /* StateKind.Value */, value }),
        error: (error) => {
            if (options?.rejectErrors) {
                // Kick the error back to RxJS. It will be caught and rethrown in a macrotask, which causes
                // the error to end up as an uncaught exception.
                throw error;
            }
            state.set({ kind: 2 /* StateKind.Error */, error });
        },
        // Completion of the Observable is meaningless to the signal. Signals don't have a concept of
        // "complete".
    });
    if (ngDevMode && options?.requireSync && state().kind === 0 /* StateKind.NoValue */) {
        throw new ɵRuntimeError(601 /* ɵRuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT */, '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');
    }
    // Unsubscribe when the current context is destroyed, if requested.
    cleanupRef?.onDestroy(sub.unsubscribe.bind(sub));
    // The actual returned signal is a `computed` of the `State` signal, which maps the various states
    // to either values or errors.
    return computed(() => {
        const current = state();
        switch (current.kind) {
            case 1 /* StateKind.Value */:
                return current.value;
            case 2 /* StateKind.Error */:
                throw current.error;
            case 0 /* StateKind.NoValue */:
                // This shouldn't really happen because the error is thrown on creation.
                // TODO(alxhub): use a RuntimeError when we finalize the error semantics
                throw new ɵRuntimeError(601 /* ɵRuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT */, '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');
        }
    });
}
function makeToSignalEquals(userEquality = Object.is) {
    return (a, b) => a.kind === 1 /* StateKind.Value */ && b.kind === 1 /* StateKind.Value */ && userEquality(a.value, b.value);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9fc2lnbmFsLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvY29yZS9yeGpzLWludGVyb3Avc3JjL3RvX3NpZ25hbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0dBTUc7QUFFSCxPQUFPLEVBQ0wsd0JBQXdCLEVBQ3hCLDBCQUEwQixFQUMxQixRQUFRLEVBQ1IsVUFBVSxFQUNWLE1BQU0sRUFFTixNQUFNLEVBR04sYUFBYSxHQUVkLE1BQU0sZUFBZSxDQUFDO0FBd0Z2Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0F1Qkc7QUFDSCxNQUFNLFVBQVUsUUFBUSxDQUN0QixNQUF1QyxFQUN2QyxPQUFxRDtJQUVyRCxTQUFTO1FBQ1AsMEJBQTBCLENBQ3hCLFFBQVEsRUFDUiwyREFBMkQ7WUFDekQsb0dBQW9HLENBQ3ZHLENBQUM7SUFFSixNQUFNLGVBQWUsR0FBRyxDQUFDLE9BQU8sRUFBRSxhQUFhLENBQUM7SUFDaEQsZUFBZSxJQUFJLENBQUMsT0FBTyxFQUFFLFFBQVEsSUFBSSx3QkFBd0IsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUM1RSxNQUFNLFVBQVUsR0FBRyxlQUFlO1FBQ2hDLENBQUMsQ0FBQyxPQUFPLEVBQUUsUUFBUSxFQUFFLEdBQUcsQ0FBQyxVQUFVLENBQUMsSUFBSSxNQUFNLENBQUMsVUFBVSxDQUFDO1FBQzFELENBQUMsQ0FBQyxJQUFJLENBQUM7SUFFVCxNQUFNLEtBQUssR0FBRyxrQkFBa0IsQ0FBQyxPQUFPLEVBQUUsTUFBTSxDQUFDLENBQUM7SUFFbEQsK0ZBQStGO0lBQy9GLDJEQUEyRDtJQUMzRCxJQUFJLEtBQW1DLENBQUM7SUFDeEMsSUFBSSxPQUFPLEVBQUUsV0FBVyxFQUFFLENBQUM7UUFDekIsZ0RBQWdEO1FBQ2hELEtBQUssR0FBRyxNQUFNLENBQUMsRUFBQyxJQUFJLDJCQUFtQixFQUFDLEVBQUUsRUFBQyxLQUFLLEVBQUMsQ0FBQyxDQUFDO0lBQ3JELENBQUM7U0FBTSxDQUFDO1FBQ04sMkZBQTJGO1FBQzNGLEtBQUssR0FBRyxNQUFNLENBQ1osRUFBQyxJQUFJLHlCQUFpQixFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUUsWUFBaUIsRUFBQyxFQUMxRCxFQUFDLEtBQUssRUFBQyxDQUNSLENBQUM7SUFDSixDQUFDO0lBRUQsOEZBQThGO0lBQzlGLCtGQUErRjtJQUMvRiwwRkFBMEY7SUFDMUYsNEZBQTRGO0lBQzVGLDREQUE0RDtJQUM1RCxpREFBaUQ7SUFDakQsTUFBTSxHQUFHLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FBQztRQUMzQixJQUFJLEVBQUUsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsRUFBQyxJQUFJLHlCQUFpQixFQUFFLEtBQUssRUFBQyxDQUFDO1FBQzFELEtBQUssRUFBRSxDQUFDLEtBQUssRUFBRSxFQUFFO1lBQ2YsSUFBSSxPQUFPLEVBQUUsWUFBWSxFQUFFLENBQUM7Z0JBQzFCLDJGQUEyRjtnQkFDM0YsZ0RBQWdEO2dCQUNoRCxNQUFNLEtBQUssQ0FBQztZQUNkLENBQUM7WUFDRCxLQUFLLENBQUMsR0FBRyxDQUFDLEVBQUMsSUFBSSx5QkFBaUIsRUFBRSxLQUFLLEVBQUMsQ0FBQyxDQUFDO1FBQzVDLENBQUM7UUFDRCw2RkFBNkY7UUFDN0YsY0FBYztLQUNmLENBQUMsQ0FBQztJQUVILElBQUksU0FBUyxJQUFJLE9BQU8sRUFBRSxXQUFXLElBQUksS0FBSyxFQUFFLENBQUMsSUFBSSw4QkFBc0IsRUFBRSxDQUFDO1FBQzVFLE1BQU0sSUFBSSxhQUFhLDZEQUVyQixxRkFBcUYsQ0FDdEYsQ0FBQztJQUNKLENBQUM7SUFFRCxtRUFBbUU7SUFDbkUsVUFBVSxFQUFFLFNBQVMsQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBRWpELGtHQUFrRztJQUNsRyw4QkFBOEI7SUFDOUIsT0FBTyxRQUFRLENBQUMsR0FBRyxFQUFFO1FBQ25CLE1BQU0sT0FBTyxHQUFHLEtBQUssRUFBRSxDQUFDO1FBQ3hCLFFBQVEsT0FBTyxDQUFDLElBQUksRUFBRSxDQUFDO1lBQ3JCO2dCQUNFLE9BQU8sT0FBTyxDQUFDLEtBQUssQ0FBQztZQUN2QjtnQkFDRSxNQUFNLE9BQU8sQ0FBQyxLQUFLLENBQUM7WUFDdEI7Z0JBQ0Usd0VBQXdFO2dCQUN4RSx3RUFBd0U7Z0JBQ3hFLE1BQU0sSUFBSSxhQUFhLDZEQUVyQixxRkFBcUYsQ0FDdEYsQ0FBQztRQUNOLENBQUM7SUFDSCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUM7QUFFRCxTQUFTLGtCQUFrQixDQUN6QixlQUFtQyxNQUFNLENBQUMsRUFBRTtJQUU1QyxPQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQ2QsQ0FBQyxDQUFDLElBQUksNEJBQW9CLElBQUksQ0FBQyxDQUFDLElBQUksNEJBQW9CLElBQUksWUFBWSxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQy9GLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuaW1wb3J0IHtcbiAgYXNzZXJ0SW5JbmplY3Rpb25Db250ZXh0LFxuICBhc3NlcnROb3RJblJlYWN0aXZlQ29udGV4dCxcbiAgY29tcHV0ZWQsXG4gIERlc3Ryb3lSZWYsXG4gIGluamVjdCxcbiAgSW5qZWN0b3IsXG4gIHNpZ25hbCxcbiAgU2lnbmFsLFxuICBXcml0YWJsZVNpZ25hbCxcbiAgybVSdW50aW1lRXJyb3IsXG4gIMm1UnVudGltZUVycm9yQ29kZSxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1ZhbHVlRXF1YWxpdHlGbn0gZnJvbSAnQGFuZ3VsYXIvY29yZS9wcmltaXRpdmVzL3NpZ25hbHMnO1xuaW1wb3J0IHtPYnNlcnZhYmxlLCBTdWJzY3JpYmFibGV9IGZyb20gJ3J4anMnO1xuXG4vKipcbiAqIE9wdGlvbnMgZm9yIGB0b1NpZ25hbGAuXG4gKlxuICogQHB1YmxpY0FwaVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRvU2lnbmFsT3B0aW9uczxUPiB7XG4gIC8qKlxuICAgKiBJbml0aWFsIHZhbHVlIGZvciB0aGUgc2lnbmFsIHByb2R1Y2VkIGJ5IGB0b1NpZ25hbGAuXG4gICAqXG4gICAqIFRoaXMgd2lsbCBiZSB0aGUgdmFsdWUgb2YgdGhlIHNpZ25hbCB1bnRpbCB0aGUgb2JzZXJ2YWJsZSBlbWl0cyBpdHMgZmlyc3QgdmFsdWUuXG4gICAqL1xuICBpbml0aWFsVmFsdWU/OiB1bmtub3duO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHJlcXVpcmUgdGhhdCB0aGUgb2JzZXJ2YWJsZSBlbWl0cyBzeW5jaHJvbm91c2x5IHdoZW4gYHRvU2lnbmFsYCBzdWJzY3JpYmVzLlxuICAgKlxuICAgKiBJZiB0aGlzIGlzIGB0cnVlYCwgYHRvU2lnbmFsYCB3aWxsIGFzc2VydCB0aGF0IHRoZSBvYnNlcnZhYmxlIHByb2R1Y2VzIGEgdmFsdWUgaW1tZWRpYXRlbHkgdXBvblxuICAgKiBzdWJzY3JpcHRpb24uIFNldHRpbmcgdGhpcyBvcHRpb24gcmVtb3ZlcyB0aGUgbmVlZCB0byBlaXRoZXIgZGVhbCB3aXRoIGB1bmRlZmluZWRgIGluIHRoZVxuICAgKiBzaWduYWwgdHlwZSBvciBwcm92aWRlIGFuIGBpbml0aWFsVmFsdWVgLCBhdCB0aGUgY29zdCBvZiBhIHJ1bnRpbWUgZXJyb3IgaWYgdGhpcyByZXF1aXJlbWVudCBpc1xuICAgKiBub3QgbWV0LlxuICAgKi9cbiAgcmVxdWlyZVN5bmM/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBgSW5qZWN0b3JgIHdoaWNoIHdpbGwgcHJvdmlkZSB0aGUgYERlc3Ryb3lSZWZgIHVzZWQgdG8gY2xlYW4gdXAgdGhlIE9ic2VydmFibGUgc3Vic2NyaXB0aW9uLlxuICAgKlxuICAgKiBJZiB0aGlzIGlzIG5vdCBwcm92aWRlZCwgYSBgRGVzdHJveVJlZmAgd2lsbCBiZSByZXRyaWV2ZWQgZnJvbSB0aGUgY3VycmVudCBbaW5qZWN0aW9uXG4gICAqIGNvbnRleHRdKGd1aWRlL2RpL2RlcGVuZGVuY3ktaW5qZWN0aW9uLWNvbnRleHQpLCB1bmxlc3MgbWFudWFsIGNsZWFudXAgaXMgcmVxdWVzdGVkLlxuICAgKi9cbiAgaW5qZWN0b3I/OiBJbmplY3RvcjtcblxuICAvKipcbiAgICogV2hldGhlciB0aGUgc3Vic2NyaXB0aW9uIHNob3VsZCBiZSBhdXRvbWF0aWNhbGx5IGNsZWFuZWQgdXAgKHZpYSBgRGVzdHJveVJlZmApIHdoZW5cbiAgICogYHRvU2lnbmFsYCdzIGNyZWF0aW9uIGNvbnRleHQgaXMgZGVzdHJveWVkLlxuICAgKlxuICAgKiBJZiBtYW51YWwgY2xlYW51cCBpcyBlbmFibGVkLCB0aGVuIGBEZXN0cm95UmVmYCBpcyBub3QgdXNlZCwgYW5kIHRoZSBzdWJzY3JpcHRpb24gd2lsbCBwZXJzaXN0XG4gICAqIHVudGlsIHRoZSBgT2JzZXJ2YWJsZWAgaXRzZWxmIGNvbXBsZXRlcy5cbiAgICovXG4gIG1hbnVhbENsZWFudXA/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIGB0b1NpZ25hbGAgc2hvdWxkIHRocm93IGVycm9ycyBmcm9tIHRoZSBPYnNlcnZhYmxlIGVycm9yIGNoYW5uZWwgYmFjayB0byBSeEpTLCB3aGVyZVxuICAgKiB0aGV5J2xsIGJlIHByb2Nlc3NlZCBhcyB1bmNhdWdodCBleGNlcHRpb25zLlxuICAgKlxuICAgKiBJbiBwcmFjdGljZSwgdGhpcyBtZWFucyB0aGF0IHRoZSBzaWduYWwgcmV0dXJuZWQgYnkgYHRvU2lnbmFsYCB3aWxsIGtlZXAgcmV0dXJuaW5nIHRoZSBsYXN0XG4gICAqIGdvb2QgdmFsdWUgZm9yZXZlciwgYXMgT2JzZXJ2YWJsZXMgd2hpY2ggZXJyb3IgcHJvZHVjZSBubyBmdXJ0aGVyIHZhbHVlcy4gVGhpcyBvcHRpb24gZW11bGF0ZXNcbiAgICogdGhlIGJlaGF2aW9yIG9mIHRoZSBgYXN5bmNgIHBpcGUuXG4gICAqL1xuICByZWplY3RFcnJvcnM/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBBIGNvbXBhcmlzb24gZnVuY3Rpb24gd2hpY2ggZGVmaW5lcyBlcXVhbGl0eSBmb3IgdmFsdWVzIGVtaXR0ZWQgYnkgdGhlIG9ic2VydmFibGUuXG4gICAqXG4gICAqIEVxdWFsaXR5IGNvbXBhcmlzb25zIGFyZSBleGVjdXRlZCBhZ2FpbnN0IHRoZSBpbml0aWFsIHZhbHVlIGlmIG9uZSBpcyBwcm92aWRlZC5cbiAgICovXG4gIGVxdWFscz86IFZhbHVlRXF1YWxpdHlGbjxUPjtcbn1cblxuLy8gQmFzZSBjYXNlOiBubyBvcHRpb25zIC0+IGB1bmRlZmluZWRgIGluIHRoZSByZXN1bHQgdHlwZS5cbmV4cG9ydCBmdW5jdGlvbiB0b1NpZ25hbDxUPihzb3VyY2U6IE9ic2VydmFibGU8VD4gfCBTdWJzY3JpYmFibGU8VD4pOiBTaWduYWw8VCB8IHVuZGVmaW5lZD47XG4vLyBPcHRpb25zIHdpdGggYHVuZGVmaW5lZGAgaW5pdGlhbCB2YWx1ZSBhbmQgbm8gYHJlcXVpcmVkU3luY2AgLT4gYHVuZGVmaW5lZGAuXG5leHBvcnQgZnVuY3Rpb24gdG9TaWduYWw8VD4oXG4gIHNvdXJjZTogT2JzZXJ2YWJsZTxUPiB8IFN1YnNjcmliYWJsZTxUPixcbiAgb3B0aW9uczogTm9JbmZlcjxUb1NpZ25hbE9wdGlvbnM8VCB8IHVuZGVmaW5lZD4+ICYge1xuICAgIGluaXRpYWxWYWx1ZT86IHVuZGVmaW5lZDtcbiAgICByZXF1aXJlU3luYz86IGZhbHNlO1xuICB9LFxuKTogU2lnbmFsPFQgfCB1bmRlZmluZWQ+O1xuLy8gT3B0aW9ucyB3aXRoIGBudWxsYCBpbml0aWFsIHZhbHVlIC0+IGBudWxsYC5cbmV4cG9ydCBmdW5jdGlvbiB0b1NpZ25hbDxUPihcbiAgc291cmNlOiBPYnNlcnZhYmxlPFQ+IHwgU3Vic2NyaWJhYmxlPFQ+LFxuICBvcHRpb25zOiBOb0luZmVyPFRvU2lnbmFsT3B0aW9uczxUIHwgbnVsbD4+ICYge2luaXRpYWxWYWx1ZT86IG51bGw7IHJlcXVpcmVTeW5jPzogZmFsc2V9LFxuKTogU2lnbmFsPFQgfCBudWxsPjtcbi8vIE9wdGlvbnMgd2l0aCBgdW5kZWZpbmVkYCBpbml0aWFsIHZhbHVlIGFuZCBgcmVxdWlyZWRTeW5jYCAtPiBzdHJpY3QgcmVzdWx0IHR5cGUuXG5leHBvcnQgZnVuY3Rpb24gdG9TaWduYWw8VD4oXG4gIHNvdXJjZTogT2JzZXJ2YWJsZTxUPiB8IFN1YnNjcmliYWJsZTxUPixcbiAgb3B0aW9uczogTm9JbmZlcjxUb1NpZ25hbE9wdGlvbnM8VD4+ICYge2luaXRpYWxWYWx1ZT86IHVuZGVmaW5lZDsgcmVxdWlyZVN5bmM6IHRydWV9LFxuKTogU2lnbmFsPFQ+O1xuLy8gT3B0aW9ucyB3aXRoIGEgbW9yZSBzcGVjaWZpYyBpbml0aWFsIHZhbHVlIHR5cGUuXG5leHBvcnQgZnVuY3Rpb24gdG9TaWduYWw8VCwgY29uc3QgVSBleHRlbmRzIFQ+KFxuICBzb3VyY2U6IE9ic2VydmFibGU8VD4gfCBTdWJzY3JpYmFibGU8VD4sXG4gIG9wdGlvbnM6IE5vSW5mZXI8VG9TaWduYWxPcHRpb25zPFQgfCBVPj4gJiB7aW5pdGlhbFZhbHVlOiBVOyByZXF1aXJlU3luYz86IGZhbHNlfSxcbik6IFNpZ25hbDxUIHwgVT47XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IHZhbHVlIG9mIGFuIGBPYnNlcnZhYmxlYCBhcyBhIHJlYWN0aXZlIGBTaWduYWxgLlxuICpcbiAqIGB0b1NpZ25hbGAgcmV0dXJucyBhIGBTaWduYWxgIHdoaWNoIHByb3ZpZGVzIHN5bmNocm9ub3VzIHJlYWN0aXZlIGFjY2VzcyB0byB2YWx1ZXMgcHJvZHVjZWRcbiAqIGJ5IHRoZSBnaXZlbiBgT2JzZXJ2YWJsZWAsIGJ5IHN1YnNjcmliaW5nIHRvIHRoYXQgYE9ic2VydmFibGVgLiBUaGUgcmV0dXJuZWQgYFNpZ25hbGAgd2lsbCBhbHdheXNcbiAqIGhhdmUgdGhlIG1vc3QgcmVjZW50IHZhbHVlIGVtaXR0ZWQgYnkgdGhlIHN1YnNjcmlwdGlvbiwgYW5kIHdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgdGhlXG4gKiBgT2JzZXJ2YWJsZWAgZXJyb3JzLlxuICpcbiAqIFdpdGggYHJlcXVpcmVTeW5jYCBzZXQgdG8gYHRydWVgLCBgdG9TaWduYWxgIHdpbGwgYXNzZXJ0IHRoYXQgdGhlIGBPYnNlcnZhYmxlYCBwcm9kdWNlcyBhIHZhbHVlXG4gKiBpbW1lZGlhdGVseSB1cG9uIHN1YnNjcmlwdGlvbi4gTm8gYGluaXRpYWxWYWx1ZWAgaXMgbmVlZGVkIGluIHRoaXMgY2FzZSwgYW5kIHRoZSByZXR1cm5lZCBzaWduYWxcbiAqIGRvZXMgbm90IGluY2x1ZGUgYW4gYHVuZGVmaW5lZGAgdHlwZS5cbiAqXG4gKiBCeSBkZWZhdWx0LCB0aGUgc3Vic2NyaXB0aW9uIHdpbGwgYmUgYXV0b21hdGljYWxseSBjbGVhbmVkIHVwIHdoZW4gdGhlIGN1cnJlbnQgW2luamVjdGlvblxuICogY29udGV4dF0oZ3VpZGUvZGkvZGVwZW5kZW5jeS1pbmplY3Rpb24tY29udGV4dCkgaXMgZGVzdHJveWVkLiBGb3IgZXhhbXBsZSwgd2hlbiBgdG9TaWduYWxgIGlzXG4gKiBjYWxsZWQgZHVyaW5nIHRoZSBjb25zdHJ1Y3Rpb24gb2YgYSBjb21wb25lbnQsIHRoZSBzdWJzY3JpcHRpb24gd2lsbCBiZSBjbGVhbmVkIHVwIHdoZW4gdGhlXG4gKiBjb21wb25lbnQgaXMgZGVzdHJveWVkLiBJZiBhbiBpbmplY3Rpb24gY29udGV4dCBpcyBub3QgYXZhaWxhYmxlLCBhbiBleHBsaWNpdCBgSW5qZWN0b3JgIGNhbiBiZVxuICogcGFzc2VkIGluc3RlYWQuXG4gKlxuICogSWYgdGhlIHN1YnNjcmlwdGlvbiBzaG91bGQgcGVyc2lzdCB1bnRpbCB0aGUgYE9ic2VydmFibGVgIGl0c2VsZiBjb21wbGV0ZXMsIHRoZSBgbWFudWFsQ2xlYW51cGBcbiAqIG9wdGlvbiBjYW4gYmUgc3BlY2lmaWVkIGluc3RlYWQsIHdoaWNoIGRpc2FibGVzIHRoZSBhdXRvbWF0aWMgc3Vic2NyaXB0aW9uIHRlYXJkb3duLiBObyBpbmplY3Rpb25cbiAqIGNvbnRleHQgaXMgbmVlZGVkIGluIHRoaXMgY29uZmlndXJhdGlvbiBhcyB3ZWxsLlxuICpcbiAqIEBkZXZlbG9wZXJQcmV2aWV3XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1NpZ25hbDxULCBVID0gdW5kZWZpbmVkPihcbiAgc291cmNlOiBPYnNlcnZhYmxlPFQ+IHwgU3Vic2NyaWJhYmxlPFQ+LFxuICBvcHRpb25zPzogVG9TaWduYWxPcHRpb25zPFQgfCBVPiAmIHtpbml0aWFsVmFsdWU/OiBVfSxcbik6IFNpZ25hbDxUIHwgVT4ge1xuICBuZ0Rldk1vZGUgJiZcbiAgICBhc3NlcnROb3RJblJlYWN0aXZlQ29udGV4dChcbiAgICAgIHRvU2lnbmFsLFxuICAgICAgJ0ludm9raW5nIGB0b1NpZ25hbGAgY2F1c2VzIG5ldyBzdWJzY3JpcHRpb25zIGV2ZXJ5IHRpbWUuICcgK1xuICAgICAgICAnQ29uc2lkZXIgbW92aW5nIGB0b1NpZ25hbGAgb3V0c2lkZSBvZiB0aGUgcmVhY3RpdmUgY29udGV4dCBhbmQgcmVhZCB0aGUgc2lnbmFsIHZhbHVlIHdoZXJlIG5lZWRlZC4nLFxuICAgICk7XG5cbiAgY29uc3QgcmVxdWlyZXNDbGVhbnVwID0gIW9wdGlvbnM/Lm1hbnVhbENsZWFudXA7XG4gIHJlcXVpcmVzQ2xlYW51cCAmJiAhb3B0aW9ucz8uaW5qZWN0b3IgJiYgYXNzZXJ0SW5JbmplY3Rpb25Db250ZXh0KHRvU2lnbmFsKTtcbiAgY29uc3QgY2xlYW51cFJlZiA9IHJlcXVpcmVzQ2xlYW51cFxuICAgID8gb3B0aW9ucz8uaW5qZWN0b3I/LmdldChEZXN0cm95UmVmKSA/PyBpbmplY3QoRGVzdHJveVJlZilcbiAgICA6IG51bGw7XG5cbiAgY29uc3QgZXF1YWwgPSBtYWtlVG9TaWduYWxFcXVhbHMob3B0aW9ucz8uZXF1YWxzKTtcblxuICAvLyBOb3RlOiBUIGlzIHRoZSBPYnNlcnZhYmxlIHZhbHVlIHR5cGUsIGFuZCBVIGlzIHRoZSBpbml0aWFsIHZhbHVlIHR5cGUuIFRoZXkgZG9uJ3QgaGF2ZSB0byBiZVxuICAvLyB0aGUgc2FtZSAtIHRoZSByZXR1cm5lZCBzaWduYWwgZ2l2ZXMgdmFsdWVzIG9mIHR5cGUgYFRgLlxuICBsZXQgc3RhdGU6IFdyaXRhYmxlU2lnbmFsPFN0YXRlPFQgfCBVPj47XG4gIGlmIChvcHRpb25zPy5yZXF1aXJlU3luYykge1xuICAgIC8vIEluaXRpYWxseSB0aGUgc2lnbmFsIGlzIGluIGEgYE5vVmFsdWVgIHN0YXRlLlxuICAgIHN0YXRlID0gc2lnbmFsKHtraW5kOiBTdGF0ZUtpbmQuTm9WYWx1ZX0sIHtlcXVhbH0pO1xuICB9IGVsc2Uge1xuICAgIC8vIElmIGFuIGluaXRpYWwgdmFsdWUgd2FzIHBhc3NlZCwgdXNlIGl0LiBPdGhlcndpc2UsIHVzZSBgdW5kZWZpbmVkYCBhcyB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAgICBzdGF0ZSA9IHNpZ25hbDxTdGF0ZTxUIHwgVT4+KFxuICAgICAge2tpbmQ6IFN0YXRlS2luZC5WYWx1ZSwgdmFsdWU6IG9wdGlvbnM/LmluaXRpYWxWYWx1ZSBhcyBVfSxcbiAgICAgIHtlcXVhbH0sXG4gICAgKTtcbiAgfVxuXG4gIC8vIE5vdGU6IFRoaXMgY29kZSBjYW5ub3QgcnVuIGluc2lkZSBhIHJlYWN0aXZlIGNvbnRleHQgKHNlZSBhc3NlcnRpb24gYWJvdmUpLiBJZiB3ZSdkIHN1cHBvcnRcbiAgLy8gdGhpcywgd2Ugd291bGQgc3Vic2NyaWJlIHRvIHRoZSBvYnNlcnZhYmxlIG91dHNpZGUgb2YgdGhlIGN1cnJlbnQgcmVhY3RpdmUgY29udGV4dCwgYXZvaWRpbmdcbiAgLy8gdGhhdCBzaWRlLWVmZmVjdCBzaWduYWwgcmVhZHMvd3JpdGVzIGFyZSBhdHRyaWJ1dGUgdG8gdGhlIGN1cnJlbnQgY29uc3VtZXIuIFRoZSBjdXJyZW50XG4gIC8vIGNvbnN1bWVyIG9ubHkgbmVlZHMgdG8gYmUgbm90aWZpZWQgd2hlbiB0aGUgYHN0YXRlYCBzaWduYWwgY2hhbmdlcyB0aHJvdWdoIHRoZSBvYnNlcnZhYmxlXG4gIC8vIHN1YnNjcmlwdGlvbi4gQWRkaXRpb25hbCBjb250ZXh0IChyZWxhdGVkIHRvIGFzeW5jIHBpcGUpOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL3B1bGwvNTA1MjIuXG4gIGNvbnN0IHN1YiA9IHNvdXJjZS5zdWJzY3JpYmUoe1xuICAgIG5leHQ6ICh2YWx1ZSkgPT4gc3RhdGUuc2V0KHtraW5kOiBTdGF0ZUtpbmQuVmFsdWUsIHZhbHVlfSksXG4gICAgZXJyb3I6IChlcnJvcikgPT4ge1xuICAgICAgaWYgKG9wdGlvbnM/LnJlamVjdEVycm9ycykge1xuICAgICAgICAvLyBLaWNrIHRoZSBlcnJvciBiYWNrIHRvIFJ4SlMuIEl0IHdpbGwgYmUgY2F1Z2h0IGFuZCByZXRocm93biBpbiBhIG1hY3JvdGFzaywgd2hpY2ggY2F1c2VzXG4gICAgICAgIC8vIHRoZSBlcnJvciB0byBlbmQgdXAgYXMgYW4gdW5jYXVnaHQgZXhjZXB0aW9uLlxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnNldCh7a2luZDogU3RhdGVLaW5kLkVycm9yLCBlcnJvcn0pO1xuICAgIH0sXG4gICAgLy8gQ29tcGxldGlvbiBvZiB0aGUgT2JzZXJ2YWJsZSBpcyBtZWFuaW5nbGVzcyB0byB0aGUgc2lnbmFsLiBTaWduYWxzIGRvbid0IGhhdmUgYSBjb25jZXB0IG9mXG4gICAgLy8gXCJjb21wbGV0ZVwiLlxuICB9KTtcblxuICBpZiAobmdEZXZNb2RlICYmIG9wdGlvbnM/LnJlcXVpcmVTeW5jICYmIHN0YXRlKCkua2luZCA9PT0gU3RhdGVLaW5kLk5vVmFsdWUpIHtcbiAgICB0aHJvdyBuZXcgybVSdW50aW1lRXJyb3IoXG4gICAgICDJtVJ1bnRpbWVFcnJvckNvZGUuUkVRVUlSRV9TWU5DX1dJVEhPVVRfU1lOQ19FTUlULFxuICAgICAgJ2B0b1NpZ25hbCgpYCBjYWxsZWQgd2l0aCBgcmVxdWlyZVN5bmNgIGJ1dCBgT2JzZXJ2YWJsZWAgZGlkIG5vdCBlbWl0IHN5bmNocm9ub3VzbHkuJyxcbiAgICApO1xuICB9XG5cbiAgLy8gVW5zdWJzY3JpYmUgd2hlbiB0aGUgY3VycmVudCBjb250ZXh0IGlzIGRlc3Ryb3llZCwgaWYgcmVxdWVzdGVkLlxuICBjbGVhbnVwUmVmPy5vbkRlc3Ryb3koc3ViLnVuc3Vic2NyaWJlLmJpbmQoc3ViKSk7XG5cbiAgLy8gVGhlIGFjdHVhbCByZXR1cm5lZCBzaWduYWwgaXMgYSBgY29tcHV0ZWRgIG9mIHRoZSBgU3RhdGVgIHNpZ25hbCwgd2hpY2ggbWFwcyB0aGUgdmFyaW91cyBzdGF0ZXNcbiAgLy8gdG8gZWl0aGVyIHZhbHVlcyBvciBlcnJvcnMuXG4gIHJldHVybiBjb21wdXRlZCgoKSA9PiB7XG4gICAgY29uc3QgY3VycmVudCA9IHN0YXRlKCk7XG4gICAgc3dpdGNoIChjdXJyZW50LmtpbmQpIHtcbiAgICAgIGNhc2UgU3RhdGVLaW5kLlZhbHVlOlxuICAgICAgICByZXR1cm4gY3VycmVudC52YWx1ZTtcbiAgICAgIGNhc2UgU3RhdGVLaW5kLkVycm9yOlxuICAgICAgICB0aHJvdyBjdXJyZW50LmVycm9yO1xuICAgICAgY2FzZSBTdGF0ZUtpbmQuTm9WYWx1ZTpcbiAgICAgICAgLy8gVGhpcyBzaG91bGRuJ3QgcmVhbGx5IGhhcHBlbiBiZWNhdXNlIHRoZSBlcnJvciBpcyB0aHJvd24gb24gY3JlYXRpb24uXG4gICAgICAgIC8vIFRPRE8oYWx4aHViKTogdXNlIGEgUnVudGltZUVycm9yIHdoZW4gd2UgZmluYWxpemUgdGhlIGVycm9yIHNlbWFudGljc1xuICAgICAgICB0aHJvdyBuZXcgybVSdW50aW1lRXJyb3IoXG4gICAgICAgICAgybVSdW50aW1lRXJyb3JDb2RlLlJFUVVJUkVfU1lOQ19XSVRIT1VUX1NZTkNfRU1JVCxcbiAgICAgICAgICAnYHRvU2lnbmFsKClgIGNhbGxlZCB3aXRoIGByZXF1aXJlU3luY2AgYnV0IGBPYnNlcnZhYmxlYCBkaWQgbm90IGVtaXQgc3luY2hyb25vdXNseS4nLFxuICAgICAgICApO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIG1ha2VUb1NpZ25hbEVxdWFsczxUPihcbiAgdXNlckVxdWFsaXR5OiBWYWx1ZUVxdWFsaXR5Rm48VD4gPSBPYmplY3QuaXMsXG4pOiBWYWx1ZUVxdWFsaXR5Rm48U3RhdGU8VD4+IHtcbiAgcmV0dXJuIChhLCBiKSA9PlxuICAgIGEua2luZCA9PT0gU3RhdGVLaW5kLlZhbHVlICYmIGIua2luZCA9PT0gU3RhdGVLaW5kLlZhbHVlICYmIHVzZXJFcXVhbGl0eShhLnZhbHVlLCBiLnZhbHVlKTtcbn1cblxuY29uc3QgZW51bSBTdGF0ZUtpbmQge1xuICBOb1ZhbHVlLFxuICBWYWx1ZSxcbiAgRXJyb3IsXG59XG5cbmludGVyZmFjZSBOb1ZhbHVlU3RhdGUge1xuICBraW5kOiBTdGF0ZUtpbmQuTm9WYWx1ZTtcbn1cblxuaW50ZXJmYWNlIFZhbHVlU3RhdGU8VD4ge1xuICBraW5kOiBTdGF0ZUtpbmQuVmFsdWU7XG4gIHZhbHVlOiBUO1xufVxuXG5pbnRlcmZhY2UgRXJyb3JTdGF0ZSB7XG4gIGtpbmQ6IFN0YXRlS2luZC5FcnJvcjtcbiAgZXJyb3I6IHVua25vd247XG59XG5cbnR5cGUgU3RhdGU8VD4gPSBOb1ZhbHVlU3RhdGUgfCBWYWx1ZVN0YXRlPFQ+IHwgRXJyb3JTdGF0ZTtcbiJdfQ==
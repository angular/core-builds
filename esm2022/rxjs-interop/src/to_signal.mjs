/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { assertInInjectionContext, assertNotInReactiveContext, computed, DestroyRef, inject, signal, ɵRuntimeError } from '@angular/core';
/**
 * Get the current value of an `Observable` as a reactive `Signal`.
 *
 * `toSignal` returns a `Signal` which provides synchronous reactive access to values produced
 * by the given `Observable`, by subscribing to that `Observable`. The returned `Signal` will always
 * have the most recent value emitted by the subscription, and will throw an error if the
 * `Observable` errors.
 *
 * With `requireSync` set to `true`, `toSignal` will assert that the `Observable` produces a value
 * immediately upon subscription. No `initialValue` is needed in this case, and the returned signal
 * does not include an `undefined` type.
 *
 * By default, the subscription will be automatically cleaned up when the current [injection
 * context](guide/di/dependency-injection-context) is destroyed. For example, when `toSignal` is
 * called during the construction of a component, the subscription will be cleaned up when the
 * component is destroyed. If an injection context is not available, an explicit `Injector` can be
 * passed instead.
 *
 * If the subscription should persist until the `Observable` itself completes, the `manualCleanup`
 * option can be specified instead, which disables the automatic subscription teardown. No injection
 * context is needed in this configuration as well.
 *
 * @developerPreview
 */
export function toSignal(source, options) {
    ngDevMode &&
        assertNotInReactiveContext(toSignal, 'Invoking `toSignal` causes new subscriptions every time. ' +
            'Consider moving `toSignal` outside of the reactive context and read the signal value where needed.');
    const requiresCleanup = !options?.manualCleanup;
    requiresCleanup && !options?.injector && assertInInjectionContext(toSignal);
    const cleanupRef = requiresCleanup ? options?.injector?.get(DestroyRef) ?? inject(DestroyRef) : null;
    // Note: T is the Observable value type, and U is the initial value type. They don't have to be
    // the same - the returned signal gives values of type `T`.
    let state;
    if (options?.requireSync) {
        // Initially the signal is in a `NoValue` state.
        state = signal({ kind: 0 /* StateKind.NoValue */ });
    }
    else {
        // If an initial value was passed, use it. Otherwise, use `undefined` as the initial value.
        state = signal({ kind: 1 /* StateKind.Value */, value: options?.initialValue });
    }
    // Note: This code cannot run inside a reactive context (see assertion above). If we'd support
    // this, we would subscribe to the observable outside of the current reactive context, avoiding
    // that side-effect signal reads/writes are attribute to the current consumer. The current
    // consumer only needs to be notified when the `state` signal changes through the observable
    // subscription. Additional context (related to async pipe):
    // https://github.com/angular/angular/pull/50522.
    const sub = source.subscribe({
        next: value => state.set({ kind: 1 /* StateKind.Value */, value }),
        error: error => {
            if (options?.rejectErrors) {
                // Kick the error back to RxJS. It will be caught and rethrown in a macrotask, which causes
                // the error to end up as an uncaught exception.
                throw error;
            }
            state.set({ kind: 2 /* StateKind.Error */, error });
        },
        // Completion of the Observable is meaningless to the signal. Signals don't have a concept of
        // "complete".
    });
    if (ngDevMode && options?.requireSync && state().kind === 0 /* StateKind.NoValue */) {
        throw new ɵRuntimeError(601 /* ɵRuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT */, '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');
    }
    // Unsubscribe when the current context is destroyed, if requested.
    cleanupRef?.onDestroy(sub.unsubscribe.bind(sub));
    // The actual returned signal is a `computed` of the `State` signal, which maps the various states
    // to either values or errors.
    return computed(() => {
        const current = state();
        switch (current.kind) {
            case 1 /* StateKind.Value */:
                return current.value;
            case 2 /* StateKind.Error */:
                throw current.error;
            case 0 /* StateKind.NoValue */:
                // This shouldn't really happen because the error is thrown on creation.
                // TODO(alxhub): use a RuntimeError when we finalize the error semantics
                throw new ɵRuntimeError(601 /* ɵRuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT */, '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');
        }
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9fc2lnbmFsLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvY29yZS9yeGpzLWludGVyb3Avc3JjL3RvX3NpZ25hbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0dBTUc7QUFFSCxPQUFPLEVBQUMsd0JBQXdCLEVBQUUsMEJBQTBCLEVBQUUsUUFBUSxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQVksTUFBTSxFQUEwQixhQUFhLEVBQW9CLE1BQU0sZUFBZSxDQUFDO0FBeUU3TDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0F1Qkc7QUFDSCxNQUFNLFVBQVUsUUFBUSxDQUNwQixNQUFxQyxFQUNyQyxPQUE0QztJQUM5QyxTQUFTO1FBQ0wsMEJBQTBCLENBQ3RCLFFBQVEsRUFDUiwyREFBMkQ7WUFDdkQsb0dBQW9HLENBQUMsQ0FBQztJQUVsSCxNQUFNLGVBQWUsR0FBRyxDQUFDLE9BQU8sRUFBRSxhQUFhLENBQUM7SUFDaEQsZUFBZSxJQUFJLENBQUMsT0FBTyxFQUFFLFFBQVEsSUFBSSx3QkFBd0IsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUM1RSxNQUFNLFVBQVUsR0FDWixlQUFlLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxRQUFRLEVBQUUsR0FBRyxDQUFDLFVBQVUsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO0lBRXRGLCtGQUErRjtJQUMvRiwyREFBMkQ7SUFDM0QsSUFBSSxLQUFpQyxDQUFDO0lBQ3RDLElBQUksT0FBTyxFQUFFLFdBQVcsRUFBRSxDQUFDO1FBQ3pCLGdEQUFnRDtRQUNoRCxLQUFLLEdBQUcsTUFBTSxDQUFDLEVBQUMsSUFBSSwyQkFBbUIsRUFBQyxDQUFDLENBQUM7SUFDNUMsQ0FBQztTQUFNLENBQUM7UUFDTiwyRkFBMkY7UUFDM0YsS0FBSyxHQUFHLE1BQU0sQ0FBYSxFQUFDLElBQUkseUJBQWlCLEVBQUUsS0FBSyxFQUFFLE9BQU8sRUFBRSxZQUFpQixFQUFDLENBQUMsQ0FBQztJQUN6RixDQUFDO0lBRUQsOEZBQThGO0lBQzlGLCtGQUErRjtJQUMvRiwwRkFBMEY7SUFDMUYsNEZBQTRGO0lBQzVGLDREQUE0RDtJQUM1RCxpREFBaUQ7SUFDakQsTUFBTSxHQUFHLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FBQztRQUMzQixJQUFJLEVBQUUsS0FBSyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEVBQUMsSUFBSSx5QkFBaUIsRUFBRSxLQUFLLEVBQUMsQ0FBQztRQUN4RCxLQUFLLEVBQUUsS0FBSyxDQUFDLEVBQUU7WUFDYixJQUFJLE9BQU8sRUFBRSxZQUFZLEVBQUUsQ0FBQztnQkFDMUIsMkZBQTJGO2dCQUMzRixnREFBZ0Q7Z0JBQ2hELE1BQU0sS0FBSyxDQUFDO1lBQ2QsQ0FBQztZQUNELEtBQUssQ0FBQyxHQUFHLENBQUMsRUFBQyxJQUFJLHlCQUFpQixFQUFFLEtBQUssRUFBQyxDQUFDLENBQUM7UUFDNUMsQ0FBQztRQUNELDZGQUE2RjtRQUM3RixjQUFjO0tBQ2YsQ0FBQyxDQUFDO0lBRUgsSUFBSSxTQUFTLElBQUksT0FBTyxFQUFFLFdBQVcsSUFBSSxLQUFLLEVBQUUsQ0FBQyxJQUFJLDhCQUFzQixFQUFFLENBQUM7UUFDNUUsTUFBTSxJQUFJLGFBQWEsNkRBRW5CLHFGQUFxRixDQUFDLENBQUM7SUFDN0YsQ0FBQztJQUVELG1FQUFtRTtJQUNuRSxVQUFVLEVBQUUsU0FBUyxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFFakQsa0dBQWtHO0lBQ2xHLDhCQUE4QjtJQUM5QixPQUFPLFFBQVEsQ0FBQyxHQUFHLEVBQUU7UUFDbkIsTUFBTSxPQUFPLEdBQUcsS0FBSyxFQUFFLENBQUM7UUFDeEIsUUFBUSxPQUFPLENBQUMsSUFBSSxFQUFFLENBQUM7WUFDckI7Z0JBQ0UsT0FBTyxPQUFPLENBQUMsS0FBSyxDQUFDO1lBQ3ZCO2dCQUNFLE1BQU0sT0FBTyxDQUFDLEtBQUssQ0FBQztZQUN0QjtnQkFDRSx3RUFBd0U7Z0JBQ3hFLHdFQUF3RTtnQkFDeEUsTUFBTSxJQUFJLGFBQWEsNkRBRW5CLHFGQUFxRixDQUFDLENBQUM7UUFDL0YsQ0FBQztJQUNILENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG5pbXBvcnQge2Fzc2VydEluSW5qZWN0aW9uQ29udGV4dCwgYXNzZXJ0Tm90SW5SZWFjdGl2ZUNvbnRleHQsIGNvbXB1dGVkLCBEZXN0cm95UmVmLCBpbmplY3QsIEluamVjdG9yLCBzaWduYWwsIFNpZ25hbCwgV3JpdGFibGVTaWduYWwsIMm1UnVudGltZUVycm9yLCDJtVJ1bnRpbWVFcnJvckNvZGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtPYnNlcnZhYmxlLCBTdWJzY3JpYmFibGV9IGZyb20gJ3J4anMnO1xuXG4vKipcbiAqIE9wdGlvbnMgZm9yIGB0b1NpZ25hbGAuXG4gKlxuICogQHB1YmxpY0FwaVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRvU2lnbmFsT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBJbml0aWFsIHZhbHVlIGZvciB0aGUgc2lnbmFsIHByb2R1Y2VkIGJ5IGB0b1NpZ25hbGAuXG4gICAqXG4gICAqIFRoaXMgd2lsbCBiZSB0aGUgdmFsdWUgb2YgdGhlIHNpZ25hbCB1bnRpbCB0aGUgb2JzZXJ2YWJsZSBlbWl0cyBpdHMgZmlyc3QgdmFsdWUuXG4gICAqL1xuICBpbml0aWFsVmFsdWU/OiB1bmtub3duO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHJlcXVpcmUgdGhhdCB0aGUgb2JzZXJ2YWJsZSBlbWl0cyBzeW5jaHJvbm91c2x5IHdoZW4gYHRvU2lnbmFsYCBzdWJzY3JpYmVzLlxuICAgKlxuICAgKiBJZiB0aGlzIGlzIGB0cnVlYCwgYHRvU2lnbmFsYCB3aWxsIGFzc2VydCB0aGF0IHRoZSBvYnNlcnZhYmxlIHByb2R1Y2VzIGEgdmFsdWUgaW1tZWRpYXRlbHkgdXBvblxuICAgKiBzdWJzY3JpcHRpb24uIFNldHRpbmcgdGhpcyBvcHRpb24gcmVtb3ZlcyB0aGUgbmVlZCB0byBlaXRoZXIgZGVhbCB3aXRoIGB1bmRlZmluZWRgIGluIHRoZVxuICAgKiBzaWduYWwgdHlwZSBvciBwcm92aWRlIGFuIGBpbml0aWFsVmFsdWVgLCBhdCB0aGUgY29zdCBvZiBhIHJ1bnRpbWUgZXJyb3IgaWYgdGhpcyByZXF1aXJlbWVudCBpc1xuICAgKiBub3QgbWV0LlxuICAgKi9cbiAgcmVxdWlyZVN5bmM/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBgSW5qZWN0b3JgIHdoaWNoIHdpbGwgcHJvdmlkZSB0aGUgYERlc3Ryb3lSZWZgIHVzZWQgdG8gY2xlYW4gdXAgdGhlIE9ic2VydmFibGUgc3Vic2NyaXB0aW9uLlxuICAgKlxuICAgKiBJZiB0aGlzIGlzIG5vdCBwcm92aWRlZCwgYSBgRGVzdHJveVJlZmAgd2lsbCBiZSByZXRyaWV2ZWQgZnJvbSB0aGUgY3VycmVudCBbaW5qZWN0aW9uXG4gICAqIGNvbnRleHRdKGd1aWRlL2RpL2RlcGVuZGVuY3ktaW5qZWN0aW9uLWNvbnRleHQpLCB1bmxlc3MgbWFudWFsIGNsZWFudXAgaXMgcmVxdWVzdGVkLlxuICAgKi9cbiAgaW5qZWN0b3I/OiBJbmplY3RvcjtcblxuICAvKipcbiAgICogV2hldGhlciB0aGUgc3Vic2NyaXB0aW9uIHNob3VsZCBiZSBhdXRvbWF0aWNhbGx5IGNsZWFuZWQgdXAgKHZpYSBgRGVzdHJveVJlZmApIHdoZW5cbiAgICogYHRvU2lnbmFsYCdzIGNyZWF0aW9uIGNvbnRleHQgaXMgZGVzdHJveWVkLlxuICAgKlxuICAgKiBJZiBtYW51YWwgY2xlYW51cCBpcyBlbmFibGVkLCB0aGVuIGBEZXN0cm95UmVmYCBpcyBub3QgdXNlZCwgYW5kIHRoZSBzdWJzY3JpcHRpb24gd2lsbCBwZXJzaXN0XG4gICAqIHVudGlsIHRoZSBgT2JzZXJ2YWJsZWAgaXRzZWxmIGNvbXBsZXRlcy5cbiAgICovXG4gIG1hbnVhbENsZWFudXA/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIGB0b1NpZ25hbGAgc2hvdWxkIHRocm93IGVycm9ycyBmcm9tIHRoZSBPYnNlcnZhYmxlIGVycm9yIGNoYW5uZWwgYmFjayB0byBSeEpTLCB3aGVyZVxuICAgKiB0aGV5J2xsIGJlIHByb2Nlc3NlZCBhcyB1bmNhdWdodCBleGNlcHRpb25zLlxuICAgKlxuICAgKiBJbiBwcmFjdGljZSwgdGhpcyBtZWFucyB0aGF0IHRoZSBzaWduYWwgcmV0dXJuZWQgYnkgYHRvU2lnbmFsYCB3aWxsIGtlZXAgcmV0dXJuaW5nIHRoZSBsYXN0XG4gICAqIGdvb2QgdmFsdWUgZm9yZXZlciwgYXMgT2JzZXJ2YWJsZXMgd2hpY2ggZXJyb3IgcHJvZHVjZSBubyBmdXJ0aGVyIHZhbHVlcy4gVGhpcyBvcHRpb24gZW11bGF0ZXNcbiAgICogdGhlIGJlaGF2aW9yIG9mIHRoZSBgYXN5bmNgIHBpcGUuXG4gICAqL1xuICByZWplY3RFcnJvcnM/OiBib29sZWFuO1xufVxuXG4vLyBCYXNlIGNhc2U6IG5vIG9wdGlvbnMgLT4gYHVuZGVmaW5lZGAgaW4gdGhlIHJlc3VsdCB0eXBlLlxuZXhwb3J0IGZ1bmN0aW9uIHRvU2lnbmFsPFQ+KHNvdXJjZTogT2JzZXJ2YWJsZTxUPnxTdWJzY3JpYmFibGU8VD4pOiBTaWduYWw8VHx1bmRlZmluZWQ+O1xuLy8gT3B0aW9ucyB3aXRoIGB1bmRlZmluZWRgIGluaXRpYWwgdmFsdWUgYW5kIG5vIGByZXF1aXJlZFN5bmNgIC0+IGB1bmRlZmluZWRgLlxuZXhwb3J0IGZ1bmN0aW9uIHRvU2lnbmFsPFQ+KFxuICAgIHNvdXJjZTogT2JzZXJ2YWJsZTxUPnxTdWJzY3JpYmFibGU8VD4sXG4gICAgb3B0aW9uczogVG9TaWduYWxPcHRpb25zJntpbml0aWFsVmFsdWU/OiB1bmRlZmluZWQsIHJlcXVpcmVTeW5jPzogZmFsc2V9KTogU2lnbmFsPFR8dW5kZWZpbmVkPjtcbi8vIE9wdGlvbnMgd2l0aCBgbnVsbGAgaW5pdGlhbCB2YWx1ZSAtPiBgbnVsbGAuXG5leHBvcnQgZnVuY3Rpb24gdG9TaWduYWw8VD4oXG4gICAgc291cmNlOiBPYnNlcnZhYmxlPFQ+fFN1YnNjcmliYWJsZTxUPixcbiAgICBvcHRpb25zOiBUb1NpZ25hbE9wdGlvbnMme2luaXRpYWxWYWx1ZT86IG51bGwsIHJlcXVpcmVTeW5jPzogZmFsc2V9KTogU2lnbmFsPFR8bnVsbD47XG4vLyBPcHRpb25zIHdpdGggYHVuZGVmaW5lZGAgaW5pdGlhbCB2YWx1ZSBhbmQgYHJlcXVpcmVkU3luY2AgLT4gc3RyaWN0IHJlc3VsdCB0eXBlLlxuZXhwb3J0IGZ1bmN0aW9uIHRvU2lnbmFsPFQ+KFxuICAgIHNvdXJjZTogT2JzZXJ2YWJsZTxUPnxTdWJzY3JpYmFibGU8VD4sXG4gICAgb3B0aW9uczogVG9TaWduYWxPcHRpb25zJntpbml0aWFsVmFsdWU/OiB1bmRlZmluZWQsIHJlcXVpcmVTeW5jOiB0cnVlfSk6IFNpZ25hbDxUPjtcbi8vIE9wdGlvbnMgd2l0aCBhIG1vcmUgc3BlY2lmaWMgaW5pdGlhbCB2YWx1ZSB0eXBlLlxuZXhwb3J0IGZ1bmN0aW9uIHRvU2lnbmFsPFQsIGNvbnN0IFUgZXh0ZW5kcyBUPihcbiAgICBzb3VyY2U6IE9ic2VydmFibGU8VD58U3Vic2NyaWJhYmxlPFQ+LFxuICAgIG9wdGlvbnM6IFRvU2lnbmFsT3B0aW9ucyZ7aW5pdGlhbFZhbHVlOiBVLCByZXF1aXJlU3luYz86IGZhbHNlfSk6IFNpZ25hbDxUfFU+O1xuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCB2YWx1ZSBvZiBhbiBgT2JzZXJ2YWJsZWAgYXMgYSByZWFjdGl2ZSBgU2lnbmFsYC5cbiAqXG4gKiBgdG9TaWduYWxgIHJldHVybnMgYSBgU2lnbmFsYCB3aGljaCBwcm92aWRlcyBzeW5jaHJvbm91cyByZWFjdGl2ZSBhY2Nlc3MgdG8gdmFsdWVzIHByb2R1Y2VkXG4gKiBieSB0aGUgZ2l2ZW4gYE9ic2VydmFibGVgLCBieSBzdWJzY3JpYmluZyB0byB0aGF0IGBPYnNlcnZhYmxlYC4gVGhlIHJldHVybmVkIGBTaWduYWxgIHdpbGwgYWx3YXlzXG4gKiBoYXZlIHRoZSBtb3N0IHJlY2VudCB2YWx1ZSBlbWl0dGVkIGJ5IHRoZSBzdWJzY3JpcHRpb24sIGFuZCB3aWxsIHRocm93IGFuIGVycm9yIGlmIHRoZVxuICogYE9ic2VydmFibGVgIGVycm9ycy5cbiAqXG4gKiBXaXRoIGByZXF1aXJlU3luY2Agc2V0IHRvIGB0cnVlYCwgYHRvU2lnbmFsYCB3aWxsIGFzc2VydCB0aGF0IHRoZSBgT2JzZXJ2YWJsZWAgcHJvZHVjZXMgYSB2YWx1ZVxuICogaW1tZWRpYXRlbHkgdXBvbiBzdWJzY3JpcHRpb24uIE5vIGBpbml0aWFsVmFsdWVgIGlzIG5lZWRlZCBpbiB0aGlzIGNhc2UsIGFuZCB0aGUgcmV0dXJuZWQgc2lnbmFsXG4gKiBkb2VzIG5vdCBpbmNsdWRlIGFuIGB1bmRlZmluZWRgIHR5cGUuXG4gKlxuICogQnkgZGVmYXVsdCwgdGhlIHN1YnNjcmlwdGlvbiB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgY2xlYW5lZCB1cCB3aGVuIHRoZSBjdXJyZW50IFtpbmplY3Rpb25cbiAqIGNvbnRleHRdKGd1aWRlL2RpL2RlcGVuZGVuY3ktaW5qZWN0aW9uLWNvbnRleHQpIGlzIGRlc3Ryb3llZC4gRm9yIGV4YW1wbGUsIHdoZW4gYHRvU2lnbmFsYCBpc1xuICogY2FsbGVkIGR1cmluZyB0aGUgY29uc3RydWN0aW9uIG9mIGEgY29tcG9uZW50LCB0aGUgc3Vic2NyaXB0aW9uIHdpbGwgYmUgY2xlYW5lZCB1cCB3aGVuIHRoZVxuICogY29tcG9uZW50IGlzIGRlc3Ryb3llZC4gSWYgYW4gaW5qZWN0aW9uIGNvbnRleHQgaXMgbm90IGF2YWlsYWJsZSwgYW4gZXhwbGljaXQgYEluamVjdG9yYCBjYW4gYmVcbiAqIHBhc3NlZCBpbnN0ZWFkLlxuICpcbiAqIElmIHRoZSBzdWJzY3JpcHRpb24gc2hvdWxkIHBlcnNpc3QgdW50aWwgdGhlIGBPYnNlcnZhYmxlYCBpdHNlbGYgY29tcGxldGVzLCB0aGUgYG1hbnVhbENsZWFudXBgXG4gKiBvcHRpb24gY2FuIGJlIHNwZWNpZmllZCBpbnN0ZWFkLCB3aGljaCBkaXNhYmxlcyB0aGUgYXV0b21hdGljIHN1YnNjcmlwdGlvbiB0ZWFyZG93bi4gTm8gaW5qZWN0aW9uXG4gKiBjb250ZXh0IGlzIG5lZWRlZCBpbiB0aGlzIGNvbmZpZ3VyYXRpb24gYXMgd2VsbC5cbiAqXG4gKiBAZGV2ZWxvcGVyUHJldmlld1xuICovXG5leHBvcnQgZnVuY3Rpb24gdG9TaWduYWw8VCwgVSA9IHVuZGVmaW5lZD4oXG4gICAgc291cmNlOiBPYnNlcnZhYmxlPFQ+fFN1YnNjcmliYWJsZTxUPixcbiAgICBvcHRpb25zPzogVG9TaWduYWxPcHRpb25zJntpbml0aWFsVmFsdWU/OiBVfSk6IFNpZ25hbDxUfFU+IHtcbiAgbmdEZXZNb2RlICYmXG4gICAgICBhc3NlcnROb3RJblJlYWN0aXZlQ29udGV4dChcbiAgICAgICAgICB0b1NpZ25hbCxcbiAgICAgICAgICAnSW52b2tpbmcgYHRvU2lnbmFsYCBjYXVzZXMgbmV3IHN1YnNjcmlwdGlvbnMgZXZlcnkgdGltZS4gJyArXG4gICAgICAgICAgICAgICdDb25zaWRlciBtb3ZpbmcgYHRvU2lnbmFsYCBvdXRzaWRlIG9mIHRoZSByZWFjdGl2ZSBjb250ZXh0IGFuZCByZWFkIHRoZSBzaWduYWwgdmFsdWUgd2hlcmUgbmVlZGVkLicpO1xuXG4gIGNvbnN0IHJlcXVpcmVzQ2xlYW51cCA9ICFvcHRpb25zPy5tYW51YWxDbGVhbnVwO1xuICByZXF1aXJlc0NsZWFudXAgJiYgIW9wdGlvbnM/LmluamVjdG9yICYmIGFzc2VydEluSW5qZWN0aW9uQ29udGV4dCh0b1NpZ25hbCk7XG4gIGNvbnN0IGNsZWFudXBSZWYgPVxuICAgICAgcmVxdWlyZXNDbGVhbnVwID8gb3B0aW9ucz8uaW5qZWN0b3I/LmdldChEZXN0cm95UmVmKSA/PyBpbmplY3QoRGVzdHJveVJlZikgOiBudWxsO1xuXG4gIC8vIE5vdGU6IFQgaXMgdGhlIE9ic2VydmFibGUgdmFsdWUgdHlwZSwgYW5kIFUgaXMgdGhlIGluaXRpYWwgdmFsdWUgdHlwZS4gVGhleSBkb24ndCBoYXZlIHRvIGJlXG4gIC8vIHRoZSBzYW1lIC0gdGhlIHJldHVybmVkIHNpZ25hbCBnaXZlcyB2YWx1ZXMgb2YgdHlwZSBgVGAuXG4gIGxldCBzdGF0ZTogV3JpdGFibGVTaWduYWw8U3RhdGU8VHxVPj47XG4gIGlmIChvcHRpb25zPy5yZXF1aXJlU3luYykge1xuICAgIC8vIEluaXRpYWxseSB0aGUgc2lnbmFsIGlzIGluIGEgYE5vVmFsdWVgIHN0YXRlLlxuICAgIHN0YXRlID0gc2lnbmFsKHtraW5kOiBTdGF0ZUtpbmQuTm9WYWx1ZX0pO1xuICB9IGVsc2Uge1xuICAgIC8vIElmIGFuIGluaXRpYWwgdmFsdWUgd2FzIHBhc3NlZCwgdXNlIGl0LiBPdGhlcndpc2UsIHVzZSBgdW5kZWZpbmVkYCBhcyB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAgICBzdGF0ZSA9IHNpZ25hbDxTdGF0ZTxUfFU+Pih7a2luZDogU3RhdGVLaW5kLlZhbHVlLCB2YWx1ZTogb3B0aW9ucz8uaW5pdGlhbFZhbHVlIGFzIFV9KTtcbiAgfVxuXG4gIC8vIE5vdGU6IFRoaXMgY29kZSBjYW5ub3QgcnVuIGluc2lkZSBhIHJlYWN0aXZlIGNvbnRleHQgKHNlZSBhc3NlcnRpb24gYWJvdmUpLiBJZiB3ZSdkIHN1cHBvcnRcbiAgLy8gdGhpcywgd2Ugd291bGQgc3Vic2NyaWJlIHRvIHRoZSBvYnNlcnZhYmxlIG91dHNpZGUgb2YgdGhlIGN1cnJlbnQgcmVhY3RpdmUgY29udGV4dCwgYXZvaWRpbmdcbiAgLy8gdGhhdCBzaWRlLWVmZmVjdCBzaWduYWwgcmVhZHMvd3JpdGVzIGFyZSBhdHRyaWJ1dGUgdG8gdGhlIGN1cnJlbnQgY29uc3VtZXIuIFRoZSBjdXJyZW50XG4gIC8vIGNvbnN1bWVyIG9ubHkgbmVlZHMgdG8gYmUgbm90aWZpZWQgd2hlbiB0aGUgYHN0YXRlYCBzaWduYWwgY2hhbmdlcyB0aHJvdWdoIHRoZSBvYnNlcnZhYmxlXG4gIC8vIHN1YnNjcmlwdGlvbi4gQWRkaXRpb25hbCBjb250ZXh0IChyZWxhdGVkIHRvIGFzeW5jIHBpcGUpOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL3B1bGwvNTA1MjIuXG4gIGNvbnN0IHN1YiA9IHNvdXJjZS5zdWJzY3JpYmUoe1xuICAgIG5leHQ6IHZhbHVlID0+IHN0YXRlLnNldCh7a2luZDogU3RhdGVLaW5kLlZhbHVlLCB2YWx1ZX0pLFxuICAgIGVycm9yOiBlcnJvciA9PiB7XG4gICAgICBpZiAob3B0aW9ucz8ucmVqZWN0RXJyb3JzKSB7XG4gICAgICAgIC8vIEtpY2sgdGhlIGVycm9yIGJhY2sgdG8gUnhKUy4gSXQgd2lsbCBiZSBjYXVnaHQgYW5kIHJldGhyb3duIGluIGEgbWFjcm90YXNrLCB3aGljaCBjYXVzZXNcbiAgICAgICAgLy8gdGhlIGVycm9yIHRvIGVuZCB1cCBhcyBhbiB1bmNhdWdodCBleGNlcHRpb24uXG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgc3RhdGUuc2V0KHtraW5kOiBTdGF0ZUtpbmQuRXJyb3IsIGVycm9yfSk7XG4gICAgfSxcbiAgICAvLyBDb21wbGV0aW9uIG9mIHRoZSBPYnNlcnZhYmxlIGlzIG1lYW5pbmdsZXNzIHRvIHRoZSBzaWduYWwuIFNpZ25hbHMgZG9uJ3QgaGF2ZSBhIGNvbmNlcHQgb2ZcbiAgICAvLyBcImNvbXBsZXRlXCIuXG4gIH0pO1xuXG4gIGlmIChuZ0Rldk1vZGUgJiYgb3B0aW9ucz8ucmVxdWlyZVN5bmMgJiYgc3RhdGUoKS5raW5kID09PSBTdGF0ZUtpbmQuTm9WYWx1ZSkge1xuICAgIHRocm93IG5ldyDJtVJ1bnRpbWVFcnJvcihcbiAgICAgICAgybVSdW50aW1lRXJyb3JDb2RlLlJFUVVJUkVfU1lOQ19XSVRIT1VUX1NZTkNfRU1JVCxcbiAgICAgICAgJ2B0b1NpZ25hbCgpYCBjYWxsZWQgd2l0aCBgcmVxdWlyZVN5bmNgIGJ1dCBgT2JzZXJ2YWJsZWAgZGlkIG5vdCBlbWl0IHN5bmNocm9ub3VzbHkuJyk7XG4gIH1cblxuICAvLyBVbnN1YnNjcmliZSB3aGVuIHRoZSBjdXJyZW50IGNvbnRleHQgaXMgZGVzdHJveWVkLCBpZiByZXF1ZXN0ZWQuXG4gIGNsZWFudXBSZWY/Lm9uRGVzdHJveShzdWIudW5zdWJzY3JpYmUuYmluZChzdWIpKTtcblxuICAvLyBUaGUgYWN0dWFsIHJldHVybmVkIHNpZ25hbCBpcyBhIGBjb21wdXRlZGAgb2YgdGhlIGBTdGF0ZWAgc2lnbmFsLCB3aGljaCBtYXBzIHRoZSB2YXJpb3VzIHN0YXRlc1xuICAvLyB0byBlaXRoZXIgdmFsdWVzIG9yIGVycm9ycy5cbiAgcmV0dXJuIGNvbXB1dGVkKCgpID0+IHtcbiAgICBjb25zdCBjdXJyZW50ID0gc3RhdGUoKTtcbiAgICBzd2l0Y2ggKGN1cnJlbnQua2luZCkge1xuICAgICAgY2FzZSBTdGF0ZUtpbmQuVmFsdWU6XG4gICAgICAgIHJldHVybiBjdXJyZW50LnZhbHVlO1xuICAgICAgY2FzZSBTdGF0ZUtpbmQuRXJyb3I6XG4gICAgICAgIHRocm93IGN1cnJlbnQuZXJyb3I7XG4gICAgICBjYXNlIFN0YXRlS2luZC5Ob1ZhbHVlOlxuICAgICAgICAvLyBUaGlzIHNob3VsZG4ndCByZWFsbHkgaGFwcGVuIGJlY2F1c2UgdGhlIGVycm9yIGlzIHRocm93biBvbiBjcmVhdGlvbi5cbiAgICAgICAgLy8gVE9ETyhhbHhodWIpOiB1c2UgYSBSdW50aW1lRXJyb3Igd2hlbiB3ZSBmaW5hbGl6ZSB0aGUgZXJyb3Igc2VtYW50aWNzXG4gICAgICAgIHRocm93IG5ldyDJtVJ1bnRpbWVFcnJvcihcbiAgICAgICAgICAgIMm1UnVudGltZUVycm9yQ29kZS5SRVFVSVJFX1NZTkNfV0lUSE9VVF9TWU5DX0VNSVQsXG4gICAgICAgICAgICAnYHRvU2lnbmFsKClgIGNhbGxlZCB3aXRoIGByZXF1aXJlU3luY2AgYnV0IGBPYnNlcnZhYmxlYCBkaWQgbm90IGVtaXQgc3luY2hyb25vdXNseS4nKTtcbiAgICB9XG4gIH0pO1xufVxuXG5jb25zdCBlbnVtIFN0YXRlS2luZCB7XG4gIE5vVmFsdWUsXG4gIFZhbHVlLFxuICBFcnJvcixcbn1cblxuaW50ZXJmYWNlIE5vVmFsdWVTdGF0ZSB7XG4gIGtpbmQ6IFN0YXRlS2luZC5Ob1ZhbHVlO1xufVxuXG5pbnRlcmZhY2UgVmFsdWVTdGF0ZTxUPiB7XG4gIGtpbmQ6IFN0YXRlS2luZC5WYWx1ZTtcbiAgdmFsdWU6IFQ7XG59XG5cbmludGVyZmFjZSBFcnJvclN0YXRlIHtcbiAga2luZDogU3RhdGVLaW5kLkVycm9yO1xuICBlcnJvcjogdW5rbm93bjtcbn1cblxudHlwZSBTdGF0ZTxUPiA9IE5vVmFsdWVTdGF0ZXxWYWx1ZVN0YXRlPFQ+fEVycm9yU3RhdGU7XG4iXX0=
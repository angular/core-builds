{"version":3,"file":"view.js","sourceRoot":"","sources":["../../../../../../packages/core/src/render3/interfaces/view.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqbA,MAAM,CAAC,uBAAM,6BAA6B,GAAG,CAAC,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injector} from '../../di/injector';\nimport {LContainer} from './container';\nimport {ComponentTemplate, DirectiveDef, DirectiveDefList, PipeDef, PipeDefList} from './definition';\nimport {LElementNode, LViewNode, TNode} from './node';\nimport {LQueries} from './query';\nimport {Renderer3} from './renderer';\n\n\n\n/**\n * `LView` stores all of the information needed to process the instructions as\n * they are invoked from the template. Each embedded view and component view has its\n * own `LView`. When processing a particular view, we set the `currentView` to that\n * `LView`. When that view is done processing, the `currentView` is set back to\n * whatever the original `currentView` was before (the parent `LView`).\n *\n * Keeping separate state for each view facilities view insertion / deletion, so we\n * don't have to edit the data array based on which views are present.\n */\nexport interface LView {\n  /** Flags for this view (see LViewFlags for definition of each bit). */\n  flags: LViewFlags;\n\n  /**\n   * The parent view is needed when we exit the view and must restore the previous\n   * `LView`. Without this, the render method would have to keep a stack of\n   * views as it is recursively rendering templates.\n   */\n  readonly parent: LView|null;\n\n  /**\n   * Pointer to the `LViewNode` or `LElementNode` which represents the root of the view.\n   *\n   * If `LViewNode`, this is an embedded view of a container. We need this to be able to\n   * efficiently find the `LViewNode` when inserting the view into an anchor.\n   *\n   * If `LElementNode`, this is the LView of a component.\n   */\n  readonly node: LViewNode|LElementNode;\n\n  /**\n   * ID to determine whether this view is the same as the previous view\n   * in this position. If it's not, we know this view needs to be inserted\n   * and the one that exists needs to be removed (e.g. if/else statements)\n   */\n  readonly id: number;\n\n  /** Renderer to be used for this view. */\n  readonly renderer: Renderer3;\n\n  /**\n   * The binding start index is the index at which the nodes array\n   * starts to store bindings only. Saving this value ensures that we\n   * will begin reading bindings at the correct point in the array when\n   * we are in update mode.\n   */\n  bindingStartIndex: number;\n\n  /**\n   * The binding index we should access next.\n   *\n   * This is stored so that bindings can continue where they left off\n   * if a view is left midway through processing bindings (e.g. if there is\n   * a setter that creates an embedded view, like in ngIf).\n   */\n  bindingIndex: number;\n\n  /**\n   * When a view is destroyed, listeners need to be released and outputs need to be\n   * unsubscribed. This cleanup array stores both listener data (in chunks of 4)\n   * and output data (in chunks of 2) for a particular view. Combining the arrays\n   * saves on memory (70 bytes per array) and on a few bytes of code size (for two\n   * separate for loops).\n   *\n   * If it's a listener being stored:\n   * 1st index is: event name to remove\n   * 2nd index is: native element\n   * 3rd index is: listener function\n   * 4th index is: useCapture boolean\n   *\n   * If it's an output subscription:\n   * 1st index is: unsubscribe function\n   * 2nd index is: context for function\n   */\n  cleanup: any[]|null;\n\n  /**\n   * This number tracks the next lifecycle hook that needs to be run.\n   *\n   * If lifecycleStage === LifecycleStage.ON_INIT, the init hooks haven't yet been run\n   * and should be executed by the first r() instruction that runs OR the first\n   * cR() instruction that runs (so inits are run for the top level view before any\n   * embedded views).\n   *\n   * If lifecycleStage === LifecycleStage.CONTENT_INIT, the init hooks have been run, but\n   * the content hooks have not yet been run. They should be executed on the first\n   * r() instruction that runs.\n   *\n   * If lifecycleStage === LifecycleStage.VIEW_INIT, both the init hooks and content hooks\n   * have already been run.\n   */\n  lifecycleStage: LifecycleStage;\n\n  /**\n   * The first LView or LContainer beneath this LView in the hierarchy.\n   *\n   * Necessary to store this so views can traverse through their nested views\n   * to remove listeners and call onDestroy callbacks.\n   *\n   * For embedded views, we store the LContainer rather than the first ViewState\n   * to avoid managing splicing when views are added/removed.\n   */\n  child: LView|LContainer|null;\n\n  /**\n   * The last LView or LContainer beneath this LView in the hierarchy.\n   *\n   * The tail allows us to quickly add a new state to the end of the view list\n   * without having to propagate starting from the first child.\n   */\n  tail: LView|LContainer|null;\n\n  /**\n   * The next sibling LView or LContainer.\n   *\n   * Allows us to propagate between sibling view states that aren't in the same\n   * container. Embedded views already have a node.next, but it is only set for\n   * views in the same container. We need a way to link component views and views\n   * across containers as well.\n   */\n  next: LView|LContainer|null;\n\n  /**\n   * This array stores all element/text/container nodes created inside this view\n   * and their bindings. Stored as an array rather than a linked list so we can\n   * look up nodes directly in the case of forward declaration or bindings\n   * (e.g. E(1)).\n   *\n   * All bindings for a given view are stored in the order in which they\n   * appear in the template, starting with `bindingStartIndex`.\n   * We use `bindingIndex` to internally keep track of which binding\n   * is currently active.\n   */\n  readonly data: any[];\n\n  /**\n   * An array of directive instances in the current view.\n   *\n   * These must be stored separately from LNodes because their presence is\n   * unknown at compile-time and thus space cannot be reserved in data[].\n   */\n  directives: any[]|null;\n\n  /**\n   * The static data for this view. We need a reference to this so we can easily walk up the\n   * node tree in DI and get the TView.data array associated with a node (where the\n   * directive defs are stored).\n   */\n  tView: TView;\n\n  /**\n   * For dynamically inserted views, the template function to refresh the view.\n   */\n  template: ComponentTemplate<{}>|null;\n\n  /**\n   * - For embedded views, the context with which to render the template.\n   * - For root view of the root component the context contains change detection data.\n   * - `null` otherwise.\n   */\n  context: {}|RootContext|null;\n\n  /**\n   * A count of dynamic views that are children of this view (indirectly via containers).\n   *\n   * This is used to decide whether to scan children of this view when refreshing dynamic views\n   * after refreshing the view itself.\n   */\n  dynamicViewCount: number;\n\n  /**\n   * Queries active for this view - nodes from a view are reported to those queries\n   */\n  queries: LQueries|null;\n\n  /**\n   * An optional Module Injector to be used as fall back after Element Injectors are consulted.\n   */\n  injector: Injector|null;\n}\n\n/** Flags associated with an LView (saved in LView.flags) */\nexport const enum LViewFlags {\n  /**\n   * Whether or not the view is in creationMode.\n   *\n   * This must be stored in the view rather than using `data` as a marker so that\n   * we can properly support embedded views. Otherwise, when exiting a child view\n   * back into the parent view, `data` will be defined and `creationMode` will be\n   * improperly reported as false.\n   */\n  CreationMode = 0b0001,\n\n  /** Whether this view has default change detection strategy (checks always) or onPush */\n  CheckAlways = 0b0010,\n\n  /** Whether or not this view is currently dirty (needing check) */\n  Dirty = 0b0100,\n\n  /** Whether or not this view is currently attached to change detection tree. */\n  Attached = 0b1000,\n}\n\n/** Interface necessary to work with view tree traversal */\nexport interface LViewOrLContainer {\n  next: LView|LContainer|null;\n  child?: LView|LContainer|null;\n  views?: LViewNode[];\n  parent: LView|null;\n}\n\n/**\n * The static data for an LView (shared between all templates of a\n * given type).\n *\n * Stored on the template function as ngPrivateData.\n */\nexport interface TView {\n  /** Whether or not this template has been processed. */\n  firstTemplatePass: boolean;\n\n  /** Static data equivalent of LView.data[]. Contains TNodes. */\n  data: TData;\n\n  /**\n   * Selector matches for a node are temporarily cached on the TView so the\n   * DI system can eagerly instantiate directives on the same node if they are\n   * created out of order. They are overwritten after each node.\n   *\n   * <div dirA dirB></div>\n   *\n   * e.g. DirA injects DirB, but DirA is created first. DI should instantiate\n   * DirB when it finds that it's on the same node, but not yet created.\n   *\n   * Even indices: Directive defs\n   * Odd indices:\n   *   - Null if the associated directive hasn't been instantiated yet\n   *   - Directive index, if associated directive has been created\n   *   - String, temporary 'CIRCULAR' token set while dependencies are being resolved\n   */\n  currentMatches: CurrentMatchesList|null;\n\n  /**\n   * Directive and component defs that have already been matched to nodes on\n   * this view.\n   *\n   * Defs are stored at the same index in TView.directives[] as their instances\n   * are stored in LView.directives[]. This simplifies lookup in DI.\n   */\n  directives: DirectiveDefList|null;\n\n  /**\n   * Full registry of directives and components that may be found in this view.\n   *\n   * It's necessary to keep a copy of the full def list on the TView so it's possible\n   * to render template functions without a host component.\n   */\n  directiveRegistry: DirectiveDefList|null;\n\n  /**\n   * Full registry of pipes that may be found in this view.\n   *\n   * The property is either an array of `PipeDefs`s or a function which returns the array of\n   * `PipeDefs`s. The function is necessary to be able to support forward declarations.\n   *\n   * It's necessary to keep a copy of the full def list on the TView so it's possible\n   * to render template functions without a host component.\n   */\n  pipeRegistry: PipeDefList|null;\n\n  /**\n   * Array of ngOnInit and ngDoCheck hooks that should be executed for this view in\n   * creation mode.\n   *\n   * Even indices: Directive index\n   * Odd indices: Hook function\n   */\n  initHooks: HookData|null;\n\n  /**\n   * Array of ngDoCheck hooks that should be executed for this view in update mode.\n   *\n   * Even indices: Directive index\n   * Odd indices: Hook function\n   */\n  checkHooks: HookData|null;\n\n  /**\n   * Array of ngAfterContentInit and ngAfterContentChecked hooks that should be executed\n   * for this view in creation mode.\n   *\n   * Even indices: Directive index\n   * Odd indices: Hook function\n   */\n  contentHooks: HookData|null;\n\n  /**\n   * Array of ngAfterContentChecked hooks that should be executed for this view in update\n   * mode.\n   *\n   * Even indices: Directive index\n   * Odd indices: Hook function\n   */\n  contentCheckHooks: HookData|null;\n\n  /**\n   * Array of ngAfterViewInit and ngAfterViewChecked hooks that should be executed for\n   * this view in creation mode.\n   *\n   * Even indices: Directive index\n   * Odd indices: Hook function\n   */\n  viewHooks: HookData|null;\n\n  /**\n   * Array of ngAfterViewChecked hooks that should be executed for this view in\n   * update mode.\n   *\n   * Even indices: Directive index\n   * Odd indices: Hook function\n   */\n  viewCheckHooks: HookData|null;\n\n  /**\n   * Array of ngOnDestroy hooks that should be executed when this view is destroyed.\n   *\n   * Even indices: Directive index\n   * Odd indices: Hook function\n   */\n  destroyHooks: HookData|null;\n\n  /**\n   * Array of pipe ngOnDestroy hooks that should be executed when this view is destroyed.\n   *\n   * Even indices: Index of pipe in data\n   * Odd indices: Hook function\n   *\n   * These must be stored separately from directive destroy hooks because their contexts\n   * are stored in data.\n   */\n  pipeDestroyHooks: HookData|null;\n\n  /**\n   * A list of directive and element indices for child components that will need to be\n   * refreshed when the current view has finished its check.\n   *\n   * Even indices: Directive indices\n   * Odd indices: Element indices\n   */\n  components: number[]|null;\n\n  /**\n   * A list of indices for child directives that have host bindings.\n   *\n   * Even indices: Directive indices\n   * Odd indices: Element indices\n   */\n  hostBindings: number[]|null;\n}\n\n/**\n * RootContext contains information which is shared for all components which\n * were bootstrapped with {@link renderComponent}.\n */\nexport interface RootContext {\n  /**\n   * A function used for scheduling change detection in the future. Usually\n   * this is `requestAnimationFrame`.\n   */\n  scheduler: (workFn: () => void) => void;\n\n  /**\n   * A promise which is resolved when all components are considered clean (not dirty).\n   *\n   * This promise is overwritten every time a first call to {@link markDirty} is invoked.\n   */\n  clean: Promise<null>;\n\n  /**\n   * RootComponent - The component which was instantiated by the call to\n   * {@link renderComponent}.\n   */\n  component: {};\n}\n\n/**\n * Array of hooks that should be executed for a view and their directive indices.\n *\n * Even indices: Directive index\n * Odd indices: Hook function\n */\nexport type HookData = (number | (() => void))[];\n\n/** Possible values of LView.lifecycleStage, used to determine which hooks to run.  */\n// TODO: Remove this enum when containerRefresh instructions are removed\nexport const enum LifecycleStage {\n\n  /* Init hooks need to be run, if any. */\n  Init = 1,\n\n  /* Content hooks need to be run, if any. Init hooks have already run. */\n  AfterInit = 2,\n}\n\n/**\n * Static data that corresponds to the instance-specific data array on an LView.\n *\n * Each node's static data is stored in tData at the same index that it's stored\n * in the data array. Each pipe's definition is stored here at the same index\n * as its pipe instance in the data array. Any nodes that do not have static\n * data store a null value in tData to avoid a sparse array.\n */\nexport type TData = (TNode | PipeDef<any>| null)[];\n\n/** Type for TView.currentMatches */\nexport type CurrentMatchesList = [DirectiveDef<any>, (string | number | null)];\n\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nexport const unusedValueExportToPlacateAjd = 1;\n"]}
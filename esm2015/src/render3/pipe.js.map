{"version":3,"file":"pipe.js","sourceRoot":"","sources":["../../../../../packages/core/src/render3/pipe.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {PipeTransform} from '../change_detection/pipe_transform';\n\nimport {getTView, load, store} from './instructions';\nimport {PipeDef} from './interfaces/definition';\nimport {pureFunction1, pureFunction2, pureFunction3, pureFunction4, pureFunctionV} from './pure_function';\n\n\n/**\n * Create a pipe.\n *\n * @param index Pipe index where the pipe will be stored.\n * @param pipeDef Pipe definition object for registering life cycle hooks.\n * @param firstInstance (optional) The first instance of the pipe that can be reused for pure pipes.\n * @returns T the instance of the pipe.\n */\nexport function pipe<T>(index: number, pipeDef: PipeDef<T>, firstInstance?: T): T {\n  const tView = getTView();\n  if (tView.firstTemplatePass) {\n    tView.data[index] = pipeDef;\n    if (pipeDef.onDestroy) {\n      (tView.pipeDestroyHooks || (tView.pipeDestroyHooks = [])).push(index, pipeDef.onDestroy);\n    }\n  }\n  const pipeInstance = pipeDef.pure && firstInstance ? firstInstance : pipeDef.n();\n  store(index, pipeInstance);\n  return pipeInstance;\n}\n\n/**\n * Invokes a pipe with 1 arguments.\n *\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\n * the pipe only when an input to the pipe changes.\n *\n * @param index Pipe index where the pipe was stored on creation.\n * @param v1 1st argument to {@link PipeTransform#transform}.\n */\nexport function pipeBind1(index: number, v1: any): any {\n  const pipeInstance = load<PipeTransform>(index);\n  return isPure(index) ? pureFunction1(pipeInstance.transform, v1, pipeInstance) :\n                         pipeInstance.transform(v1);\n}\n\n/**\n * Invokes a pipe with 2 arguments.\n *\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\n * the pipe only when an input to the pipe changes.\n *\n * @param index Pipe index where the pipe was stored on creation.\n * @param v1 1st argument to {@link PipeTransform#transform}.\n * @param v2 2nd argument to {@link PipeTransform#transform}.\n */\nexport function pipeBind2(index: number, v1: any, v2: any): any {\n  const pipeInstance = load<PipeTransform>(index);\n  return isPure(index) ? pureFunction2(pipeInstance.transform, v1, v2, pipeInstance) :\n                         pipeInstance.transform(v1, v2);\n}\n\n/**\n * Invokes a pipe with 3 arguments.\n *\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\n * the pipe only when an input to the pipe changes.\n *\n * @param index Pipe index where the pipe was stored on creation.\n * @param v1 1st argument to {@link PipeTransform#transform}.\n * @param v2 2nd argument to {@link PipeTransform#transform}.\n * @param v3 4rd argument to {@link PipeTransform#transform}.\n */\nexport function pipeBind3(index: number, v1: any, v2: any, v3: any): any {\n  const pipeInstance = load<PipeTransform>(index);\n  return isPure(index) ? pureFunction3(pipeInstance.transform.bind(pipeInstance), v1, v2, v3) :\n                         pipeInstance.transform(v1, v2, v3);\n}\n\n/**\n * Invokes a pipe with 4 arguments.\n *\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\n * the pipe only when an input to the pipe changes.\n *\n * @param index Pipe index where the pipe was stored on creation.\n * @param v1 1st argument to {@link PipeTransform#transform}.\n * @param v2 2nd argument to {@link PipeTransform#transform}.\n * @param v3 3rd argument to {@link PipeTransform#transform}.\n * @param v4 4th argument to {@link PipeTransform#transform}.\n */\nexport function pipeBind4(index: number, v1: any, v2: any, v3: any, v4: any): any {\n  const pipeInstance = load<PipeTransform>(index);\n  return isPure(index) ? pureFunction4(pipeInstance.transform, v1, v2, v3, v4, pipeInstance) :\n                         pipeInstance.transform(v1, v2, v3, v4);\n}\n\n/**\n * Invokes a pipe with variable number of arguments.\n *\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\n * the pipe only when an input to the pipe changes.\n *\n * @param index Pipe index where the pipe was stored on creation.\n * @param values Array of arguments to pass to {@link PipeTransform#transform} method.\n */\nexport function pipeBindV(index: number, values: any[]): any {\n  const pipeInstance = load<PipeTransform>(index);\n  return isPure(index) ? pureFunctionV(pipeInstance.transform, values, pipeInstance) :\n                         pipeInstance.transform.apply(pipeInstance, values);\n}\n\nfunction isPure(index: number): boolean {\n  return (<PipeDef<any>>getTView().data[index]).pure;\n}\n"]}
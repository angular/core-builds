{"version":3,"file":"view_ref.js","sourceRoot":"","sources":["../../../../../packages/core/src/render3/view_ref.ts"],"names":[],"mappings":";;;;;;;;;;;AAUA,OAAO,EAAC,cAAc,EAAE,aAAa,EAAE,aAAa,EAAC,MAAM,gBAAgB,CAAC;AAI5E,OAAO,EAAC,cAAc,EAAC,MAAM,QAAQ,CAAC;;;;AAEtC,MAAM;;;;;IAIJ,YAAoB,KAAY,EAAE,OAAe;QAA7B,UAAK,GAAL,KAAK,CAAO;QAAuB,IAAI,CAAC,OAAO,sBAAG,OAAO,EAAE,CAAC;KAAE;;;;;;;IAGlF,oBAAoB,CAAC,IAAW,EAAE,OAAU;QAC1C,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;QAClB,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;KACxB;;;;IAED,OAAO,KAAW,cAAc,EAAE,CAAC,EAAE;;;;;IAErC,SAAS,CAAC,QAAkB,IAAI,cAAc,EAAE,CAAC,EAAE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAmCnD,YAAY,KAAW,aAAa,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAsDnD,MAAM,KAAW,IAAI,CAAC,KAAK,CAAC,KAAK,IAAI,iBAAoB,CAAC,EAAE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAyD5D,QAAQ,KAAW,IAAI,CAAC,KAAK,CAAC,KAAK,oBAAuB,CAAC,EAAE;;;;;;;;;;;;;;;;;;;;;;IAsB7D,aAAa,KAAW,aAAa,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,EAAE;;;;;;;;IAQtD,cAAc,KAAW,cAAc,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,EAAE;CACzD;;;;;;;;;;;;;;AAGD,MAAM,sBAA0B,SAAQ,OAAU;;;;;;IAMhD,YAAY,QAAmB,EAAE,QAA8B,EAAE,OAAU;QACzE,KAAK,CAAC,QAAQ,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;QAC9B,IAAI,CAAC,UAAU,GAAG,QAAQ,CAAC;KAC5B;CACF;;;;;;;;;;;;;;;;AAQD,MAAM,wBAA2B,IAAkB,EAAE,OAAU;;IAE7D,MAAM,CAAC,cAAc,CAAC,IAAI,OAAO,oBAAC,IAAI,IAAI,OAAO,CAAC,CAAC,CAAC;CACrD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmBD,MAAM,yBAA+B,GAAQ;IAC3C,qBAAI,SAAS,GAAoB,IAAI,CAAC;IACtC,GAAG,CAAC,SAAS,GAAG,KAAK,CAAC;IACtB,GAAG,CAAC,OAAO,GAAG;QACZ,SAAS,IAAI,SAAS,CAAC,OAAO,CAAC,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC;QAC7C,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;KACvB,CAAC;IACF,GAAG,CAAC,SAAS,GAAG,CAAC,EAAY,EAAE,EAAE,CAAC,CAAC,SAAS,IAAI,CAAC,SAAS,GAAG,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;IAC3E,MAAM,CAAC,GAAG,CAAC;CACZ","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {EmbeddedViewRef as viewEngine_EmbeddedViewRef} from '../linker/view_ref';\n\nimport {checkNoChanges, detectChanges, markViewDirty} from './instructions';\nimport {ComponentTemplate} from './interfaces/definition';\nimport {LViewNode} from './interfaces/node';\nimport {LView, LViewFlags} from './interfaces/view';\nimport {notImplemented} from './util';\n\nexport class ViewRef<T> implements viewEngine_EmbeddedViewRef<T> {\n  context: T;\n  rootNodes: any[];\n\n  constructor(private _view: LView, context: T|null, ) { this.context = context !; }\n\n  /** @internal */\n  _setComponentContext(view: LView, context: T) {\n    this._view = view;\n    this.context = context;\n  }\n\n  destroy(): void { notImplemented(); }\n  destroyed: boolean;\n  onDestroy(callback: Function) { notImplemented(); }\n\n  /**\n   * Marks a view and all of its ancestors dirty.\n   *\n   * It also triggers change detection by calling `scheduleTick` internally, which coalesces\n   * multiple `markForCheck` calls to into one change detection run.\n   *\n   * This can be used to ensure an {@link ChangeDetectionStrategy#OnPush OnPush} component is\n   * checked when it needs to be re-rendered but the two normal triggers haven't marked it\n   * dirty (i.e. inputs haven't changed and events haven't fired in the view).\n   *\n   * <!-- TODO: Add a link to a chapter on OnPush components -->\n   *\n   * ### Example ([live demo](https://stackblitz.com/edit/angular-kx7rrw))\n   *\n   * ```typescript\n   * @Component({\n   *   selector: 'my-app',\n   *   template: `Number of ticks: {{numberOfTicks}}`\n   *   changeDetection: ChangeDetectionStrategy.OnPush,\n   * })\n   * class AppComponent {\n   *   numberOfTicks = 0;\n   *\n   *   constructor(private ref: ChangeDetectorRef) {\n   *     setInterval(() => {\n   *       this.numberOfTicks++;\n   *       // the following is required, otherwise the view will not be updated\n   *       this.ref.markForCheck();\n   *     }, 1000);\n   *   }\n   * }\n   * ```\n   */\n  markForCheck(): void { markViewDirty(this._view); }\n\n  /**\n   * Detaches the view from the change detection tree.\n   *\n   * Detached views will not be checked during change detection runs until they are\n   * re-attached, even if they are dirty. `detach` can be used in combination with\n   * {@link ChangeDetectorRef#detectChanges detectChanges} to implement local change\n   * detection checks.\n   *\n   * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n   * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->\n   *\n   * ### Example\n   *\n   * The following example defines a component with a large list of readonly data.\n   * Imagine the data changes constantly, many times per second. For performance reasons,\n   * we want to check and update the list every five seconds. We can do that by detaching\n   * the component's change detector and doing a local check every five seconds.\n   *\n   * ```typescript\n   * class DataProvider {\n   *   // in a real application the returned data will be different every time\n   *   get data() {\n   *     return [1,2,3,4,5];\n   *   }\n   * }\n   *\n   * @Component({\n   *   selector: 'giant-list',\n   *   template: `\n   *     <li *ngFor=\"let d of dataProvider.data\">Data {{d}}</li>\n   *   `,\n   * })\n   * class GiantList {\n   *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {\n   *     ref.detach();\n   *     setInterval(() => {\n   *       this.ref.detectChanges();\n   *     }, 5000);\n   *   }\n   * }\n   *\n   * @Component({\n   *   selector: 'app',\n   *   providers: [DataProvider],\n   *   template: `\n   *     <giant-list><giant-list>\n   *   `,\n   * })\n   * class App {\n   * }\n   * ```\n   */\n  detach(): void { this._view.flags &= ~LViewFlags.Attached; }\n\n  /**\n   * Re-attaches a view to the change detection tree.\n   *\n   * This can be used to re-attach views that were previously detached from the tree\n   * using {@link ChangeDetectorRef#detach detach}. Views are attached to the tree by default.\n   *\n   * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n   *\n   * ### Example ([live demo](https://stackblitz.com/edit/angular-ymgsxw))\n   *\n   * The following example creates a component displaying `live` data. The component will detach\n   * its change detector from the main change detector tree when the component's live property\n   * is set to false.\n   *\n   * ```typescript\n   * class DataProvider {\n   *   data = 1;\n   *\n   *   constructor() {\n   *     setInterval(() => {\n   *       this.data = this.data * 2;\n   *     }, 500);\n   *   }\n   * }\n   *\n   * @Component({\n   *   selector: 'live-data',\n   *   inputs: ['live'],\n   *   template: 'Data: {{dataProvider.data}}'\n   * })\n   * class LiveData {\n   *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {}\n   *\n   *   set live(value) {\n   *     if (value) {\n   *       this.ref.reattach();\n   *     } else {\n   *       this.ref.detach();\n   *     }\n   *   }\n   * }\n   *\n   * @Component({\n   *   selector: 'my-app',\n   *   providers: [DataProvider],\n   *   template: `\n   *     Live Update: <input type=\"checkbox\" [(ngModel)]=\"live\">\n   *     <live-data [live]=\"live\"><live-data>\n   *   `,\n   * })\n   * class AppComponent {\n   *   live = true;\n   * }\n   * ```\n   */\n  reattach(): void { this._view.flags |= LViewFlags.Attached; }\n\n  /**\n   * Checks the view and its children.\n   *\n   * This can also be used in combination with {@link ChangeDetectorRef#detach detach} to implement\n   * local change detection checks.\n   *\n   * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n   * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->\n   *\n   * ### Example\n   *\n   * The following example defines a component with a large list of readonly data.\n   * Imagine, the data changes constantly, many times per second. For performance reasons,\n   * we want to check and update the list every five seconds.\n   *\n   * We can do that by detaching the component's change detector and doing a local change detection\n   * check every five seconds.\n   *\n   * See {@link ChangeDetectorRef#detach detach} for more information.\n   */\n  detectChanges(): void { detectChanges(this.context); }\n\n  /**\n   * Checks the change detector and its children, and throws if any changes are detected.\n   *\n   * This is used in development mode to verify that running change detection doesn't\n   * introduce other changes.\n   */\n  checkNoChanges(): void { checkNoChanges(this.context); }\n}\n\n\nexport class EmbeddedViewRef<T> extends ViewRef<T> {\n  /**\n   * @internal\n   */\n  _lViewNode: LViewNode;\n\n  constructor(viewNode: LViewNode, template: ComponentTemplate<T>, context: T) {\n    super(viewNode.data, context);\n    this._lViewNode = viewNode;\n  }\n}\n\n/**\n * Creates a ViewRef bundled with destroy functionality.\n *\n * @param context The context for this view\n * @returns The ViewRef\n */\nexport function createViewRef<T>(view: LView | null, context: T): ViewRef<T> {\n  // TODO: add detectChanges back in when implementing ChangeDetectorRef.detectChanges\n  return addDestroyable(new ViewRef(view !, context));\n}\n\n/** Interface for destroy logic. Implemented by addDestroyable. */\nexport interface DestroyRef<T> {\n  /** Whether or not this object has been destroyed */\n  destroyed: boolean;\n  /** Destroy the instance and call all onDestroy callbacks. */\n  destroy(): void;\n  /** Register callbacks that should be called onDestroy */\n  onDestroy(cb: Function): void;\n}\n\n/**\n * Decorates an object with destroy logic (implementing the DestroyRef interface)\n * and returns the enhanced object.\n *\n * @param obj The object to decorate\n * @returns The object with destroy logic\n */\nexport function addDestroyable<T, C>(obj: any): T&DestroyRef<C> {\n  let destroyFn: Function[]|null = null;\n  obj.destroyed = false;\n  obj.destroy = function() {\n    destroyFn && destroyFn.forEach((fn) => fn());\n    this.destroyed = true;\n  };\n  obj.onDestroy = (fn: Function) => (destroyFn || (destroyFn = [])).push(fn);\n  return obj;\n}\n"]}
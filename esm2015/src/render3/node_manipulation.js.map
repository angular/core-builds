{"version":3,"file":"node_manipulation.js","sourceRoot":"","sources":["../../../../../packages/core/src/render3/node_manipulation.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertNotNull} from './assert';\nimport {callHooks} from './hooks';\nimport {LContainer, unusedValueExportToPlacateAjd as unused1} from './interfaces/container';\nimport {LContainerNode, LElementNode, LNode, LNodeType, LProjectionNode, LTextNode, LViewNode, unusedValueExportToPlacateAjd as unused2} from './interfaces/node';\nimport {unusedValueExportToPlacateAjd as unused3} from './interfaces/projection';\nimport {ProceduralRenderer3, RElement, RNode, RText, Renderer3, isProceduralRenderer, unusedValueExportToPlacateAjd as unused4} from './interfaces/renderer';\nimport {HookData, LView, LViewOrLContainer, TView, unusedValueExportToPlacateAjd as unused5} from './interfaces/view';\nimport {assertNodeType} from './node_assert';\nimport {stringify} from './util';\n\nconst unusedValueToPlacateAjd = unused1 + unused2 + unused3 + unused4 + unused5;\n\n/**\n * Returns the first RNode following the given LNode in the same parent DOM element.\n *\n * This is needed in order to insert the given node with insertBefore.\n *\n * @param node The node whose following DOM node must be found.\n * @param stopNode A parent node at which the lookup in the tree should be stopped, or null if the\n * lookup should not be stopped until the result is found.\n * @returns RNode before which the provided node should be inserted or null if the lookup was\n * stopped\n * or if there is no native node after the given logical node in the same native parent.\n */\nfunction findNextRNodeSibling(node: LNode | null, stopNode: LNode | null): RElement|RText|null {\n  let currentNode = node;\n  while (currentNode && currentNode !== stopNode) {\n    let pNextOrParent = currentNode.pNextOrParent;\n    if (pNextOrParent) {\n      while (pNextOrParent.type !== LNodeType.Projection) {\n        const nativeNode = findFirstRNode(pNextOrParent);\n        if (nativeNode) {\n          return nativeNode;\n        }\n        pNextOrParent = pNextOrParent.pNextOrParent !;\n      }\n      currentNode = pNextOrParent;\n    } else {\n      let currentSibling = currentNode.next;\n      while (currentSibling) {\n        const nativeNode = findFirstRNode(currentSibling);\n        if (nativeNode) {\n          return nativeNode;\n        }\n        currentSibling = currentSibling.next;\n      }\n      const parentNode = currentNode.parent;\n      currentNode = null;\n      if (parentNode) {\n        const parentType = parentNode.type;\n        if (parentType === LNodeType.Container || parentType === LNodeType.View) {\n          currentNode = parentNode;\n        }\n      }\n    }\n  }\n  return null;\n}\n\n/**\n * Get the next node in the LNode tree, taking into account the place where a node is\n * projected (in the shadow DOM) rather than where it comes from (in the light DOM).\n *\n * @param node The node whose next node in the LNode tree must be found.\n * @return LNode|null The next sibling in the LNode tree.\n */\nfunction getNextLNodeWithProjection(node: LNode): LNode|null {\n  const pNextOrParent = node.pNextOrParent;\n\n  if (pNextOrParent) {\n    // The node is projected\n    const isLastProjectedNode = pNextOrParent.type === LNodeType.Projection;\n    // returns pNextOrParent if we are not at the end of the list, null otherwise\n    return isLastProjectedNode ? null : pNextOrParent;\n  }\n\n  // returns node.next because the the node is not projected\n  return node.next;\n}\n\n/**\n * Find the next node in the LNode tree, taking into account the place where a node is\n * projected (in the shadow DOM) rather than where it comes from (in the light DOM).\n *\n * If there is no sibling node, this function goes to the next sibling of the parent node...\n * until it reaches rootNode (at which point null is returned).\n *\n * @param initialNode The node whose following node in the LNode tree must be found.\n * @param rootNode The root node at which the lookup should stop.\n * @return LNode|null The following node in the LNode tree.\n */\nfunction getNextOrParentSiblingNode(initialNode: LNode, rootNode: LNode): LNode|null {\n  let node: LNode|null = initialNode;\n  let nextNode = getNextLNodeWithProjection(node);\n  while (node && !nextNode) {\n    // if node.pNextOrParent is not null here, it is not the next node\n    // (because, at this point, nextNode is null, so it is the parent)\n    node = node.pNextOrParent || node.parent;\n    if (node === rootNode) {\n      return null;\n    }\n    nextNode = node && getNextLNodeWithProjection(node);\n  }\n  return nextNode;\n}\n\n/**\n * Returns the first RNode inside the given LNode.\n *\n * @param node The node whose first DOM node must be found\n * @returns RNode The first RNode of the given LNode or null if there is none.\n */\nfunction findFirstRNode(rootNode: LNode): RElement|RText|null {\n  let node: LNode|null = rootNode;\n  while (node) {\n    let nextNode: LNode|null = null;\n    if (node.type === LNodeType.Element) {\n      // A LElementNode has a matching RNode in LElementNode.native\n      return (node as LElementNode).native;\n    } else if (node.type === LNodeType.Container) {\n      const lContainerNode: LContainerNode = (node as LContainerNode);\n      const childContainerData: LContainer = lContainerNode.dynamicLContainerNode ?\n          lContainerNode.dynamicLContainerNode.data :\n          lContainerNode.data;\n      nextNode = childContainerData.views.length ? childContainerData.views[0].child : null;\n    } else if (node.type === LNodeType.Projection) {\n      // For Projection look at the first projected node\n      nextNode = (node as LProjectionNode).data.head;\n    } else {\n      // Otherwise look at the first child\n      nextNode = (node as LViewNode).child;\n    }\n\n    node = nextNode === null ? getNextOrParentSiblingNode(node, rootNode) : nextNode;\n  }\n  return null;\n}\n\nexport function createTextNode(value: any, renderer: Renderer3): RText {\n  return isProceduralRenderer(renderer) ? renderer.createText(stringify(value)) :\n                                          renderer.createTextNode(stringify(value));\n}\n\n/**\n * Adds or removes all DOM elements associated with a view.\n *\n * Because some root nodes of the view may be containers, we sometimes need\n * to propagate deeply into the nested containers to remove all elements in the\n * views beneath it.\n *\n * @param container The container to which the root view belongs\n * @param rootNode The view from which elements should be added or removed\n * @param insertMode Whether or not elements should be added (if false, removing)\n * @param beforeNode The node before which elements should be added, if insert mode\n */\nexport function addRemoveViewFromContainer(\n    container: LContainerNode, rootNode: LViewNode, insertMode: true,\n    beforeNode: RNode | null): void;\nexport function addRemoveViewFromContainer(\n    container: LContainerNode, rootNode: LViewNode, insertMode: false): void;\nexport function addRemoveViewFromContainer(\n    container: LContainerNode, rootNode: LViewNode, insertMode: boolean,\n    beforeNode?: RNode | null): void {\n  ngDevMode && assertNodeType(container, LNodeType.Container);\n  ngDevMode && assertNodeType(rootNode, LNodeType.View);\n  const parentNode = container.data.renderParent;\n  const parent = parentNode ? parentNode.native : null;\n  let node: LNode|null = rootNode.child;\n  if (parent) {\n    while (node) {\n      let nextNode: LNode|null = null;\n      const renderer = container.view.renderer;\n      if (node.type === LNodeType.Element) {\n        if (insertMode) {\n          isProceduralRenderer(renderer) ?\n              renderer.insertBefore(parent, node.native !, beforeNode as RNode | null) :\n              parent.insertBefore(node.native !, beforeNode as RNode | null, true);\n        } else {\n          isProceduralRenderer(renderer) ? renderer.removeChild(parent as RElement, node.native !) :\n                                           parent.removeChild(node.native !);\n        }\n        nextNode = node.next;\n      } else if (node.type === LNodeType.Container) {\n        // if we get to a container, it must be a root node of a view because we are only\n        // propagating down into child views / containers and not child elements\n        const childContainerData: LContainer = (node as LContainerNode).data;\n        childContainerData.renderParent = parentNode;\n        nextNode = childContainerData.views.length ? childContainerData.views[0].child : null;\n      } else if (node.type === LNodeType.Projection) {\n        nextNode = (node as LProjectionNode).data.head;\n      } else {\n        nextNode = (node as LViewNode).child;\n      }\n      if (nextNode === null) {\n        node = getNextOrParentSiblingNode(node, rootNode);\n      } else {\n        node = nextNode;\n      }\n    }\n  }\n}\n\n/**\n * Traverses the tree of component views and containers to remove listeners and\n * call onDestroy callbacks.\n *\n * Notes:\n *  - Because it's used for onDestroy calls, it needs to be bottom-up.\n *  - Must process containers instead of their views to avoid splicing\n *  when views are destroyed and re-added.\n *  - Using a while loop because it's faster than recursion\n *  - Destroy only called on movement to sibling or movement to parent (laterally or up)\n *\n *  @param rootView The view to destroy\n */\nexport function destroyViewTree(rootView: LView): void {\n  let viewOrContainer: LViewOrLContainer|null = rootView;\n\n  while (viewOrContainer) {\n    let next: LViewOrLContainer|null = null;\n\n    if (viewOrContainer.views && viewOrContainer.views.length) {\n      next = viewOrContainer.views[0].data;\n    } else if (viewOrContainer.child) {\n      next = viewOrContainer.child;\n    } else if (viewOrContainer.next) {\n      cleanUpView(viewOrContainer as LView);\n      next = viewOrContainer.next;\n    }\n\n    if (next == null) {\n      // If the viewOrContainer is the rootView, then the cleanup is done twice.\n      // Without this check, ngOnDestroy would be called twice for a directive on an element.\n      while (viewOrContainer && !viewOrContainer !.next && viewOrContainer !== rootView) {\n        cleanUpView(viewOrContainer as LView);\n        viewOrContainer = getParentState(viewOrContainer, rootView);\n      }\n      cleanUpView(viewOrContainer as LView || rootView);\n\n      next = viewOrContainer && viewOrContainer.next;\n    }\n    viewOrContainer = next;\n  }\n}\n\n/**\n * Inserts a view into a container.\n *\n * This adds the view to the container's array of active views in the correct\n * position. It also adds the view's elements to the DOM if the container isn't a\n * root node of another view (in that case, the view's elements will be added when\n * the container's parent view is added later).\n *\n * @param container The container into which the view should be inserted\n * @param newView The view to insert\n * @param index The index at which to insert the view\n * @returns The inserted view\n */\nexport function insertView(\n    container: LContainerNode, newView: LViewNode, index: number): LViewNode {\n  const state = container.data;\n  const views = state.views;\n\n  if (index > 0) {\n    // This is a new view, we need to add it to the children.\n    setViewNext(views[index - 1], newView);\n  }\n\n  if (index < views.length) {\n    setViewNext(newView, views[index]);\n    views.splice(index, 0, newView);\n  } else {\n    views.push(newView);\n  }\n\n  // If the container's renderParent is null, we know that it is a root node of its own parent view\n  // and we should wait until that parent processes its nodes (otherwise, we will insert this view's\n  // nodes twice - once now and once when its parent inserts its views).\n  if (container.data.renderParent !== null) {\n    let beforeNode = findNextRNodeSibling(newView, container);\n    if (!beforeNode) {\n      let containerNextNativeNode = container.native;\n      if (containerNextNativeNode === undefined) {\n        containerNextNativeNode = container.native = findNextRNodeSibling(container, null);\n      }\n      beforeNode = containerNextNativeNode;\n    }\n    addRemoveViewFromContainer(container, newView, true, beforeNode);\n  }\n\n  return newView;\n}\n\n/**\n * Removes a view from a container.\n *\n * This method splices the view from the container's array of active views. It also\n * removes the view's elements from the DOM and conducts cleanup (e.g. removing\n * listeners, calling onDestroys).\n *\n * @param container The container from which to remove a view\n * @param removeIndex The index of the view to remove\n * @returns The removed view\n */\nexport function removeView(container: LContainerNode, removeIndex: number): LViewNode {\n  const views = container.data.views;\n  const viewNode = views[removeIndex];\n  if (removeIndex > 0) {\n    setViewNext(views[removeIndex - 1], viewNode.next);\n  }\n  views.splice(removeIndex, 1);\n  viewNode.next = null;\n  destroyViewTree(viewNode.data);\n  addRemoveViewFromContainer(container, viewNode, false);\n  // Notify query that view has been removed\n  container.data.queries && container.data.queries.removeView(removeIndex);\n  return viewNode;\n}\n\n/**\n * Sets a next on the view node, so views in for loops can easily jump from\n * one view to the next to add/remove elements. Also adds the LView (view.data)\n * to the view tree for easy traversal when cleaning up the view.\n *\n * @param view The view to set up\n * @param next The view's new next\n */\nexport function setViewNext(view: LViewNode, next: LViewNode | null): void {\n  view.next = next;\n  view.data.next = next ? next.data : null;\n}\n\n/**\n * Determines which LViewOrLContainer to jump to when traversing back up the\n * tree in destroyViewTree.\n *\n * Normally, the view's parent LView should be checked, but in the case of\n * embedded views, the container (which is the view node's parent, but not the\n * LView's parent) needs to be checked for a possible next property.\n *\n * @param state The LViewOrLContainer for which we need a parent state\n * @param rootView The rootView, so we don't propagate too far up the view tree\n * @returns The correct parent LViewOrLContainer\n */\nexport function getParentState(state: LViewOrLContainer, rootView: LView): LViewOrLContainer|null {\n  let node;\n  if ((node = (state as LView) !.node) && node.type === LNodeType.View) {\n    // if it's an embedded view, the state needs to go up to the container, in case the\n    // container has a next\n    return node.parent !.data as any;\n  } else {\n    // otherwise, use parent view for containers or component views\n    return state.parent === rootView ? null : state.parent;\n  }\n}\n\n/**\n * Removes all listeners and call all onDestroys in a given view.\n *\n * @param view The LView to clean up\n */\nfunction cleanUpView(view: LView): void {\n  removeListeners(view);\n  executeOnDestroys(view);\n  executePipeOnDestroys(view);\n}\n\n/** Removes listeners and unsubscribes from output subscriptions */\nfunction removeListeners(view: LView): void {\n  const cleanup = view.cleanup !;\n  if (cleanup != null) {\n    for (let i = 0; i < cleanup.length - 1; i += 2) {\n      if (typeof cleanup[i] === 'string') {\n        cleanup ![i + 1].removeEventListener(cleanup[i], cleanup[i + 2], cleanup[i + 3]);\n        i += 2;\n      } else {\n        cleanup[i].call(cleanup[i + 1]);\n      }\n    }\n    view.cleanup = null;\n  }\n}\n\n/** Calls onDestroy hooks for this view */\nfunction executeOnDestroys(view: LView): void {\n  const tView = view.tView;\n  let destroyHooks: HookData|null;\n  if (tView != null && (destroyHooks = tView.destroyHooks) != null) {\n    callHooks(view.directives !, destroyHooks);\n  }\n}\n\n/** Calls pipe destroy hooks for this view */\nfunction executePipeOnDestroys(view: LView): void {\n  const pipeDestroyHooks = view.tView && view.tView.pipeDestroyHooks;\n  if (pipeDestroyHooks) {\n    callHooks(view.data !, pipeDestroyHooks);\n  }\n}\n\n/**\n * Returns whether a native element should be inserted in the given parent.\n *\n * The native node can be inserted when its parent is:\n * - A regular element => Yes\n * - A component host element =>\n *    - if the `currentView` === the parent `view`: The element is in the content (vs the\n *      template)\n *      => don't add as the parent component will project if needed.\n *    - `currentView` !== the parent `view` => The element is in the template (vs the content),\n *      add it\n * - View element => delay insertion, will be done on `viewEnd()`\n *\n * @param parent The parent in which to insert the child\n * @param currentView The LView being processed\n * @return boolean Whether the child element should be inserted.\n */\nexport function canInsertNativeNode(parent: LNode, currentView: LView): boolean {\n  const parentIsElement = parent.type === LNodeType.Element;\n\n  return parentIsElement &&\n      (parent.view !== currentView || parent.data === null /* Regular Element. */);\n}\n\n/**\n * Appends the `child` element to the `parent`.\n *\n * The element insertion might be delayed {@link canInsertNativeNode}\n *\n * @param parent The parent to which to append the child\n * @param child The child that should be appended\n * @param currentView The current LView\n * @returns Whether or not the child was appended\n */\nexport function appendChild(parent: LNode, child: RNode | null, currentView: LView): boolean {\n  if (child !== null && canInsertNativeNode(parent, currentView)) {\n    // We only add element if not in View or not projected.\n    const renderer = currentView.renderer;\n    isProceduralRenderer(renderer) ? renderer.appendChild(parent.native !as RElement, child) :\n                                     parent.native !.appendChild(child);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Inserts the provided node before the correct element in the DOM.\n *\n * The element insertion might be delayed {@link canInsertNativeNode}\n *\n * @param node Node to insert\n * @param currentView Current LView\n */\nexport function insertChild(node: LNode, currentView: LView): void {\n  const parent = node.parent !;\n  if (canInsertNativeNode(parent, currentView)) {\n    let nativeSibling: RNode|null = findNextRNodeSibling(node, null);\n    const renderer = currentView.renderer;\n    isProceduralRenderer(renderer) ?\n        renderer.insertBefore(parent.native !, node.native !, nativeSibling) :\n        parent.native !.insertBefore(node.native !, nativeSibling, false);\n  }\n}\n\n/**\n * Appends a projected node to the DOM, or in the case of a projected container,\n * appends the nodes from all of the container's active views to the DOM.\n *\n * @param node The node to process\n * @param currentParent The last parent element to be processed\n * @param currentView Current LView\n */\nexport function appendProjectedNode(\n    node: LElementNode | LTextNode | LContainerNode, currentParent: LElementNode,\n    currentView: LView): void {\n  if (node.type !== LNodeType.Container) {\n    appendChild(currentParent, (node as LElementNode | LTextNode).native, currentView);\n  } else {\n    // The node we are adding is a Container and we are adding it to Element which\n    // is not a component (no more re-projection).\n    // Alternatively a container is projected at the root of a component's template\n    // and can't be re-projected (as not content of any component).\n    // Assignee the final projection location in those cases.\n    const lContainer = (node as LContainerNode).data;\n    lContainer.renderParent = currentParent;\n    const views = lContainer.views;\n    for (let i = 0; i < views.length; i++) {\n      addRemoveViewFromContainer(node as LContainerNode, views[i], true, null);\n    }\n  }\n  if (node.dynamicLContainerNode) {\n    node.dynamicLContainerNode.data.renderParent = currentParent;\n  }\n}\n"]}
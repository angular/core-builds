{"version":3,"sources":["../../../../../modules/@angular/core/src/profile/profile.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,EAAa,WAAA,EAAa,SAAA,EAAW,YAAA,EAAc,KAAA,EAAO,cAAA,EAAe,MAAA,YAAA,CAAA;AAKhF;;GAEG;AACH,MAAM,CAAC,IAAA,gBAAA,CAAM,UAAA,GAAa,SAAA,EAAU,CAAE;AACtC;;;;GAIG;AACH,mBAJC,IAAA,EAAA,IAAA;IAKC,MAAM,CAJC,IAAA,CAAK;AAKd,CAAC;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA6BG;AACH,MAAM,CAJC,IAAA,gBAAA,CAAM,cAAA,GAKT,UAAU,GAJG,WAAA,GAAc,UAAA,SAAY,EAAQ,KAAQ,IAAQ,OAAA,SAAA,EAAA,CAAA,CAAU;AAM7E;;;;;;;;GAQG;AACH,MAAM,CAJC,IAAA,gBAAA,CAAM,QAAA,GAKT,UAAU,GAJG,KAAA,GAAQ,UAAA,CAAI,EAAK,CAAI,IAAQ,OAAA,CAAA,EAAA,CAAA,CAAE;AAMhD;;;;;;;;;;;;GAYG;AACH,MAAM,CAJC,IAAA,gBAAA,CAAM,iBAAA,GAKT,UAAU,GAJG,cAAA,GAAiB,UAAA,SAAY,EAAQ,MAAQ,IAAW,OAAA,IAAA,EAAA,CAAA,CAAK;AAM9E;;;;;GAKG;AACH,MAAM,CAJC,IAAA,gBAAA,CAAM,eAAA,GAAwC,UAAA,GAAa,YAAA,GAAe,UAAA,CAAI,IAAQ,OAAA,IAAA,EAAA,CAAA,CAAK","file":"profile.js","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {WtfScopeFn, createScope, detectWTF, endTimeRange, leave, startTimeRange} from './wtf_impl';\n\nexport {WtfScopeFn} from './wtf_impl';\n\n\n/**\n * True if WTF is enabled.\n */\nexport const /** @type {?} */ wtfEnabled = detectWTF();\n/**\n * @param {?=} arg0\n * @param {?=} arg1\n * @return {?}\n */\nfunction noopScope(arg0?: any, arg1?: any): any {\n  return null;\n}\n\n/**\n * Create trace scope.\n *\n * Scopes must be strictly nested and are analogous to stack frames, but\n * do not have to follow the stack frames. Instead it is recommended that they follow logical\n * nesting. You may want to use\n * [Event\n * Signatures](http://google.github.io/tracing-framework/instrumenting-code.html#custom-events)\n * as they are defined in WTF.\n *\n * Used to mark scope entry. The return value is used to leave the scope.\n *\n *     var myScope = wtfCreateScope('MyClass#myMethod(ascii someVal)');\n *\n *     someMethod() {\n *        var s = myScope('Foo'); // 'Foo' gets stored in tracing UI\n *        // DO SOME WORK HERE\n *        return wtfLeave(s, 123); // Return value 123\n *     }\n *\n * Note, adding try-finally block around the work to ensure that `wtfLeave` gets called can\n * negatively impact the performance of your application. For this reason we recommend that\n * you don't add them to ensure that `wtfLeave` gets called. In production `wtfLeave` is a noop and\n * so try-finally block has no value. When debugging perf issues, skipping `wtfLeave`, do to\n * exception, will produce incorrect trace, but presence of exception signifies logic error which\n * needs to be fixed before the app should be profiled. Add try-finally only when you expect that\n * an exception is expected during normal execution while profiling.\n *\n * @experimental\n */\nexport const /** @type {?} */ wtfCreateScope: (signature: string, flags?: any) => WtfScopeFn =\n    wtfEnabled ? createScope : (signature: string, flags?: any) => noopScope;\n\n/**\n * Used to mark end of Scope.\n *\n * - `scope` to end.\n * - `returnValue` (optional) to be passed to the WTF.\n *\n * Returns the `returnValue for easy chaining.\n * @experimental\n */\nexport const /** @type {?} */ wtfLeave: <T>(scope: any, returnValue?: T) => T =\n    wtfEnabled ? leave : (s: any, r?: any) => r;\n\n/**\n * Used to mark Async start. Async are similar to scope but they don't have to be strictly nested.\n * The return value is used in the call to [endAsync]. Async ranges only work if WTF has been\n * enabled.\n *\n *     someMethod() {\n *        var s = wtfStartTimeRange('HTTP:GET', 'some.url');\n *        var future = new Future.delay(5).then((_) {\n *          wtfEndTimeRange(s);\n *        });\n *     }\n * @experimental\n */\nexport const /** @type {?} */ wtfStartTimeRange: (rangeType: string, action: string) => any =\n    wtfEnabled ? startTimeRange : (rangeType: string, action: string) => null;\n\n/**\n * Ends a async time range operation.\n * [range] is the return value from [wtfStartTimeRange] Async ranges only work if WTF has been\n * enabled.\n * @experimental\n */\nexport const /** @type {?} */ wtfEndTimeRange: (range: any) => void = wtfEnabled ? endTimeRange : (r: any) => null;\n"]}
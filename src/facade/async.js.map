{"version":3,"sources":["../../../../../modules/@angular/core/src/facade/async.ts"],"names":[],"mappings":"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","file":"async.js","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Subject} from 'rxjs/Subject';\n\nexport {Observable} from 'rxjs/Observable';\nexport {Subject} from 'rxjs/Subject';\n/**\n * Use by directives and components to emit custom Events.\n * \n * ### Examples\n * \n * In the following example, `Zippy` alternatively emits `open` and `close` events when its\n * title gets clicked:\n * \n * ```\n * \\@Component({ \n *   selector: 'zippy',\n *   template: `\n *   <div class=\"zippy\">\n *     <div (click)=\"toggle()\">Toggle</div>\n *     <div [hidden]=\"!visible\">\n *       <ng-content></ng-content>\n *     </div>\n *  </div>`})\n * export class Zippy {\n *   visible: boolean = true;\n *   \\@Output() open: EventEmitter<any> = new EventEmitter();\n *   \\@Output() close: EventEmitter<any> = new EventEmitter();\n * \n *   toggle() {\n *     this.visible = !this.visible;\n *     if (this.visible) {\n *       this.open.emit(null);\n *     } else {\n *       this.close.emit(null);\n *     }\n *   }\n * }\n * ```\n * \n * The events payload can be accessed by the parameter `$event` on the components output event\n * handler:\n * \n * ```\n * <zippy (open)=\"onOpen($event)\" (close)=\"onClose($event)\"></zippy>\n * ```\n * \n * Uses Rx.Observable but provides an adapter to make it work as specified here:\n * https://github.com/jhusain/observable-spec\n * \n * Once a reference implementation of the spec is available, switch to it.\n * \\@stable\n */\nexport class EventEmitter<T> extends Subject<T> {\n  // TODO: mark this as internal once all the facades are gone\n  // we can't mark it as internal now because EventEmitter exported via @angular/core would not\n  // contain this property making it incompatible with all the code that uses EventEmitter via\n  // facades, which are local to the code and do not have this property stripped.\n  // tslint:disable-next-line\n  __isAsync: boolean;\n/**\n * Creates an instance of [EventEmitter], which depending on [isAsync],\n * delivers events synchronously or asynchronously.\n * @param {?=} isAsync\n */\nconstructor(isAsync: boolean = false) {\n    super();\n    this.__isAsync = isAsync;\n  }\n/**\n * @param {?=} value\n * @return {?}\n */\nemit(value?: T) { super.next(value); }\n/**\n * @param {?=} generatorOrNext\n * @param {?=} error\n * @param {?=} complete\n * @return {?}\n */\nsubscribe(generatorOrNext?: any, error?: any, complete?: any): any {\n    let /** @type {?} */ schedulerFn: (t: any) => any;\n    let /** @type {?} */ errorFn = (err: any): any => null;\n    let /** @type {?} */ completeFn = (): any => null;\n\n    if (generatorOrNext && typeof generatorOrNext === 'object') {\n      schedulerFn = this.__isAsync ? (value: any) => {\n        setTimeout(() => generatorOrNext.next(value));\n      } : (value: any) => { generatorOrNext.next(value); };\n\n      if (generatorOrNext.error) {\n        errorFn = this.__isAsync ? (err) => { setTimeout(() => generatorOrNext.error(err)); } :\n                                   (err) => { generatorOrNext.error(err); };\n      }\n\n      if (generatorOrNext.complete) {\n        completeFn = this.__isAsync ? () => { setTimeout(() => generatorOrNext.complete()); } :\n                                      () => { generatorOrNext.complete(); };\n      }\n    } else {\n      schedulerFn = this.__isAsync ? (value: any) => { setTimeout(() => generatorOrNext(value)); } :\n                                     (value: any) => { generatorOrNext(value); };\n\n      if (error) {\n        errorFn =\n            this.__isAsync ? (err) => { setTimeout(() => error(err)); } : (err) => { error(err); };\n      }\n\n      if (complete) {\n        completeFn =\n            this.__isAsync ? () => { setTimeout(() => complete()); } : () => { complete(); };\n      }\n    }\n\n    return super.subscribe(schedulerFn, errorFn, completeFn);\n  }\n}\n\nfunction EventEmitter_tsickle_Closure_declarations() {\n/** @type {?} */\nEventEmitter.prototype.__isAsync;\n}\n\n"]}
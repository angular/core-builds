{"version":3,"file":"opaque_token.js","sourceRoot":"","sources":["../../../../../modules/@angular/core/src/di/opaque_token.ts"],"names":[],"mappings":"AACA;;;;;;;;;;;;;;;;;;;;GAoBG;AACH;IACA;;OAEG;IACH,qBAAoB,KAAa;QAAb,UAAK,GAAL,KAAK,CAAQ;IAAG,CAAC;IACrC;;OAEG;IACH,8BAAQ,GAAR,cAAqB,MAAM,CAAC,WAAS,IAAI,CAAC,KAAO,CAAC,CAAC,CAAC;IACpD,kBAAC;AAAD,CAAC,AATD,IASC;AAED;IACC,gBAAgB;IACjB,WAAW,CAAC,SAAS,CAAC,KAAK,CAAC;AAC5B,CAAC","sourcesContent":["\n/**\n *  Creates a token that can be used in a DI Provider.\n  * *\n  * ### Example ([live demo](http://plnkr.co/edit/Ys9ezXpj2Mnoy3Uc8KBp?p=preview))\n  * *\n  * ```typescript\n  * var t = new OpaqueToken(\"value\");\n  * *\n  * var injector = Injector.resolveAndCreate([\n  * {provide: t, useValue: \"bindingValue\"}\n  * ]);\n  * *\n  * expect(injector.get(t)).toEqual(\"bindingValue\");\n  * ```\n  * *\n  * Using an `OpaqueToken` is preferable to using strings as tokens because of possible collisions\n  * caused by multiple providers using the same string as two different tokens.\n  * *\n  * Using an `OpaqueToken` is preferable to using an `Object` as tokens because it provides better\n  * error messages.\n */\nexport class OpaqueToken {\n/**\n * @param {?} _desc\n */\nconstructor(private _desc: string) {}\n/**\n * @return {?}\n */\ntoString(): string { return `Token ${this._desc}`; }\n}\n\nfunction OpaqueToken_tsickle_Closure_declarations() {\n /** @type {?} */\nOpaqueToken.prototype._desc;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}
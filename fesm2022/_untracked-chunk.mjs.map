{"version":3,"file":"_untracked-chunk.mjs","sources":["../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/core/primitives/signals/src/linked_signal.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/core/primitives/signals/src/untracked.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {COMPUTING, ERRORED, UNSET} from './computed';\nimport {defaultEquals, ValueEqualityFn} from './equality';\nimport {\n  consumerAfterComputation,\n  consumerBeforeComputation,\n  producerAccessed,\n  producerMarkClean,\n  producerUpdateValueVersion,\n  REACTIVE_NODE,\n  ReactiveNode,\n  runPostProducerCreatedFn,\n  SIGNAL,\n} from './graph';\nimport {signalSetFn, signalUpdateFn} from './signal';\n\n// Required as the signals library is in a separate package, so we need to explicitly ensure the\n// global `ngDevMode` type is defined.\ndeclare const ngDevMode: boolean | undefined;\n\nexport type ComputationFn<S, D> = (source: S, previous?: {source: S; value: D}) => D;\n\nexport interface LinkedSignalNode<S, D> extends ReactiveNode {\n  /**\n   * Value of the source signal that was used to derive the computed value.\n   */\n  sourceValue: S;\n\n  /**\n   * Current state value, or one of the sentinel values (`UNSET`, `COMPUTING`,\n   * `ERROR`).\n   */\n  value: D;\n\n  /**\n   * If `value` is `ERRORED`, the error caught from the last computation attempt which will\n   * be re-thrown.\n   */\n  error: unknown;\n\n  /**\n   * The source function represents reactive dependency based on which the linked state is reset.\n   */\n  source: () => S;\n\n  /**\n   * The computation function which will produce a new value based on the source and, optionally - previous values.\n   */\n  computation: ComputationFn<S, D>;\n\n  equal: ValueEqualityFn<D>;\n}\n\nexport type LinkedSignalGetter<S, D> = (() => D) & {\n  [SIGNAL]: LinkedSignalNode<S, D>;\n};\n\nexport function createLinkedSignal<S, D>(\n  sourceFn: () => S,\n  computationFn: ComputationFn<S, D>,\n  equalityFn?: ValueEqualityFn<D>,\n): LinkedSignalGetter<S, D> {\n  const node: LinkedSignalNode<S, D> = Object.create(LINKED_SIGNAL_NODE);\n\n  node.source = sourceFn;\n  node.computation = computationFn;\n  if (equalityFn != undefined) {\n    node.equal = equalityFn;\n  }\n\n  const linkedSignalGetter = () => {\n    // Check if the value needs updating before returning it.\n    producerUpdateValueVersion(node);\n\n    // Record that someone looked at this signal.\n    producerAccessed(node);\n\n    if (node.value === ERRORED) {\n      throw node.error;\n    }\n\n    return node.value;\n  };\n\n  const getter = linkedSignalGetter as LinkedSignalGetter<S, D>;\n  getter[SIGNAL] = node;\n  if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n    const debugName = node.debugName ? ' (' + node.debugName + ')' : '';\n    getter.toString = () => `[LinkedSignal${debugName}: ${node.value}]`;\n  }\n\n  runPostProducerCreatedFn(node);\n\n  return getter;\n}\n\nexport function linkedSignalSetFn<S, D>(node: LinkedSignalNode<S, D>, newValue: D) {\n  producerUpdateValueVersion(node);\n  signalSetFn(node, newValue);\n  producerMarkClean(node);\n}\n\nexport function linkedSignalUpdateFn<S, D>(\n  node: LinkedSignalNode<S, D>,\n  updater: (value: D) => D,\n): void {\n  producerUpdateValueVersion(node);\n  signalUpdateFn(node, updater);\n  producerMarkClean(node);\n}\n\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `LINKED_SIGNAL_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nexport const LINKED_SIGNAL_NODE: object = /* @__PURE__ */ (() => {\n  return {\n    ...REACTIVE_NODE,\n    value: UNSET,\n    dirty: true,\n    error: null,\n    equal: defaultEquals,\n    kind: 'linkedSignal',\n\n    producerMustRecompute(node: LinkedSignalNode<unknown, unknown>): boolean {\n      // Force a recomputation if there's no current value, or if the current value is in the\n      // process of being calculated (which should throw an error).\n      return node.value === UNSET || node.value === COMPUTING;\n    },\n\n    producerRecomputeValue(node: LinkedSignalNode<unknown, unknown>): void {\n      if (node.value === COMPUTING) {\n        // Our computation somehow led to a cyclic read of itself.\n        throw new Error(\n          typeof ngDevMode !== 'undefined' && ngDevMode ? 'Detected cycle in computations.' : '',\n        );\n      }\n\n      const oldValue = node.value;\n      node.value = COMPUTING;\n\n      const prevConsumer = consumerBeforeComputation(node);\n      let newValue: unknown;\n      try {\n        const newSourceValue = node.source();\n        const prev =\n          oldValue === UNSET || oldValue === ERRORED\n            ? undefined\n            : {\n                source: node.sourceValue,\n                value: oldValue,\n              };\n        newValue = node.computation(newSourceValue, prev);\n        node.sourceValue = newSourceValue;\n      } catch (err) {\n        newValue = ERRORED;\n        node.error = err;\n      } finally {\n        consumerAfterComputation(node, prevConsumer);\n      }\n\n      if (oldValue !== UNSET && newValue !== ERRORED && node.equal(oldValue, newValue)) {\n        // No change to `valueVersion` - old and new values are\n        // semantically equivalent.\n        node.value = oldValue;\n        return;\n      }\n\n      node.value = newValue;\n      node.version++;\n    },\n  };\n})();\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {setActiveConsumer} from './graph';\n\n/**\n * Execute an arbitrary function in a non-reactive (non-tracking) context. The executed function\n * can, optionally, return a value.\n */\nexport function untracked<T>(nonReactiveReadsFn: () => T): T {\n  const prevConsumer = setActiveConsumer(null);\n  // We are not trying to catch any particular errors here, just making sure that the consumers\n  // stack is restored in case of errors.\n  try {\n    return nonReactiveReadsFn();\n  } finally {\n    setActiveConsumer(prevConsumer);\n  }\n}\n"],"names":["node","source","sourceFn","computation","computationFn","equalityFn","undefined","linkedSignalGetter","producerUpdateValueVersion","value","ERRORED","getter","ngDevMode","debugName","toString","runPostProducerCreatedFn","linkedSignalSetFn","newValue","prevConsumer","setActiveConsumer"],"mappings":";;;;;;;;;;EAuEEA,IAAA,CAAAC,MAAA,GAAAC,QAAA;EAEAF,IAAA,CAAIG,WAAU,GAAAC,aAAe;EAC3B,IAAAC,UAAA,IAAaC,SAAU,EAAA;IACzBN;;EAyEI,MAAAO,kBAAI,GAAAA,MACJ;AAOUC,IAAAA,0BAAA,CAAAR,IAAA,CAAA;oBAEA,CAAAA,IAAA,CAAA;AACR,IAAA,IAAAA,IAAA,CAAAS,KAAA,KAAAC,OAAK,EAAA;;;IAGL,OAAAV,IAAA,CAAAS,KAAA;;AAEAE,EAAAA,MAAAA,MAAA,GAAAJ,kBAAA;uBACF;sBAGyD,KAAA,WAAA,IAAAK,SAAA,EAAA;mBAC5B,GAAAZ,IAAA,CAAAa,SAAA,GAAAb,IAAAA,GAAAA,IAAA,CAAAa,SAAA,GAAA,GAAA,GAAA,EAAA;AAC3BF,IAAAA,MAAA,CAAAG,QAAA,GAAA,MAAA,CAAA,aAAA,EAAAD,SAAA,CAAAb,EAAAA,EAAAA,IAAA,CAAAS,KAAA,CAAA,CAAA,CAAA;;AAIFM,EAAAA,wBAAA,CAAAf,IAAA,CAAA;SAEFW,MAAC;;AAEH,SAAEK,iBAAAA,CAAAhB,IAAA,EAAAiB,QAAA,EAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ECnKF,MAAAC,YAAA,GAAAC,iBAAA,CAAA,IAAA,CAAA;;;GAOA,SAAA;AACFA,IAAAA,iBAAA,CAAAD,YAAA,CAAA;;;;;;"}
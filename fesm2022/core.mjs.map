{"version":3,"file":"core.mjs","sources":["../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/core/src/authoring/input/input_signal_node.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/core/src/compiler/compiler_facade_interface.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/core/src/di/host_attribute_token.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/core/src/di/host_tag_name_token.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/core/src/authoring/input/input.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/core/src/authoring/queries.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/core/src/authoring/model/model.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/core/src/application/application_ngmodule_factory_compiler.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/core/src/change_detection/scheduling/ng_zone_scheduling.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/core/src/image_performance_warning.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/core/src/platform/bootstrap.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/core/src/platform/platform_ref.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/core/src/platform/platform.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/core/src/change_detection/scheduling/exhaustive_check_no_changes.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/core/src/change_detection/provide_check_no_changes_config.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/core/src/linker/ng_module_factory_loader.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/core/src/linker/view_ref.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/core/src/change_detection/differs/default_iterable_differ.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/core/src/change_detection/differs/default_keyvalue_differ.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/core/src/change_detection/change_detection.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/core/src/platform/platform_core_providers.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/core/src/application/create_application.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/core/src/hydration/event_replay.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/core/src/hydration/annotate.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/core/src/hydration/api.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/core/src/profiler.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/core/src/internal/get_closest_component_name.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/core/src/render3/jit/partial.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/core/src/render3/reactivity/after_render_effect.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {SIGNAL_NODE, SignalNode, signalSetFn} from '../../../primitives/signals';\n\nexport const REQUIRED_UNSET_VALUE: unique symbol = /* @__PURE__ */ Symbol('InputSignalNode#UNSET');\n\n/**\n * Reactive node type for an input signal. An input signal extends a signal.\n * There are special properties to enable transforms and required inputs.\n */\nexport interface InputSignalNode<T, TransformT> extends SignalNode<T> {\n  /**\n   * User-configured transform that will run whenever a new value is applied\n   * to the input signal node.\n   */\n  transformFn: ((value: TransformT) => T) | undefined;\n\n  /**\n   * Applies a new value to the input signal. Expects transforms to be run\n   * manually before.\n   *\n   * This function is called by the framework runtime code whenever a binding\n   * changes. The value can in practice be anything at runtime, but for typing\n   * purposes we assume it's a valid `T` value. Type-checking will enforce that.\n   */\n  applyValueToInputSignal<T, TransformT>(node: InputSignalNode<T, TransformT>, value: T): void;\n\n  /**\n   * A debug name for the input signal. Used in Angular DevTools to identify the signal.\n   */\n  debugName?: string;\n}\n\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nexport const INPUT_SIGNAL_NODE: InputSignalNode<unknown, unknown> = /* @__PURE__ */ (() => {\n  return {\n    ...SIGNAL_NODE,\n    transformFn: undefined,\n\n    applyValueToInputSignal<T, TransformT>(node: InputSignalNode<T, TransformT>, value: T) {\n      signalSetFn(node, value);\n    },\n  };\n})();\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\n/**\n * A set of interfaces which are shared between `@angular/core` and `@angular/compiler` to allow\n * for late binding of `@angular/compiler` for JIT purposes.\n *\n * This file has two copies. Please ensure that they are in sync:\n *  - packages/compiler/src/compiler_facade_interface.ts          (main)\n *  - packages/core/src/compiler/compiler_facade_interface.ts     (replica)\n *\n * Please ensure that the two files are in sync using this command:\n * ```shell\n * cp packages/compiler/src/compiler_facade_interface.ts \\\n *    packages/core/src/compiler/compiler_facade_interface.ts\n * ```\n */\n\nexport interface ExportedCompilerFacade {\n  ɵcompilerFacade: CompilerFacade;\n}\n\nexport interface CompilerFacade {\n  compilePipe(\n    angularCoreEnv: CoreEnvironment,\n    sourceMapUrl: string,\n    meta: R3PipeMetadataFacade,\n  ): any;\n  compilePipeDeclaration(\n    angularCoreEnv: CoreEnvironment,\n    sourceMapUrl: string,\n    declaration: R3DeclarePipeFacade,\n  ): any;\n  compileInjectable(\n    angularCoreEnv: CoreEnvironment,\n    sourceMapUrl: string,\n    meta: R3InjectableMetadataFacade,\n  ): any;\n  compileInjectableDeclaration(\n    angularCoreEnv: CoreEnvironment,\n    sourceMapUrl: string,\n    meta: R3DeclareInjectableFacade,\n  ): any;\n  compileInjector(\n    angularCoreEnv: CoreEnvironment,\n    sourceMapUrl: string,\n    meta: R3InjectorMetadataFacade,\n  ): any;\n  compileInjectorDeclaration(\n    angularCoreEnv: CoreEnvironment,\n    sourceMapUrl: string,\n    declaration: R3DeclareInjectorFacade,\n  ): any;\n  compileNgModule(\n    angularCoreEnv: CoreEnvironment,\n    sourceMapUrl: string,\n    meta: R3NgModuleMetadataFacade,\n  ): any;\n  compileNgModuleDeclaration(\n    angularCoreEnv: CoreEnvironment,\n    sourceMapUrl: string,\n    declaration: R3DeclareNgModuleFacade,\n  ): any;\n  compileDirective(\n    angularCoreEnv: CoreEnvironment,\n    sourceMapUrl: string,\n    meta: R3DirectiveMetadataFacade,\n  ): any;\n  compileDirectiveDeclaration(\n    angularCoreEnv: CoreEnvironment,\n    sourceMapUrl: string,\n    declaration: R3DeclareDirectiveFacade,\n  ): any;\n  compileComponent(\n    angularCoreEnv: CoreEnvironment,\n    sourceMapUrl: string,\n    meta: R3ComponentMetadataFacade,\n  ): any;\n  compileComponentDeclaration(\n    angularCoreEnv: CoreEnvironment,\n    sourceMapUrl: string,\n    declaration: R3DeclareComponentFacade,\n  ): any;\n  compileFactory(\n    angularCoreEnv: CoreEnvironment,\n    sourceMapUrl: string,\n    meta: R3FactoryDefMetadataFacade,\n  ): any;\n  compileFactoryDeclaration(\n    angularCoreEnv: CoreEnvironment,\n    sourceMapUrl: string,\n    meta: R3DeclareFactoryFacade,\n  ): any;\n\n  createParseSourceSpan(kind: string, typeName: string, sourceUrl: string): ParseSourceSpan;\n\n  FactoryTarget: typeof FactoryTarget;\n  // Note that we do not use `{new(): ResourceLoader}` here because\n  // the resource loader class is abstract and not constructable.\n  ResourceLoader: Function & {prototype: ResourceLoader};\n}\n\nexport interface CoreEnvironment {\n  [name: string]: unknown;\n}\n\nexport type ResourceLoader = {\n  get(url: string): Promise<string> | string;\n};\n\nexport type Provider = unknown;\nexport type Type = Function;\nexport type OpaqueValue = unknown;\n\nexport enum FactoryTarget {\n  Directive = 0,\n  Component = 1,\n  Injectable = 2,\n  Pipe = 3,\n  NgModule = 4,\n}\n\nexport interface R3DependencyMetadataFacade {\n  token: OpaqueValue;\n  attribute: string | null;\n  host: boolean;\n  optional: boolean;\n  self: boolean;\n  skipSelf: boolean;\n}\n\nexport interface R3DeclareDependencyMetadataFacade {\n  token: OpaqueValue;\n  attribute?: boolean;\n  host?: boolean;\n  optional?: boolean;\n  self?: boolean;\n  skipSelf?: boolean;\n}\n\nexport interface R3PipeMetadataFacade {\n  name: string;\n  type: Type;\n  pipeName: string | null;\n  pure: boolean;\n  isStandalone: boolean;\n}\n\nexport interface R3InjectableMetadataFacade {\n  name: string;\n  type: Type;\n  typeArgumentCount: number;\n  providedIn?: Type | 'root' | 'platform' | 'any' | null;\n  useClass?: OpaqueValue;\n  useFactory?: OpaqueValue;\n  useExisting?: OpaqueValue;\n  useValue?: OpaqueValue;\n  deps?: R3DependencyMetadataFacade[];\n}\n\nexport interface R3NgModuleMetadataFacade {\n  type: Type;\n  bootstrap: Function[];\n  declarations: Function[];\n  imports: Function[];\n  exports: Function[];\n  schemas: {name: string}[] | null;\n  id: string | null;\n}\n\nexport interface R3InjectorMetadataFacade {\n  name: string;\n  type: Type;\n  providers: Provider[];\n  imports: OpaqueValue[];\n}\n\nexport interface R3HostDirectiveMetadataFacade {\n  directive: Type;\n  inputs?: string[];\n  outputs?: string[];\n}\n\nexport interface R3DirectiveMetadataFacade {\n  name: string;\n  type: Type;\n  typeSourceSpan: ParseSourceSpan;\n  selector: string | null;\n  queries: R3QueryMetadataFacade[];\n  host: {[key: string]: string};\n  propMetadata: {[key: string]: OpaqueValue[]};\n  lifecycle: {usesOnChanges: boolean};\n  inputs: (string | {name: string; alias?: string; required?: boolean})[];\n  outputs: string[];\n  usesInheritance: boolean;\n  exportAs: string[] | null;\n  providers: Provider[] | null;\n  viewQueries: R3QueryMetadataFacade[];\n  isStandalone: boolean;\n  isSignal: boolean;\n  hostDirectives: R3HostDirectiveMetadataFacade[] | null;\n}\n\nexport interface R3ComponentMetadataFacade extends R3DirectiveMetadataFacade {\n  template: string;\n  preserveWhitespaces: boolean;\n  animations: OpaqueValue[] | undefined;\n  declarations: R3TemplateDependencyFacade[];\n  styles: string[];\n  encapsulation: ViewEncapsulation;\n  viewProviders: Provider[] | null;\n  changeDetection?: ChangeDetectionStrategy;\n  hasDirectiveDependencies: boolean;\n}\n\n// TODO(legacy-partial-output-inputs): Remove in v18.\n// https://github.com/angular/angular/blob/d4b423690210872b5c32a322a6090beda30b05a3/packages/core/src/compiler/compiler_facade_interface.ts#L197-L199\nexport type LegacyInputPartialMapping =\n  | string\n  | [bindingPropertyName: string, classPropertyName: string, transformFunction?: Function];\n\nexport interface R3DeclareDirectiveFacade {\n  selector?: string;\n  type: Type;\n  version: string;\n  inputs?: {\n    [fieldName: string]:\n      | {\n          classPropertyName: string;\n          publicName: string;\n          isSignal: boolean;\n          isRequired: boolean;\n          transformFunction: Function | null;\n        }\n      | LegacyInputPartialMapping;\n  };\n  outputs?: {[classPropertyName: string]: string};\n  host?: {\n    attributes?: {[key: string]: OpaqueValue};\n    listeners?: {[key: string]: string};\n    properties?: {[key: string]: string};\n    classAttribute?: string;\n    styleAttribute?: string;\n  };\n  queries?: R3DeclareQueryMetadataFacade[];\n  viewQueries?: R3DeclareQueryMetadataFacade[];\n  providers?: OpaqueValue;\n  exportAs?: string[];\n  usesInheritance?: boolean;\n  usesOnChanges?: boolean;\n  isStandalone?: boolean;\n  hostDirectives?: R3HostDirectiveMetadataFacade[] | null;\n  isSignal?: boolean;\n}\n\nexport interface R3DeclareComponentFacade extends R3DeclareDirectiveFacade {\n  template: string;\n  isInline?: boolean;\n  styles?: string[];\n\n  // Post-standalone libraries use a unified dependencies field.\n  dependencies?: R3DeclareTemplateDependencyFacade[];\n\n  // Pre-standalone libraries have separate component/directive/pipe fields:\n  components?: R3DeclareDirectiveDependencyFacade[];\n  directives?: R3DeclareDirectiveDependencyFacade[];\n  pipes?: {[pipeName: string]: OpaqueValue | (() => OpaqueValue)};\n\n  deferBlockDependencies?: (() => Promise<Type> | null)[];\n  viewProviders?: OpaqueValue;\n  animations?: OpaqueValue;\n  changeDetection?: ChangeDetectionStrategy;\n  encapsulation?: ViewEncapsulation;\n  preserveWhitespaces?: boolean;\n}\n\nexport type R3DeclareTemplateDependencyFacade = {\n  kind: string;\n} & (\n  | R3DeclareDirectiveDependencyFacade\n  | R3DeclarePipeDependencyFacade\n  | R3DeclareNgModuleDependencyFacade\n);\n\nexport interface R3DeclareDirectiveDependencyFacade {\n  kind?: 'directive' | 'component';\n  selector: string;\n  type: OpaqueValue | (() => OpaqueValue);\n  inputs?: string[];\n  outputs?: string[];\n  exportAs?: string[];\n}\n\nexport interface R3DeclarePipeDependencyFacade {\n  kind?: 'pipe';\n  name: string;\n  type: OpaqueValue | (() => OpaqueValue);\n}\n\nexport interface R3DeclareNgModuleDependencyFacade {\n  kind: 'ngmodule';\n  type: OpaqueValue | (() => OpaqueValue);\n}\n\nexport enum R3TemplateDependencyKind {\n  Directive = 0,\n  Pipe = 1,\n  NgModule = 2,\n}\n\nexport interface R3TemplateDependencyFacade {\n  kind: R3TemplateDependencyKind;\n  type: OpaqueValue | (() => OpaqueValue);\n}\nexport interface R3FactoryDefMetadataFacade {\n  name: string;\n  type: Type;\n  typeArgumentCount: number;\n  deps: R3DependencyMetadataFacade[] | null;\n  target: FactoryTarget;\n}\n\nexport interface R3DeclareFactoryFacade {\n  type: Type;\n  deps: R3DeclareDependencyMetadataFacade[] | 'invalid' | null;\n  target: FactoryTarget;\n}\n\nexport interface R3DeclareInjectableFacade {\n  type: Type;\n  providedIn?: Type | 'root' | 'platform' | 'any' | null;\n  useClass?: OpaqueValue;\n  useFactory?: OpaqueValue;\n  useExisting?: OpaqueValue;\n  useValue?: OpaqueValue;\n  deps?: R3DeclareDependencyMetadataFacade[];\n}\n\nexport enum ViewEncapsulation {\n  Emulated = 0,\n  // Historically the 1 value was for `Native` encapsulation which has been removed as of v11.\n  None = 2,\n  ShadowDom = 3,\n  IsolatedShadowDom = 4,\n}\n\nexport type ChangeDetectionStrategy = number;\n\nexport interface R3QueryMetadataFacade {\n  propertyName: string;\n  first: boolean;\n  predicate: OpaqueValue | string[];\n  descendants: boolean;\n  emitDistinctChangesOnly: boolean;\n  read: OpaqueValue | null;\n  static: boolean;\n  isSignal: boolean;\n}\n\nexport interface R3DeclareQueryMetadataFacade {\n  propertyName: string;\n  first?: boolean;\n  predicate: OpaqueValue | string[];\n  descendants?: boolean;\n  read?: OpaqueValue;\n  static?: boolean;\n  emitDistinctChangesOnly?: boolean;\n  isSignal?: boolean;\n}\n\nexport interface R3DeclareInjectorFacade {\n  type: Type;\n  imports?: OpaqueValue[];\n  providers?: OpaqueValue[];\n}\n\nexport interface R3DeclareNgModuleFacade {\n  type: Type;\n  bootstrap?: OpaqueValue[] | (() => OpaqueValue[]);\n  declarations?: OpaqueValue[] | (() => OpaqueValue[]);\n  imports?: OpaqueValue[] | (() => OpaqueValue[]);\n  exports?: OpaqueValue[] | (() => OpaqueValue[]);\n  schemas?: OpaqueValue[];\n  id?: OpaqueValue;\n}\n\nexport interface R3DeclarePipeFacade {\n  type: Type;\n  name: string;\n  version: string;\n  pure?: boolean;\n  isStandalone?: boolean;\n}\n\nexport interface ParseSourceSpan {\n  start: any;\n  end: any;\n  details: any;\n  fullStart: any;\n}\n","/*!\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ɵɵinjectAttribute} from '../render3/instructions/di_attr';\n\n/**\n * Creates a token that can be used to inject static attributes of the host node.\n *\n * @usageNotes\n * ### Injecting an attribute that is known to exist\n * ```ts\n * @Directive()\n * class MyDir {\n *   attr: string = inject(new HostAttributeToken('some-attr'));\n * }\n * ```\n *\n * ### Optionally injecting an attribute\n * ```ts\n * @Directive()\n * class MyDir {\n *   attr: string | null = inject(new HostAttributeToken('some-attr'), {optional: true});\n * }\n * ```\n * @publicApi\n */\nexport class HostAttributeToken {\n  constructor(private attributeName: string) {}\n\n  /** @internal */\n  __NG_ELEMENT_ID__ = () => ɵɵinjectAttribute(this.attributeName);\n\n  toString(): string {\n    return `HostAttributeToken ${this.attributeName}`;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {RuntimeError, RuntimeErrorCode} from '../errors';\nimport {TNode, TNodeType} from '../render3/interfaces/node';\nimport {getCurrentTNode} from '../render3/state';\n\nimport {InjectionToken} from './injection_token';\nimport {InternalInjectFlags} from './interface/injector';\n\n/**\n * A token that can be used to inject the tag name of the host node.\n *\n * @usageNotes\n * ### Injecting a tag name that is known to exist\n * ```ts\n * @Directive()\n * class MyDir {\n *   tagName: string = inject(HOST_TAG_NAME);\n * }\n * ```\n *\n * ### Optionally injecting a tag name\n * ```ts\n * @Directive()\n * class MyDir {\n *   tagName: string | null = inject(HOST_TAG_NAME, {optional: true});\n * }\n * ```\n * @publicApi\n */\nexport const HOST_TAG_NAME: InjectionToken<string> = /* @__PURE__ */ (() => {\n  // Wrapped in a `@__PURE__` IIFE so this token stays tree-shakable.\n  // If nothing ever injects `HOST_TAG_NAME`, the IIFE result is unused and\n  // the bundler can drop the whole block. If we set `__NG_ELEMENT_ID__` at\n  // the top level instead, the mutation would look like a side effect,\n  // forcing the bundler to keep it even when unused.\n  const HOST_TAG_NAME_TOKEN = new InjectionToken<string>(\n    typeof ngDevMode !== undefined && ngDevMode ? 'HOST_TAG_NAME' : '',\n  );\n\n  // HOST_TAG_NAME should be resolved at the current node, similar to e.g. ElementRef,\n  // so we manually specify __NG_ELEMENT_ID__ here, instead of using a factory.\n  // tslint:disable-next-line:no-toplevel-property-access\n  (HOST_TAG_NAME_TOKEN as any).__NG_ELEMENT_ID__ = (flags: InternalInjectFlags) => {\n    const tNode = getCurrentTNode();\n    if (tNode === null) {\n      throw new RuntimeError(\n        RuntimeErrorCode.INVALID_INJECTION_TOKEN,\n        ngDevMode &&\n          'HOST_TAG_NAME can only be injected in directives and components ' +\n            'during construction time (in a class constructor or as a class field initializer)',\n      );\n    }\n    if (tNode.type & TNodeType.Element) {\n      return tNode.value;\n    }\n    if (flags & InternalInjectFlags.Optional) {\n      return null;\n    }\n    throw new RuntimeError(\n      RuntimeErrorCode.INVALID_INJECTION_TOKEN,\n      ngDevMode &&\n        `HOST_TAG_NAME was used on ${getDevModeNodeName(\n          tNode,\n        )} which doesn't have an underlying element in the DOM. ` +\n          `This is invalid, and so the dependency should be marked as optional.`,\n    );\n  };\n\n  return HOST_TAG_NAME_TOKEN;\n})();\n\nfunction getDevModeNodeName(tNode: TNode) {\n  if (tNode.type & TNodeType.ElementContainer) {\n    return 'an <ng-container>';\n  } else if (tNode.type & TNodeType.Container) {\n    return 'an <ng-template>';\n  } else if (tNode.type & TNodeType.LetDeclaration) {\n    return 'an @let declaration';\n  } else {\n    return 'a node';\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {assertInInjectionContext} from '../../di';\n\nimport {\n  createInputSignal,\n  InputOptions,\n  InputOptionsWithoutTransform,\n  InputOptionsWithTransform,\n  InputSignal,\n  InputSignalWithTransform,\n} from './input_signal';\nimport {REQUIRED_UNSET_VALUE} from './input_signal_node';\n\nexport function inputFunction<ReadT, WriteT>(\n  initialValue?: ReadT,\n  opts?: InputOptions<ReadT, WriteT>,\n): InputSignalWithTransform<ReadT | undefined, WriteT> {\n  ngDevMode && assertInInjectionContext(input);\n  return createInputSignal(initialValue, opts);\n}\n\nexport function inputRequiredFunction<ReadT, WriteT = ReadT>(\n  opts?: InputOptions<ReadT, WriteT>,\n): InputSignalWithTransform<ReadT, WriteT> {\n  ngDevMode && assertInInjectionContext(input);\n  return createInputSignal(REQUIRED_UNSET_VALUE as never, opts);\n}\n\n/**\n * The `input` function allows declaration of inputs in directives and\n * components.\n *\n * The function exposes an API for also declaring required inputs via the\n * `input.required` function.\n *\n * @publicAPI\n * @docsPrivate Ignored because `input` is the canonical API entry.\n */\nexport interface InputFunction {\n  /**\n   * Initializes an input of type `T` with an initial value of `undefined`.\n   * Angular will implicitly use `undefined` as initial value.\n   */\n  <T>(): InputSignal<T | undefined>;\n  /** Declares an input of type `T` with an explicit initial value. */\n  <T>(initialValue: T, opts?: InputOptionsWithoutTransform<T>): InputSignal<T>;\n  /** Declares an input of type `T|undefined` without an initial value, but with input options */\n  <T>(initialValue: undefined, opts: InputOptionsWithoutTransform<T>): InputSignal<T | undefined>;\n  /**\n   * Declares an input of type `T` with an initial value and a transform\n   * function.\n   *\n   * The input accepts values of type `TransformT` and the given\n   * transform function will transform the value to type `T`.\n   */\n  <T, TransformT>(\n    initialValue: T,\n    opts: InputOptionsWithTransform<T, TransformT>,\n  ): InputSignalWithTransform<T, TransformT>;\n  /**\n   * Declares an input of type `T|undefined` without an initial value and with a transform\n   * function.\n   *\n   * The input accepts values of type `TransformT` and the given\n   * transform function will transform the value to type `T|undefined`.\n   */ <T, TransformT>(\n    initialValue: undefined,\n    opts: InputOptionsWithTransform<T | undefined, TransformT>,\n  ): InputSignalWithTransform<T | undefined, TransformT>;\n\n  /**\n   * Initializes a required input.\n   *\n   * Consumers of your directive/component need to bind to this\n   * input. If unset, a compile time error will be reported.\n   *\n   * @publicAPI\n   */\n  required: {\n    /** Declares a required input of type `T`. */\n    <T>(opts?: InputOptionsWithoutTransform<T>): InputSignal<T>;\n    /**\n     * Declares a required input of type `T` with a transform function.\n     *\n     * The input accepts values of type `TransformT` and the given\n     * transform function will transform the value to type `T`.\n     */\n    <T, TransformT>(\n      opts: InputOptionsWithTransform<T, TransformT>,\n    ): InputSignalWithTransform<T, TransformT>;\n  };\n}\n\n/**\n * The `input` function allows declaration of Angular inputs in directives\n * and components.\n *\n * There are two variants of inputs that can be declared:\n *\n *   1. **Optional inputs** with an initial value.\n *   2. **Required inputs** that consumers need to set.\n *\n * By default, the `input` function will declare optional inputs that\n * always have an initial value. Required inputs can be declared\n * using the `input.required()` function.\n *\n * Inputs are signals. The values of an input are exposed as a `Signal`.\n * The signal always holds the latest value of the input that is bound\n * from the parent.\n *\n * @usageNotes\n * To use signal-based inputs, import `input` from `@angular/core`.\n *\n * ```ts\n * import {input} from '@angular/core';\n * ```\n *\n * Inside your component, introduce a new class member and initialize\n * it with a call to `input` or `input.required`.\n *\n * ```ts\n * @Component({\n *   ...\n * })\n * export class UserProfileComponent {\n *   firstName = input<string>();             // Signal<string|undefined>\n *   lastName  = input.required<string>();    // Signal<string>\n *   age       = input(0)                     // Signal<number>\n * }\n * ```\n *\n * Inside your component template, you can display values of the inputs\n * by calling the signal.\n *\n * ```html\n * <span>{{firstName()}}</span>\n * ```\n *\n * @publicAPI\n * @initializerApiFunction\n */\nexport const input: InputFunction = (() => {\n  // Note: This may be considered a side-effect, but nothing will depend on\n  // this assignment, unless this `input` constant export is accessed. It's a\n  // self-contained side effect that is local to the user facing`input` export.\n  (inputFunction as any).required = inputRequiredFunction;\n  return inputFunction as typeof inputFunction & {required: typeof inputRequiredFunction};\n})();\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {assertInInjectionContext} from '../di';\nimport {ProviderToken} from '../di/provider_token';\nimport {\n  createMultiResultQuerySignalFn,\n  createSingleResultOptionalQuerySignalFn,\n  createSingleResultRequiredQuerySignalFn,\n} from '../render3/queries/query_reactive';\nimport {Signal} from '../render3/reactivity/api';\n\nfunction viewChildFn<LocatorT, ReadT>(\n  locator: ProviderToken<LocatorT> | string,\n  opts?: {read?: ProviderToken<ReadT>; debugName?: string},\n): Signal<ReadT | undefined> {\n  ngDevMode && assertInInjectionContext(viewChild);\n  return createSingleResultOptionalQuerySignalFn<ReadT>(opts);\n}\n\nfunction viewChildRequiredFn<LocatorT, ReadT>(\n  locator: ProviderToken<LocatorT> | string,\n  opts?: {read?: ProviderToken<ReadT>; debugName?: string},\n): Signal<ReadT> {\n  ngDevMode && assertInInjectionContext(viewChild);\n  return createSingleResultRequiredQuerySignalFn<ReadT>(opts);\n}\n\n/**\n * Type of the `viewChild` function. The viewChild function creates a singular view query.\n *\n * It is a special function that also provides access to required query results via the `.required`\n * property.\n *\n * @publicApi\n * @docsPrivate Ignored because `viewChild` is the canonical API entry.\n */\nexport interface ViewChildFunction {\n  /**\n   * Initializes a view child query. Consider using `viewChild.required` for queries that should\n   * always match.\n   *\n   * @publicAPI\n   */\n\n  <LocatorT, ReadT>(\n    locator: ProviderToken<LocatorT> | string,\n    opts: {\n      read: ProviderToken<ReadT>;\n      debugName?: string;\n    },\n  ): Signal<ReadT | undefined>;\n\n  <LocatorT>(\n    locator: ProviderToken<LocatorT> | string,\n    opts?: {\n      debugName?: string;\n    },\n  ): Signal<LocatorT | undefined>;\n\n  /**\n   * Initializes a view child query that is expected to always match an element.\n   *\n   * @publicAPI\n   */\n  required: {\n    <LocatorT>(\n      locator: ProviderToken<LocatorT> | string,\n      opts?: {\n        debugName?: string;\n      },\n    ): Signal<LocatorT>;\n\n    <LocatorT, ReadT>(\n      locator: ProviderToken<LocatorT> | string,\n      opts: {\n        read: ProviderToken<ReadT>;\n        debugName?: string;\n      },\n    ): Signal<ReadT>;\n  };\n}\n\n/**\n * Initializes a view child query.\n *\n * Consider using `viewChild.required` for queries that should always match.\n *\n * @usageNotes\n * Create a child query in your component by declaring a\n * class field and initializing it with the `viewChild()` function.\n *\n * ```angular-ts\n * @Component({template: '<div #el></div><my-component #cmp />'})\n * export class TestComponent {\n *   divEl = viewChild<ElementRef>('el');                   // Signal<ElementRef|undefined>\n *   divElRequired = viewChild.required<ElementRef>('el');  // Signal<ElementRef>\n *   cmp = viewChild(MyComponent);                          // Signal<MyComponent|undefined>\n *   cmpRequired = viewChild.required(MyComponent);         // Signal<MyComponent>\n * }\n * ```\n *\n * @publicApi 19.0\n * @initializerApiFunction\n */\nexport const viewChild: ViewChildFunction = (() => {\n  // Note: This may be considered a side-effect, but nothing will depend on\n  // this assignment, unless this `viewChild` constant export is accessed. It's a\n  // self-contained side effect that is local to the user facing `viewChild` export.\n  (viewChildFn as any).required = viewChildRequiredFn;\n  return viewChildFn as typeof viewChildFn & {required: typeof viewChildRequiredFn};\n})();\n\nexport function viewChildren<LocatorT>(\n  locator: ProviderToken<LocatorT> | string,\n  opts?: {debugName?: string},\n): Signal<ReadonlyArray<LocatorT>>;\nexport function viewChildren<LocatorT, ReadT>(\n  locator: ProviderToken<LocatorT> | string,\n  opts: {\n    read: ProviderToken<ReadT>;\n    debugName?: string;\n  },\n): Signal<ReadonlyArray<ReadT>>;\n\n/**\n * Initializes a view children query.\n *\n * Query results are represented as a signal of a read-only collection containing all matched\n * elements.\n *\n * @usageNotes\n * Create a children query in your component by declaring a\n * class field and initializing it with the `viewChildren()` function.\n *\n * ```ts\n * @Component({...})\n * export class TestComponent {\n *   divEls = viewChildren<ElementRef>('el');   // Signal<ReadonlyArray<ElementRef>>\n * }\n * ```\n *\n * @initializerApiFunction\n * @publicApi 19.0\n */\nexport function viewChildren<LocatorT, ReadT>(\n  locator: ProviderToken<LocatorT> | string,\n  opts?: {\n    read?: ProviderToken<ReadT>;\n    debugName?: string;\n  },\n): Signal<ReadonlyArray<ReadT>> {\n  ngDevMode && assertInInjectionContext(viewChildren);\n  return createMultiResultQuerySignalFn<ReadT>(opts);\n}\n\nexport function contentChildFn<LocatorT, ReadT>(\n  locator: ProviderToken<LocatorT> | string,\n  opts?: {\n    descendants?: boolean;\n    read?: ProviderToken<ReadT>;\n    debugName?: string;\n  },\n): Signal<ReadT | undefined> {\n  ngDevMode && assertInInjectionContext(contentChild);\n  return createSingleResultOptionalQuerySignalFn<ReadT>(opts);\n}\n\nfunction contentChildRequiredFn<LocatorT, ReadT>(\n  locator: ProviderToken<LocatorT> | string,\n  opts?: {\n    descendants?: boolean;\n    read?: ProviderToken<ReadT>;\n    debugName?: string;\n  },\n): Signal<ReadT> {\n  ngDevMode && assertInInjectionContext(contentChildren);\n  return createSingleResultRequiredQuerySignalFn<ReadT>(opts);\n}\n\n/**\n * Type of the `contentChild` function.\n *\n * The contentChild function creates a singular content query. It is a special function that also\n * provides access to required query results via the `.required` property.\n *\n * @publicApi 19.0\n * @docsPrivate Ignored because `contentChild` is the canonical API entry.\n */\nexport interface ContentChildFunction {\n  /**\n   * Initializes a content child query.\n   *\n   * Consider using `contentChild.required` for queries that should always match.\n   * @publicAPI\n   */\n  <LocatorT>(\n    locator: ProviderToken<LocatorT> | string,\n    opts?: {\n      descendants?: boolean;\n      read?: undefined;\n      debugName?: string;\n    },\n  ): Signal<LocatorT | undefined>;\n\n  <LocatorT, ReadT>(\n    locator: ProviderToken<LocatorT> | string,\n    opts: {\n      descendants?: boolean;\n      read: ProviderToken<ReadT>;\n      debugName?: string;\n    },\n  ): Signal<ReadT | undefined>;\n\n  /**\n   * Initializes a content child query that is always expected to match.\n   */\n  required: {\n    <LocatorT>(\n      locator: ProviderToken<LocatorT> | string,\n      opts?: {\n        descendants?: boolean;\n        read?: undefined;\n        debugName?: string;\n      },\n    ): Signal<LocatorT>;\n\n    <LocatorT, ReadT>(\n      locator: ProviderToken<LocatorT> | string,\n      opts: {\n        descendants?: boolean;\n        read: ProviderToken<ReadT>;\n        debugName?: string;\n      },\n    ): Signal<ReadT>;\n  };\n}\n\n/**\n * Initializes a content child query. Consider using `contentChild.required` for queries that should\n * always match.\n *\n * @usageNotes\n * Create a child query in your component by declaring a\n * class field and initializing it with the `contentChild()` function.\n *\n * ```ts\n * @Component({...})\n * export class TestComponent {\n *   headerEl = contentChild<ElementRef>('h');                    // Signal<ElementRef|undefined>\n *   headerElElRequired = contentChild.required<ElementRef>('h'); // Signal<ElementRef>\n *   header = contentChild(MyHeader);                             // Signal<MyHeader|undefined>\n *   headerRequired = contentChild.required(MyHeader);            // Signal<MyHeader>\n * }\n * ```\n *\n * Note: By default `descendants` is `true` which means the query will traverse all descendants in the same template.\n *\n * @initializerApiFunction\n * @publicApi 19.0\n */\nexport const contentChild: ContentChildFunction = (() => {\n  // Note: This may be considered a side-effect, but nothing will depend on\n  // this assignment, unless this `viewChild` constant export is accessed. It's a\n  // self-contained side effect that is local to the user facing `viewChild` export.\n  (contentChildFn as any).required = contentChildRequiredFn;\n  return contentChildFn as typeof contentChildFn & {required: typeof contentChildRequiredFn};\n})();\n\nexport function contentChildren<LocatorT>(\n  locator: ProviderToken<LocatorT> | string,\n  opts?: {\n    descendants?: boolean;\n    read?: undefined;\n    debugName?: string;\n  },\n): Signal<ReadonlyArray<LocatorT>>;\nexport function contentChildren<LocatorT, ReadT>(\n  locator: ProviderToken<LocatorT> | string,\n  opts: {\n    descendants?: boolean;\n    read: ProviderToken<ReadT>;\n    debugName?: string;\n  },\n): Signal<ReadonlyArray<ReadT>>;\n\n/**\n * Initializes a content children query.\n *\n * Query results are represented as a signal of a read-only collection containing all matched\n * elements.\n *\n * @usageNotes\n * Create a children query in your component by declaring a\n * class field and initializing it with the `contentChildren()` function.\n *\n * ```ts\n * @Component({...})\n * export class TestComponent {\n *   headerEl = contentChildren<ElementRef>('h');   // Signal<ReadonlyArray<ElementRef>>\n * }\n * ```\n *\n * Note: By default `descendants` is `false` which means the query will not traverse all descendants in the same template.\n *\n * @initializerApiFunction\n * @publicApi 19.0\n */\nexport function contentChildren<LocatorT, ReadT>(\n  locator: ProviderToken<LocatorT> | string,\n  opts?: {\n    descendants?: boolean;\n    read?: ProviderToken<ReadT>;\n    debugName?: string;\n  },\n): Signal<ReadonlyArray<ReadT>> {\n  return createMultiResultQuerySignalFn<ReadT>(opts);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {assertInInjectionContext} from '../../di';\nimport {REQUIRED_UNSET_VALUE} from '../input/input_signal_node';\n\nimport {createModelSignal, ModelOptions, ModelSignal} from './model_signal';\n\nexport function modelFunction<T>(\n  initialValue?: T,\n  opts?: ModelOptions,\n): ModelSignal<T | undefined> {\n  ngDevMode && assertInInjectionContext(model);\n\n  return createModelSignal(initialValue, opts);\n}\n\nexport function modelRequiredFunction<T>(opts?: ModelOptions): ModelSignal<T> {\n  ngDevMode && assertInInjectionContext(model);\n\n  return createModelSignal(REQUIRED_UNSET_VALUE as T, opts);\n}\n\n/**\n * `model` declares a writeable signal that is exposed as an input/output pair on the containing\n * directive. The input name is taken either from the class member or from the `alias` option.\n * The output name is generated by taking the input name and appending `Change`.\n *\n * The function exposes an API for also declaring required models via the\n * `model.required` function.\n *\n * @publicAPI\n * @docsPrivate Ignored because `model` is the canonical API entry.\n */\nexport interface ModelFunction {\n  /**\n   * Initializes a model of type `T` with an initial value of `undefined`.\n   * Angular will implicitly use `undefined` as initial value.\n   */\n  <T>(): ModelSignal<T | undefined>;\n  /** Initializes a model of type `T` with the given initial value. */\n  <T>(initialValue: T, opts?: ModelOptions): ModelSignal<T>;\n\n  required: {\n    /**\n     * Initializes a required model.\n     *\n     * Users of your directive/component need to bind to the input side of the model.\n     * If unset, a compile time error will be reported.\n     */\n    <T>(opts?: ModelOptions): ModelSignal<T>;\n  };\n}\n\n/**\n * `model` declares a writeable signal that is exposed as an input/output\n * pair on the containing directive.\n *\n * The input name is taken either from the class member or from the `alias` option.\n * The output name is generated by taking the input name and appending `Change`.\n *\n * @usageNotes\n *\n * To use `model()`, import the function from `@angular/core`.\n *\n * ```ts\n * import {model} from '@angular/core';\n * ```\n *\n * Inside your component, introduce a new class member and initialize\n * it with a call to `model` or `model.required`.\n *\n * ```ts\n * @Directive({\n *   ...\n * })\n * export class MyDir {\n *   firstName = model<string>();            // ModelSignal<string|undefined>\n *   lastName  = model.required<string>();   // ModelSignal<string>\n *   age       = model(0);                   // ModelSignal<number>\n * }\n * ```\n *\n * Inside your component template, you can display the value of a `model`\n * by calling the signal.\n *\n * ```html\n * <span>{{firstName()}}</span>\n * ```\n *\n * Updating the `model` is equivalent to updating a writable signal.\n *\n * ```ts\n * updateName(newFirstName: string): void {\n *   this.firstName.set(newFirstName);\n * }\n * ```\n *\n * @publicApi 19.0\n * @initializerApiFunction\n */\nexport const model: ModelFunction = (() => {\n  // Note: This may be considered a side-effect, but nothing will depend on\n  // this assignment, unless this `model` constant export is accessed. It's a\n  // self-contained side effect that is local to the user facing `model` export.\n  (modelFunction as any).required = modelRequiredFunction;\n  return modelFunction as typeof modelFunction & {required: typeof modelRequiredFunction};\n})();\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {getCompilerFacade, JitCompilerUsage} from '../compiler/compiler_facade';\nimport {Injector} from '../di/injector';\nimport {Type} from '../interface/type';\nimport {COMPILER_OPTIONS, CompilerOptions} from '../linker/compiler';\nimport {NgModuleFactory} from '../linker/ng_module_factory';\nimport {\n  isComponentResourceResolutionQueueEmpty,\n  resolveComponentResources,\n} from '../metadata/resource_loading';\nimport {assertNgModuleType} from '../render3/assert';\nimport {setJitOptions} from '../render3/jit/jit_options';\nimport {NgModuleFactory as R3NgModuleFactory} from '../render3/ng_module_ref';\n\nexport function compileNgModuleFactory<M>(\n  injector: Injector,\n  options: CompilerOptions,\n  moduleType: Type<M>,\n): Promise<NgModuleFactory<M>> {\n  ngDevMode && assertNgModuleType(moduleType);\n\n  const moduleFactory = new R3NgModuleFactory(moduleType);\n\n  // All of the logic below is irrelevant for AOT-compiled code.\n  if (typeof ngJitMode !== 'undefined' && !ngJitMode) {\n    return Promise.resolve(moduleFactory);\n  }\n\n  const compilerOptions = injector.get(COMPILER_OPTIONS, []).concat(options);\n\n  // Configure the compiler to use the provided options. This call may fail when multiple modules\n  // are bootstrapped with incompatible options, as a component can only be compiled according to\n  // a single set of options.\n  setJitOptions({\n    defaultEncapsulation: _lastDefined(compilerOptions.map((opts) => opts.defaultEncapsulation)),\n    preserveWhitespaces: _lastDefined(compilerOptions.map((opts) => opts.preserveWhitespaces)),\n  });\n\n  if (isComponentResourceResolutionQueueEmpty()) {\n    return Promise.resolve(moduleFactory);\n  }\n\n  const compilerProviders = compilerOptions.flatMap((option) => option.providers ?? []);\n\n  // In case there are no compiler providers, we just return the module factory as\n  // there won't be any resource loader. This can happen with Ivy, because AOT compiled\n  // modules can be still passed through \"bootstrapModule\". In that case we shouldn't\n  // unnecessarily require the JIT compiler.\n  if (compilerProviders.length === 0) {\n    return Promise.resolve(moduleFactory);\n  }\n\n  const compiler = getCompilerFacade({\n    usage: JitCompilerUsage.Decorator,\n    kind: 'NgModule',\n    type: moduleType,\n  });\n  const compilerInjector = Injector.create({providers: compilerProviders});\n  const resourceLoader = compilerInjector.get(compiler.ResourceLoader);\n  // The resource loader can also return a string while the \"resolveComponentResources\"\n  // always expects a promise. Therefore we need to wrap the returned value in a promise.\n  return resolveComponentResources((url) => Promise.resolve(resourceLoader.get(url))).then(\n    () => moduleFactory,\n  );\n}\n\nfunction _lastDefined<T>(args: T[]): T | undefined {\n  for (let i = args.length - 1; i >= 0; i--) {\n    if (args[i] !== undefined) {\n      return args[i];\n    }\n  }\n  return undefined;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Subscription} from 'rxjs';\n\nimport {ApplicationRef, ApplicationRefDirtyFlags} from '../../application/application_ref';\nimport {\n  ENVIRONMENT_INITIALIZER,\n  EnvironmentProviders,\n  inject,\n  Injectable,\n  InjectionToken,\n  makeEnvironmentProviders,\n  StaticProvider,\n} from '../../di';\nimport {RuntimeError, RuntimeErrorCode} from '../../errors';\nimport {PendingTasksInternal} from '../../pending_tasks_internal';\nimport {performanceMarkFeature} from '../../util/performance';\nimport {NgZone} from '../../zone';\nimport {InternalNgZoneOptions} from '../../zone/ng_zone';\n\nimport {\n  ChangeDetectionScheduler,\n  ZONELESS_ENABLED,\n  SCHEDULE_IN_ROOT_ZONE,\n} from './zoneless_scheduling';\nimport {SCHEDULE_IN_ROOT_ZONE_DEFAULT} from './flags';\nimport {INTERNAL_APPLICATION_ERROR_HANDLER} from '../../error_handler';\n\n@Injectable({providedIn: 'root'})\nexport class NgZoneChangeDetectionScheduler {\n  private readonly zone = inject(NgZone);\n  private readonly changeDetectionScheduler = inject(ChangeDetectionScheduler);\n  private readonly applicationRef = inject(ApplicationRef);\n  private readonly applicationErrorHandler = inject(INTERNAL_APPLICATION_ERROR_HANDLER);\n\n  private _onMicrotaskEmptySubscription?: Subscription;\n\n  initialize(): void {\n    if (this._onMicrotaskEmptySubscription) {\n      return;\n    }\n\n    this._onMicrotaskEmptySubscription = this.zone.onMicrotaskEmpty.subscribe({\n      next: () => {\n        // `onMicroTaskEmpty` can happen _during_ the zoneless scheduler change detection because\n        // zone.run(() => {}) will result in `checkStable` at the end of the `zone.run` closure\n        // and emit `onMicrotaskEmpty` synchronously if run coalsecing is false.\n        if (this.changeDetectionScheduler.runningTick) {\n          return;\n        }\n        this.zone.run(() => {\n          try {\n            this.applicationRef.dirtyFlags |= ApplicationRefDirtyFlags.ViewTreeGlobal;\n            this.applicationRef._tick();\n          } catch (e) {\n            this.applicationErrorHandler(e);\n          }\n        });\n      },\n    });\n  }\n\n  ngOnDestroy() {\n    this._onMicrotaskEmptySubscription?.unsubscribe();\n  }\n}\n\n/**\n * Internal token used to verify that `provideZoneChangeDetection` is not used\n * with the bootstrapModule API.\n */\nexport const PROVIDED_NG_ZONE = new InjectionToken<boolean>(\n  typeof ngDevMode === 'undefined' || ngDevMode ? 'provideZoneChangeDetection token' : '',\n  {factory: () => false},\n);\n\nexport function internalProvideZoneChangeDetection({\n  ngZoneFactory,\n  scheduleInRootZone,\n}: {\n  ngZoneFactory?: () => NgZone;\n  scheduleInRootZone?: boolean;\n}): StaticProvider[] {\n  ngZoneFactory ??= () =>\n    new NgZone({...getNgZoneOptions(), scheduleInRootZone} as InternalNgZoneOptions);\n  return [\n    {provide: ZONELESS_ENABLED, useValue: false},\n    {provide: NgZone, useFactory: ngZoneFactory},\n    {\n      provide: ENVIRONMENT_INITIALIZER,\n      multi: true,\n      useFactory: () => {\n        const ngZoneChangeDetectionScheduler = inject(NgZoneChangeDetectionScheduler, {\n          optional: true,\n        });\n        if (\n          (typeof ngDevMode === 'undefined' || ngDevMode) &&\n          ngZoneChangeDetectionScheduler === null\n        ) {\n          throw new RuntimeError(\n            RuntimeErrorCode.MISSING_REQUIRED_INJECTABLE_IN_BOOTSTRAP,\n            `A required Injectable was not found in the dependency injection tree. ` +\n              'If you are bootstrapping an NgModule, make sure that the `BrowserModule` is imported.',\n          );\n        }\n        return () => ngZoneChangeDetectionScheduler!.initialize();\n      },\n    },\n    {\n      provide: ENVIRONMENT_INITIALIZER,\n      multi: true,\n      useFactory: () => {\n        const service = inject(ZoneStablePendingTask);\n        return () => {\n          service.initialize();\n        };\n      },\n    },\n    {\n      provide: SCHEDULE_IN_ROOT_ZONE,\n      useValue: scheduleInRootZone ?? SCHEDULE_IN_ROOT_ZONE_DEFAULT,\n    },\n  ];\n}\n\n/**\n * Provides `NgZone`-based change detection for the application bootstrapped using\n * `bootstrapApplication`.\n *\n * `NgZone` is already provided in applications by default. This provider allows you to configure\n * options like `eventCoalescing` in the `NgZone`.\n * This provider is not available for `platformBrowser().bootstrapModule`, which uses\n * `BootstrapOptions` instead.\n *\n * @usageNotes\n * ```ts\n * bootstrapApplication(MyApp, {providers: [\n *   provideZoneChangeDetection({eventCoalescing: true}),\n * ]});\n * ```\n *\n * @publicApi\n * @see {@link /api/platform-browser/bootstrapApplication bootstrapApplication}\n * @see {@link NgZoneOptions}\n */\nexport function provideZoneChangeDetection(options?: NgZoneOptions): EnvironmentProviders {\n  const scheduleInRootZone = (options as any)?.scheduleInRootZone;\n  const zoneProviders = internalProvideZoneChangeDetection({\n    ngZoneFactory: () => {\n      const ngZoneOptions = getNgZoneOptions(options);\n      ngZoneOptions.scheduleInRootZone = scheduleInRootZone;\n      if (ngZoneOptions.shouldCoalesceEventChangeDetection) {\n        performanceMarkFeature('NgZone_CoalesceEvent');\n      }\n      return new NgZone(ngZoneOptions);\n    },\n    scheduleInRootZone,\n  });\n  return makeEnvironmentProviders([{provide: PROVIDED_NG_ZONE, useValue: true}, zoneProviders]);\n}\n\n/**\n * Used to configure event and run coalescing with `provideZoneChangeDetection`.\n *\n * @publicApi\n *\n * @see {@link provideZoneChangeDetection}\n */\nexport interface NgZoneOptions {\n  /**\n   * Optionally specify coalescing event change detections or not.\n   * Consider the following case.\n   *\n   * ```html\n   * <div (click)=\"doSomething()\">\n   *   <button (click)=\"doSomethingElse()\"></button>\n   * </div>\n   * ```\n   *\n   * When button is clicked, because of the event bubbling, both\n   * event handlers will be called and 2 change detections will be\n   * triggered. We can coalesce such kind of events to trigger\n   * change detection only once.\n   *\n   * By default, this option is set to false, meaning events will\n   * not be coalesced, and change detection will be triggered multiple times.\n   * If this option is set to true, change detection will be triggered\n   * once in the scenario described above.\n   */\n  eventCoalescing?: boolean;\n\n  /**\n   * Optionally specify if `NgZone#run()` method invocations should be coalesced\n   * into a single change detection.\n   *\n   * Consider the following case.\n   * ```ts\n   * for (let i = 0; i < 10; i ++) {\n   *   ngZone.run(() => {\n   *     // do something\n   *   });\n   * }\n   * ```\n   *\n   * This case triggers the change detection multiple times.\n   * With ngZoneRunCoalescing options, all change detections in an event loop trigger only once.\n   * In addition, the change detection executes in requestAnimation.\n   *\n   */\n  runCoalescing?: boolean;\n}\n\n// Transforms a set of `BootstrapOptions` (supported by the NgModule-based bootstrap APIs) ->\n// `NgZoneOptions` that are recognized by the NgZone constructor. Passing no options will result in\n// a set of default options returned.\nexport function getNgZoneOptions(options?: NgZoneOptions): InternalNgZoneOptions {\n  return {\n    enableLongStackTrace: typeof ngDevMode === 'undefined' ? false : !!ngDevMode,\n    shouldCoalesceEventChangeDetection: options?.eventCoalescing ?? false,\n    shouldCoalesceRunChangeDetection: options?.runCoalescing ?? false,\n  };\n}\n\n@Injectable({providedIn: 'root'})\nexport class ZoneStablePendingTask {\n  private readonly subscription = new Subscription();\n  private initialized = false;\n  private readonly zone = inject(NgZone);\n  private readonly pendingTasks = inject(PendingTasksInternal);\n\n  initialize() {\n    if (this.initialized) {\n      return;\n    }\n    this.initialized = true;\n\n    let task: number | null = null;\n    if (!this.zone.isStable && !this.zone.hasPendingMacrotasks && !this.zone.hasPendingMicrotasks) {\n      task = this.pendingTasks.add();\n    }\n\n    this.zone.runOutsideAngular(() => {\n      this.subscription.add(\n        this.zone.onStable.subscribe(() => {\n          NgZone.assertNotInAngularZone();\n\n          // Check whether there are no pending macro/micro tasks in the next tick\n          // to allow for NgZone to update the state.\n          queueMicrotask(() => {\n            if (\n              task !== null &&\n              !this.zone.hasPendingMacrotasks &&\n              !this.zone.hasPendingMicrotasks\n            ) {\n              this.pendingTasks.remove(task);\n              task = null;\n            }\n          });\n        }),\n      );\n    });\n\n    this.subscription.add(\n      this.zone.onUnstable.subscribe(() => {\n        NgZone.assertInAngularZone();\n        task ??= this.pendingTasks.add();\n      }),\n    );\n  }\n\n  ngOnDestroy() {\n    this.subscription.unsubscribe();\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {IMAGE_CONFIG, ImageConfig} from './application/application_tokens';\nimport {Injectable} from './di';\nimport {inject} from './di/injector_compatibility';\nimport {formatRuntimeError, RuntimeErrorCode} from './errors';\nimport {OnDestroy} from './change_detection/lifecycle_hooks';\nimport {getDocument} from './render3/interfaces/document';\n\n// A delay in milliseconds before the scan is run after onLoad, to avoid any\n// potential race conditions with other LCP-related functions. This delay\n// happens outside of the main JavaScript execution and will only effect the timing\n// on when the warning becomes visible in the console.\nconst SCAN_DELAY = 200;\n\nconst OVERSIZED_IMAGE_TOLERANCE = 1200;\n\n@Injectable({providedIn: 'root'})\nexport class ImagePerformanceWarning implements OnDestroy {\n  // Map of full image URLs -> original `ngSrc` values.\n  private window: Window | null = null;\n  private observer: PerformanceObserver | null = null;\n  private options: ImageConfig = inject(IMAGE_CONFIG);\n  private lcpImageUrl?: string;\n\n  public start() {\n    if (\n      (typeof ngServerMode !== 'undefined' && ngServerMode) ||\n      typeof PerformanceObserver === 'undefined' ||\n      (this.options?.disableImageSizeWarning && this.options?.disableImageLazyLoadWarning)\n    ) {\n      return;\n    }\n    this.observer = this.initPerformanceObserver();\n    const doc = getDocument();\n    const win = doc.defaultView;\n    if (win) {\n      this.window = win;\n      // Wait to avoid race conditions where LCP image triggers\n      // load event before it's recorded by the performance observer\n      const waitToScan = () => {\n        setTimeout(this.scanImages.bind(this), SCAN_DELAY);\n      };\n      const setup = () => {\n        // Consider the case when the application is created and destroyed multiple times.\n        // Typically, applications are created instantly once the page is loaded, and the\n        // `window.load` listener is always triggered. However, the `window.load` event will never\n        // be fired if the page is loaded, and the application is created later. Checking for\n        // `readyState` is the easiest way to determine whether the page has been loaded or not.\n        if (doc.readyState === 'complete') {\n          waitToScan();\n        } else {\n          this.window?.addEventListener('load', waitToScan, {once: true});\n        }\n      };\n      // Angular doesn't have to run change detection whenever any asynchronous tasks are invoked in\n      // the scope of this functionality.\n      if (typeof Zone !== 'undefined') {\n        Zone.root.run(() => setup());\n      } else {\n        setup();\n      }\n    }\n  }\n\n  ngOnDestroy() {\n    this.observer?.disconnect();\n  }\n\n  private initPerformanceObserver(): PerformanceObserver | null {\n    if (typeof PerformanceObserver === 'undefined') {\n      return null;\n    }\n    const observer = new PerformanceObserver((entryList) => {\n      const entries = entryList.getEntries();\n      if (entries.length === 0) return;\n      // We use the latest entry produced by the `PerformanceObserver` as the best\n      // signal on which element is actually an LCP one. As an example, the first image to load on\n      // a page, by virtue of being the only thing on the page so far, is often a LCP candidate\n      // and gets reported by PerformanceObserver, but isn't necessarily the LCP element.\n      const lcpElement = entries[entries.length - 1];\n\n      // Cast to `any` due to missing `element` on the `LargestContentfulPaint` type of entry.\n      // See https://developer.mozilla.org/en-US/docs/Web/API/LargestContentfulPaint\n      const imgSrc = (lcpElement as any).element?.src ?? '';\n\n      // Exclude `data:` and `blob:` URLs, since they are fetched resources.\n      if (imgSrc.startsWith('data:') || imgSrc.startsWith('blob:')) return;\n      this.lcpImageUrl = imgSrc;\n    });\n    observer.observe({type: 'largest-contentful-paint', buffered: true});\n    return observer;\n  }\n\n  private scanImages(): void {\n    const images = getDocument().querySelectorAll('img');\n    let lcpElementFound,\n      lcpElementLoadedCorrectly = false;\n    // Important: do not refactor this to use `images.forEach` or\n    // `for (const ... of ...)`, because images might be a custom internal\n    // data structure — such as a lazily evaluated query result in Domino.\n    // (This naturally would never be a case in any browser).\n    for (let index = 0; index < images.length; index++) {\n      const image = images[index];\n\n      if (!image) {\n        continue;\n      }\n\n      if (!this.options?.disableImageSizeWarning) {\n        // Image elements using the NgOptimizedImage directive are excluded,\n        // as that directive has its own version of this check.\n        if (!image.getAttribute('ng-img') && this.isOversized(image)) {\n          logOversizedImageWarning(image.src);\n        }\n      }\n      if (!this.options?.disableImageLazyLoadWarning && this.lcpImageUrl) {\n        if (image.src === this.lcpImageUrl) {\n          lcpElementFound = true;\n          if (image.loading !== 'lazy' || image.getAttribute('ng-img')) {\n            // This variable is set to true and never goes back to false to account\n            // for the case where multiple images have the same src url, and some\n            // have lazy loading while others don't.\n            // Also ignore NgOptimizedImage because there's a different warning for that.\n            lcpElementLoadedCorrectly = true;\n          }\n        }\n      }\n    }\n    if (\n      lcpElementFound &&\n      !lcpElementLoadedCorrectly &&\n      this.lcpImageUrl &&\n      !this.options?.disableImageLazyLoadWarning\n    ) {\n      logLazyLCPWarning(this.lcpImageUrl);\n    }\n  }\n\n  private isOversized(image: HTMLImageElement): boolean {\n    if (!this.window) {\n      return false;\n    }\n\n    // The `isOversized` check may not be applicable or may require adjustments\n    // for several types of image formats or scenarios. Currently, we specify only\n    // `svg`, but this may also include `gif` since their quality isn’t tied to\n    // dimensions in the same way as raster images.\n    const nonOversizedImageExtentions = [\n      // SVG images are vector-based, which means they can scale\n      // to any size without losing quality.\n      '.svg',\n    ];\n\n    // Convert it to lowercase because this may have uppercase\n    // extensions, such as `IMAGE.SVG`.\n    // We fallback to an empty string because `src` may be `undefined`\n    // if it is explicitly set to `null` by some third-party code\n    // (e.g., `image.src = null`).\n    const imageSource = (image.src || '').toLowerCase();\n\n    if (nonOversizedImageExtentions.some((extension) => imageSource.endsWith(extension))) {\n      return false;\n    }\n\n    const computedStyle = this.window.getComputedStyle(image);\n    let renderedWidth = parseFloat(computedStyle.getPropertyValue('width'));\n    let renderedHeight = parseFloat(computedStyle.getPropertyValue('height'));\n    const boxSizing = computedStyle.getPropertyValue('box-sizing');\n    const objectFit = computedStyle.getPropertyValue('object-fit');\n\n    if (objectFit === `cover`) {\n      // Object fit cover may indicate a use case such as a sprite sheet where\n      // this warning does not apply.\n      return false;\n    }\n\n    if (boxSizing === 'border-box') {\n      // If the image `box-sizing` is set to `border-box`, we adjust the rendered\n      // dimensions by subtracting padding values.\n      const paddingTop = computedStyle.getPropertyValue('padding-top');\n      const paddingRight = computedStyle.getPropertyValue('padding-right');\n      const paddingBottom = computedStyle.getPropertyValue('padding-bottom');\n      const paddingLeft = computedStyle.getPropertyValue('padding-left');\n      renderedWidth -= parseFloat(paddingRight) + parseFloat(paddingLeft);\n      renderedHeight -= parseFloat(paddingTop) + parseFloat(paddingBottom);\n    }\n\n    const intrinsicWidth = image.naturalWidth;\n    const intrinsicHeight = image.naturalHeight;\n\n    const recommendedWidth = this.window.devicePixelRatio * renderedWidth;\n    const recommendedHeight = this.window.devicePixelRatio * renderedHeight;\n    const oversizedWidth = intrinsicWidth - recommendedWidth >= OVERSIZED_IMAGE_TOLERANCE;\n    const oversizedHeight = intrinsicHeight - recommendedHeight >= OVERSIZED_IMAGE_TOLERANCE;\n    return oversizedWidth || oversizedHeight;\n  }\n}\n\nfunction logLazyLCPWarning(src: string) {\n  console.warn(\n    formatRuntimeError(\n      RuntimeErrorCode.IMAGE_PERFORMANCE_WARNING,\n      `An image with src ${src} is the Largest Contentful Paint (LCP) element ` +\n        `but was given a \"loading\" value of \"lazy\", which can negatively impact ` +\n        `application loading performance. This warning can be addressed by ` +\n        `changing the loading value of the LCP image to \"eager\", or by using the ` +\n        `NgOptimizedImage directive's prioritization utilities. For more ` +\n        `information about addressing or disabling this warning, see ` +\n        `https://angular.dev/errors/NG0913`,\n    ),\n  );\n}\n\nfunction logOversizedImageWarning(src: string) {\n  console.warn(\n    formatRuntimeError(\n      RuntimeErrorCode.IMAGE_PERFORMANCE_WARNING,\n      `An image with src ${src} has intrinsic file dimensions much larger than its ` +\n        `rendered size. This can negatively impact application loading performance. ` +\n        `For more information about addressing or disabling this warning, see ` +\n        `https://angular.dev/errors/NG0913`,\n    ),\n  );\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\nimport {Subscription} from 'rxjs';\n\nimport {PROVIDED_NG_ZONE} from '../change_detection/scheduling/ng_zone_scheduling';\nimport {R3Injector} from '../di/r3_injector';\nimport {INTERNAL_APPLICATION_ERROR_HANDLER} from '../error_handler';\nimport {formatRuntimeError, RuntimeError, RuntimeErrorCode} from '../errors';\nimport {DEFAULT_LOCALE_ID} from '../i18n/localization';\nimport {LOCALE_ID} from '../i18n/tokens';\nimport {ImagePerformanceWarning} from '../image_performance_warning';\nimport {Type} from '../interface/type';\nimport {PLATFORM_DESTROY_LISTENERS} from './platform_destroy_listeners';\nimport {setLocaleId} from '../render3/i18n/i18n_locale_id';\nimport {NgZone} from '../zone/ng_zone';\n\nimport {ApplicationInitStatus} from '../application/application_init';\nimport {ApplicationRef, remove} from '../application/application_ref';\nimport {PROVIDED_ZONELESS} from '../change_detection/scheduling/zoneless_scheduling';\nimport {InjectionToken, Injector} from '../di';\nimport {InternalNgModuleRef, NgModuleRef} from '../linker/ng_module_factory';\nimport {stringify} from '../util/stringify';\nimport {isPromise} from '../util/lang';\nimport {PendingTasksInternal} from '../pending_tasks_internal';\n\nconst REQUIRE_ONE_CD_PROVIDER_BOOTSTRAP_MODULE = false;\n\n/**\n * InjectionToken to control root component bootstrap behavior.\n *\n * This token is primarily used in Angular's server-side rendering (SSR) scenarios,\n * particularly by the `@angular/ssr` package, to manage whether the root component\n * should be bootstrapped during the application initialization process.\n *\n * ## Purpose:\n * During SSR route extraction, setting this token to `false` prevents Angular from\n * bootstrapping the root component. This avoids unnecessary component rendering,\n * enabling route extraction without requiring additional APIs or triggering\n * component logic.\n *\n * ## Behavior:\n * - **`false`**: Prevents the root component from being bootstrapped.\n * - **`true`** (default): Proceeds with the normal root component bootstrap process.\n *\n * This mechanism ensures SSR can efficiently separate route extraction logic\n * from component rendering.\n */\nexport const ENABLE_ROOT_COMPONENT_BOOTSTRAP = new InjectionToken<boolean>(\n  typeof ngDevMode !== undefined && ngDevMode ? 'ENABLE_ROOT_COMPONENT_BOOTSTRAP' : '',\n);\n\nexport interface BootstrapConfig {\n  platformInjector: Injector;\n}\n\nexport interface ModuleBootstrapConfig<M> extends BootstrapConfig {\n  moduleRef: InternalNgModuleRef<M>;\n  allPlatformModules: NgModuleRef<unknown>[];\n}\n\nexport interface ApplicationBootstrapConfig extends BootstrapConfig {\n  r3Injector: R3Injector;\n  rootComponent: Type<unknown> | undefined;\n}\n\nfunction isApplicationBootstrapConfig(\n  config: ApplicationBootstrapConfig | ModuleBootstrapConfig<unknown>,\n): config is ApplicationBootstrapConfig {\n  return !(config as ModuleBootstrapConfig<unknown>).moduleRef;\n}\n\nexport function bootstrap<M>(\n  moduleBootstrapConfig: ModuleBootstrapConfig<M>,\n): Promise<NgModuleRef<M>>;\nexport function bootstrap(\n  applicationBootstrapConfig: ApplicationBootstrapConfig,\n): Promise<ApplicationRef>;\nexport function bootstrap<M>(\n  config: ModuleBootstrapConfig<M> | ApplicationBootstrapConfig,\n): Promise<ApplicationRef> | Promise<NgModuleRef<M>> {\n  const envInjector = isApplicationBootstrapConfig(config)\n    ? config.r3Injector\n    : config.moduleRef.injector;\n  const ngZone = envInjector.get(NgZone);\n  return ngZone.run(() => {\n    if (isApplicationBootstrapConfig(config)) {\n      config.r3Injector.resolveInjectorInitializers();\n    } else {\n      config.moduleRef.resolveInjectorInitializers();\n    }\n    const exceptionHandler = envInjector.get(INTERNAL_APPLICATION_ERROR_HANDLER);\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (envInjector.get(PROVIDED_ZONELESS) && envInjector.get(PROVIDED_NG_ZONE)) {\n        console.warn(\n          formatRuntimeError(\n            RuntimeErrorCode.PROVIDED_BOTH_ZONE_AND_ZONELESS,\n            'Both provideZoneChangeDetection and provideZonelessChangeDetection are provided. ' +\n              'This is likely a mistake. Update the application providers to use only one of the two.',\n          ),\n        );\n      }\n      if (!envInjector.get(PROVIDED_ZONELESS) && !envInjector.get(PROVIDED_NG_ZONE)) {\n        if (REQUIRE_ONE_CD_PROVIDER_BOOTSTRAP_MODULE && !isApplicationBootstrapConfig(config)) {\n          throw new Error(\n            'Missing change detection configuration: ' +\n              'please add either `provideZoneChangeDetection()` or `provideZonelessChangeDetection()` ' +\n              \"to the list of root providers in your application's bootstrap code.\",\n          );\n        }\n      }\n    }\n\n    let onErrorSubscription: Subscription;\n    ngZone.runOutsideAngular(() => {\n      onErrorSubscription = ngZone.onError.subscribe({\n        next: exceptionHandler,\n      });\n    });\n\n    // If the whole platform is destroyed, invoke the `destroy` method\n    // for all bootstrapped applications as well.\n    if (isApplicationBootstrapConfig(config)) {\n      const destroyListener = () => envInjector.destroy();\n      const onPlatformDestroyListeners = config.platformInjector.get(PLATFORM_DESTROY_LISTENERS);\n      onPlatformDestroyListeners.add(destroyListener);\n\n      envInjector.onDestroy(() => {\n        onErrorSubscription.unsubscribe();\n        onPlatformDestroyListeners.delete(destroyListener);\n      });\n    } else {\n      const destroyListener = () => config.moduleRef.destroy();\n      const onPlatformDestroyListeners = config.platformInjector.get(PLATFORM_DESTROY_LISTENERS);\n      onPlatformDestroyListeners.add(destroyListener);\n\n      config.moduleRef.onDestroy(() => {\n        remove(config.allPlatformModules, config.moduleRef);\n        onErrorSubscription.unsubscribe();\n        onPlatformDestroyListeners.delete(destroyListener);\n      });\n    }\n\n    return _callAndReportToErrorHandler(exceptionHandler, ngZone, () => {\n      const pendingTasks = envInjector.get(PendingTasksInternal);\n      const taskId = pendingTasks.add();\n      const initStatus = envInjector.get(ApplicationInitStatus);\n      initStatus.runInitializers();\n\n      return initStatus.donePromise\n        .then(() => {\n          // If the `LOCALE_ID` provider is defined at bootstrap then we set the value for ivy\n          const localeId = envInjector.get(LOCALE_ID, DEFAULT_LOCALE_ID);\n          setLocaleId(localeId || DEFAULT_LOCALE_ID);\n\n          const enableRootComponentbootstrap = envInjector.get(\n            ENABLE_ROOT_COMPONENT_BOOTSTRAP,\n            true,\n          );\n          if (!enableRootComponentbootstrap) {\n            if (isApplicationBootstrapConfig(config)) {\n              return envInjector.get(ApplicationRef);\n            }\n\n            config.allPlatformModules.push(config.moduleRef);\n            return config.moduleRef;\n          }\n\n          if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            const imagePerformanceService = envInjector.get(ImagePerformanceWarning);\n            imagePerformanceService.start();\n          }\n\n          if (isApplicationBootstrapConfig(config)) {\n            const appRef = envInjector.get(ApplicationRef);\n            if (config.rootComponent !== undefined) {\n              appRef.bootstrap(config.rootComponent);\n            }\n            return appRef;\n          } else {\n            moduleBootstrapImpl?.(config.moduleRef, config.allPlatformModules);\n            return config.moduleRef;\n          }\n        })\n        .finally(() => void pendingTasks.remove(taskId));\n    });\n  });\n}\n\n/**\n * Having a separate symbol for the module bootstrap implementation allows us to\n * tree shake the module based bootstrap implementation in standalone apps.\n */\nlet moduleBootstrapImpl: undefined | typeof _moduleDoBootstrap;\n\n/**\n * Set the implementation of the module based bootstrap.\n */\nexport function setModuleBootstrapImpl() {\n  moduleBootstrapImpl = _moduleDoBootstrap;\n}\n\nfunction _moduleDoBootstrap(\n  moduleRef: InternalNgModuleRef<any>,\n  allPlatformModules: NgModuleRef<unknown>[],\n): void {\n  const appRef = moduleRef.injector.get(ApplicationRef);\n  if (moduleRef._bootstrapComponents.length > 0) {\n    moduleRef._bootstrapComponents.forEach((f) => appRef.bootstrap(f));\n  } else if (moduleRef.instance.ngDoBootstrap) {\n    moduleRef.instance.ngDoBootstrap(appRef);\n  } else {\n    throw new RuntimeError(\n      RuntimeErrorCode.BOOTSTRAP_COMPONENTS_NOT_FOUND,\n      ngDevMode &&\n        `The module ${stringify(moduleRef.instance.constructor)} was bootstrapped, ` +\n          `but it does not declare \"@NgModule.bootstrap\" components nor a \"ngDoBootstrap\" method. ` +\n          `Please define one of these.`,\n    );\n  }\n  allPlatformModules.push(moduleRef);\n}\n\nfunction _callAndReportToErrorHandler(\n  errorHandler: (e: unknown) => void,\n  ngZone: NgZone,\n  callback: () => any,\n): any {\n  try {\n    const result = callback();\n    if (isPromise(result)) {\n      return result.catch((e: any) => {\n        ngZone.runOutsideAngular(() => errorHandler(e));\n        // rethrow as the exception handler might not do it\n        throw e;\n      });\n    }\n\n    return result;\n  } catch (e) {\n    ngZone.runOutsideAngular(() => errorHandler(e));\n    // rethrow as the exception handler might not do it\n    throw e;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {compileNgModuleFactory} from '../application/application_ngmodule_factory_compiler';\nimport {BootstrapOptions, optionsReducer} from '../application/application_ref';\nimport {validAppIdInitializer} from '../application/application_tokens';\nimport {provideZonelessChangeDetectionInternal} from '../change_detection/scheduling/zoneless_scheduling_impl';\nimport {EnvironmentProviders, Injectable, Injector, Provider, StaticProvider} from '../di';\nimport {errorHandlerEnvironmentInitializer} from '../error_handler';\nimport {RuntimeError, RuntimeErrorCode} from '../errors';\nimport {Type} from '../interface/type';\nimport {CompilerOptions} from '../linker';\nimport {NgModuleFactory, NgModuleRef} from '../linker/ng_module_factory';\nimport {createNgModuleRefWithProviders} from '../render3/ng_module_ref';\nimport {bootstrap, setModuleBootstrapImpl} from './bootstrap';\nimport {PLATFORM_DESTROY_LISTENERS} from './platform_destroy_listeners';\nimport {\n  getNgZoneOptions,\n  internalProvideZoneChangeDetection,\n} from '../change_detection/scheduling/ng_zone_scheduling';\nimport {getNgZone} from '../zone/ng_zone';\n\nconst ZONELESS_BY_DEFAULT = true;\n\n/**\n * The Angular platform is the entry point for Angular on a web page.\n * Each page has exactly one platform. Services (such as reflection) which are common\n * to every Angular application running on the page are bound in its scope.\n * A page's platform is initialized implicitly when a platform is created using a platform\n * factory such as `PlatformBrowser`, or explicitly by calling the `createPlatform()` function.\n *\n * @publicApi\n */\n@Injectable({providedIn: 'platform'})\nexport class PlatformRef {\n  private _modules: NgModuleRef<any>[] = [];\n  private _destroyListeners: Array<() => void> = [];\n  private _destroyed: boolean = false;\n\n  /** @internal */\n  constructor(private _injector: Injector) {}\n\n  /**\n   * Creates an instance of an `@NgModule` for the given platform.\n   *\n   * @deprecated Passing NgModule factories as the `PlatformRef.bootstrapModuleFactory` function\n   *     argument is deprecated. Use the `PlatformRef.bootstrapModule` API instead.\n   */\n  bootstrapModuleFactory<M>(\n    moduleFactory: NgModuleFactory<M>,\n    options?: BootstrapOptions & {applicationProviders?: Array<Provider | EnvironmentProviders>},\n  ): Promise<NgModuleRef<M>> {\n    const defaultZoneCdProviders = [];\n    if (!ZONELESS_BY_DEFAULT) {\n      const ngZoneFactory = () =>\n        getNgZone(options?.ngZone, {\n          ...getNgZoneOptions({\n            eventCoalescing: options?.ngZoneEventCoalescing,\n            runCoalescing: options?.ngZoneRunCoalescing,\n          }),\n        });\n      defaultZoneCdProviders.push(internalProvideZoneChangeDetection({ngZoneFactory}));\n    }\n    const allAppProviders = [\n      provideZonelessChangeDetectionInternal(),\n      ...defaultZoneCdProviders,\n      ...(options?.applicationProviders ?? []),\n      errorHandlerEnvironmentInitializer,\n      ...(ngDevMode ? [validAppIdInitializer] : []),\n    ];\n    const moduleRef = createNgModuleRefWithProviders(\n      moduleFactory.moduleType,\n      this.injector,\n      allAppProviders,\n    );\n\n    setModuleBootstrapImpl();\n    return bootstrap({\n      moduleRef,\n      allPlatformModules: this._modules,\n      platformInjector: this.injector,\n    });\n  }\n\n  /**\n   * Creates an instance of an `@NgModule` for a given platform.\n   *\n   * @usageNotes\n   * ### Simple Example\n   *\n   * ```ts\n   * @NgModule({\n   *   imports: [BrowserModule]\n   * })\n   * class MyModule {}\n   *\n   * let moduleRef = platformBrowser().bootstrapModule(MyModule);\n   * ```\n   *\n   */\n  bootstrapModule<M>(\n    moduleType: Type<M>,\n    compilerOptions:\n      | (CompilerOptions &\n          BootstrapOptions & {applicationProviders?: Array<Provider | EnvironmentProviders>})\n      | Array<\n          CompilerOptions &\n            BootstrapOptions & {applicationProviders?: Array<Provider | EnvironmentProviders>}\n        > = [],\n  ): Promise<NgModuleRef<M>> {\n    const options = optionsReducer({}, compilerOptions);\n    setModuleBootstrapImpl();\n    return compileNgModuleFactory(this.injector, options, moduleType).then((moduleFactory) =>\n      this.bootstrapModuleFactory(moduleFactory, options),\n    );\n  }\n\n  /**\n   * Registers a listener to be called when the platform is destroyed.\n   */\n  onDestroy(callback: () => void): void {\n    this._destroyListeners.push(callback);\n  }\n\n  /**\n   * Retrieves the platform {@link Injector}, which is the parent injector for\n   * every Angular application on the page and provides singleton providers.\n   */\n  get injector(): Injector {\n    return this._injector;\n  }\n\n  /**\n   * Destroys the current Angular platform and all Angular applications on the page.\n   * Destroys all modules and listeners registered with the platform.\n   */\n  destroy() {\n    if (this._destroyed) {\n      throw new RuntimeError(\n        RuntimeErrorCode.PLATFORM_ALREADY_DESTROYED,\n        ngDevMode && 'The platform has already been destroyed!',\n      );\n    }\n    this._modules.slice().forEach((module) => module.destroy());\n    this._destroyListeners.forEach((listener) => listener());\n\n    const destroyListeners = this._injector.get(PLATFORM_DESTROY_LISTENERS, null);\n    if (destroyListeners) {\n      destroyListeners.forEach((listener) => listener());\n      destroyListeners.clear();\n    }\n\n    this._destroyed = true;\n  }\n\n  /**\n   * Indicates whether this instance was destroyed.\n   */\n  get destroyed() {\n    return this._destroyed;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  publishDefaultGlobalUtils,\n  publishSignalConfiguration,\n} from '../application/application_ref';\nimport {PLATFORM_INITIALIZER} from '../application/application_tokens';\nimport {\n  EnvironmentProviders,\n  InjectionToken,\n  Injector,\n  makeEnvironmentProviders,\n  runInInjectionContext,\n  StaticProvider,\n} from '../di';\nimport {INJECTOR_SCOPE} from '../di/scope';\nimport {RuntimeError, RuntimeErrorCode} from '../errors';\n\nimport {PlatformRef} from './platform_ref';\nimport {PLATFORM_DESTROY_LISTENERS} from './platform_destroy_listeners';\n\nlet _platformInjector: Injector | null = null;\n\n/**\n * Creates a platform.\n * Platforms must be created on launch using this function.\n *\n * @publicApi\n */\nexport function createPlatform(injector: Injector): PlatformRef {\n  if (getPlatform()) {\n    throw new RuntimeError(\n      RuntimeErrorCode.MULTIPLE_PLATFORMS,\n      ngDevMode && 'There can be only one platform. Destroy the previous one to create a new one.',\n    );\n  }\n\n  publishDefaultGlobalUtils();\n  publishSignalConfiguration();\n\n  // During SSR, using this setting and using an injector from the global can cause the\n  // injector to be used for a different requjest due to concurrency.\n  _platformInjector = typeof ngServerMode === 'undefined' || !ngServerMode ? injector : null;\n\n  const platform = injector.get(PlatformRef);\n  runPlatformInitializers(injector);\n  return platform;\n}\n\n/**\n * Creates a factory for a platform. Can be used to provide or override `Providers` specific to\n * your application's runtime needs, such as `PLATFORM_INITIALIZER` and `PLATFORM_ID`.\n * @param parentPlatformFactory Another platform factory to modify. Allows you to compose factories\n * to build up configurations that might be required by different libraries or parts of the\n * application.\n * @param name Identifies the new platform factory.\n * @param providers A set of dependency providers for platforms created with the new factory.\n *\n * @publicApi\n */\nexport function createPlatformFactory(\n  parentPlatformFactory: ((extraProviders?: StaticProvider[]) => PlatformRef) | null,\n  name: string,\n  providers: StaticProvider[] = [],\n): (extraProviders?: StaticProvider[]) => PlatformRef {\n  const desc = `Platform: ${name}`;\n  const marker = new InjectionToken(desc);\n  return (extraProviders: StaticProvider[] = []) => {\n    let platform = getPlatform();\n    if (!platform) {\n      const platformProviders: StaticProvider[] = [\n        ...providers,\n        ...extraProviders,\n        {provide: marker, useValue: true},\n      ];\n\n      platform =\n        parentPlatformFactory?.(platformProviders) ??\n        createPlatform(createPlatformInjector(platformProviders, desc));\n    }\n\n    return typeof ngServerMode !== 'undefined' && ngServerMode ? platform : assertPlatform(marker);\n  };\n}\n\n/**\n * Helper function to create an instance of a platform injector (that maintains the 'platform'\n * scope).\n */\nfunction createPlatformInjector(providers: StaticProvider[] = [], name?: string): Injector {\n  return Injector.create({\n    name,\n    providers: [\n      {provide: INJECTOR_SCOPE, useValue: 'platform'},\n      {provide: PLATFORM_DESTROY_LISTENERS, useValue: new Set([() => (_platformInjector = null)])},\n      ...providers,\n    ],\n  });\n}\n\n/**\n * Checks that there is currently a platform that contains the given token as a provider.\n *\n * @publicApi\n */\nexport function assertPlatform(requiredToken: any): PlatformRef {\n  const platform = getPlatform();\n  if (!platform) {\n    throw new RuntimeError(RuntimeErrorCode.PLATFORM_NOT_FOUND, ngDevMode && 'No platform exists!');\n  }\n\n  if (\n    (typeof ngDevMode === 'undefined' || ngDevMode) &&\n    !platform.injector.get(requiredToken, null)\n  ) {\n    throw new RuntimeError(\n      RuntimeErrorCode.MULTIPLE_PLATFORMS,\n      'A platform with a different configuration has been created. Please destroy it first.',\n    );\n  }\n\n  return platform;\n}\n\n/**\n * Returns the current platform in the browser environment. In the server environment,\n * returns `null`. If you need access to the platform information, inject `PlatformRef` in your application.\n *\n * @publicApi\n */\nexport function getPlatform(): PlatformRef | null {\n  if (typeof ngServerMode !== 'undefined' && ngServerMode) {\n    return null;\n  }\n\n  return _platformInjector?.get(PlatformRef) ?? null;\n}\n\n/**\n * Destroys the current Angular platform and all Angular applications on the page.\n * Destroys all modules and listeners registered with the platform.\n *\n * This function should not be used in a server environment, as it will be a no-op.\n *\n * @publicApi\n */\nexport function destroyPlatform(): void {\n  getPlatform()?.destroy();\n}\n\n/**\n * The goal of this function is to bootstrap a platform injector,\n * but avoid referencing `PlatformRef` class.\n * This function is needed for bootstrapping a Standalone Component.\n */\nexport function createOrReusePlatformInjector(providers: StaticProvider[] = []): Injector {\n  // If a platform injector already exists, it means that the platform\n  // is already bootstrapped and no additional actions are required.\n  if (_platformInjector) return _platformInjector;\n\n  publishDefaultGlobalUtils();\n\n  // Otherwise, setup a new platform injector and run platform initializers.\n  const injector = createPlatformInjector(providers);\n\n  // During SSR, using this setting and using an injector from the global can cause the\n  // injector to be used for a different request due to concurrency.\n  if (typeof ngServerMode === 'undefined' || !ngServerMode) {\n    _platformInjector = injector;\n  }\n\n  publishSignalConfiguration();\n  runPlatformInitializers(injector);\n  return injector;\n}\n\n/**\n * @description\n * This function is used to provide initialization functions that will be executed upon\n * initialization of the platform injector.\n *\n * Note that the provided initializer is run in the injection context.\n *\n * Previously, this was achieved using the `PLATFORM_INITIALIZER` token which is now deprecated.\n *\n * @see {@link PLATFORM_INITIALIZER}\n *\n * @publicApi\n */\nexport function providePlatformInitializer(initializerFn: () => void): EnvironmentProviders {\n  return makeEnvironmentProviders([\n    {\n      provide: PLATFORM_INITIALIZER,\n      useValue: initializerFn,\n      multi: true,\n    },\n  ]);\n}\n\nfunction runPlatformInitializers(injector: Injector): void {\n  const inits = injector.get(PLATFORM_INITIALIZER, null);\n  runInInjectionContext(injector, () => {\n    inits?.forEach((init) => init());\n  });\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ApplicationRef} from '../../application/application_ref';\nimport {ChangeDetectionSchedulerImpl} from './zoneless_scheduling_impl';\nimport {inject} from '../../di/injector_compatibility';\nimport {provideEnvironmentInitializer} from '../../di/provider_collection';\nimport {NgZone} from '../../zone/ng_zone';\n\nimport {ErrorHandler} from '../../error_handler';\nimport {checkNoChangesInternal} from '../../render3/instructions/change_detection';\n\nexport function exhaustiveCheckNoChangesInterval(interval: number) {\n  return provideEnvironmentInitializer(() => {\n    const applicationRef = inject(ApplicationRef);\n    const errorHandler = inject(ErrorHandler);\n    const scheduler = inject(ChangeDetectionSchedulerImpl);\n    const ngZone = inject(NgZone);\n\n    function scheduleCheckNoChanges() {\n      ngZone.runOutsideAngular(() => {\n        setTimeout(() => {\n          if (applicationRef.destroyed) {\n            return;\n          }\n          if (scheduler.pendingRenderTaskId || scheduler.runningTick) {\n            scheduleCheckNoChanges();\n            return;\n          }\n\n          for (const view of applicationRef.allViews) {\n            try {\n              checkNoChangesInternal(view._lView, true /** exhaustive */);\n            } catch (e) {\n              errorHandler.handleError(e);\n            }\n          }\n\n          scheduleCheckNoChanges();\n        }, interval);\n      });\n    }\n    scheduleCheckNoChanges();\n  });\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {EnvironmentProviders, makeEnvironmentProviders} from '../di';\nimport {UseExhaustiveCheckNoChanges} from './use_exhaustive_check_no_changes';\nimport {exhaustiveCheckNoChangesInterval} from './scheduling/exhaustive_check_no_changes';\n\n/**\n * Used to disable exhaustive checks when verifying no expressions changed after they were checked.\n *\n * This means that `OnPush` components that are not marked for check will not be checked.\n * This behavior is the current default behavior in Angular. When running change detection\n * on a view tree, views marked for check are refreshed and the flag to check it is removed.\n * When Angular checks views a second time to ensure nothing has changed, `OnPush` components\n * will no longer be marked and not be checked.\n *\n * @developerPreview 20.0\n */\nexport function provideCheckNoChangesConfig(options: {exhaustive: false}): EnvironmentProviders;\n/**\n * - `interval` will periodically run `checkNoChanges` on application views. This can be useful\n *   in zoneless applications to periodically ensure no changes have been made without notifying\n *   Angular that templates need to be refreshed.\n * - The exhaustive option will treat all application views as if they were `ChangeDetectionStrategy.Default` when verifying\n *   no expressions have changed. All views attached to `ApplicationRef` and all the descendants of\n *   those views will be checked for changes (excluding those subtrees which are detached via `ChangeDetectorRef.detach()`).\n *   This is useful because the check that runs after regular change detection does not work for components using `ChangeDetectionStrategy.OnPush`.\n *   This check is will surface any existing errors hidden by `OnPush` components.\n *\n * @developerPreview 20.0\n */\nexport function provideCheckNoChangesConfig(options: {\n  interval?: number;\n  exhaustive: true;\n}): EnvironmentProviders;\nexport function provideCheckNoChangesConfig(options: {\n  interval?: number;\n  exhaustive: boolean;\n}): EnvironmentProviders {\n  return makeEnvironmentProviders(\n    typeof ngDevMode === 'undefined' || ngDevMode\n      ? [\n          {\n            provide: UseExhaustiveCheckNoChanges,\n            useValue: options.exhaustive,\n          },\n          options?.interval !== undefined ? exhaustiveCheckNoChangesInterval(options.interval) : [],\n        ]\n      : [],\n  );\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Type} from '../interface/type';\nimport {NgModuleFactory as R3NgModuleFactory} from '../render3/ng_module_ref';\n\nimport {NgModuleFactory} from './ng_module_factory';\nimport {getRegisteredNgModuleType} from './ng_module_registration';\n\n/**\n * Returns the NgModuleFactory with the given id (specified using [@NgModule.id\n * field](api/core/NgModule#id)), if it exists and has been loaded. Factories for NgModules that do\n * not specify an `id` cannot be retrieved. Throws if an NgModule cannot be found.\n * @publicApi\n * @deprecated Use `getNgModuleById` instead.\n */\nexport function getModuleFactory(id: string): NgModuleFactory<any> {\n  const type = getRegisteredNgModuleType(id);\n  if (!type) throw noModuleError(id);\n  return new R3NgModuleFactory(type);\n}\n\n/**\n * Returns the NgModule class with the given id (specified using [@NgModule.id\n * field](api/core/NgModule#id)), if it exists and has been loaded. Classes for NgModules that do\n * not specify an `id` cannot be retrieved. Throws if an NgModule cannot be found.\n * @publicApi\n */\nexport function getNgModuleById<T>(id: string): Type<T> {\n  const type = getRegisteredNgModuleType(id);\n  if (!type) throw noModuleError(id);\n  return type;\n}\n\nfunction noModuleError(id: string): Error {\n  return new Error(`No module with ID ${id} loaded`);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ChangeDetectorRef} from '../change_detection/change_detector_ref';\n\n/**\n * Represents an Angular view.\n *\n * @see {@link /api/core/ChangeDetectorRef?tab=usage-notes Change detection usage}\n *\n * @publicApi\n */\nexport abstract class ViewRef extends ChangeDetectorRef {\n  /**\n   * Destroys this view and all of the data structures associated with it.\n   */\n  abstract destroy(): void;\n\n  /**\n   * Reports whether this view has been destroyed.\n   * @returns True after the `destroy()` method has been called, false otherwise.\n   */\n  abstract get destroyed(): boolean;\n\n  /**\n   * A lifecycle hook that provides additional developer-defined cleanup\n   * functionality for views.\n   * @param callback A handler function that cleans up developer-defined data\n   * associated with a view. Called when the `destroy()` method is invoked.\n   */\n  abstract onDestroy(callback: Function): void;\n}\n\n/**\n * Represents an Angular view in a view container.\n * An embedded view can be referenced from a component\n * other than the hosting component whose template defines it, or it can be defined\n * independently by a `TemplateRef`.\n *\n * Properties of elements in a view can change, but the structure (number and order) of elements in\n * a view cannot. Change the structure of elements by inserting, moving, or\n * removing nested views in a view container.\n *\n * @see {@link ViewContainerRef}\n *\n * @usageNotes\n *\n * The following template breaks down into two separate `TemplateRef` instances,\n * an outer one and an inner one.\n *\n * ```html\n * Count: {{items.length}}\n * <ul>\n *   <li *ngFor=\"let  item of items\">{{item}}</li>\n * </ul>\n * ```\n *\n * This is the outer `TemplateRef`:\n *\n * ```html\n * Count: {{items.length}}\n * <ul>\n *   <ng-template ngFor let-item [ngForOf]=\"items\"></ng-template>\n * </ul>\n * ```\n *\n * This is the inner `TemplateRef`:\n *\n * ```html\n *   <li>{{item}}</li>\n * ```\n *\n * The outer and inner `TemplateRef` instances are assembled into views as follows:\n *\n * ```html\n * <!-- ViewRef: outer-0 -->\n * Count: 2\n * <ul>\n *   <ng-template view-container-ref></ng-template>\n *   <!-- ViewRef: inner-1 --><li>first</li><!-- /ViewRef: inner-1 -->\n *   <!-- ViewRef: inner-2 --><li>second</li><!-- /ViewRef: inner-2 -->\n * </ul>\n * <!-- /ViewRef: outer-0 -->\n * ```\n * @publicApi\n */\nexport abstract class EmbeddedViewRef<C> extends ViewRef {\n  /**\n   * The context for this view, inherited from the anchor element.\n   */\n  abstract context: C;\n\n  /**\n   * The root nodes for this embedded view.\n   */\n  abstract get rootNodes(): any[];\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {RuntimeError, RuntimeErrorCode} from '../../errors';\nimport {Writable} from '../../interface/type';\nimport {isListLikeIterable, iterateListLike} from '../../util/iterable';\nimport {stringify} from '../../util/stringify';\n\nimport type {\n  IterableChangeRecord,\n  IterableChanges,\n  IterableDiffer,\n  IterableDifferFactory,\n  NgIterable,\n  TrackByFunction,\n} from './iterable_differs';\n\nexport class DefaultIterableDifferFactory implements IterableDifferFactory {\n  constructor() {}\n  supports(obj: Object | null | undefined): boolean {\n    return isListLikeIterable(obj);\n  }\n\n  create<V>(trackByFn?: TrackByFunction<V>): DefaultIterableDiffer<V> {\n    return new DefaultIterableDiffer<V>(trackByFn);\n  }\n}\n\nconst trackByIdentity = (index: number, item: any) => item;\n\n/**\n * @deprecated v4.0.0 - Should not be part of public API.\n * @publicApi\n */\nexport class DefaultIterableDiffer<V> implements IterableDiffer<V>, IterableChanges<V> {\n  public readonly length: number = 0;\n  // TODO: confirm the usage of `collection` as it's unused, readonly and on a non public API.\n  public readonly collection!: V[] | Iterable<V> | null;\n  // Keeps track of the used records at any point in time (during & across `_check()` calls)\n  private _linkedRecords: _DuplicateMap<V> | null = null;\n  // Keeps track of the removed records at any point in time during `_check()` calls.\n  private _unlinkedRecords: _DuplicateMap<V> | null = null;\n  private _previousItHead: IterableChangeRecord_<V> | null = null;\n  private _itHead: IterableChangeRecord_<V> | null = null;\n  private _itTail: IterableChangeRecord_<V> | null = null;\n  private _additionsHead: IterableChangeRecord_<V> | null = null;\n  private _additionsTail: IterableChangeRecord_<V> | null = null;\n  private _movesHead: IterableChangeRecord_<V> | null = null;\n  private _movesTail: IterableChangeRecord_<V> | null = null;\n  private _removalsHead: IterableChangeRecord_<V> | null = null;\n  private _removalsTail: IterableChangeRecord_<V> | null = null;\n  // Keeps track of records where custom track by is the same, but item identity has changed\n  private _identityChangesHead: IterableChangeRecord_<V> | null = null;\n  private _identityChangesTail: IterableChangeRecord_<V> | null = null;\n  private _trackByFn: TrackByFunction<V>;\n\n  constructor(trackByFn?: TrackByFunction<V>) {\n    this._trackByFn = trackByFn || trackByIdentity;\n  }\n\n  forEachItem(fn: (record: IterableChangeRecord_<V>) => void) {\n    let record: IterableChangeRecord_<V> | null;\n    for (record = this._itHead; record !== null; record = record._next) {\n      fn(record);\n    }\n  }\n\n  forEachOperation(\n    fn: (\n      item: IterableChangeRecord<V>,\n      previousIndex: number | null,\n      currentIndex: number | null,\n    ) => void,\n  ) {\n    let nextIt = this._itHead;\n    let nextRemove = this._removalsHead;\n    let addRemoveOffset = 0;\n    let moveOffsets: number[] | null = null;\n    while (nextIt || nextRemove) {\n      // Figure out which is the next record to process\n      // Order: remove, add, move\n      const record: IterableChangeRecord<V> =\n        !nextRemove ||\n        (nextIt &&\n          nextIt.currentIndex! < getPreviousIndex(nextRemove, addRemoveOffset, moveOffsets))\n          ? nextIt!\n          : nextRemove;\n      const adjPreviousIndex = getPreviousIndex(record, addRemoveOffset, moveOffsets);\n      const currentIndex = record.currentIndex;\n\n      // consume the item, and adjust the addRemoveOffset and update moveDistance if necessary\n      if (record === nextRemove) {\n        addRemoveOffset--;\n        nextRemove = nextRemove._nextRemoved;\n      } else {\n        nextIt = nextIt!._next;\n        if (record.previousIndex == null) {\n          addRemoveOffset++;\n        } else {\n          // INVARIANT:  currentIndex < previousIndex\n          if (!moveOffsets) moveOffsets = [];\n          const localMovePreviousIndex = adjPreviousIndex - addRemoveOffset;\n          const localCurrentIndex = currentIndex! - addRemoveOffset;\n          if (localMovePreviousIndex != localCurrentIndex) {\n            for (let i = 0; i < localMovePreviousIndex; i++) {\n              const offset = i < moveOffsets.length ? moveOffsets[i] : (moveOffsets[i] = 0);\n              const index = offset + i;\n              if (localCurrentIndex <= index && index < localMovePreviousIndex) {\n                moveOffsets[i] = offset + 1;\n              }\n            }\n            const previousIndex = record.previousIndex;\n            moveOffsets[previousIndex] = localCurrentIndex - localMovePreviousIndex;\n          }\n        }\n      }\n\n      if (adjPreviousIndex !== currentIndex) {\n        fn(record, adjPreviousIndex, currentIndex);\n      }\n    }\n  }\n\n  forEachPreviousItem(fn: (record: IterableChangeRecord_<V>) => void) {\n    let record: IterableChangeRecord_<V> | null;\n    for (record = this._previousItHead; record !== null; record = record._nextPrevious) {\n      fn(record);\n    }\n  }\n\n  forEachAddedItem(fn: (record: IterableChangeRecord_<V>) => void) {\n    let record: IterableChangeRecord_<V> | null;\n    for (record = this._additionsHead; record !== null; record = record._nextAdded) {\n      fn(record);\n    }\n  }\n\n  forEachMovedItem(fn: (record: IterableChangeRecord_<V>) => void) {\n    let record: IterableChangeRecord_<V> | null;\n    for (record = this._movesHead; record !== null; record = record._nextMoved) {\n      fn(record);\n    }\n  }\n\n  forEachRemovedItem(fn: (record: IterableChangeRecord_<V>) => void) {\n    let record: IterableChangeRecord_<V> | null;\n    for (record = this._removalsHead; record !== null; record = record._nextRemoved) {\n      fn(record);\n    }\n  }\n\n  forEachIdentityChange(fn: (record: IterableChangeRecord_<V>) => void) {\n    let record: IterableChangeRecord_<V> | null;\n    for (record = this._identityChangesHead; record !== null; record = record._nextIdentityChange) {\n      fn(record);\n    }\n  }\n\n  diff(collection: NgIterable<V> | null | undefined): DefaultIterableDiffer<V> | null {\n    if (collection == null) collection = [];\n    if (!isListLikeIterable(collection)) {\n      throw new RuntimeError(\n        RuntimeErrorCode.INVALID_DIFFER_INPUT,\n        ngDevMode &&\n          `Error trying to diff '${stringify(collection)}'. Only arrays and iterables are allowed`,\n      );\n    }\n\n    if (this.check(collection)) {\n      return this;\n    } else {\n      return null;\n    }\n  }\n\n  onDestroy() {}\n\n  check(collection: NgIterable<V>): boolean {\n    this._reset();\n\n    let record: IterableChangeRecord_<V> | null = this._itHead;\n    let mayBeDirty: boolean = false;\n    let index: number;\n    let item: V;\n    let itemTrackBy: any;\n    if (Array.isArray(collection)) {\n      (this as Writable<this>).length = collection.length;\n\n      for (let index = 0; index < this.length; index++) {\n        item = collection[index];\n        itemTrackBy = this._trackByFn(index, item);\n        if (record === null || !Object.is(record.trackById, itemTrackBy)) {\n          record = this._mismatch(record, item, itemTrackBy, index);\n          mayBeDirty = true;\n        } else {\n          if (mayBeDirty) {\n            // TODO(misko): can we limit this to duplicates only?\n            record = this._verifyReinsertion(record, item, itemTrackBy, index);\n          }\n          if (!Object.is(record.item, item)) this._addIdentityChange(record, item);\n        }\n\n        record = record._next;\n      }\n    } else {\n      index = 0;\n      iterateListLike(collection, (item: V) => {\n        itemTrackBy = this._trackByFn(index, item);\n        if (record === null || !Object.is(record.trackById, itemTrackBy)) {\n          record = this._mismatch(record, item, itemTrackBy, index);\n          mayBeDirty = true;\n        } else {\n          if (mayBeDirty) {\n            // TODO(misko): can we limit this to duplicates only?\n            record = this._verifyReinsertion(record, item, itemTrackBy, index);\n          }\n          if (!Object.is(record.item, item)) this._addIdentityChange(record, item);\n        }\n        record = record._next;\n        index++;\n      });\n      (this as Writable<this>).length = index;\n    }\n\n    this._truncate(record);\n    (this as Writable<this>).collection = collection;\n    return this.isDirty;\n  }\n\n  /* CollectionChanges is considered dirty if it has any additions, moves, removals, or identity\n   * changes.\n   */\n  get isDirty(): boolean {\n    return (\n      this._additionsHead !== null ||\n      this._movesHead !== null ||\n      this._removalsHead !== null ||\n      this._identityChangesHead !== null\n    );\n  }\n\n  /**\n   * Reset the state of the change objects to show no changes. This means set previousKey to\n   * currentKey, and clear all of the queues (additions, moves, removals).\n   * Set the previousIndexes of moved and added items to their currentIndexes\n   * Reset the list of additions, moves and removals\n   *\n   * @internal\n   */\n  _reset() {\n    if (this.isDirty) {\n      let record: IterableChangeRecord_<V> | null;\n\n      for (record = this._previousItHead = this._itHead; record !== null; record = record._next) {\n        record._nextPrevious = record._next;\n      }\n\n      for (record = this._additionsHead; record !== null; record = record._nextAdded) {\n        record.previousIndex = record.currentIndex;\n      }\n      this._additionsHead = this._additionsTail = null;\n\n      for (record = this._movesHead; record !== null; record = record._nextMoved) {\n        record.previousIndex = record.currentIndex;\n      }\n      this._movesHead = this._movesTail = null;\n      this._removalsHead = this._removalsTail = null;\n      this._identityChangesHead = this._identityChangesTail = null;\n\n      // TODO(vicb): when assert gets supported\n      // assert(!this.isDirty);\n    }\n  }\n\n  /**\n   * This is the core function which handles differences between collections.\n   *\n   * - `record` is the record which we saw at this position last time. If null then it is a new\n   *   item.\n   * - `item` is the current item in the collection\n   * - `index` is the position of the item in the collection\n   *\n   * @internal\n   */\n  _mismatch(\n    record: IterableChangeRecord_<V> | null,\n    item: V,\n    itemTrackBy: any,\n    index: number,\n  ): IterableChangeRecord_<V> {\n    // The previous record after which we will append the current one.\n    let previousRecord: IterableChangeRecord_<V> | null;\n\n    if (record === null) {\n      previousRecord = this._itTail;\n    } else {\n      previousRecord = record._prev;\n      // Remove the record from the collection since we know it does not match the item.\n      this._remove(record);\n    }\n\n    // See if we have evicted the item, which used to be at some anterior position of _itHead list.\n    record = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy, null);\n    if (record !== null) {\n      // It is an item which we have evicted earlier: reinsert it back into the list.\n      // But first we need to check if identity changed, so we can update in view if necessary.\n      if (!Object.is(record.item, item)) this._addIdentityChange(record, item);\n\n      this._reinsertAfter(record, previousRecord, index);\n    } else {\n      // Attempt to see if the item is at some posterior position of _itHead list.\n      record = this._linkedRecords === null ? null : this._linkedRecords.get(itemTrackBy, index);\n      if (record !== null) {\n        // We have the item in _itHead at/after `index` position. We need to move it forward in the\n        // collection.\n        // But first we need to check if identity changed, so we can update in view if necessary.\n        if (!Object.is(record.item, item)) this._addIdentityChange(record, item);\n\n        this._moveAfter(record, previousRecord, index);\n      } else {\n        // It is a new item: add it.\n        record = this._addAfter(\n          new IterableChangeRecord_<V>(item, itemTrackBy),\n          previousRecord,\n          index,\n        );\n      }\n    }\n    return record;\n  }\n\n  /**\n   * This check is only needed if an array contains duplicates. (Short circuit of nothing dirty)\n   *\n   * Use case: `[a, a]` => `[b, a, a]`\n   *\n   * If we did not have this check then the insertion of `b` would:\n   *   1) evict first `a`\n   *   2) insert `b` at `0` index.\n   *   3) leave `a` at index `1` as is. <-- this is wrong!\n   *   3) reinsert `a` at index 2. <-- this is wrong!\n   *\n   * The correct behavior is:\n   *   1) evict first `a`\n   *   2) insert `b` at `0` index.\n   *   3) reinsert `a` at index 1.\n   *   3) move `a` at from `1` to `2`.\n   *\n   *\n   * Double check that we have not evicted a duplicate item. We need to check if the item type may\n   * have already been removed:\n   * The insertion of b will evict the first 'a'. If we don't reinsert it now it will be reinserted\n   * at the end. Which will show up as the two 'a's switching position. This is incorrect, since a\n   * better way to think of it is as insert of 'b' rather then switch 'a' with 'b' and then add 'a'\n   * at the end.\n   *\n   * @internal\n   */\n  _verifyReinsertion(\n    record: IterableChangeRecord_<V>,\n    item: V,\n    itemTrackBy: any,\n    index: number,\n  ): IterableChangeRecord_<V> {\n    let reinsertRecord: IterableChangeRecord_<V> | null =\n      this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy, null);\n    if (reinsertRecord !== null) {\n      record = this._reinsertAfter(reinsertRecord, record._prev!, index);\n    } else if (record.currentIndex != index) {\n      record.currentIndex = index;\n      this._addToMoves(record, index);\n    }\n    return record;\n  }\n\n  /**\n   * Get rid of any excess {@link IterableChangeRecord_}s from the previous collection\n   *\n   * - `record` The first excess {@link IterableChangeRecord_}.\n   *\n   * @internal\n   */\n  _truncate(record: IterableChangeRecord_<V> | null) {\n    // Anything after that needs to be removed;\n    while (record !== null) {\n      const nextRecord: IterableChangeRecord_<V> | null = record._next;\n      this._addToRemovals(this._unlink(record));\n      record = nextRecord;\n    }\n    if (this._unlinkedRecords !== null) {\n      this._unlinkedRecords.clear();\n    }\n\n    if (this._additionsTail !== null) {\n      this._additionsTail._nextAdded = null;\n    }\n    if (this._movesTail !== null) {\n      this._movesTail._nextMoved = null;\n    }\n    if (this._itTail !== null) {\n      this._itTail._next = null;\n    }\n    if (this._removalsTail !== null) {\n      this._removalsTail._nextRemoved = null;\n    }\n    if (this._identityChangesTail !== null) {\n      this._identityChangesTail._nextIdentityChange = null;\n    }\n  }\n\n  /** @internal */\n  _reinsertAfter(\n    record: IterableChangeRecord_<V>,\n    prevRecord: IterableChangeRecord_<V> | null,\n    index: number,\n  ): IterableChangeRecord_<V> {\n    if (this._unlinkedRecords !== null) {\n      this._unlinkedRecords.remove(record);\n    }\n    const prev = record._prevRemoved;\n    const next = record._nextRemoved;\n\n    if (prev === null) {\n      this._removalsHead = next;\n    } else {\n      prev._nextRemoved = next;\n    }\n    if (next === null) {\n      this._removalsTail = prev;\n    } else {\n      next._prevRemoved = prev;\n    }\n\n    this._insertAfter(record, prevRecord, index);\n    this._addToMoves(record, index);\n    return record;\n  }\n\n  /** @internal */\n  _moveAfter(\n    record: IterableChangeRecord_<V>,\n    prevRecord: IterableChangeRecord_<V> | null,\n    index: number,\n  ): IterableChangeRecord_<V> {\n    this._unlink(record);\n    this._insertAfter(record, prevRecord, index);\n    this._addToMoves(record, index);\n    return record;\n  }\n\n  /** @internal */\n  _addAfter(\n    record: IterableChangeRecord_<V>,\n    prevRecord: IterableChangeRecord_<V> | null,\n    index: number,\n  ): IterableChangeRecord_<V> {\n    this._insertAfter(record, prevRecord, index);\n\n    if (this._additionsTail === null) {\n      // TODO(vicb):\n      // assert(this._additionsHead === null);\n      this._additionsTail = this._additionsHead = record;\n    } else {\n      // TODO(vicb):\n      // assert(_additionsTail._nextAdded === null);\n      // assert(record._nextAdded === null);\n      this._additionsTail = this._additionsTail._nextAdded = record;\n    }\n    return record;\n  }\n\n  /** @internal */\n  _insertAfter(\n    record: IterableChangeRecord_<V>,\n    prevRecord: IterableChangeRecord_<V> | null,\n    index: number,\n  ): IterableChangeRecord_<V> {\n    // TODO(vicb):\n    // assert(record != prevRecord);\n    // assert(record._next === null);\n    // assert(record._prev === null);\n\n    const next: IterableChangeRecord_<V> | null =\n      prevRecord === null ? this._itHead : prevRecord._next;\n    // TODO(vicb):\n    // assert(next != record);\n    // assert(prevRecord != record);\n    record._next = next;\n    record._prev = prevRecord;\n    if (next === null) {\n      this._itTail = record;\n    } else {\n      next._prev = record;\n    }\n    if (prevRecord === null) {\n      this._itHead = record;\n    } else {\n      prevRecord._next = record;\n    }\n\n    if (this._linkedRecords === null) {\n      this._linkedRecords = new _DuplicateMap<V>();\n    }\n    this._linkedRecords.put(record);\n\n    record.currentIndex = index;\n    return record;\n  }\n\n  /** @internal */\n  _remove(record: IterableChangeRecord_<V>): IterableChangeRecord_<V> {\n    return this._addToRemovals(this._unlink(record));\n  }\n\n  /** @internal */\n  _unlink(record: IterableChangeRecord_<V>): IterableChangeRecord_<V> {\n    if (this._linkedRecords !== null) {\n      this._linkedRecords.remove(record);\n    }\n\n    const prev = record._prev;\n    const next = record._next;\n\n    // TODO(vicb):\n    // assert((record._prev = null) === null);\n    // assert((record._next = null) === null);\n\n    if (prev === null) {\n      this._itHead = next;\n    } else {\n      prev._next = next;\n    }\n    if (next === null) {\n      this._itTail = prev;\n    } else {\n      next._prev = prev;\n    }\n\n    return record;\n  }\n\n  /** @internal */\n  _addToMoves(record: IterableChangeRecord_<V>, toIndex: number): IterableChangeRecord_<V> {\n    // TODO(vicb):\n    // assert(record._nextMoved === null);\n\n    if (record.previousIndex === toIndex) {\n      return record;\n    }\n\n    if (this._movesTail === null) {\n      // TODO(vicb):\n      // assert(_movesHead === null);\n      this._movesTail = this._movesHead = record;\n    } else {\n      // TODO(vicb):\n      // assert(_movesTail._nextMoved === null);\n      this._movesTail = this._movesTail._nextMoved = record;\n    }\n\n    return record;\n  }\n\n  private _addToRemovals(record: IterableChangeRecord_<V>): IterableChangeRecord_<V> {\n    if (this._unlinkedRecords === null) {\n      this._unlinkedRecords = new _DuplicateMap<V>();\n    }\n    this._unlinkedRecords.put(record);\n    record.currentIndex = null;\n    record._nextRemoved = null;\n\n    if (this._removalsTail === null) {\n      // TODO(vicb):\n      // assert(_removalsHead === null);\n      this._removalsTail = this._removalsHead = record;\n      record._prevRemoved = null;\n    } else {\n      // TODO(vicb):\n      // assert(_removalsTail._nextRemoved === null);\n      // assert(record._nextRemoved === null);\n      record._prevRemoved = this._removalsTail;\n      this._removalsTail = this._removalsTail._nextRemoved = record;\n    }\n    return record;\n  }\n\n  /** @internal */\n  _addIdentityChange(record: IterableChangeRecord_<V>, item: V) {\n    record.item = item;\n    if (this._identityChangesTail === null) {\n      this._identityChangesTail = this._identityChangesHead = record;\n    } else {\n      this._identityChangesTail = this._identityChangesTail._nextIdentityChange = record;\n    }\n    return record;\n  }\n}\n\nexport class IterableChangeRecord_<V> implements IterableChangeRecord<V> {\n  currentIndex: number | null = null;\n  previousIndex: number | null = null;\n\n  /** @internal */\n  _nextPrevious: IterableChangeRecord_<V> | null = null;\n  /** @internal */\n  _prev: IterableChangeRecord_<V> | null = null;\n  /** @internal */\n  _next: IterableChangeRecord_<V> | null = null;\n  /** @internal */\n  _prevDup: IterableChangeRecord_<V> | null = null;\n  /** @internal */\n  _nextDup: IterableChangeRecord_<V> | null = null;\n  /** @internal */\n  _prevRemoved: IterableChangeRecord_<V> | null = null;\n  /** @internal */\n  _nextRemoved: IterableChangeRecord_<V> | null = null;\n  /** @internal */\n  _nextAdded: IterableChangeRecord_<V> | null = null;\n  /** @internal */\n  _nextMoved: IterableChangeRecord_<V> | null = null;\n  /** @internal */\n  _nextIdentityChange: IterableChangeRecord_<V> | null = null;\n\n  constructor(\n    public item: V,\n    public trackById: any,\n  ) {}\n}\n\n// A linked list of IterableChangeRecords with the same IterableChangeRecord_.item\nclass _DuplicateItemRecordList<V> {\n  /** @internal */\n  _head: IterableChangeRecord_<V> | null = null;\n  /** @internal */\n  _tail: IterableChangeRecord_<V> | null = null;\n\n  /**\n   * Append the record to the list of duplicates.\n   *\n   * Note: by design all records in the list of duplicates hold the same value in record.item.\n   */\n  add(record: IterableChangeRecord_<V>): void {\n    if (this._head === null) {\n      this._head = this._tail = record;\n      record._nextDup = null;\n      record._prevDup = null;\n    } else {\n      // TODO(vicb):\n      // assert(record.item ==  _head.item ||\n      //       record.item is num && record.item.isNaN && _head.item is num && _head.item.isNaN);\n      this._tail!._nextDup = record;\n      record._prevDup = this._tail;\n      record._nextDup = null;\n      this._tail = record;\n    }\n  }\n\n  // Returns a IterableChangeRecord_ having IterableChangeRecord_.trackById == trackById and\n  // IterableChangeRecord_.currentIndex >= atOrAfterIndex\n  get(trackById: any, atOrAfterIndex: number | null): IterableChangeRecord_<V> | null {\n    let record: IterableChangeRecord_<V> | null;\n    for (record = this._head; record !== null; record = record._nextDup) {\n      if (\n        (atOrAfterIndex === null || atOrAfterIndex <= record.currentIndex!) &&\n        Object.is(record.trackById, trackById)\n      ) {\n        return record;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Remove one {@link IterableChangeRecord_} from the list of duplicates.\n   *\n   * Returns whether the list of duplicates is empty.\n   */\n  remove(record: IterableChangeRecord_<V>): boolean {\n    // TODO(vicb):\n    // assert(() {\n    //  // verify that the record being removed is in the list.\n    //  for (IterableChangeRecord_ cursor = _head; cursor != null; cursor = cursor._nextDup) {\n    //    if (identical(cursor, record)) return true;\n    //  }\n    //  return false;\n    //});\n\n    const prev: IterableChangeRecord_<V> | null = record._prevDup;\n    const next: IterableChangeRecord_<V> | null = record._nextDup;\n    if (prev === null) {\n      this._head = next;\n    } else {\n      prev._nextDup = next;\n    }\n    if (next === null) {\n      this._tail = prev;\n    } else {\n      next._prevDup = prev;\n    }\n    return this._head === null;\n  }\n}\n\nclass _DuplicateMap<V> {\n  map = new Map<any, _DuplicateItemRecordList<V>>();\n\n  put(record: IterableChangeRecord_<V>) {\n    const key = record.trackById;\n\n    let duplicates = this.map.get(key);\n    if (!duplicates) {\n      duplicates = new _DuplicateItemRecordList<V>();\n      this.map.set(key, duplicates);\n    }\n    duplicates.add(record);\n  }\n\n  /**\n   * Retrieve the `value` using key. Because the IterableChangeRecord_ value may be one which we\n   * have already iterated over, we use the `atOrAfterIndex` to pretend it is not there.\n   *\n   * Use case: `[a, b, c, a, a]` if we are at index `3` which is the second `a` then asking if we\n   * have any more `a`s needs to return the second `a`.\n   */\n  get(trackById: any, atOrAfterIndex: number | null): IterableChangeRecord_<V> | null {\n    const key = trackById;\n    const recordList = this.map.get(key);\n    return recordList ? recordList.get(trackById, atOrAfterIndex) : null;\n  }\n\n  /**\n   * Removes a {@link IterableChangeRecord_} from the list of duplicates.\n   *\n   * The list of duplicates also is removed from the map if it gets empty.\n   */\n  remove(record: IterableChangeRecord_<V>): IterableChangeRecord_<V> {\n    const key = record.trackById;\n    const recordList: _DuplicateItemRecordList<V> = this.map.get(key)!;\n    // Remove the list of duplicates when it gets empty\n    if (recordList.remove(record)) {\n      this.map.delete(key);\n    }\n    return record;\n  }\n\n  get isEmpty(): boolean {\n    return this.map.size === 0;\n  }\n\n  clear() {\n    this.map.clear();\n  }\n}\n\nfunction getPreviousIndex(\n  item: any,\n  addRemoveOffset: number,\n  moveOffsets: number[] | null,\n): number {\n  const previousIndex = item.previousIndex;\n  if (previousIndex === null) return previousIndex;\n  let moveOffset = 0;\n  if (moveOffsets && previousIndex < moveOffsets.length) {\n    moveOffset = moveOffsets[previousIndex];\n  }\n  return previousIndex + addRemoveOffset + moveOffset;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {RuntimeError, RuntimeErrorCode} from '../../errors';\nimport {isJsObject} from '../../util/iterable';\nimport {stringify} from '../../util/stringify';\n\nimport type {\n  KeyValueChangeRecord,\n  KeyValueChanges,\n  KeyValueDiffer,\n  KeyValueDifferFactory,\n} from './keyvalue_differs';\n\nexport class DefaultKeyValueDifferFactory<K, V> implements KeyValueDifferFactory {\n  constructor() {}\n  supports(obj: any): boolean {\n    return obj instanceof Map || isJsObject(obj);\n  }\n\n  create<K, V>(): KeyValueDiffer<K, V> {\n    return new DefaultKeyValueDiffer<K, V>();\n  }\n}\n\nexport class DefaultKeyValueDiffer<K, V> implements KeyValueDiffer<K, V>, KeyValueChanges<K, V> {\n  private _records = new Map<K, KeyValueChangeRecord_<K, V>>();\n  private _mapHead: KeyValueChangeRecord_<K, V> | null = null;\n  // _appendAfter is used in the check loop\n  private _appendAfter: KeyValueChangeRecord_<K, V> | null = null;\n  private _previousMapHead: KeyValueChangeRecord_<K, V> | null = null;\n  private _changesHead: KeyValueChangeRecord_<K, V> | null = null;\n  private _changesTail: KeyValueChangeRecord_<K, V> | null = null;\n  private _additionsHead: KeyValueChangeRecord_<K, V> | null = null;\n  private _additionsTail: KeyValueChangeRecord_<K, V> | null = null;\n  private _removalsHead: KeyValueChangeRecord_<K, V> | null = null;\n  private _removalsTail: KeyValueChangeRecord_<K, V> | null = null;\n\n  get isDirty(): boolean {\n    return (\n      this._additionsHead !== null || this._changesHead !== null || this._removalsHead !== null\n    );\n  }\n\n  forEachItem(fn: (r: KeyValueChangeRecord<K, V>) => void) {\n    let record: KeyValueChangeRecord_<K, V> | null;\n    for (record = this._mapHead; record !== null; record = record._next) {\n      fn(record);\n    }\n  }\n\n  forEachPreviousItem(fn: (r: KeyValueChangeRecord<K, V>) => void) {\n    let record: KeyValueChangeRecord_<K, V> | null;\n    for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {\n      fn(record);\n    }\n  }\n\n  forEachChangedItem(fn: (r: KeyValueChangeRecord<K, V>) => void) {\n    let record: KeyValueChangeRecord_<K, V> | null;\n    for (record = this._changesHead; record !== null; record = record._nextChanged) {\n      fn(record);\n    }\n  }\n\n  forEachAddedItem(fn: (r: KeyValueChangeRecord<K, V>) => void) {\n    let record: KeyValueChangeRecord_<K, V> | null;\n    for (record = this._additionsHead; record !== null; record = record._nextAdded) {\n      fn(record);\n    }\n  }\n\n  forEachRemovedItem(fn: (r: KeyValueChangeRecord<K, V>) => void) {\n    let record: KeyValueChangeRecord_<K, V> | null;\n    for (record = this._removalsHead; record !== null; record = record._nextRemoved) {\n      fn(record);\n    }\n  }\n\n  diff(map?: Map<any, any> | {[k: string]: any} | null): any {\n    if (!map) {\n      map = new Map();\n    } else if (!(map instanceof Map || isJsObject(map))) {\n      throw new RuntimeError(\n        RuntimeErrorCode.INVALID_DIFFER_INPUT,\n        ngDevMode && `Error trying to diff '${stringify(map)}'. Only maps and objects are allowed`,\n      );\n    }\n\n    return this.check(map) ? this : null;\n  }\n\n  onDestroy() {}\n\n  /**\n   * Check the current state of the map vs the previous.\n   * The algorithm is optimised for when the keys do no change.\n   */\n  check(map: Map<any, any> | {[k: string]: any}): boolean {\n    this._reset();\n\n    let insertBefore = this._mapHead;\n    this._appendAfter = null;\n\n    this._forEach(map, (value: any, key: any) => {\n      if (insertBefore && insertBefore.key === key) {\n        this._maybeAddToChanges(insertBefore, value);\n        this._appendAfter = insertBefore;\n        insertBefore = insertBefore._next;\n      } else {\n        const record = this._getOrCreateRecordForKey(key, value);\n        insertBefore = this._insertBeforeOrAppend(insertBefore, record);\n      }\n    });\n\n    // Items remaining at the end of the list have been deleted\n    if (insertBefore) {\n      if (insertBefore._prev) {\n        insertBefore._prev._next = null;\n      }\n\n      this._removalsHead = insertBefore;\n\n      for (\n        let record: KeyValueChangeRecord_<K, V> | null = insertBefore;\n        record !== null;\n        record = record._nextRemoved\n      ) {\n        if (record === this._mapHead) {\n          this._mapHead = null;\n        }\n        this._records.delete(record.key);\n        record._nextRemoved = record._next;\n        record.previousValue = record.currentValue;\n        record.currentValue = null;\n        record._prev = null;\n        record._next = null;\n      }\n    }\n\n    // Make sure tails have no next records from previous runs\n    if (this._changesTail) this._changesTail._nextChanged = null;\n    if (this._additionsTail) this._additionsTail._nextAdded = null;\n\n    return this.isDirty;\n  }\n\n  /**\n   * Inserts a record before `before` or append at the end of the list when `before` is null.\n   *\n   * Notes:\n   * - This method appends at `this._appendAfter`,\n   * - This method updates `this._appendAfter`,\n   * - The return value is the new value for the insertion pointer.\n   */\n  private _insertBeforeOrAppend(\n    before: KeyValueChangeRecord_<K, V> | null,\n    record: KeyValueChangeRecord_<K, V>,\n  ): KeyValueChangeRecord_<K, V> | null {\n    if (before) {\n      const prev = before._prev;\n      record._next = before;\n      record._prev = prev;\n      before._prev = record;\n      if (prev) {\n        prev._next = record;\n      }\n      if (before === this._mapHead) {\n        this._mapHead = record;\n      }\n\n      this._appendAfter = before;\n      return before;\n    }\n\n    if (this._appendAfter) {\n      this._appendAfter._next = record;\n      record._prev = this._appendAfter;\n    } else {\n      this._mapHead = record;\n    }\n\n    this._appendAfter = record;\n    return null;\n  }\n\n  private _getOrCreateRecordForKey(key: K, value: V): KeyValueChangeRecord_<K, V> {\n    if (this._records.has(key)) {\n      const record = this._records.get(key)!;\n      this._maybeAddToChanges(record, value);\n      const prev = record._prev;\n      const next = record._next;\n      if (prev) {\n        prev._next = next;\n      }\n      if (next) {\n        next._prev = prev;\n      }\n      record._next = null;\n      record._prev = null;\n\n      return record;\n    }\n\n    const record = new KeyValueChangeRecord_<K, V>(key);\n    this._records.set(key, record);\n    record.currentValue = value;\n    this._addToAdditions(record);\n    return record;\n  }\n\n  /** @internal */\n  _reset() {\n    if (this.isDirty) {\n      let record: KeyValueChangeRecord_<K, V> | null;\n      // let `_previousMapHead` contain the state of the map before the changes\n      this._previousMapHead = this._mapHead;\n      for (record = this._previousMapHead; record !== null; record = record._next) {\n        record._nextPrevious = record._next;\n      }\n\n      // Update `record.previousValue` with the value of the item before the changes\n      // We need to update all changed items (that's those which have been added and changed)\n      for (record = this._changesHead; record !== null; record = record._nextChanged) {\n        record.previousValue = record.currentValue;\n      }\n      for (record = this._additionsHead; record != null; record = record._nextAdded) {\n        record.previousValue = record.currentValue;\n      }\n\n      this._changesHead = this._changesTail = null;\n      this._additionsHead = this._additionsTail = null;\n      this._removalsHead = null;\n    }\n  }\n\n  // Add the record or a given key to the list of changes only when the value has actually changed\n  private _maybeAddToChanges(record: KeyValueChangeRecord_<K, V>, newValue: any): void {\n    if (!Object.is(newValue, record.currentValue)) {\n      record.previousValue = record.currentValue;\n      record.currentValue = newValue;\n      this._addToChanges(record);\n    }\n  }\n\n  private _addToAdditions(record: KeyValueChangeRecord_<K, V>) {\n    if (this._additionsHead === null) {\n      this._additionsHead = this._additionsTail = record;\n    } else {\n      this._additionsTail!._nextAdded = record;\n      this._additionsTail = record;\n    }\n  }\n\n  private _addToChanges(record: KeyValueChangeRecord_<K, V>) {\n    if (this._changesHead === null) {\n      this._changesHead = this._changesTail = record;\n    } else {\n      this._changesTail!._nextChanged = record;\n      this._changesTail = record;\n    }\n  }\n\n  /** @internal */\n  private _forEach<K, V>(obj: Map<K, V> | {[k: string]: V}, fn: (v: V, k: any) => void) {\n    if (obj instanceof Map) {\n      obj.forEach(fn);\n    } else {\n      Object.keys(obj).forEach((k) => fn(obj[k], k));\n    }\n  }\n}\n\nclass KeyValueChangeRecord_<K, V> implements KeyValueChangeRecord<K, V> {\n  previousValue: V | null = null;\n  currentValue: V | null = null;\n\n  /** @internal */\n  _nextPrevious: KeyValueChangeRecord_<K, V> | null = null;\n  /** @internal */\n  _next: KeyValueChangeRecord_<K, V> | null = null;\n  /** @internal */\n  _prev: KeyValueChangeRecord_<K, V> | null = null;\n  /** @internal */\n  _nextAdded: KeyValueChangeRecord_<K, V> | null = null;\n  /** @internal */\n  _nextRemoved: KeyValueChangeRecord_<K, V> | null = null;\n  /** @internal */\n  _nextChanged: KeyValueChangeRecord_<K, V> | null = null;\n\n  constructor(public key: K) {}\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {DefaultIterableDifferFactory} from './differs/default_iterable_differ';\nimport {DefaultKeyValueDifferFactory} from './differs/default_keyvalue_differ';\nimport {IterableDifferFactory, IterableDiffers} from './differs/iterable_differs';\nimport {KeyValueDifferFactory, KeyValueDiffers} from './differs/keyvalue_differs';\n\nexport {SimpleChange, SimpleChanges} from './simple_change';\nexport {devModeEqual} from '../util/comparison';\nexport {ChangeDetectorRef} from './change_detector_ref';\nexport {ChangeDetectionStrategy} from './constants';\nexport {\n  DefaultIterableDiffer,\n  DefaultIterableDifferFactory,\n} from './differs/default_iterable_differ';\nexport {DefaultKeyValueDifferFactory} from './differs/default_keyvalue_differ';\nexport {\n  IterableChangeRecord,\n  IterableChanges,\n  IterableDiffer,\n  IterableDifferFactory,\n  IterableDiffers,\n  NgIterable,\n  TrackByFunction,\n} from './differs/iterable_differs';\nexport {\n  KeyValueChangeRecord,\n  KeyValueChanges,\n  KeyValueDiffer,\n  KeyValueDifferFactory,\n  KeyValueDiffers,\n} from './differs/keyvalue_differs';\n\nexport {PipeTransform} from './pipe_transform';\n\n/**\n * Structural diffing for `Object`s and `Map`s.\n */\nconst keyValDiff: KeyValueDifferFactory[] = [new DefaultKeyValueDifferFactory()];\n\n/**\n * Structural diffing for `Iterable` types such as `Array`s.\n */\nconst iterableDiff: IterableDifferFactory[] = [new DefaultIterableDifferFactory()];\n\nexport const defaultIterableDiffers = new IterableDiffers(iterableDiff);\n\nexport const defaultKeyValueDiffers = new KeyValueDiffers(keyValDiff);\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {StaticProvider} from '../di';\n\nimport {createPlatformFactory} from './platform';\nimport {PlatformRef} from './platform_ref';\n\n/**\n * This platform has to be included in any other platform\n *\n * @publicApi\n */\nexport const platformCore: (extraProviders?: StaticProvider[] | undefined) => PlatformRef =\n  createPlatformFactory(null, 'core', []);\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {EnvironmentProviders, Provider, StaticProvider} from '../di/interface/provider';\nimport {EnvironmentInjector} from '../di/r3_injector';\nimport {Type} from '../interface/type';\nimport {createOrReusePlatformInjector} from '../platform/platform';\nimport {assertStandaloneComponentType} from '../render3/errors';\nimport {EnvironmentNgModuleRefAdapter} from '../render3/ng_module_ref';\n\nimport {ApplicationRef} from './application_ref';\nimport {provideZonelessChangeDetectionInternal} from '../change_detection/scheduling/zoneless_scheduling_impl';\nimport {bootstrap} from '../platform/bootstrap';\nimport {profiler} from '../render3/profiler';\nimport {ProfilerEvent} from '../render3/profiler_types';\nimport {errorHandlerEnvironmentInitializer} from '../error_handler';\nimport {RuntimeError, RuntimeErrorCode} from '../errors';\nimport {PlatformRef} from '../platform/platform_ref';\nimport {validAppIdInitializer} from './application_tokens';\n\n/**\n * Internal create application API that implements the core application creation logic and optional\n * bootstrap logic.\n *\n * Platforms (such as `platform-browser`) may require different set of application and platform\n * providers for an application to function correctly. As a result, platforms may use this function\n * internally and supply the necessary providers during the bootstrap, while exposing\n * platform-specific APIs as a part of their public API.\n *\n * @returns A promise that returns an `ApplicationRef` instance once resolved.\n */\n\nexport function internalCreateApplication(config: {\n  rootComponent?: Type<unknown>;\n  appProviders?: Array<Provider | EnvironmentProviders>;\n  platformProviders?: Provider[];\n  platformRef?: PlatformRef;\n}): Promise<ApplicationRef> {\n  const {rootComponent, appProviders, platformProviders, platformRef} = config;\n  profiler(ProfilerEvent.BootstrapApplicationStart);\n\n  if (typeof ngServerMode !== 'undefined' && ngServerMode && !platformRef) {\n    throw new RuntimeError(\n      RuntimeErrorCode.PLATFORM_NOT_FOUND,\n      ngDevMode &&\n        'Missing Platform: This may be due to using `bootstrapApplication` on the server without passing a `BootstrapContext`. ' +\n          'Please make sure that `bootstrapApplication` is called with a `context` argument.',\n    );\n  }\n\n  try {\n    const platformInjector =\n      platformRef?.injector ?? createOrReusePlatformInjector(platformProviders as StaticProvider[]);\n\n    if ((typeof ngDevMode === 'undefined' || ngDevMode) && rootComponent !== undefined) {\n      assertStandaloneComponentType(rootComponent);\n    }\n\n    // Create root application injector based on a set of providers configured at the platform\n    // bootstrap level as well as providers passed to the bootstrap call by a user.\n    const allAppProviders = [\n      provideZonelessChangeDetectionInternal(),\n      errorHandlerEnvironmentInitializer,\n      ...(ngDevMode ? [validAppIdInitializer] : []),\n      ...(appProviders || []),\n    ];\n    const adapter = new EnvironmentNgModuleRefAdapter({\n      providers: allAppProviders,\n      parent: platformInjector as EnvironmentInjector,\n      debugName: typeof ngDevMode === 'undefined' || ngDevMode ? 'Environment Injector' : '',\n      // We skip environment initializers because we need to run them inside the NgZone, which\n      // happens after we get the NgZone instance from the Injector.\n      runEnvironmentInitializers: false,\n    });\n\n    return bootstrap({\n      r3Injector: adapter.injector,\n      platformInjector,\n      rootComponent,\n    });\n  } catch (e) {\n    return Promise.reject(e);\n  } finally {\n    profiler(ProfilerEvent.BootstrapApplicationEnd);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  isEarlyEventType,\n  isCaptureEventType,\n  EventContractContainer,\n  EventContract,\n  EventDispatcher,\n  registerDispatcher,\n  getAppScopedQueuedEventInfos,\n  clearAppScopedEarlyEventContract,\n  EventPhase,\n} from '../../primitives/event-dispatch';\n\nimport {APP_BOOTSTRAP_LISTENER, ApplicationRef} from '../application/application_ref';\nimport {ENVIRONMENT_INITIALIZER, Injector} from '../di';\nimport {inject} from '../di/injector_compatibility';\nimport {Provider} from '../di/interface/provider';\nimport {RElement, RNode} from '../render3/interfaces/renderer_dom';\nimport {CLEANUP, LView, TView} from '../render3/interfaces/view';\nimport {unwrapRNode} from '../render3/util/view_utils';\n\nimport {\n  JSACTION_BLOCK_ELEMENT_MAP,\n  EVENT_REPLAY_ENABLED_DEFAULT,\n  IS_EVENT_REPLAY_ENABLED,\n} from './tokens';\nimport {\n  sharedStashFunction,\n  sharedMapFunction,\n  DEFER_BLOCK_SSR_ID_ATTRIBUTE,\n  EventContractDetails,\n  JSACTION_EVENT_CONTRACT,\n  invokeListeners,\n  removeListeners,\n  enableStashEventListenerImpl,\n  setStashFn,\n} from '../event_delegation_utils';\nimport {APP_ID} from '../application/application_tokens';\nimport {performanceMarkFeature} from '../util/performance';\nimport {triggerHydrationFromBlockName} from '../defer/triggering';\nimport {isIncrementalHydrationEnabled} from './utils';\n\n/** Apps in which we've enabled event replay.\n *  This is to prevent initializing event replay more than once per app.\n */\nconst appsWithEventReplay = new WeakSet<ApplicationRef>();\n\n/**\n * The key that represents all replayable elements that are not in defer blocks.\n */\nconst EAGER_CONTENT_LISTENERS_KEY = '';\n\n/**\n * A list of block events that need to be replayed\n */\nlet blockEventQueue: {event: Event; currentTarget: Element}[] = [];\n\n/**\n * Determines whether Event Replay feature should be activated on the client.\n */\nfunction shouldEnableEventReplay(injector: Injector) {\n  return injector.get(IS_EVENT_REPLAY_ENABLED, EVENT_REPLAY_ENABLED_DEFAULT);\n}\n\n/**\n * Returns a set of providers required to setup support for event replay.\n * Requires hydration to be enabled separately.\n */\nexport function withEventReplay(): Provider[] {\n  const providers: Provider[] = [\n    {\n      provide: IS_EVENT_REPLAY_ENABLED,\n      useFactory: () => {\n        let isEnabled = true;\n        if (typeof ngServerMode === 'undefined' || !ngServerMode) {\n          // Note: globalThis[CONTRACT_PROPERTY] may be undefined in case Event Replay feature\n          // is enabled, but there are no events configured in this application, in which case\n          // we don't activate this feature, since there are no events to replay.\n          const appId = inject(APP_ID);\n          isEnabled = !!window._ejsas?.[appId];\n        }\n        if (isEnabled) {\n          performanceMarkFeature('NgEventReplay');\n        }\n        return isEnabled;\n      },\n    },\n  ];\n\n  if (typeof ngServerMode === 'undefined' || !ngServerMode) {\n    providers.push(\n      {\n        provide: ENVIRONMENT_INITIALIZER,\n        useValue: () => {\n          const appRef = inject(ApplicationRef);\n          const {injector} = appRef;\n          // We have to check for the appRef here due to the possibility of multiple apps\n          // being present on the same page. We only want to enable event replay for the\n          // apps that actually want it.\n          if (!appsWithEventReplay.has(appRef)) {\n            const jsActionMap = inject(JSACTION_BLOCK_ELEMENT_MAP);\n            if (shouldEnableEventReplay(injector)) {\n              enableStashEventListenerImpl();\n              const appId = injector.get(APP_ID);\n              const clearStashFn = setStashFn(\n                appId,\n                (rEl: RNode, eventName: string, listenerFn: VoidFunction) => {\n                  // If a user binds to a ng-container and uses a directive that binds using a host listener,\n                  // this element could be a comment node. So we need to ensure we have an actual element\n                  // node before stashing anything.\n                  if ((rEl as Node).nodeType !== Node.ELEMENT_NODE) return;\n                  sharedStashFunction(rEl as RElement, eventName, listenerFn);\n                  sharedMapFunction(rEl as RElement, jsActionMap);\n                },\n              );\n              // Clean up the reference to the function set by the environment initializer,\n              // as the function closure may capture injected elements and prevent them\n              // from being properly garbage collected.\n              appRef.onDestroy(clearStashFn);\n            }\n          }\n        },\n        multi: true,\n      },\n      {\n        provide: APP_BOOTSTRAP_LISTENER,\n        useFactory: () => {\n          const appRef = inject(ApplicationRef);\n          const {injector} = appRef;\n\n          return () => {\n            // We have to check for the appRef here due to the possibility of multiple apps\n            // being present on the same page. We only want to enable event replay for the\n            // apps that actually want it.\n            if (!shouldEnableEventReplay(injector) || appsWithEventReplay.has(appRef)) {\n              return;\n            }\n\n            appsWithEventReplay.add(appRef);\n\n            const appId = injector.get(APP_ID);\n            appRef.onDestroy(() => {\n              appsWithEventReplay.delete(appRef);\n              // Ensure that we're always safe calling this in the browser.\n              if (typeof ngServerMode !== 'undefined' && !ngServerMode) {\n                // `_ejsa` should be deleted when the app is destroyed, ensuring that\n                // no elements are still captured in the global list and are not prevented\n                // from being garbage collected.\n                clearAppScopedEarlyEventContract(appId);\n              }\n            });\n\n            // Kick off event replay logic once hydration for the initial part\n            // of the application is completed. This timing is similar to the unclaimed\n            // dehydrated views cleanup timing.\n            appRef.whenStable().then(() => {\n              // Note: we have to check whether the application is destroyed before\n              // performing other operations with the `injector`.\n              // The application may be destroyed **before** it becomes stable, so when\n              // the `whenStable` resolves, the injector might already be in\n              // a destroyed state. Thus, calling `injector.get` would throw an error\n              // indicating that the injector has already been destroyed.\n              if (appRef.destroyed) {\n                return;\n              }\n\n              const eventContractDetails = injector.get(JSACTION_EVENT_CONTRACT);\n              initEventReplay(eventContractDetails, injector);\n              const jsActionMap = injector.get(JSACTION_BLOCK_ELEMENT_MAP);\n              jsActionMap.get(EAGER_CONTENT_LISTENERS_KEY)?.forEach(removeListeners);\n              jsActionMap.delete(EAGER_CONTENT_LISTENERS_KEY);\n\n              const eventContract = eventContractDetails.instance!;\n              // This removes event listeners registered through the container manager,\n              // as listeners registered on `document.body` might never be removed if we\n              // don't clean up the contract.\n              if (isIncrementalHydrationEnabled(injector)) {\n                // When incremental hydration is enabled, we cannot clean up the event\n                // contract immediately because we're unaware if there are any deferred\n                // blocks to hydrate. We can only schedule a contract cleanup when the\n                // app is destroyed.\n                appRef.onDestroy(() => eventContract.cleanUp());\n              } else {\n                eventContract.cleanUp();\n              }\n            });\n          };\n        },\n        multi: true,\n      },\n    );\n  }\n\n  return providers;\n}\n\nconst initEventReplay = (eventDelegation: EventContractDetails, injector: Injector) => {\n  const appId = injector.get(APP_ID);\n  // This is set in packages/platform-server/src/utils.ts\n  const earlyJsactionData = window._ejsas![appId]!;\n  const eventContract = (eventDelegation.instance = new EventContract(\n    new EventContractContainer(earlyJsactionData.c),\n  ));\n  for (const et of earlyJsactionData.et) {\n    eventContract.addEvent(et);\n  }\n  for (const et of earlyJsactionData.etc) {\n    eventContract.addEvent(et);\n  }\n  const eventInfos = getAppScopedQueuedEventInfos(appId);\n  eventContract.replayEarlyEventInfos(eventInfos);\n  clearAppScopedEarlyEventContract(appId);\n  const dispatcher = new EventDispatcher((event) => {\n    invokeRegisteredReplayListeners(injector, event, event.currentTarget as Element);\n  });\n  registerDispatcher(eventContract, dispatcher);\n};\n\n/**\n * Extracts information about all DOM events (added in a template) registered on elements in a give\n * LView. Maps collected events to a corresponding DOM element (an element is used as a key).\n */\nexport function collectDomEventsInfo(\n  tView: TView,\n  lView: LView,\n  eventTypesToReplay: {regular: Set<string>; capture: Set<string>},\n): Map<Element, string[]> {\n  const domEventsInfo = new Map<Element, string[]>();\n  const lCleanup = lView[CLEANUP];\n  const tCleanup = tView.cleanup;\n  if (!tCleanup || !lCleanup) {\n    return domEventsInfo;\n  }\n  for (let i = 0; i < tCleanup.length; ) {\n    const firstParam = tCleanup[i++];\n    const secondParam = tCleanup[i++];\n    if (typeof firstParam !== 'string') {\n      continue;\n    }\n    const eventType = firstParam;\n    if (!isEarlyEventType(eventType)) {\n      continue;\n    }\n    if (isCaptureEventType(eventType)) {\n      eventTypesToReplay.capture.add(eventType);\n    } else {\n      eventTypesToReplay.regular.add(eventType);\n    }\n    const listenerElement = unwrapRNode(lView[secondParam]) as any as Element;\n    i++; // move the cursor to the next position (location of the listener idx)\n    const useCaptureOrIndx = tCleanup[i++];\n    // if useCaptureOrIndx is boolean then report it as is.\n    // if useCaptureOrIndx is positive number then it in unsubscribe method\n    // if useCaptureOrIndx is negative number then it is a Subscription\n    const isDomEvent = typeof useCaptureOrIndx === 'boolean' || useCaptureOrIndx >= 0;\n    if (!isDomEvent) {\n      continue;\n    }\n    if (!domEventsInfo.has(listenerElement)) {\n      domEventsInfo.set(listenerElement, [eventType]);\n    } else {\n      domEventsInfo.get(listenerElement)!.push(eventType);\n    }\n  }\n  return domEventsInfo;\n}\n\nexport function invokeRegisteredReplayListeners(\n  injector: Injector,\n  event: Event,\n  currentTarget: Element | null,\n) {\n  const blockName =\n    (currentTarget && currentTarget.getAttribute(DEFER_BLOCK_SSR_ID_ATTRIBUTE)) ?? '';\n  if (/d\\d+/.test(blockName)) {\n    hydrateAndInvokeBlockListeners(blockName, injector, event, currentTarget!);\n  } else if (event.eventPhase === EventPhase.REPLAY) {\n    invokeListeners(event, currentTarget);\n  }\n}\n\nfunction hydrateAndInvokeBlockListeners(\n  blockName: string,\n  injector: Injector,\n  event: Event,\n  currentTarget: Element,\n) {\n  blockEventQueue.push({event, currentTarget});\n  triggerHydrationFromBlockName(injector, blockName, replayQueuedBlockEvents);\n}\n\nfunction replayQueuedBlockEvents(hydratedBlocks: string[]) {\n  // clone the queue\n  const queue = [...blockEventQueue];\n  const hydrated = new Set<string>(hydratedBlocks);\n  // empty it\n  blockEventQueue = [];\n  for (let {event, currentTarget} of queue) {\n    const blockName = currentTarget.getAttribute(DEFER_BLOCK_SSR_ID_ATTRIBUTE)!;\n    if (hydrated.has(blockName)) {\n      invokeListeners(event, currentTarget);\n    } else {\n      // requeue events that weren't yet hydrated\n      blockEventQueue.push({event, currentTarget});\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ApplicationRef} from '../application/application_ref';\nimport {APP_ID} from '../application/application_tokens';\nimport {\n  DEFER_BLOCK_STATE as CURRENT_DEFER_BLOCK_STATE,\n  DeferBlockTrigger,\n  HydrateTriggerDetails,\n  TDeferBlockDetails,\n} from '../defer/interfaces';\nimport {getLDeferBlockDetails, getTDeferBlockDetails, isDeferBlock} from '../defer/utils';\nimport {isDetachedByI18n} from '../i18n/utils';\nimport {ViewEncapsulation} from '../metadata';\nimport {Renderer2} from '../render';\nimport {assertTNode} from '../render3/assert';\nimport {collectNativeNodes, collectNativeNodesInLContainer} from '../render3/collect_native_nodes';\nimport {getComponentDef} from '../render3/def_getters';\nimport {CONTAINER_HEADER_OFFSET, LContainer} from '../render3/interfaces/container';\nimport {isLetDeclaration, isTNodeShape, TNode, TNodeType} from '../render3/interfaces/node';\nimport {RComment, RElement} from '../render3/interfaces/renderer_dom';\nimport {\n  hasI18n,\n  isComponentHost,\n  isLContainer,\n  isProjectionTNode,\n  isRootView,\n} from '../render3/interfaces/type_checks';\nimport {\n  CONTEXT,\n  HEADER_OFFSET,\n  HOST,\n  INJECTOR,\n  LView,\n  PARENT,\n  RENDERER,\n  TView,\n  TVIEW,\n  TViewType,\n} from '../render3/interfaces/view';\nimport {unwrapLView, unwrapRNode} from '../render3/util/view_utils';\nimport {TransferState} from '../transfer_state';\n\nimport {\n  unsupportedProjectionOfDomNodes,\n  validateMatchingNode,\n  validateNodeExists,\n} from './error_handling';\nimport {collectDomEventsInfo} from './event_replay';\nimport {setJSActionAttributes} from '../event_delegation_utils';\nimport {\n  getOrComputeI18nChildren,\n  isI18nHydrationEnabled,\n  isI18nHydrationSupportEnabled,\n  trySerializeI18nBlock,\n} from './i18n';\nimport {\n  CONTAINERS,\n  DEFER_BLOCK_ID,\n  DEFER_BLOCK_STATE,\n  DEFER_HYDRATE_TRIGGERS,\n  DEFER_PARENT_BLOCK_ID,\n  DISCONNECTED_NODES,\n  ELEMENT_CONTAINERS,\n  I18N_DATA,\n  MULTIPLIER,\n  NODES,\n  NUM_ROOT_NODES,\n  SerializedContainerView,\n  SerializedDeferBlock,\n  SerializedTriggerDetails,\n  SerializedView,\n  TEMPLATE_ID,\n  TEMPLATES,\n} from './interfaces';\nimport {calcPathForNode, isDisconnectedNode} from './node_lookup_utils';\nimport {isInSkipHydrationBlock, SKIP_HYDRATION_ATTR_NAME} from './skip_hydration';\nimport {EVENT_REPLAY_ENABLED_DEFAULT, IS_EVENT_REPLAY_ENABLED} from './tokens';\nimport {\n  convertHydrateTriggersToJsAction,\n  getLNodeForHydration,\n  isIncrementalHydrationEnabled,\n  NGH_ATTR_NAME,\n  NGH_DATA_KEY,\n  NGH_DEFER_BLOCKS_KEY,\n  processTextNodeBeforeSerialization,\n  TextNodeMarker,\n} from './utils';\nimport {Injector} from '../di';\n\n/**\n * A collection that tracks all serialized views (`ngh` DOM annotations)\n * to avoid duplication. An attempt to add a duplicate view results in the\n * collection returning the index of the previously collected serialized view.\n * This reduces the number of annotations needed for a given page.\n */\nclass SerializedViewCollection {\n  private views: SerializedView[] = [];\n  private indexByContent = new Map<string, number>();\n\n  add(serializedView: SerializedView): number {\n    const viewAsString = JSON.stringify(serializedView);\n    if (!this.indexByContent.has(viewAsString)) {\n      const index = this.views.length;\n      this.views.push(serializedView);\n      this.indexByContent.set(viewAsString, index);\n      return index;\n    }\n    return this.indexByContent.get(viewAsString)!;\n  }\n\n  getAll(): SerializedView[] {\n    return this.views;\n  }\n}\n\n/**\n * Global counter that is used to generate a unique id for TViews\n * during the serialization process.\n */\nlet tViewSsrId = 0;\n\n/**\n * Generates a unique id for a given TView and returns this id.\n * The id is also stored on this instance of a TView and reused in\n * subsequent calls.\n *\n * This id is needed to uniquely identify and pick up dehydrated views\n * at runtime.\n */\nfunction getSsrId(tView: TView): string {\n  if (!tView.ssrId) {\n    tView.ssrId = `t${tViewSsrId++}`;\n  }\n  return tView.ssrId;\n}\n\n/**\n * Describes a context available during the serialization\n * process. The context is used to share and collect information\n * during the serialization.\n */\nexport interface HydrationContext {\n  serializedViewCollection: SerializedViewCollection;\n  corruptedTextNodes: Map<HTMLElement, TextNodeMarker>;\n  isI18nHydrationEnabled: boolean;\n  isIncrementalHydrationEnabled: boolean;\n  i18nChildren: Map<TView, Set<number> | null>;\n  eventTypesToReplay: {regular: Set<string>; capture: Set<string>};\n  shouldReplayEvents: boolean;\n  appId: string; // the value of `APP_ID`\n  deferBlocks: Map<string /* defer block id, e.g. `d0` */, SerializedDeferBlock>;\n}\n\n/**\n * Computes the number of root nodes in a given view\n * (or child nodes in a given container if a tNode is provided).\n */\nfunction calcNumRootNodes(tView: TView, lView: LView, tNode: TNode | null): number {\n  const rootNodes: unknown[] = [];\n  collectNativeNodes(tView, lView, tNode, rootNodes);\n  return rootNodes.length;\n}\n\n/**\n * Computes the number of root nodes in all views in a given LContainer.\n */\nfunction calcNumRootNodesInLContainer(lContainer: LContainer): number {\n  const rootNodes: unknown[] = [];\n  collectNativeNodesInLContainer(lContainer, rootNodes);\n  return rootNodes.length;\n}\n\n/**\n * Annotates root level component's LView for hydration,\n * see `annotateHostElementForHydration` for additional information.\n */\nfunction annotateComponentLViewForHydration(\n  lView: LView,\n  context: HydrationContext,\n  injector: Injector,\n): number | null {\n  const hostElement = lView[HOST];\n  // Root elements might also be annotated with the `ngSkipHydration` attribute,\n  // check if it's present before starting the serialization process.\n  if (hostElement && !(hostElement as HTMLElement).hasAttribute(SKIP_HYDRATION_ATTR_NAME)) {\n    return annotateHostElementForHydration(hostElement as HTMLElement, lView, null, context);\n  }\n  return null;\n}\n\n/**\n * Annotates root level LContainer for hydration. This happens when a root component\n * injects ViewContainerRef, thus making the component an anchor for a view container.\n * This function serializes the component itself as well as all views from the view\n * container.\n */\nfunction annotateLContainerForHydration(\n  lContainer: LContainer,\n  context: HydrationContext,\n  injector: Injector,\n) {\n  const componentLView = unwrapLView(lContainer[HOST]) as LView<unknown>;\n\n  // Serialize the root component itself.\n  const componentLViewNghIndex = annotateComponentLViewForHydration(\n    componentLView,\n    context,\n    injector,\n  );\n\n  if (componentLViewNghIndex === null) {\n    // Component was not serialized (for example, if hydration was skipped by adding\n    // the `ngSkipHydration` attribute or this component uses i18n blocks in the template,\n    // but `withI18nSupport()` was not added), avoid annotating host element with the `ngh`\n    // attribute.\n    return;\n  }\n\n  const hostElement = unwrapRNode(componentLView[HOST]!) as HTMLElement;\n\n  // Serialize all views within this view container.\n  const rootLView = lContainer[PARENT];\n  const rootLViewNghIndex = annotateHostElementForHydration(hostElement, rootLView, null, context);\n\n  const renderer = componentLView[RENDERER] as Renderer2;\n\n  // For cases when a root component also acts as an anchor node for a ViewContainerRef\n  // (for example, when ViewContainerRef is injected in a root component), there is a need\n  // to serialize information about the component itself, as well as an LContainer that\n  // represents this ViewContainerRef. Effectively, we need to serialize 2 pieces of info:\n  // (1) hydration info for the root component itself and (2) hydration info for the\n  // ViewContainerRef instance (an LContainer). Each piece of information is included into\n  // the hydration data (in the TransferState object) separately, thus we end up with 2 ids.\n  // Since we only have 1 root element, we encode both bits of info into a single string:\n  // ids are separated by the `|` char (e.g. `10|25`, where `10` is the ngh for a component view\n  // and 25 is the `ngh` for a root view which holds LContainer).\n  const finalIndex = `${componentLViewNghIndex}|${rootLViewNghIndex}`;\n  renderer.setAttribute(hostElement, NGH_ATTR_NAME, finalIndex);\n}\n\n/**\n * Annotates all components bootstrapped in a given ApplicationRef\n * with info needed for hydration.\n *\n * @param appRef An instance of an ApplicationRef.\n * @param doc A reference to the current Document instance.\n * @return event types that need to be replayed\n */\nexport function annotateForHydration(appRef: ApplicationRef, doc: Document) {\n  const injector = appRef.injector;\n  const isI18nHydrationEnabledVal = isI18nHydrationEnabled(injector);\n  const isIncrementalHydrationEnabledVal = isIncrementalHydrationEnabled(injector);\n  const serializedViewCollection = new SerializedViewCollection();\n  const corruptedTextNodes = new Map<HTMLElement, TextNodeMarker>();\n  const viewRefs = appRef._views;\n  const shouldReplayEvents = injector.get(IS_EVENT_REPLAY_ENABLED, EVENT_REPLAY_ENABLED_DEFAULT);\n  const eventTypesToReplay = {\n    regular: new Set<string>(),\n    capture: new Set<string>(),\n  };\n  const deferBlocks = new Map<string, SerializedDeferBlock>();\n  const appId = appRef.injector.get(APP_ID);\n  for (const viewRef of viewRefs) {\n    const lNode = getLNodeForHydration(viewRef);\n\n    // An `lView` might be `null` if a `ViewRef` represents\n    // an embedded view (not a component view).\n    if (lNode !== null) {\n      const context: HydrationContext = {\n        serializedViewCollection,\n        corruptedTextNodes,\n        isI18nHydrationEnabled: isI18nHydrationEnabledVal,\n        isIncrementalHydrationEnabled: isIncrementalHydrationEnabledVal,\n        i18nChildren: new Map(),\n        eventTypesToReplay,\n        shouldReplayEvents,\n        appId,\n        deferBlocks,\n      };\n      if (isLContainer(lNode)) {\n        annotateLContainerForHydration(lNode, context, injector);\n      } else {\n        annotateComponentLViewForHydration(lNode, context, injector);\n      }\n      insertCorruptedTextNodeMarkers(corruptedTextNodes, doc);\n    }\n  }\n\n  // Note: we *always* include hydration info key and a corresponding value\n  // into the TransferState, even if the list of serialized views is empty.\n  // This is needed as a signal to the client that the server part of the\n  // hydration logic was setup and enabled correctly. Otherwise, if a client\n  // hydration doesn't find a key in the transfer state - an error is produced.\n  const serializedViews = serializedViewCollection.getAll();\n  const transferState = injector.get(TransferState);\n  transferState.set(NGH_DATA_KEY, serializedViews);\n\n  if (deferBlocks.size > 0) {\n    const blocks: {[key: string]: SerializedDeferBlock} = {};\n    for (const [id, info] of deferBlocks.entries()) {\n      blocks[id] = info;\n    }\n    transferState.set(NGH_DEFER_BLOCKS_KEY, blocks);\n  }\n\n  return eventTypesToReplay;\n}\n\n/**\n * Serializes the lContainer data into a list of SerializedView objects,\n * that represent views within this lContainer.\n *\n * @param lContainer the lContainer we are serializing\n * @param tNode the TNode that contains info about this LContainer\n * @param lView that hosts this LContainer\n * @param parentDeferBlockId the defer block id of the parent if it exists\n * @param context the hydration context\n * @returns an array of the `SerializedView` objects\n */\nfunction serializeLContainer(\n  lContainer: LContainer,\n  tNode: TNode,\n  lView: LView,\n  parentDeferBlockId: string | null,\n  context: HydrationContext,\n): SerializedContainerView[] {\n  const views: SerializedContainerView[] = [];\n  let lastViewAsString = '';\n\n  for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {\n    let childLView = lContainer[i] as LView;\n\n    let template: string;\n    let numRootNodes: number;\n    let serializedView: SerializedContainerView | undefined;\n\n    if (isRootView(childLView)) {\n      // If this is a root view, get an LView for the underlying component,\n      // because it contains information about the view to serialize.\n      childLView = childLView[HEADER_OFFSET];\n\n      // If we have an LContainer at this position, this indicates that the\n      // host element was used as a ViewContainerRef anchor (e.g. a `ViewContainerRef`\n      // was injected within the component class). This case requires special handling.\n      if (isLContainer(childLView)) {\n        // Calculate the number of root nodes in all views in a given container\n        // and increment by one to account for an anchor node itself, i.e. in this\n        // scenario we'll have a layout that would look like this:\n        // `<app-root /><#VIEW1><#VIEW2>...<!--container-->`\n        // The `+1` is to capture the `<app-root />` element.\n        numRootNodes = calcNumRootNodesInLContainer(childLView) + 1;\n\n        annotateLContainerForHydration(childLView, context, lView[INJECTOR]);\n\n        const componentLView = unwrapLView(childLView[HOST]) as LView<unknown>;\n\n        serializedView = {\n          [TEMPLATE_ID]: componentLView[TVIEW].ssrId!,\n          [NUM_ROOT_NODES]: numRootNodes,\n        };\n      }\n    }\n\n    if (!serializedView) {\n      const childTView = childLView[TVIEW];\n\n      if (childTView.type === TViewType.Component) {\n        template = childTView.ssrId!;\n\n        // This is a component view, thus it has only 1 root node: the component\n        // host node itself (other nodes would be inside that host node).\n        numRootNodes = 1;\n      } else {\n        template = getSsrId(childTView);\n        numRootNodes = calcNumRootNodes(childTView, childLView, childTView.firstChild);\n      }\n\n      serializedView = {\n        [TEMPLATE_ID]: template,\n        [NUM_ROOT_NODES]: numRootNodes,\n      };\n\n      let isHydrateNeverBlock = false;\n\n      // If this is a defer block, serialize extra info.\n      if (isDeferBlock(lView[TVIEW], tNode)) {\n        const lDetails = getLDeferBlockDetails(lView, tNode);\n        const tDetails = getTDeferBlockDetails(lView[TVIEW], tNode);\n\n        if (context.isIncrementalHydrationEnabled && tDetails.hydrateTriggers !== null) {\n          const deferBlockId = `d${context.deferBlocks.size}`;\n\n          if (tDetails.hydrateTriggers.has(DeferBlockTrigger.Never)) {\n            isHydrateNeverBlock = true;\n          }\n\n          let rootNodes: any[] = [];\n          collectNativeNodesInLContainer(lContainer, rootNodes);\n\n          // Add defer block into info context.deferBlocks\n          const deferBlockInfo: SerializedDeferBlock = {\n            [NUM_ROOT_NODES]: rootNodes.length,\n            [DEFER_BLOCK_STATE]: lDetails[CURRENT_DEFER_BLOCK_STATE],\n          };\n\n          const serializedTriggers = serializeHydrateTriggers(tDetails.hydrateTriggers);\n          if (serializedTriggers.length > 0) {\n            deferBlockInfo[DEFER_HYDRATE_TRIGGERS] = serializedTriggers;\n          }\n\n          if (parentDeferBlockId !== null) {\n            // Serialize parent id only when it's present.\n            deferBlockInfo[DEFER_PARENT_BLOCK_ID] = parentDeferBlockId;\n          }\n\n          context.deferBlocks.set(deferBlockId, deferBlockInfo);\n\n          const node = unwrapRNode(lContainer);\n          if (node !== undefined) {\n            if ((node as Node).nodeType === Node.COMMENT_NODE) {\n              annotateDeferBlockAnchorForHydration(node as RComment, deferBlockId);\n            }\n          } else {\n            ngDevMode && validateNodeExists(node, childLView, tNode);\n            ngDevMode &&\n              validateMatchingNode(node, Node.COMMENT_NODE, null, childLView, tNode, true);\n\n            annotateDeferBlockAnchorForHydration(node as RComment, deferBlockId);\n          }\n\n          if (!isHydrateNeverBlock) {\n            // Add JSAction attributes for root nodes that use some hydration triggers\n            annotateDeferBlockRootNodesWithJsAction(tDetails, rootNodes, deferBlockId, context);\n          }\n\n          // Use current block id as parent for nested routes.\n          parentDeferBlockId = deferBlockId;\n\n          // Serialize extra info into the view object.\n          // TODO(incremental-hydration): this should be serialized and included at a different level\n          // (not at the view level).\n          serializedView[DEFER_BLOCK_ID] = deferBlockId;\n        }\n        // DEFER_BLOCK_STATE is used for reconciliation in hydration, both regular and incremental.\n        // We need to know which template is rendered when hydrating. So we serialize this state\n        // regardless of hydration type.\n        serializedView[DEFER_BLOCK_STATE] = lDetails[CURRENT_DEFER_BLOCK_STATE];\n      }\n\n      if (!isHydrateNeverBlock) {\n        Object.assign(\n          serializedView,\n          serializeLView(lContainer[i] as LView, parentDeferBlockId, context),\n        );\n      }\n    }\n\n    // Check if the previous view has the same shape (for example, it was\n    // produced by the *ngFor), in which case bump the counter on the previous\n    // view instead of including the same information again.\n    const currentViewAsString = JSON.stringify(serializedView);\n    if (views.length > 0 && currentViewAsString === lastViewAsString) {\n      const previousView = views[views.length - 1];\n      previousView[MULTIPLIER] ??= 1;\n      previousView[MULTIPLIER]++;\n    } else {\n      // Record this view as most recently added.\n      lastViewAsString = currentViewAsString;\n      views.push(serializedView);\n    }\n  }\n  return views;\n}\n\nfunction serializeHydrateTriggers(\n  triggerMap: Map<DeferBlockTrigger, HydrateTriggerDetails | null>,\n): (DeferBlockTrigger | SerializedTriggerDetails)[] {\n  const serializableDeferBlockTrigger = new Set<DeferBlockTrigger>([\n    DeferBlockTrigger.Idle,\n    DeferBlockTrigger.Immediate,\n    DeferBlockTrigger.Viewport,\n    DeferBlockTrigger.Timer,\n  ]);\n  let triggers: (DeferBlockTrigger | SerializedTriggerDetails)[] = [];\n  for (let [trigger, details] of triggerMap) {\n    if (serializableDeferBlockTrigger.has(trigger)) {\n      if (details === null) {\n        triggers.push(trigger);\n      } else if (details.type === DeferBlockTrigger.Timer) {\n        triggers.push({trigger, delay: details.delay});\n      } else {\n        triggers.push({trigger, intersectionObserverOptions: details.intersectionObserverOptions});\n      }\n    }\n  }\n  return triggers;\n}\n\n/**\n * Helper function to produce a node path (which navigation steps runtime logic\n * needs to take to locate a node) and stores it in the `NODES` section of the\n * current serialized view.\n */\nfunction appendSerializedNodePath(\n  ngh: SerializedView,\n  tNode: TNode,\n  lView: LView,\n  excludedParentNodes: Set<number> | null,\n) {\n  const noOffsetIndex = tNode.index - HEADER_OFFSET;\n  ngh[NODES] ??= {};\n  // Ensure we don't calculate the path multiple times.\n  ngh[NODES][noOffsetIndex] ??= calcPathForNode(tNode, lView, excludedParentNodes);\n}\n\n/**\n * Helper function to append information about a disconnected node.\n * This info is needed at runtime to avoid DOM lookups for this element\n * and instead, the element would be created from scratch.\n */\nfunction appendDisconnectedNodeIndex(ngh: SerializedView, tNodeOrNoOffsetIndex: TNode | number) {\n  const noOffsetIndex =\n    typeof tNodeOrNoOffsetIndex === 'number'\n      ? tNodeOrNoOffsetIndex\n      : tNodeOrNoOffsetIndex.index - HEADER_OFFSET;\n  ngh[DISCONNECTED_NODES] ??= [];\n  if (!ngh[DISCONNECTED_NODES].includes(noOffsetIndex)) {\n    ngh[DISCONNECTED_NODES].push(noOffsetIndex);\n  }\n}\n\n/**\n * Serializes the lView data into a SerializedView object that will later be added\n * to the TransferState storage and referenced using the `ngh` attribute on a host\n * element.\n *\n * @param lView the lView we are serializing\n * @param context the hydration context\n * @returns the `SerializedView` object containing the data to be added to the host node\n */\nfunction serializeLView(\n  lView: LView,\n  parentDeferBlockId: string | null = null,\n  context: HydrationContext,\n): SerializedView {\n  const ngh: SerializedView = {};\n  const tView = lView[TVIEW];\n  const i18nChildren = getOrComputeI18nChildren(tView, context);\n  const nativeElementsToEventTypes = context.shouldReplayEvents\n    ? collectDomEventsInfo(tView, lView, context.eventTypesToReplay)\n    : null;\n  // Iterate over DOM element references in an LView.\n  for (let i = HEADER_OFFSET; i < tView.bindingStartIndex; i++) {\n    const tNode = tView.data[i];\n    const noOffsetIndex = i - HEADER_OFFSET;\n\n    // Attempt to serialize any i18n data for the given slot. We do this first, as i18n\n    // has its own process for serialization.\n    const i18nData = trySerializeI18nBlock(lView, i, context);\n    if (i18nData) {\n      ngh[I18N_DATA] ??= {};\n      ngh[I18N_DATA][noOffsetIndex] = i18nData.caseQueue;\n\n      for (const nodeNoOffsetIndex of i18nData.disconnectedNodes) {\n        appendDisconnectedNodeIndex(ngh, nodeNoOffsetIndex);\n      }\n\n      for (const nodeNoOffsetIndex of i18nData.disjointNodes) {\n        const tNode = tView.data[nodeNoOffsetIndex + HEADER_OFFSET] as TNode;\n        ngDevMode && assertTNode(tNode);\n        appendSerializedNodePath(ngh, tNode, lView, i18nChildren);\n      }\n\n      continue;\n    }\n\n    // Skip processing of a given slot in the following cases:\n    // - Local refs (e.g. <div #localRef>) take up an extra slot in LViews\n    //   to store the same element. In this case, there is no information in\n    //   a corresponding slot in TNode data structure.\n    // - When a slot contains something other than a TNode. For example, there\n    //   might be some metadata information about a defer block or a control flow block.\n    if (!isTNodeShape(tNode)) {\n      continue;\n    }\n\n    // Skip any nodes that are in an i18n block but are considered detached (i.e. not\n    // present in the template). These nodes are disconnected from the DOM tree, and\n    // so we don't want to serialize any information about them.\n    if (isDetachedByI18n(tNode)) {\n      continue;\n    }\n\n    // Serialize information about template.\n    if (isLContainer(lView[i]) && tNode.tView) {\n      ngh[TEMPLATES] ??= {};\n      ngh[TEMPLATES][noOffsetIndex] = getSsrId(tNode.tView!);\n    }\n\n    // Check if a native node that represents a given TNode is disconnected from the DOM tree.\n    // Such nodes must be excluded from the hydration (since the hydration won't be able to\n    // find them), so the TNode ids are collected and used at runtime to skip the hydration.\n    // This situation may happen during the content projection, when some nodes don't make it\n    // into one of the content projection slots (for example, when there is no default\n    // <ng-content /> slot in projector component's template).\n    if (isDisconnectedNode(tNode, lView) && isContentProjectedNode(tNode)) {\n      appendDisconnectedNodeIndex(ngh, tNode);\n      continue;\n    }\n\n    if (Array.isArray(tNode.projection)) {\n      for (const projectionHeadTNode of tNode.projection) {\n        // We may have `null`s in slots with no projected content.\n        if (!projectionHeadTNode) continue;\n\n        if (!Array.isArray(projectionHeadTNode)) {\n          // If we process re-projected content (i.e. `<ng-content>`\n          // appears at projection location), skip annotations for this content\n          // since all DOM nodes in this projection were handled while processing\n          // a parent lView, which contains those nodes.\n          if (\n            !isProjectionTNode(projectionHeadTNode) &&\n            !isInSkipHydrationBlock(projectionHeadTNode)\n          ) {\n            if (isDisconnectedNode(projectionHeadTNode, lView)) {\n              // Check whether this node is connected, since we may have a TNode\n              // in the data structure as a projection segment head, but the\n              // content projection slot might be disabled (e.g.\n              // <ng-content *ngIf=\"false\" />).\n              appendDisconnectedNodeIndex(ngh, projectionHeadTNode);\n            } else {\n              appendSerializedNodePath(ngh, projectionHeadTNode, lView, i18nChildren);\n            }\n          }\n        } else {\n          // If a value is an array, it means that we are processing a projection\n          // where projectable nodes were passed in as DOM nodes (for example, when\n          // calling `ViewContainerRef.createComponent(CmpA, {projectableNodes: [...]})`).\n          //\n          // In this scenario, nodes can come from anywhere (either created manually,\n          // accessed via `document.querySelector`, etc) and may be in any state\n          // (attached or detached from the DOM tree). As a result, we can not reliably\n          // restore the state for such cases during hydration.\n\n          throw unsupportedProjectionOfDomNodes(unwrapRNode(lView[i]));\n        }\n      }\n    }\n\n    conditionallyAnnotateNodePath(ngh, tNode, lView, i18nChildren);\n    if (isLContainer(lView[i])) {\n      // Serialize views within this LContainer.\n      const hostNode = lView[i][HOST]!; // host node of this container\n\n      // LView[i][HOST] can be of 2 different types:\n      // - either a DOM node\n      // - or an array that represents an LView of a component\n      if (Array.isArray(hostNode)) {\n        // This is a component, serialize info about it.\n        const targetNode = unwrapRNode(hostNode as LView) as RElement;\n        if (!(targetNode as HTMLElement).hasAttribute(SKIP_HYDRATION_ATTR_NAME)) {\n          annotateHostElementForHydration(\n            targetNode,\n            hostNode as LView,\n            parentDeferBlockId,\n            context,\n          );\n        }\n      }\n\n      ngh[CONTAINERS] ??= {};\n      ngh[CONTAINERS][noOffsetIndex] = serializeLContainer(\n        lView[i],\n        tNode,\n        lView,\n        parentDeferBlockId,\n        context,\n      );\n    } else if (Array.isArray(lView[i]) && !isLetDeclaration(tNode)) {\n      // This is a component, annotate the host node with an `ngh` attribute.\n      // Note: Let declarations that return an array are also storing an array in the LView,\n      // we need to exclude them.\n      const targetNode = unwrapRNode(lView[i][HOST]!);\n      if (!(targetNode as HTMLElement).hasAttribute(SKIP_HYDRATION_ATTR_NAME)) {\n        annotateHostElementForHydration(\n          targetNode as RElement,\n          lView[i],\n          parentDeferBlockId,\n          context,\n        );\n      }\n    } else {\n      // <ng-container> case\n      if (tNode.type & TNodeType.ElementContainer) {\n        // An <ng-container> is represented by the number of\n        // top-level nodes. This information is needed to skip over\n        // those nodes to reach a corresponding anchor node (comment node).\n        ngh[ELEMENT_CONTAINERS] ??= {};\n        ngh[ELEMENT_CONTAINERS][noOffsetIndex] = calcNumRootNodes(tView, lView, tNode.child);\n      } else if (tNode.type & (TNodeType.Projection | TNodeType.LetDeclaration)) {\n        // Current TNode represents an `<ng-content>` slot or `@let` declaration,\n        // thus it has no DOM elements associated with it, so the **next sibling**\n        // node would not be able to find an anchor. In this case, use full path instead.\n        let nextTNode = tNode.next;\n        // Skip over all `<ng-content>` slots and `@let` declarations in a row.\n        while (\n          nextTNode !== null &&\n          nextTNode.type & (TNodeType.Projection | TNodeType.LetDeclaration)\n        ) {\n          nextTNode = nextTNode.next;\n        }\n        if (nextTNode && !isInSkipHydrationBlock(nextTNode)) {\n          // Handle a tNode after the `<ng-content>` slot.\n          appendSerializedNodePath(ngh, nextTNode, lView, i18nChildren);\n        }\n      } else if (tNode.type & TNodeType.Text) {\n        const rNode = unwrapRNode(lView[i]);\n        processTextNodeBeforeSerialization(context, rNode);\n      }\n    }\n\n    // Attach `jsaction` attribute to elements that have registered listeners,\n    // thus potentially having a need to do an event replay.\n    if (nativeElementsToEventTypes && tNode.type & TNodeType.Element) {\n      const nativeElement = unwrapRNode(lView[i]) as Element;\n      if (nativeElementsToEventTypes.has(nativeElement)) {\n        setJSActionAttributes(\n          nativeElement,\n          nativeElementsToEventTypes.get(nativeElement)!,\n          parentDeferBlockId,\n        );\n      }\n    }\n  }\n  return ngh;\n}\n\n/**\n * Serializes node location in cases when it's needed, specifically:\n *\n *  1. If `tNode.projectionNext` is different from `tNode.next` - it means that\n *     the next `tNode` after projection is different from the one in the original\n *     template. Since hydration relies on `tNode.next`, this serialized info\n *     is required to help runtime code find the node at the correct location.\n *  2. In certain content projection-based use-cases, it's possible that only\n *     a content of a projected element is rendered. In this case, content nodes\n *     require an extra annotation, since runtime logic can't rely on parent-child\n *     connection to identify the location of a node.\n */\nfunction conditionallyAnnotateNodePath(\n  ngh: SerializedView,\n  tNode: TNode,\n  lView: LView<unknown>,\n  excludedParentNodes: Set<number> | null,\n) {\n  if (isProjectionTNode(tNode)) {\n    // Do not annotate projection nodes (<ng-content />), since\n    // they don't have a corresponding DOM node representing them.\n    return;\n  }\n\n  // Handle case #1 described above.\n  if (\n    tNode.projectionNext &&\n    tNode.projectionNext !== tNode.next &&\n    !isInSkipHydrationBlock(tNode.projectionNext)\n  ) {\n    appendSerializedNodePath(ngh, tNode.projectionNext, lView, excludedParentNodes);\n  }\n\n  // Handle case #2 described above.\n  // Note: we only do that for the first node (i.e. when `tNode.prev === null`),\n  // the rest of the nodes would rely on the current node location, so no extra\n  // annotation is needed.\n  if (\n    tNode.prev === null &&\n    tNode.parent !== null &&\n    isDisconnectedNode(tNode.parent, lView) &&\n    !isDisconnectedNode(tNode, lView)\n  ) {\n    appendSerializedNodePath(ngh, tNode, lView, excludedParentNodes);\n  }\n}\n\n/**\n * Determines whether a component instance that is represented\n * by a given LView uses `ViewEncapsulation.ShadowDom`.\n */\nfunction componentUsesShadowDomEncapsulation(lView: LView): boolean {\n  const instance = lView[CONTEXT];\n  if (!instance?.constructor) return false;\n  const def = getComponentDef(instance.constructor);\n  return (\n    def?.encapsulation === ViewEncapsulation.ShadowDom ||\n    def?.encapsulation === ViewEncapsulation.IsolatedShadowDom\n  );\n}\n\n/**\n * Annotates component host element for hydration:\n * - by either adding the `ngh` attribute and collecting hydration-related info\n *   for the serialization and transferring to the client\n * - or by adding the `ngSkipHydration` attribute in case Angular detects that\n *   component contents is not compatible with hydration.\n *\n * @param element The Host element to be annotated\n * @param lView The associated LView\n * @param context The hydration context\n * @returns An index of serialized view from the transfer state object\n *          or `null` when a given component can not be serialized.\n */\nfunction annotateHostElementForHydration(\n  element: RElement,\n  lView: LView,\n  parentDeferBlockId: string | null,\n  context: HydrationContext,\n): number | null {\n  const renderer = lView[RENDERER];\n  if (\n    (hasI18n(lView) && !isI18nHydrationSupportEnabled()) ||\n    componentUsesShadowDomEncapsulation(lView)\n  ) {\n    // Attach the skip hydration attribute if this component:\n    // - either has i18n blocks, since hydrating such blocks is not yet supported\n    // - or uses ShadowDom view encapsulation, since Domino doesn't support\n    //   shadow DOM, so we can not guarantee that client and server representations\n    //   would exactly match\n    renderer.setAttribute(element, SKIP_HYDRATION_ATTR_NAME, '');\n    return null;\n  } else {\n    const ngh = serializeLView(lView, parentDeferBlockId, context);\n    const index = context.serializedViewCollection.add(ngh);\n    renderer.setAttribute(element, NGH_ATTR_NAME, index.toString());\n    return index;\n  }\n}\n\n/**\n * Annotates defer block comment node for hydration:\n *\n * @param comment The Host element to be annotated\n * @param deferBlockId the id of the target defer block\n */\nfunction annotateDeferBlockAnchorForHydration(comment: RComment, deferBlockId: string): void {\n  comment.textContent = `ngh=${deferBlockId}`;\n}\n\n/**\n * Physically inserts the comment nodes to ensure empty text nodes and adjacent\n * text node separators are preserved after server serialization of the DOM.\n * These get swapped back for empty text nodes or separators once hydration happens\n * on the client.\n *\n * @param corruptedTextNodes The Map of text nodes to be replaced with comments\n * @param doc The document\n */\nfunction insertCorruptedTextNodeMarkers(\n  corruptedTextNodes: Map<HTMLElement, string>,\n  doc: Document,\n) {\n  for (const [textNode, marker] of corruptedTextNodes) {\n    textNode.after(doc.createComment(marker));\n  }\n}\n\n/**\n * Detects whether a given TNode represents a node that\n * is being content projected.\n */\nfunction isContentProjectedNode(tNode: TNode): boolean {\n  let currentTNode = tNode;\n  while (currentTNode != null) {\n    // If we come across a component host node in parent nodes -\n    // this TNode is in the content projection section.\n    if (isComponentHost(currentTNode)) {\n      return true;\n    }\n    currentTNode = currentTNode.parent as TNode;\n  }\n  return false;\n}\n\n/**\n * Incremental hydration requires that any defer block root node\n * with interaction or hover triggers have all of their root nodes\n * trigger hydration with those events. So we need to make sure all\n * the root nodes of that block have the proper jsaction attribute\n * to ensure hydration is triggered, since the content is dehydrated\n */\nfunction annotateDeferBlockRootNodesWithJsAction(\n  tDetails: TDeferBlockDetails,\n  rootNodes: any[],\n  parentDeferBlockId: string,\n  context: HydrationContext,\n) {\n  const actionList = convertHydrateTriggersToJsAction(tDetails.hydrateTriggers);\n  for (let et of actionList) {\n    context.eventTypesToReplay.regular.add(et);\n  }\n\n  if (actionList.length > 0) {\n    const elementNodes = (rootNodes as HTMLElement[]).filter(\n      (rn) => rn.nodeType === Node.ELEMENT_NODE,\n    );\n    for (let rNode of elementNodes) {\n      setJSActionAttributes(rNode, actionList, parentDeferBlockId);\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {APP_BOOTSTRAP_LISTENER, ApplicationRef} from '../application/application_ref';\nimport {Console} from '../console';\nimport {\n  ENVIRONMENT_INITIALIZER,\n  EnvironmentProviders,\n  Injector,\n  makeEnvironmentProviders,\n  Provider,\n} from '../di';\nimport {inject} from '../di/injector_compatibility';\nimport {formatRuntimeError, RuntimeError, RuntimeErrorCode} from '../errors';\nimport {enableLocateOrCreateContainerRefImpl} from '../linker/view_container_ref';\nimport {enableLocateOrCreateI18nNodeImpl} from '../render3/i18n/i18n_apply';\nimport {enableLocateOrCreateElementNodeImpl} from '../render3/instructions/element';\nimport {enableLocateOrCreateElementContainerNodeImpl} from '../render3/instructions/element_container';\nimport {enableApplyRootElementTransformImpl} from '../render3/instructions/shared';\nimport {enableLocateOrCreateContainerAnchorImpl} from '../render3/instructions/template';\nimport {enableLocateOrCreateTextNodeImpl} from '../render3/instructions/text';\nimport {getDocument} from '../render3/interfaces/document';\nimport {TransferState} from '../transfer_state';\nimport {performanceMarkFeature} from '../util/performance';\nimport {NgZone} from '../zone';\nimport {withEventReplay} from './event_replay';\n\nimport {cleanupDehydratedViews} from './cleanup';\nimport {\n  enableClaimDehydratedIcuCaseImpl,\n  enablePrepareI18nBlockForHydrationImpl,\n  setIsI18nHydrationSupportEnabled,\n} from './i18n';\nimport {\n  IS_HYDRATION_DOM_REUSE_ENABLED,\n  IS_I18N_HYDRATION_ENABLED,\n  IS_INCREMENTAL_HYDRATION_ENABLED,\n  PRESERVE_HOST_CONTENT,\n} from './tokens';\nimport {\n  appendDeferBlocksToJSActionMap,\n  countBlocksSkippedByHydration,\n  enableRetrieveDeferBlockDataImpl,\n  enableRetrieveHydrationInfoImpl,\n  isIncrementalHydrationEnabled,\n  NGH_DATA_KEY,\n  processBlockData,\n  verifySsrContentsIntegrity,\n} from './utils';\nimport {enableFindMatchingDehydratedViewImpl} from './views';\nimport {DEHYDRATED_BLOCK_REGISTRY, DehydratedBlockRegistry} from '../defer/registry';\nimport {gatherDeferBlocksCommentNodes} from './node_lookup_utils';\nimport {processAndInitTriggers} from '../defer/triggering';\n\n/**\n * Indicates whether the hydration-related code was added,\n * prevents adding it multiple times.\n */\nlet isHydrationSupportEnabled = false;\n\n/**\n * Indicates whether the i18n-related code was added,\n * prevents adding it multiple times.\n *\n * Note: This merely controls whether the code is loaded,\n * while `setIsI18nHydrationSupportEnabled` determines\n * whether i18n blocks are serialized or hydrated.\n */\nlet isI18nHydrationRuntimeSupportEnabled = false;\n\n/**\n * Indicates whether the incremental hydration code was added,\n * prevents adding it multiple times.\n */\nlet isIncrementalHydrationRuntimeSupportEnabled = false;\n\n/**\n * Defines a period of time that Angular waits for the `ApplicationRef.isStable` to emit `true`.\n * If there was no event with the `true` value during this time, Angular reports a warning.\n */\nconst APPLICATION_IS_STABLE_TIMEOUT = 10_000;\n\n/**\n * Brings the necessary hydration code in tree-shakable manner.\n * The code is only present when the `provideClientHydration` is\n * invoked. Otherwise, this code is tree-shaken away during the\n * build optimization step.\n *\n * This technique allows us to swap implementations of methods so\n * tree shaking works appropriately when hydration is disabled or\n * enabled. It brings in the appropriate version of the method that\n * supports hydration only when enabled.\n */\nfunction enableHydrationRuntimeSupport() {\n  if (!isHydrationSupportEnabled) {\n    isHydrationSupportEnabled = true;\n    enableRetrieveHydrationInfoImpl();\n    enableLocateOrCreateElementNodeImpl();\n    enableLocateOrCreateTextNodeImpl();\n    enableLocateOrCreateElementContainerNodeImpl();\n    enableLocateOrCreateContainerAnchorImpl();\n    enableLocateOrCreateContainerRefImpl();\n    enableFindMatchingDehydratedViewImpl();\n    enableApplyRootElementTransformImpl();\n  }\n}\n\n/**\n * Brings the necessary i18n hydration code in tree-shakable manner.\n * Similar to `enableHydrationRuntimeSupport`, the code is only\n * present when `withI18nSupport` is invoked.\n */\nfunction enableI18nHydrationRuntimeSupport() {\n  if (!isI18nHydrationRuntimeSupportEnabled) {\n    isI18nHydrationRuntimeSupportEnabled = true;\n    enableLocateOrCreateI18nNodeImpl();\n    enablePrepareI18nBlockForHydrationImpl();\n    enableClaimDehydratedIcuCaseImpl();\n  }\n}\n\n/**\n * Brings the necessary incremental hydration code in tree-shakable manner.\n * Similar to `enableHydrationRuntimeSupport`, the code is only\n * present when `enableIncrementalHydrationRuntimeSupport` is invoked.\n */\nfunction enableIncrementalHydrationRuntimeSupport() {\n  if (!isIncrementalHydrationRuntimeSupportEnabled) {\n    isIncrementalHydrationRuntimeSupportEnabled = true;\n    enableRetrieveDeferBlockDataImpl();\n  }\n}\n\n/**\n * Outputs a message with hydration stats into a console.\n */\nfunction printHydrationStats(injector: Injector) {\n  const console = injector.get(Console);\n  const message =\n    `Angular hydrated ${ngDevMode!.hydratedComponents} component(s) ` +\n    `and ${ngDevMode!.hydratedNodes} node(s), ` +\n    `${ngDevMode!.componentsSkippedHydration} component(s) were skipped. ` +\n    (isIncrementalHydrationEnabled(injector)\n      ? `${ngDevMode!.deferBlocksWithIncrementalHydration} defer block(s) were configured to use incremental hydration. `\n      : '') +\n    `Learn more at https://angular.dev/guide/hydration.`;\n  // tslint:disable-next-line:no-console\n  console.log(message);\n}\n\n/**\n * Returns a Promise that is resolved when an application becomes stable.\n */\nfunction whenStableWithTimeout(appRef: ApplicationRef): Promise<void> {\n  const whenStablePromise = appRef.whenStable();\n  if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n    const timeoutTime = APPLICATION_IS_STABLE_TIMEOUT;\n    const console = appRef.injector.get(Console);\n    const ngZone = appRef.injector.get(NgZone);\n\n    // The following call should not and does not prevent the app to become stable\n    // We cannot use RxJS timer here because the app would remain unstable.\n    // This also avoids an extra change detection cycle.\n    const timeoutId = ngZone.runOutsideAngular(() => {\n      return setTimeout(() => logWarningOnStableTimedout(timeoutTime, console), timeoutTime);\n    });\n\n    whenStablePromise.finally(() => clearTimeout(timeoutId));\n  }\n\n  return whenStablePromise;\n}\n\n/**\n * Defines a name of an attribute that is added to the <body> tag\n * in the `index.html` file in case a given route was configured\n * with `RenderMode.Client`. 'cm' is an abbreviation for \"Client Mode\".\n */\nexport const CLIENT_RENDER_MODE_FLAG = 'ngcm';\n\n/**\n * Checks whether the `RenderMode.Client` was defined for the current route.\n */\nfunction isClientRenderModeEnabled(): boolean {\n  const doc = getDocument();\n  return (\n    (typeof ngServerMode === 'undefined' || !ngServerMode) &&\n    doc.body.hasAttribute(CLIENT_RENDER_MODE_FLAG)\n  );\n}\n\n/**\n * Returns a set of providers required to setup hydration support\n * for an application that is server side rendered. This function is\n * included into the `provideClientHydration` public API function from\n * the `platform-browser` package.\n *\n * The function sets up an internal flag that would be recognized during\n * the server side rendering time as well, so there is no need to\n * configure or change anything in NgUniversal to enable the feature.\n */\nexport function withDomHydration(): EnvironmentProviders {\n  const providers: Provider[] = [\n    {\n      provide: IS_HYDRATION_DOM_REUSE_ENABLED,\n      useFactory: () => {\n        let isEnabled = true;\n        if (typeof ngServerMode === 'undefined' || !ngServerMode) {\n          // On the client, verify that the server response contains\n          // hydration annotations. Otherwise, keep hydration disabled.\n          const transferState = inject(TransferState, {optional: true});\n          isEnabled = !!transferState?.get(NGH_DATA_KEY, null);\n        }\n        if (isEnabled) {\n          performanceMarkFeature('NgHydration');\n        }\n        return isEnabled;\n      },\n    },\n    {\n      provide: ENVIRONMENT_INITIALIZER,\n      useValue: () => {\n        // i18n support is enabled by calling withI18nSupport(), but there's\n        // no way to turn it off (e.g. for tests), so we turn it off by default.\n        setIsI18nHydrationSupportEnabled(false);\n\n        if (typeof ngServerMode !== 'undefined' && ngServerMode) {\n          // Since this function is used across both server and client,\n          // make sure that the runtime code is only added when invoked\n          // on the client (see the `enableHydrationRuntimeSupport` function\n          // call below).\n          return;\n        }\n\n        if (inject(IS_HYDRATION_DOM_REUSE_ENABLED)) {\n          verifySsrContentsIntegrity(getDocument());\n          enableHydrationRuntimeSupport();\n        } else if (typeof ngDevMode !== 'undefined' && ngDevMode && !isClientRenderModeEnabled()) {\n          const console = inject(Console);\n          const message = formatRuntimeError(\n            RuntimeErrorCode.MISSING_HYDRATION_ANNOTATIONS,\n            'Angular hydration was requested on the client, but there was no ' +\n              'serialized information present in the server response, ' +\n              'thus hydration was not enabled. ' +\n              'Make sure the `provideClientHydration()` is included into the list ' +\n              'of providers in the server part of the application configuration.',\n          );\n          console.warn(message);\n        }\n      },\n      multi: true,\n    },\n  ];\n\n  if (typeof ngServerMode === 'undefined' || !ngServerMode) {\n    providers.push(\n      {\n        provide: PRESERVE_HOST_CONTENT,\n        useFactory: () => {\n          // Preserve host element content only in a browser\n          // environment and when hydration is configured properly.\n          // On a server, an application is rendered from scratch,\n          // so the host content needs to be empty.\n          return inject(IS_HYDRATION_DOM_REUSE_ENABLED);\n        },\n      },\n      {\n        provide: APP_BOOTSTRAP_LISTENER,\n        useFactory: () => {\n          if (inject(IS_HYDRATION_DOM_REUSE_ENABLED)) {\n            const appRef = inject(ApplicationRef);\n\n            return () => {\n              // Wait until an app becomes stable and cleanup all views that\n              // were not claimed during the application bootstrap process.\n              // The timing is similar to when we start the serialization process\n              // on the server.\n              //\n              // Note: the cleanup task *MUST* be scheduled within the Angular zone in Zone apps\n              // to ensure that change detection is properly run afterward.\n              whenStableWithTimeout(appRef).then(() => {\n                // Note: we have to check whether the application is destroyed before\n                // performing other operations with the `injector`.\n                // The application may be destroyed **before** it becomes stable, so when\n                // the `whenStableWithTimeout` resolves, the injector might already be in\n                // a destroyed state. Thus, calling `injector.get` would throw an error\n                // indicating that the injector has already been destroyed.\n                if (appRef.destroyed) {\n                  return;\n                }\n\n                cleanupDehydratedViews(appRef);\n                if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n                  countBlocksSkippedByHydration(appRef.injector);\n                  printHydrationStats(appRef.injector);\n                }\n              });\n            };\n          }\n          return () => {}; // noop\n        },\n        multi: true,\n      },\n    );\n  }\n\n  return makeEnvironmentProviders(providers);\n}\n\n/**\n * Returns a set of providers required to setup support for i18n hydration.\n * Requires hydration to be enabled separately.\n */\nexport function withI18nSupport(): Provider[] {\n  return [\n    {\n      provide: IS_I18N_HYDRATION_ENABLED,\n      useFactory: () => inject(IS_HYDRATION_DOM_REUSE_ENABLED),\n    },\n    {\n      provide: ENVIRONMENT_INITIALIZER,\n      useValue: () => {\n        if (inject(IS_HYDRATION_DOM_REUSE_ENABLED)) {\n          enableI18nHydrationRuntimeSupport();\n          setIsI18nHydrationSupportEnabled(true);\n          performanceMarkFeature('NgI18nHydration');\n        }\n      },\n      multi: true,\n    },\n  ];\n}\n\n/**\n * Returns a set of providers required to setup support for incremental hydration.\n * Requires hydration to be enabled separately.\n * Enabling incremental hydration also enables event replay for the entire app.\n */\nexport function withIncrementalHydration(): Provider[] {\n  const providers: Provider[] = [\n    withEventReplay(),\n    {\n      provide: IS_INCREMENTAL_HYDRATION_ENABLED,\n      useValue: true,\n    },\n    {\n      provide: DEHYDRATED_BLOCK_REGISTRY,\n      useClass: DehydratedBlockRegistry,\n    },\n    {\n      provide: ENVIRONMENT_INITIALIZER,\n      useValue: () => {\n        enableIncrementalHydrationRuntimeSupport();\n        performanceMarkFeature('NgIncrementalHydration');\n      },\n      multi: true,\n    },\n  ];\n\n  if (typeof ngServerMode === 'undefined' || !ngServerMode) {\n    providers.push({\n      provide: APP_BOOTSTRAP_LISTENER,\n      useFactory: () => {\n        const injector = inject(Injector);\n        const doc = getDocument();\n\n        return () => {\n          const deferBlockData = processBlockData(injector);\n          const commentsByBlockId = gatherDeferBlocksCommentNodes(doc, doc.body);\n          processAndInitTriggers(injector, deferBlockData, commentsByBlockId);\n          appendDeferBlocksToJSActionMap(doc, injector);\n        };\n      },\n      multi: true,\n    });\n  }\n\n  return providers;\n}\n\n/**\n *\n * @param time The time in ms until the stable timedout warning message is logged\n */\nfunction logWarningOnStableTimedout(time: number, console: Console): void {\n  const message =\n    `Angular hydration expected the ApplicationRef.isStable() to emit \\`true\\`, but it ` +\n    `didn't happen within ${time}ms. Angular hydration logic depends on the application becoming stable ` +\n    `as a signal to complete hydration process.`;\n\n  console.warn(formatRuntimeError(RuntimeErrorCode.HYDRATION_STABLE_TIMEDOUT, message));\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nexport const PERFORMANCE_MARK_PREFIX = '🅰️';\n\nlet enablePerfLogging = false;\n\n/**\n * Function that will start measuring against the performance API\n * Should be used in pair with stopMeasuring\n */\nexport function startMeasuring<T>(label: string): void {\n  if (!enablePerfLogging) {\n    return;\n  }\n\n  const {startLabel} = labels(label);\n  /* tslint:disable:ban */\n  performance.mark(startLabel);\n  /* tslint:enable:ban */\n}\n\n/**\n * Function that will stop measuring against the performance API\n * Should be used in pair with startMeasuring\n */\nexport function stopMeasuring(label: string): void {\n  if (!enablePerfLogging) {\n    return;\n  }\n\n  const {startLabel, labelName, endLabel} = labels(label);\n  /* tslint:disable:ban */\n  performance.mark(endLabel);\n  performance.measure(labelName, startLabel, endLabel);\n  performance.clearMarks(startLabel);\n  performance.clearMarks(endLabel);\n  /* tslint:enable:ban */\n}\n\nexport function labels(label: string) {\n  const labelName = `${PERFORMANCE_MARK_PREFIX}:${label}`;\n  return {\n    labelName,\n    startLabel: `start:${labelName}`,\n    endLabel: `end:${labelName}`,\n  };\n}\n\nlet warningLogged = false;\n/**\n * This enables an internal performance profiler\n *\n * It should not be imported in application code\n */\nexport function enableProfiling() {\n  if (\n    !warningLogged &&\n    (typeof performance === 'undefined' || !performance.mark || !performance.measure)\n  ) {\n    warningLogged = true;\n    console.warn('Performance API is not supported on this platform');\n    return;\n  }\n\n  enablePerfLogging = true;\n}\nexport function disableProfiling() {\n  enablePerfLogging = false;\n}\n","/*!\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ComponentDef} from '../render3';\nimport {readPatchedLView} from '../render3/context_discovery';\nimport {isComponentHost, isLContainer, isLView} from '../render3/interfaces/type_checks';\nimport {HEADER_OFFSET, HOST, TVIEW} from '../render3/interfaces/view';\nimport {getTNode} from '../render3/util/view_utils';\n\n/**\n * Gets the class name of the closest component to a node.\n * Warning! this function will return minified names if the name of the component is minified. The\n * consumer of the function is responsible for resolving the minified name to its original name.\n * @param node Node from which to start the search.\n */\nexport function getClosestComponentName(node: Node): string | null {\n  let currentNode = node as Node | null;\n\n  while (currentNode) {\n    const lView = readPatchedLView(currentNode);\n\n    if (lView !== null) {\n      for (let i = HEADER_OFFSET; i < lView.length; i++) {\n        const current = lView[i];\n\n        if ((!isLView(current) && !isLContainer(current)) || current[HOST] !== currentNode) {\n          continue;\n        }\n\n        const tView = lView[TVIEW];\n        const tNode = getTNode(tView, i);\n        if (isComponentHost(tNode)) {\n          const def = tView.data[tNode.directiveStart + tNode.componentOffset] as ComponentDef<{}>;\n          const name = def.debugInfo?.className || def.type.name;\n\n          // Note: the name may be an empty string if the class name is\n          // dropped due to minification. In such cases keep going up the tree.\n          if (name) {\n            return name;\n          } else {\n            break;\n          }\n        }\n      }\n    }\n\n    currentNode = currentNode.parentNode;\n  }\n\n  return null;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  FactoryTarget,\n  getCompilerFacade,\n  JitCompilerUsage,\n  R3DeclareComponentFacade,\n  R3DeclareDirectiveFacade,\n  R3DeclareFactoryFacade,\n  R3DeclareInjectableFacade,\n  R3DeclareInjectorFacade,\n  R3DeclareNgModuleFacade,\n  R3DeclarePipeFacade,\n} from '../../compiler/compiler_facade';\nimport {Type} from '../../interface/type';\nimport {setClassMetadata, setClassMetadataAsync} from '../metadata';\n\nimport {angularCoreEnv} from './environment';\n\n/**\n * Compiles a partial directive declaration object into a full directive definition object.\n *\n * @codeGenApi\n */\nexport function ɵɵngDeclareDirective(decl: R3DeclareDirectiveFacade): unknown {\n  const compiler = getCompilerFacade({\n    usage: JitCompilerUsage.PartialDeclaration,\n    kind: 'directive',\n    type: decl.type,\n  });\n  return compiler.compileDirectiveDeclaration(\n    angularCoreEnv,\n    `ng:///${decl.type.name}/ɵfac.js`,\n    decl,\n  );\n}\n\n/**\n * Evaluates the class metadata declaration.\n *\n * @codeGenApi\n */\nexport function ɵɵngDeclareClassMetadata(decl: {\n  type: Type<any>;\n  decorators: any[];\n  ctorParameters?: () => any[];\n  propDecorators?: {[field: string]: any};\n}): void {\n  setClassMetadata(\n    decl.type,\n    decl.decorators,\n    decl.ctorParameters ?? null,\n    decl.propDecorators ?? null,\n  );\n}\n\n/**\n * Evaluates the class metadata of a component that contains deferred blocks.\n *\n * @codeGenApi\n */\nexport function ɵɵngDeclareClassMetadataAsync(decl: {\n  type: Type<any>;\n  resolveDeferredDeps: () => Promise<Type<unknown>>[];\n  resolveMetadata: (...types: Type<unknown>[]) => {\n    decorators: any[];\n    ctorParameters: (() => any[]) | null;\n    propDecorators: {[field: string]: any} | null;\n  };\n}): void {\n  setClassMetadataAsync(decl.type, decl.resolveDeferredDeps, (...types: Type<unknown>[]) => {\n    const meta = decl.resolveMetadata(...types);\n    setClassMetadata(decl.type, meta.decorators, meta.ctorParameters, meta.propDecorators);\n  });\n}\n\n/**\n * Compiles a partial component declaration object into a full component definition object.\n *\n * @codeGenApi\n */\nexport function ɵɵngDeclareComponent(decl: R3DeclareComponentFacade): unknown {\n  const compiler = getCompilerFacade({\n    usage: JitCompilerUsage.PartialDeclaration,\n    kind: 'component',\n    type: decl.type,\n  });\n  return compiler.compileComponentDeclaration(\n    angularCoreEnv,\n    `ng:///${decl.type.name}/ɵcmp.js`,\n    decl,\n  );\n}\n\n/**\n * Compiles a partial pipe declaration object into a full pipe definition object.\n *\n * @codeGenApi\n */\nexport function ɵɵngDeclareFactory(decl: R3DeclareFactoryFacade): unknown {\n  const compiler = getCompilerFacade({\n    usage: JitCompilerUsage.PartialDeclaration,\n    kind: getFactoryKind(decl.target),\n    type: decl.type,\n  });\n  return compiler.compileFactoryDeclaration(\n    angularCoreEnv,\n    `ng:///${decl.type.name}/ɵfac.js`,\n    decl,\n  );\n}\n\nfunction getFactoryKind(target: FactoryTarget) {\n  switch (target) {\n    case FactoryTarget.Directive:\n      return 'directive';\n    case FactoryTarget.Component:\n      return 'component';\n    case FactoryTarget.Injectable:\n      return 'injectable';\n    case FactoryTarget.Pipe:\n      return 'pipe';\n    case FactoryTarget.NgModule:\n      return 'NgModule';\n  }\n}\n\n/**\n * Compiles a partial injectable declaration object into a full injectable definition object.\n *\n * @codeGenApi\n */\nexport function ɵɵngDeclareInjectable(decl: R3DeclareInjectableFacade): unknown {\n  const compiler = getCompilerFacade({\n    usage: JitCompilerUsage.PartialDeclaration,\n    kind: 'injectable',\n    type: decl.type,\n  });\n  return compiler.compileInjectableDeclaration(\n    angularCoreEnv,\n    `ng:///${decl.type.name}/ɵprov.js`,\n    decl,\n  );\n}\n\n/**\n * These enums are used in the partial factory declaration calls.\n */\nexport {FactoryTarget} from '../../compiler/compiler_facade';\n\n/**\n * Compiles a partial injector declaration object into a full injector definition object.\n *\n * @codeGenApi\n */\nexport function ɵɵngDeclareInjector(decl: R3DeclareInjectorFacade): unknown {\n  const compiler = getCompilerFacade({\n    usage: JitCompilerUsage.PartialDeclaration,\n    kind: 'NgModule',\n    type: decl.type,\n  });\n  return compiler.compileInjectorDeclaration(\n    angularCoreEnv,\n    `ng:///${decl.type.name}/ɵinj.js`,\n    decl,\n  );\n}\n\n/**\n * Compiles a partial NgModule declaration object into a full NgModule definition object.\n *\n * @codeGenApi\n */\nexport function ɵɵngDeclareNgModule(decl: R3DeclareNgModuleFacade): unknown {\n  const compiler = getCompilerFacade({\n    usage: JitCompilerUsage.PartialDeclaration,\n    kind: 'NgModule',\n    type: decl.type,\n  });\n  return compiler.compileNgModuleDeclaration(\n    angularCoreEnv,\n    `ng:///${decl.type.name}/ɵmod.js`,\n    decl,\n  );\n}\n\n/**\n * Compiles a partial pipe declaration object into a full pipe definition object.\n *\n * @codeGenApi\n */\nexport function ɵɵngDeclarePipe(decl: R3DeclarePipeFacade): unknown {\n  const compiler = getCompilerFacade({\n    usage: JitCompilerUsage.PartialDeclaration,\n    kind: 'pipe',\n    type: decl.type,\n  });\n  return compiler.compilePipeDeclaration(angularCoreEnv, `ng:///${decl.type.name}/ɵpipe.js`, decl);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  consumerAfterComputation,\n  consumerBeforeComputation,\n  consumerDestroy,\n  consumerPollProducersForChange,\n  producerAccessed,\n  SIGNAL,\n  SIGNAL_NODE,\n  type SignalNode,\n} from '../../../primitives/signals';\nimport {type EffectCleanupFn, type EffectCleanupRegisterFn} from './effect';\nimport {type Signal} from '../reactivity/api';\nimport {TracingService, TracingSnapshot} from '../../application/tracing';\nimport {\n  ChangeDetectionScheduler,\n  NotificationSource,\n} from '../../change_detection/scheduling/zoneless_scheduling';\nimport {assertInInjectionContext} from '../../di/contextual';\nimport {Injector} from '../../di/injector';\nimport {inject} from '../../di/injector_compatibility';\nimport {DestroyRef} from '../../linker/destroy_ref';\nimport {AfterRenderPhase, type AfterRenderRef} from '../after_render/api';\nimport {NOOP_AFTER_RENDER_REF, type AfterRenderOptions} from '../after_render/hooks';\nimport {\n  AFTER_RENDER_PHASES,\n  AfterRenderImpl,\n  AfterRenderManager,\n  AfterRenderSequence,\n} from '../after_render/manager';\nimport {LView} from '../interfaces/view';\nimport {ViewContext} from '../view_context';\nimport {assertNotInReactiveContext} from './asserts';\nimport {\n  emitAfterRenderEffectPhaseCreatedEvent,\n  setInjectorProfilerContext,\n} from '../debug/injector_profiler';\n\nconst NOT_SET = /* @__PURE__ */ Symbol('NOT_SET');\nconst EMPTY_CLEANUP_SET = /* @__PURE__ */ new Set<() => void>();\n\n/** Callback type for an `afterRenderEffect` phase effect */\ntype AfterRenderPhaseEffectHook = (\n  // Either a cleanup function or a pipelined value and a cleanup function\n  ...args:\n    | [onCleanup: EffectCleanupRegisterFn]\n    | [previousPhaseValue: unknown, onCleanup: EffectCleanupRegisterFn]\n) => unknown;\n\n/**\n * Reactive node in the graph for this `afterRenderEffect` phase effect.\n *\n * This node type extends `SignalNode` because `afterRenderEffect` phases effects produce a value\n * which is consumed as a `Signal` by subsequent phases.\n */\nexport interface AfterRenderPhaseEffectNode extends SignalNode<unknown> {\n  /** The phase of the effect implemented by this node */\n  phase: AfterRenderPhase;\n  /** The sequence of phases to which this node belongs, used for state of the whole sequence */\n  sequence: AfterRenderEffectSequence;\n  /** The user's callback function */\n  userFn: AfterRenderPhaseEffectHook;\n  /** Signal function that retrieves the value of this node, used as the value for the next phase */\n  signal: Signal<unknown>;\n  /** Registered cleanup functions, or `null` if none have ever been registered */\n  cleanup: Set<() => void> | null;\n  /** Pre-bound helper function passed to the user's callback which writes to `this.cleanup` */\n  registerCleanupFn: EffectCleanupRegisterFn;\n  /** Entrypoint to running this effect that's given to the `afterRender` machinery */\n  phaseFn(previousValue?: unknown): unknown;\n}\n\nconst AFTER_RENDER_PHASE_EFFECT_NODE = /* @__PURE__ */ (() => ({\n  ...SIGNAL_NODE,\n  kind: 'afterRenderEffectPhase',\n  consumerIsAlwaysLive: true,\n  consumerAllowSignalWrites: true,\n  value: NOT_SET,\n  cleanup: null,\n  /** Called when the effect becomes dirty */\n  consumerMarkedDirty(this: AfterRenderPhaseEffectNode): void {\n    if (this.sequence.impl.executing) {\n      // If hooks are in the middle of executing, then it matters whether this node has yet been\n      // executed within its sequence. If not, then we don't want to notify the scheduler since\n      // this node will be reached naturally.\n      if (this.sequence.lastPhase === null || this.sequence.lastPhase < this.phase) {\n        return;\n      }\n\n      // If during the execution of a later phase an earlier phase became dirty, then we should not\n      // run any further phases until the earlier one reruns.\n      this.sequence.erroredOrDestroyed = true;\n    }\n\n    // Either hooks are not running, or we're marking a node dirty that has already run within its\n    // sequence.\n    this.sequence.scheduler.notify(NotificationSource.RenderHook);\n  },\n  phaseFn(this: AfterRenderPhaseEffectNode, previousValue?: unknown): unknown {\n    this.sequence.lastPhase = this.phase;\n\n    if (!this.dirty) {\n      return this.signal;\n    }\n\n    this.dirty = false;\n    if (this.value !== NOT_SET && !consumerPollProducersForChange(this)) {\n      // None of our producers report a change since the last time they were read, so no\n      // recomputation of our value is necessary.\n      return this.signal;\n    }\n\n    // Run any needed cleanup functions.\n    try {\n      for (const cleanupFn of this.cleanup ?? EMPTY_CLEANUP_SET) {\n        cleanupFn();\n      }\n    } finally {\n      // Even if a cleanup function errors, ensure it's cleared.\n      this.cleanup?.clear();\n    }\n\n    // Prepare to call the user's effect callback. If there was a previous phase, then it gave us\n    // its value as a `Signal`, otherwise `previousValue` will be `undefined`.\n    const args: unknown[] = [];\n    if (previousValue !== undefined) {\n      args.push(previousValue);\n    }\n    args.push(this.registerCleanupFn);\n\n    // Call the user's callback in our reactive context.\n    const prevConsumer = consumerBeforeComputation(this);\n    let newValue;\n    try {\n      newValue = this.userFn.apply(null, args as any);\n    } finally {\n      consumerAfterComputation(this, prevConsumer);\n    }\n\n    if (this.value === NOT_SET || !this.equal(this.value, newValue)) {\n      this.value = newValue;\n      this.version++;\n    }\n\n    return this.signal;\n  },\n}))();\n\n/**\n * An `AfterRenderSequence` that manages an `afterRenderEffect`'s phase effects.\n */\nexport class AfterRenderEffectSequence extends AfterRenderSequence {\n  /**\n   * While this sequence is executing, this tracks the last phase which was called by the\n   * `afterRender` machinery.\n   *\n   * When a phase effect is marked dirty, this is used to determine whether it's already run or not.\n   */\n  lastPhase: AfterRenderPhase | null = null;\n\n  /**\n   * The reactive nodes for each phase, if a phase effect is defined for that phase.\n   *\n   * These are initialized to `undefined` but set in the constructor.\n   */\n  private readonly nodes: [\n    AfterRenderPhaseEffectNode | undefined,\n    AfterRenderPhaseEffectNode | undefined,\n    AfterRenderPhaseEffectNode | undefined,\n    AfterRenderPhaseEffectNode | undefined,\n  ] = [undefined, undefined, undefined, undefined];\n\n  constructor(\n    impl: AfterRenderImpl,\n    effectHooks: Array<AfterRenderPhaseEffectHook | undefined>,\n    view: LView | undefined,\n    readonly scheduler: ChangeDetectionScheduler,\n    injector: Injector,\n    snapshot: TracingSnapshot | null = null,\n  ) {\n    // Note that we also initialize the underlying `AfterRenderSequence` hooks to `undefined` and\n    // populate them as we create reactive nodes below.\n    super(\n      impl,\n      [undefined, undefined, undefined, undefined],\n      view,\n      false,\n      injector.get(DestroyRef),\n      snapshot,\n    );\n\n    // Setup a reactive node for each phase.\n    for (const phase of AFTER_RENDER_PHASES) {\n      const effectHook = effectHooks[phase];\n      if (effectHook === undefined) {\n        continue;\n      }\n\n      const node = Object.create(AFTER_RENDER_PHASE_EFFECT_NODE) as AfterRenderPhaseEffectNode;\n      node.sequence = this;\n      node.phase = phase;\n      node.userFn = effectHook;\n      node.dirty = true;\n      node.signal = (() => {\n        producerAccessed(node);\n        return node.value;\n      }) as Signal<unknown>;\n      node.signal[SIGNAL] = node;\n      node.registerCleanupFn = (fn: EffectCleanupFn) =>\n        (node.cleanup ??= new Set<() => void>()).add(fn);\n\n      this.nodes[phase] = node;\n\n      // Install the upstream hook which runs the `phaseFn` for this phase.\n      this.hooks[phase] = (value) => node.phaseFn(value);\n\n      if (ngDevMode) {\n        setupDebugInfo(node, injector);\n      }\n    }\n  }\n\n  override afterRun(): void {\n    super.afterRun();\n    // We're done running this sequence, so reset `lastPhase`.\n    this.lastPhase = null;\n  }\n\n  override destroy(): void {\n    super.destroy();\n\n    // Run the cleanup functions for each node.\n    for (const node of this.nodes) {\n      if (node) {\n        try {\n          for (const fn of node.cleanup ?? EMPTY_CLEANUP_SET) {\n            fn();\n          }\n        } finally {\n          consumerDestroy(node);\n        }\n      }\n    }\n  }\n}\n\n/**\n * An argument list containing the first non-never type in the given type array, or an empty\n * argument list if there are no non-never types in the type array.\n */\nexport type ɵFirstAvailableSignal<T extends unknown[]> = T extends [infer H, ...infer R]\n  ? [H] extends [never]\n    ? ɵFirstAvailableSignal<R>\n    : [Signal<H>]\n  : [];\n\n/**\n * Register an effect that, when triggered, is invoked when the application finishes rendering, during the\n * `mixedReadWrite` phase.\n *\n * <div class=\"docs-alert docs-alert-critical\">\n *\n * You should prefer specifying an explicit phase for the effect instead, or you risk significant\n * performance degradation.\n *\n * </div>\n *\n * Note that callback-based `afterRenderEffect`s will run\n * - in the order it they are registered\n * - only when dirty\n * - on browser platforms only\n * - during the `mixedReadWrite` phase\n *\n * <div class=\"docs-alert docs-alert-important\">\n *\n * Components are not guaranteed to be [hydrated](guide/hydration) before the callback runs.\n * You must use caution when directly reading or writing the DOM and layout.\n *\n * </div>\n *\n * @param callback An effect callback function to register\n * @param options Options to control the behavior of the callback\n *\n * @publicApi\n */\nexport function afterRenderEffect(\n  callback: (onCleanup: EffectCleanupRegisterFn) => void,\n  options?: AfterRenderOptions,\n): AfterRenderRef;\n/**\n * Register effects that, when triggered, are invoked when the application finishes rendering,\n * during the specified phases. The available phases are:\n * - `earlyRead`\n *   Use this phase to **read** from the DOM before a subsequent `write` callback, for example to\n *   perform custom layout that the browser doesn't natively support. Prefer the `read` phase if\n *   reading can wait until after the write phase. **Never** write to the DOM in this phase.\n * - `write`\n *    Use this phase to **write** to the DOM. **Never** read from the DOM in this phase.\n * - `mixedReadWrite`\n *    Use this phase to read from and write to the DOM simultaneously. **Never** use this phase if\n *    it is possible to divide the work among the other phases instead.\n * - `read`\n *    Use this phase to **read** from the DOM. **Never** write to the DOM in this phase.\n *\n * <div class=\"docs-alert docs-alert-critical\">\n *\n * You should prefer using the `read` and `write` phases over the `earlyRead` and `mixedReadWrite`\n * phases when possible, to avoid performance degradation.\n *\n * </div>\n *\n * Note that:\n * - Effects run in the following phase order, only when dirty through signal dependencies:\n *   1. `earlyRead`\n *   2. `write`\n *   3. `mixedReadWrite`\n *   4. `read`\n * - `afterRenderEffect`s in the same phase run in the order they are registered.\n * - `afterRenderEffect`s run on browser platforms only, they will not run on the server.\n * - `afterRenderEffect`s will run at least once.\n *\n * The first phase callback to run as part of this spec will receive no parameters. Each\n * subsequent phase callback in this spec will receive the return value of the previously run\n * phase callback as a `Signal`. This can be used to coordinate work across multiple phases.\n *\n * Angular is unable to verify or enforce that phases are used correctly, and instead\n * relies on each developer to follow the guidelines documented for each value and\n * carefully choose the appropriate one, refactoring their code if necessary. By doing\n * so, Angular is better able to minimize the performance degradation associated with\n * manual DOM access, ensuring the best experience for the end users of your application\n * or library.\n *\n * <div class=\"docs-alert docs-alert-important\">\n *\n * Components are not guaranteed to be [hydrated](guide/hydration) before the callback runs.\n * You must use caution when directly reading or writing the DOM and layout.\n *\n * </div>\n *\n * @param spec The effect functions to register\n * @param options Options to control the behavior of the effects\n *\n * @usageNotes\n *\n * Use `afterRenderEffect` to create effects that will read or write from the DOM and thus should\n * run after rendering.\n *\n * @publicApi\n */\nexport function afterRenderEffect<E = never, W = never, M = never>(\n  spec: {\n    earlyRead?: (onCleanup: EffectCleanupRegisterFn) => E;\n    write?: (...args: [...ɵFirstAvailableSignal<[E]>, EffectCleanupRegisterFn]) => W;\n    mixedReadWrite?: (...args: [...ɵFirstAvailableSignal<[W, E]>, EffectCleanupRegisterFn]) => M;\n    read?: (...args: [...ɵFirstAvailableSignal<[M, W, E]>, EffectCleanupRegisterFn]) => void;\n  },\n  options?: AfterRenderOptions,\n): AfterRenderRef;\n\n/**\n * @publicApi\n */\nexport function afterRenderEffect<E = never, W = never, M = never>(\n  callbackOrSpec:\n    | ((onCleanup: EffectCleanupRegisterFn) => void)\n    | {\n        earlyRead?: (onCleanup: EffectCleanupRegisterFn) => E;\n        write?: (...args: [...ɵFirstAvailableSignal<[E]>, EffectCleanupRegisterFn]) => W;\n        mixedReadWrite?: (\n          ...args: [...ɵFirstAvailableSignal<[W, E]>, EffectCleanupRegisterFn]\n        ) => M;\n        read?: (...args: [...ɵFirstAvailableSignal<[M, W, E]>, EffectCleanupRegisterFn]) => void;\n      },\n  options?: AfterRenderOptions,\n): AfterRenderRef {\n  ngDevMode &&\n    assertNotInReactiveContext(\n      afterRenderEffect,\n      'Call `afterRenderEffect` outside of a reactive context. For example, create the render ' +\n        'effect inside the component constructor`.',\n    );\n\n  if (ngDevMode && !options?.injector) {\n    assertInInjectionContext(afterRenderEffect);\n  }\n\n  if (typeof ngServerMode !== 'undefined' && ngServerMode) {\n    return NOOP_AFTER_RENDER_REF;\n  }\n\n  const injector = options?.injector ?? inject(Injector);\n  const scheduler = injector.get(ChangeDetectionScheduler);\n  const manager = injector.get(AfterRenderManager);\n  const tracing = injector.get(TracingService, null, {optional: true});\n  manager.impl ??= injector.get(AfterRenderImpl);\n\n  let spec = callbackOrSpec;\n  if (typeof spec === 'function') {\n    spec = {mixedReadWrite: callbackOrSpec as any};\n  }\n\n  const viewContext = injector.get(ViewContext, null, {optional: true});\n\n  const sequence = new AfterRenderEffectSequence(\n    manager.impl,\n    [spec.earlyRead, spec.write, spec.mixedReadWrite, spec.read] as AfterRenderPhaseEffectHook[],\n    viewContext?.view,\n    scheduler,\n    injector,\n    tracing?.snapshot(null),\n  );\n  manager.impl.register(sequence);\n  return sequence;\n}\n\nfunction setupDebugInfo(node: AfterRenderPhaseEffectNode, injector: Injector): void {\n  node.debugName = `afterRenderEffect - ${phaseDebugName(node.phase)} phase`;\n  const prevInjectorProfilerContext = setInjectorProfilerContext({injector, token: null});\n  try {\n    emitAfterRenderEffectPhaseCreatedEvent(node);\n  } finally {\n    setInjectorProfilerContext(prevInjectorProfilerContext);\n  }\n}\n\nfunction phaseDebugName(phase: AfterRenderPhase): string {\n  switch (phase) {\n    case AfterRenderPhase.EarlyRead:\n      return 'EarlyRead';\n    case AfterRenderPhase.Write:\n      return 'Write';\n    case AfterRenderPhase.MixedReadWrite:\n      return 'MixedReadWrite';\n    case AfterRenderPhase.Read:\n      return 'Read';\n  }\n}\n"],"names":["SIGNAL_NODE","transformFn","undefined","FactoryTarget","__NG_ELEMENT_ID__","ɵɵinjectAttribute","attributeName","toString","HOST_TAG_NAME_TOKEN","InjectionToken","ngDevMode","flags","tNode","type","value","RuntimeError","getDevModeNodeName","inputRequiredFunction","opts","assertInInjectionContext","viewChildRequiredFn","locator","viewChild","modelRequiredFunction","model","createModelSignal","REQUIRED_UNSET_VALUE","compileNgModuleFactory","injector","options","moduleType","moduleFactory","ngJitMode","Promise","resolve","compilerOptions","get","setJitOptions","defaultEncapsulation","_lastDefined","map","isComponentResourceResolutionQueueEmpty","flatMap","option","providers","compilerProviders","length","compiler","getCompilerFacade","NgZoneChangeDetectionScheduler","inject","ChangeDetectionScheduler","applicationRef","applicationErrorHandler","INTERNAL_APPLICATION_ERROR_HANDLER","_onMicrotaskEmptySubscription","zone","onMicrotaskEmpty","subscribe","next","run","dirtyFlags","e","unsubscribe","NgZoneChangeDetectionScheduler_Factory","__ngFactoryType__","i0","Injectable","internalProvideZoneChangeDetection","ngZoneFactory","scheduleInRootZone","provide","ENVIRONMENT_INITIALIZER","useFactory","ngZoneChangeDetectionScheduler","optional","service","ZoneStablePendingTask","initialize","SCHEDULE_IN_ROOT_ZONE","SCHEDULE_IN_ROOT_ZONE_DEFAULT","performanceMarkFeature","NgZone","ngZoneOptions","PROVIDED_NG_ZONE","useValue","zoneProviders","getNgZoneOptions","shouldCoalesceEventChangeDetection","eventCoalescing","SCAN_DELAY","window","observer","lcpImageUrl","start","ngServerMode","PerformanceObserver","disableImageSizeWarning","disableImageLazyLoadWarning","initPerformanceObserver","doc","getDocument","win","defaultView","waitToScan","setTimeout","scanImages","bind","Zone","root","setup","disconnect","entryList","getEntries","lcpElement","entries","imgSrc","element","src","startsWith","querySelectorAll","lcpElementLoadedCorrectly","index","images","isOversized","image","lcpElementFound","loading","getAttribute","nonOversizedImageExtentions","toLowerCase","computedStyle","getPropertyValue","boxSizing","objectFit","paddingBottom","paddingLeft","renderedWidth","parseFloat","paddingRight","naturalWidth","naturalHeight","recommendedWidth","devicePixelRatio","recommendedHeight","renderedHeight","oversizedWidth","OVERSIZED_IMAGE_TOLERANCE","intrinsicHeight","ENABLE_ROOT_COMPONENT_BOOTSTRAP","isApplicationBootstrapConfig","config","moduleRef","bootstrap","r3Injector","ngZone","envInjector","resolveInjectorInitializers","PROVIDED_ZONELESS","warn","runOutsideAngular","onErrorSubscription","onError","destroyListener","destroy","onPlatformDestroyListeners","platformInjector","PLATFORM_DESTROY_LISTENERS","add","onDestroy","remove","allPlatformModules","delete","_callAndReportToErrorHandler","exceptionHandler","pendingTasks","PendingTasksInternal","taskId","initStatus","ApplicationInitStatus","runInitializers","donePromise","localeId","LOCALE_ID","DEFAULT_LOCALE_ID","setLocaleId","enableRootComponentbootstrap","ApplicationRef","push","imagePerformanceService","ImagePerformanceWarning","_injector","bootstrapModuleFactory","defaultZoneCdProviders","applicationProviders","callback","_destroyListeners","_platformInjector","createPlatform","platform","PlatformRef","runPlatformInitializers","parentPlatformFactory","platformProviders","createPlatformInjector","desc","assertPlatform","marker","createOrReusePlatformInjector","exhaustiveCheckNoChangesInterval","interval","provideEnvironmentInitializer","errorHandler","ErrorHandler","scheduler","ChangeDetectionSchedulerImpl","scheduleCheckNoChanges","destroyed","pendingRenderTaskId","runningTick","allViews","handleError","UseExhaustiveCheckNoChanges","exhaustive","getModuleFactory","id","getNgModuleById","getRegisteredNgModuleType","ViewRef","ChangeDetectorRef","isListLikeIterable","obj","create","trackByFn","DefaultIterableDiffer","trackByIdentity","item","_unlinkedRecords","_previousItHead","_itHead","_itTail","_additionsHead","_movesTail","_removalsHead","_removalsTail","_identityChangesHead","_identityChangesTail","_trackByFn","constructor","forEachItem","fn","record","_next","forEachOperation","nextIt","moveOffsets","nextRemove","currentIndex","getPreviousIndex","addRemoveOffset","_nextRemoved","previousIndex","localMovePreviousIndex","adjPreviousIndex","localCurrentIndex","offset","i","forEachPreviousItem","_nextPrevious","forEachAddedItem","_nextAdded","forEachMovedItem","_movesHead","_nextMoved","forEachRemovedItem","forEachIdentityChange","_nextIdentityChange","diff","collection","stringify","check","Array","isArray","itemTrackBy","Object","is","trackById","_mismatch","mayBeDirty","_verifyReinsertion","_addIdentityChange","isDirty","_additionsTail","_linkedRecords","_moveAfter","previousRecord","_addToMoves","_truncate","_reinsertAfter","prevRecord","prev","_prevRemoved","_insertAfter","_unlink","_addAfter","_prev","_addToRemovals","toIndex","_DuplicateMap","put","IterableChangeRecord_","_prevDup","_nextDup","_head","_tail","atOrAfterIndex","DefaultKeyValueDiffer","Map","_previousMapHead","_changesHead","_mapHead","_nextChanged","isJsObject","insertBefore","_appendAfter","_getOrCreateRecordForKey","key","_insertBeforeOrAppend","_records","previousValue","currentValue","_changesTail","before","has","_maybeAddToChanges","KeyValueChangeRecord_","set","newValue","_addToChanges","_addToAdditions","DefaultKeyValueDifferFactory","platformCore","createPlatformFactory","platformRef","rootComponent","assertStandaloneComponentType","allAppProviders","provideZonelessChangeDetectionInternal","errorHandlerEnvironmentInitializer","validAppIdInitializer","appProviders","appsWithEventReplay","WeakSet","shouldEnableEventReplay","isEnabled","appRef","jsActionMap","JSACTION_BLOCK_ELEMENT_MAP","rEl","nodeType","Node","ELEMENT_NODE","eventName","listenerFn","clearStashFn","clearAppScopedEarlyEventContract","appId","then","eventContractDetails","JSACTION_EVENT_CONTRACT","initEventReplay","EAGER_CONTENT_LISTENERS_KEY","forEach","removeListeners","isIncrementalHydrationEnabled","eventContract","cleanUp","eventDelegation","APP_ID","earlyJsactionData","_ejsas","et","etc","eventInfos","getAppScopedQueuedEventInfos","replayEarlyEventInfos","dispatcher","EventDispatcher","event","invokeRegisteredReplayListeners","currentTarget","registerDispatcher","collectDomEventsInfo","tView","lView","eventTypesToReplay","domEventsInfo","lCleanup","CLEANUP","tCleanup","cleanup","firstParam","secondParam","eventType","isCaptureEventType","views","serializedView","indexByContent","viewAsString","calcNumRootNodes","rootNodes","collectNativeNodes","calcNumRootNodesInLContainer","lContainer","annotateComponentLViewForHydration","context","HOST","annotateLContainerForHydration","hostElement","unwrapRNode","componentLView","renderer","RENDERER","setAttribute","NGH_ATTR_NAME","finalIndex","EVENT_REPLAY_ENABLED_DEFAULT","lNode","getLNodeForHydration","viewRef","isI18nHydrationEnabled","isI18nHydrationEnabledVal","i18nChildren","shouldReplayEvents","isLContainer","blocks","info","NGH_DEFER_BLOCKS_KEY","numRootNodes","isRootView","childLView","HEADER_OFFSET","TEMPLATE_ID","TVIEW","ssrId","NUM_ROOT_NODES","childTView","template","getSsrId","firstChild","lDetails","getLDeferBlockDetails","tDetails","getTDeferBlockDetails","hydrateTriggers","deferBlockId","deferBlocks","size","isHydrateNeverBlock","collectNativeNodesInLContainer","deferBlockInfo","DEFER_BLOCK_STATE","CURRENT_DEFER_BLOCK_STATE","serializedTriggers","serializeHydrateTriggers","DEFER_HYDRATE_TRIGGERS","parentDeferBlockId","DEFER_PARENT_BLOCK_ID","node","COMMENT_NODE","annotateDeferBlockAnchorForHydration","validateNodeExists","validateMatchingNode","annotateDeferBlockRootNodesWithJsAction","DEFER_BLOCK_ID","JSON","currentViewAsString","Set","trigger","delay","details","appendSerializedNodePath","ngh","excludedParentNodes","appendDisconnectedNodeIndex","tNodeOrNoOffsetIndex","noOffsetIndex","i18nData","trySerializeI18nBlock","I18N_DATA","caseQueue","nodeNoOffsetIndex","disconnectedNodes","disjointNodes","data","assertTNode","isDetachedByI18n","isDisconnectedNode","isContentProjectedNode","projectionHeadTNode","isProjectionTNode","isInSkipHydrationBlock","unsupportedProjectionOfDomNodes","hostNode","targetNode","hasAttribute","SKIP_HYDRATION_ATTR_NAME","annotateHostElementForHydration","enableLocateOrCreateElementContainerNodeImpl","enableLocateOrCreateContainerRefImpl","enableFindMatchingDehydratedViewImpl","enableApplyRootElementTransformImpl","isI18nHydrationRuntimeSupportEnabled","isIncrementalHydrationRuntimeSupportEnabled","message","hydratedComponents","hydratedNodes","deferBlocksWithIncrementalHydration","log","console","Console","logWarningOnStableTimedout","timeoutTime","clearTimeout","timeoutId","NGH_DATA_KEY","enableHydrationRuntimeSupport","formatRuntimeError","IS_HYDRATION_DOM_REUSE_ENABLED","APP_BOOTSTRAP_LISTENER","whenStableWithTimeout","cleanupDehydratedViews","countBlocksSkippedByHydration","printHydrationStats","withI18nSupport","enableI18nHydrationRuntimeSupport","setIsI18nHydrationSupportEnabled","multi","PERFORMANCE_MARK_PREFIX","startMeasuring","label","performance","mark","startLabel","stopMeasuring","endLabel","measure","labelName","clearMarks","warningLogged","getClosestComponentName","currentNode","isLView","current","getTNode","def","debugInfo","className","name","ɵɵngDeclareDirective","decl","compileDirectiveDeclaration","angularCoreEnv","ɵɵngDeclareClassMetadataAsync","setClassMetadataAsync","resolveDeferredDeps","types","ɵɵngDeclareComponent","usage","compileComponentDeclaration","compileFactoryDeclaration","Component","ɵɵngDeclareInjectable","NOT_SET","Symbol","kind","consumerAllowSignalWrites","consumerMarkedDirty","sequence","impl","executing","lastPhase","phase","notify","dirty","signal","cleanupFn","EMPTY_CLEANUP_SET","clear","args","prevConsumer","consumerBeforeComputation","userFn","apply","equal","effectHooks","view","snapshot","effectHook","AFTER_RENDER_PHASE_EFFECT_NODE"],"mappings":"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"}
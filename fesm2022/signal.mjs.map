{"version":3,"file":"signal.mjs","sources":["../../../../../k8-fastbuild-ST-46c76129e412/bin/packages/core/primitives/signals/src/equality.ts","../../../../../k8-fastbuild-ST-46c76129e412/bin/packages/core/primitives/signals/src/graph.ts","../../../../../k8-fastbuild-ST-46c76129e412/bin/packages/core/primitives/signals/src/computed.ts","../../../../../k8-fastbuild-ST-46c76129e412/bin/packages/core/primitives/signals/src/errors.ts","../../../../../k8-fastbuild-ST-46c76129e412/bin/packages/core/primitives/signals/src/signal.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\n/**\n * A comparison function which can determine if two values are equal.\n */\nexport type ValueEqualityFn<T> = (a: T, b: T) => boolean;\n\n/**\n * The default equality function used for `signal` and `computed`, which uses referential equality.\n */\nexport function defaultEquals<T>(a: T, b: T) {\n  return Object.is(a, b);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\n// Required as the signals library is in a separate package, so we need to explicitly ensure the\n// global `ngDevMode` type is defined.\ndeclare const ngDevMode: boolean | undefined;\n\n/**\n * The currently active consumer `ReactiveNode`, if running code in a reactive context.\n *\n * Change this via `setActiveConsumer`.\n */\nlet activeConsumer: ReactiveNode | null = null;\nlet inNotificationPhase = false;\n\ntype Version = number & {__brand: 'Version'};\n\n/**\n * Global epoch counter. Incremented whenever a source signal is set.\n */\nlet epoch: Version = 1 as Version;\n\nexport type ReactiveHookFn = (node: ReactiveNode) => void;\n\n/**\n * If set, called after a producer `ReactiveNode` is created.\n */\nlet postProducerCreatedFn: ReactiveHookFn | null = null;\n\n/**\n * Symbol used to tell `Signal`s apart from other functions.\n *\n * This can be used to auto-unwrap signals in various cases, or to auto-wrap non-signal values.\n */\nexport const SIGNAL: unique symbol = /* @__PURE__ */ Symbol('SIGNAL');\n\nexport function setActiveConsumer(consumer: ReactiveNode | null): ReactiveNode | null {\n  const prev = activeConsumer;\n  activeConsumer = consumer;\n  return prev;\n}\n\nexport function getActiveConsumer(): ReactiveNode | null {\n  return activeConsumer;\n}\n\nexport function isInNotificationPhase(): boolean {\n  return inNotificationPhase;\n}\n\nexport interface Reactive {\n  [SIGNAL]: ReactiveNode;\n}\n\nexport function isReactive(value: unknown): value is Reactive {\n  return (value as Partial<Reactive>)[SIGNAL] !== undefined;\n}\n\nexport const REACTIVE_NODE: ReactiveNode = {\n  version: 0 as Version,\n  lastCleanEpoch: 0 as Version,\n  dirty: false,\n  producers: undefined,\n  producersTail: undefined,\n  consumers: undefined,\n  consumersTail: undefined,\n  recomputing: false,\n  consumerAllowSignalWrites: false,\n  consumerIsAlwaysLive: false,\n  kind: 'unknown',\n  producerMustRecompute: () => false,\n  producerRecomputeValue: () => {},\n  consumerMarkedDirty: () => {},\n  consumerOnSignalRead: () => {},\n};\n\ninterface ReactiveLink {\n  producer: ReactiveNode;\n  consumer: ReactiveNode;\n  lastReadVersion: number;\n  prevConsumer: ReactiveLink | undefined;\n  nextConsumer: ReactiveLink | undefined;\n  nextProducer: ReactiveLink | undefined;\n}\n\n/**\n * A producer and/or consumer which participates in the reactive graph.\n *\n * Producer `ReactiveNode`s which are accessed when a consumer `ReactiveNode` is the\n * `activeConsumer` are tracked as dependencies of that consumer.\n *\n * Certain consumers are also tracked as \"live\" consumers and create edges in the other direction,\n * from producer to consumer. These edges are used to propagate change notifications when a\n * producer's value is updated.\n *\n * A `ReactiveNode` may be both a producer and consumer.\n */\nexport interface ReactiveNode {\n  /**\n   * Version of the value that this node produces.\n   *\n   * This is incremented whenever a new value is produced by this node which is not equal to the\n   * previous value (by whatever definition of equality is in use).\n   */\n  version: Version;\n\n  /**\n   * Epoch at which this node is verified to be clean.\n   *\n   * This allows skipping of some polling operations in the case where no signals have been set\n   * since this node was last read.\n   */\n  lastCleanEpoch: Version;\n\n  /**\n   * Whether this node (in its consumer capacity) is dirty.\n   *\n   * Only live consumers become dirty, when receiving a change notification from a dependency\n   * producer.\n   */\n  dirty: boolean;\n\n  /**\n   * Whether this node is currently rebuilding its producer list.\n   */\n  recomputing: boolean;\n\n  /**\n   * Producers which are dependencies of this consumer.\n   */\n  producers: ReactiveLink | undefined;\n\n  /**\n   * Points to the last linked list node in the `producers` linked list.\n   *\n   * When this node is recomputing, this is used to track the producers that we have accessed so far.\n   */\n  producersTail: ReactiveLink | undefined;\n\n  /**\n   * Linked list of consumers of this producer that are \"live\" (they require push notifications).\n   *\n   * The length of this list is effectively our reference count for this node.\n   */\n  consumers: ReactiveLink | undefined;\n  consumersTail: ReactiveLink | undefined;\n\n  /**\n   * Whether writes to signals are allowed when this consumer is the `activeConsumer`.\n   *\n   * This is used to enforce guardrails such as preventing writes to writable signals in the\n   * computation function of computed signals, which is supposed to be pure.\n   */\n  consumerAllowSignalWrites: boolean;\n\n  readonly consumerIsAlwaysLive: boolean;\n\n  /**\n   * Tracks whether producers need to recompute their value independently of the reactive graph (for\n   * example, if no initial value has been computed).\n   */\n  producerMustRecompute(node: unknown): boolean;\n  producerRecomputeValue(node: unknown): void;\n  consumerMarkedDirty(node: unknown): void;\n\n  /**\n   * Called when a signal is read within this consumer.\n   */\n  consumerOnSignalRead(node: unknown): void;\n\n  /**\n   * A debug name for the reactive node. Used in Angular DevTools to identify the node.\n   */\n  debugName?: string;\n\n  /**\n   * Kind of node. Example: 'signal', 'computed', 'input', 'effect'.\n   *\n   * ReactiveNode has this as 'unknown' by default, but derived node types should override this to\n   * make available the kind of signal that particular instance of a ReactiveNode represents.\n   *\n   * Used in Angular DevTools to identify the kind of signal.\n   */\n  kind: string;\n}\n\n/**\n * Called by implementations when a producer's signal is read.\n */\nexport function producerAccessed(node: ReactiveNode): void {\n  if (inNotificationPhase) {\n    throw new Error(\n      typeof ngDevMode !== 'undefined' && ngDevMode\n        ? `Assertion error: signal read during notification phase`\n        : '',\n    );\n  }\n\n  if (activeConsumer === null) {\n    // Accessed outside of a reactive context, so nothing to record.\n    return;\n  }\n\n  activeConsumer.consumerOnSignalRead(node);\n\n  const prevProducerLink = activeConsumer.producersTail;\n\n  // If the last producer we accessed is the same as the current one, we can skip adding a new\n  // link\n  if (prevProducerLink !== undefined && prevProducerLink.producer === node) {\n    return;\n  }\n\n  let nextProducerLink: ReactiveLink | undefined = undefined;\n  const isRecomputing = activeConsumer.recomputing;\n  if (isRecomputing) {\n    // If we're incrementally rebuilding the producers list, we want to check if the next producer\n    // in the list is the same as the one we're trying to add.\n\n    // If the previous producer is defined, then the next producer is just the one that follows it.\n    // Otherwise, we should check the head of the producers list (the first node that we accessed the last time this consumer was run).\n    nextProducerLink =\n      prevProducerLink !== undefined ? prevProducerLink.nextProducer : activeConsumer.producers;\n    if (nextProducerLink !== undefined && nextProducerLink.producer === node) {\n      // If the next producer is the same as the one we're trying to add, we can just update the\n      // last read version, update the tail of the producers list of this rerun, and return.\n      activeConsumer.producersTail = nextProducerLink;\n      nextProducerLink.lastReadVersion = node.version;\n      return;\n    }\n  }\n\n  const prevConsumerLink = node.consumersTail;\n\n  // If the producer we're accessing already has a link to this consumer, we can skip adding a new\n  // link. This can short circuit the creation of a new link in the case where the consumer reads alternating ReeactiveNodes\n  if (\n    prevConsumerLink !== undefined &&\n    prevConsumerLink.consumer === activeConsumer &&\n    // However, we have to make sure that the link we've discovered isn't from a node that is incrementally rebuilding its producer list\n    (!isRecomputing || isValidLink(prevConsumerLink, activeConsumer))\n  ) {\n    // If we found an existing link to the consumer we can just return.\n    return;\n  }\n\n  // If we got here, it means that we need to create a new link between the producer and the consumer.\n  const isLive = consumerIsLive(activeConsumer);\n  const newLink = {\n    producer: node,\n    consumer: activeConsumer,\n    // instead of eagerly destroying the previous link, we delay until we've finished recomputing\n    // the producers list, so that we can destroy all of the old links at once.\n    nextProducer: nextProducerLink,\n    prevConsumer: prevConsumerLink,\n    lastReadVersion: node.version,\n    nextConsumer: undefined,\n  };\n  activeConsumer.producersTail = newLink;\n  if (prevProducerLink !== undefined) {\n    prevProducerLink.nextProducer = newLink;\n  } else {\n    activeConsumer.producers = newLink;\n  }\n\n  if (isLive) {\n    producerAddLiveConsumer(node, newLink);\n  }\n}\n\n/**\n * Increment the global epoch counter.\n *\n * Called by source producers (that is, not computeds) whenever their values change.\n */\nexport function producerIncrementEpoch(): void {\n  epoch++;\n}\n\n/**\n * Ensure this producer's `version` is up-to-date.\n */\nexport function producerUpdateValueVersion(node: ReactiveNode): void {\n  if (consumerIsLive(node) && !node.dirty) {\n    // A live consumer will be marked dirty by producers, so a clean state means that its version\n    // is guaranteed to be up-to-date.\n    return;\n  }\n\n  if (!node.dirty && node.lastCleanEpoch === epoch) {\n    // Even non-live consumers can skip polling if they previously found themselves to be clean at\n    // the current epoch, since their dependencies could not possibly have changed (such a change\n    // would've increased the epoch).\n    return;\n  }\n\n  if (!node.producerMustRecompute(node) && !consumerPollProducersForChange(node)) {\n    // None of our producers report a change since the last time they were read, so no\n    // recomputation of our value is necessary, and we can consider ourselves clean.\n    producerMarkClean(node);\n    return;\n  }\n\n  node.producerRecomputeValue(node);\n\n  // After recomputing the value, we're no longer dirty.\n  producerMarkClean(node);\n}\n\n/**\n * Propagate a dirty notification to live consumers of this producer.\n */\nexport function producerNotifyConsumers(node: ReactiveNode): void {\n  if (node.consumers === undefined) {\n    return;\n  }\n\n  // Prevent signal reads when we're updating the graph\n  const prev = inNotificationPhase;\n  inNotificationPhase = true;\n  try {\n    for (\n      let link: ReactiveLink | undefined = node.consumers;\n      link !== undefined;\n      link = link.nextConsumer\n    ) {\n      const consumer = link.consumer;\n      if (!consumer.dirty) {\n        consumerMarkDirty(consumer);\n      }\n    }\n  } finally {\n    inNotificationPhase = prev;\n  }\n}\n\n/**\n * Whether this `ReactiveNode` in its producer capacity is currently allowed to initiate updates,\n * based on the current consumer context.\n */\nexport function producerUpdatesAllowed(): boolean {\n  return activeConsumer?.consumerAllowSignalWrites !== false;\n}\n\nexport function consumerMarkDirty(node: ReactiveNode): void {\n  node.dirty = true;\n  producerNotifyConsumers(node);\n  node.consumerMarkedDirty?.(node);\n}\n\nexport function producerMarkClean(node: ReactiveNode): void {\n  node.dirty = false;\n  node.lastCleanEpoch = epoch;\n}\n\n/**\n * Prepare this consumer to run a computation in its reactive context.\n *\n * Must be called by subclasses which represent reactive computations, before those computations\n * begin.\n */\nexport function consumerBeforeComputation(node: ReactiveNode | null): ReactiveNode | null {\n  if (node) {\n    node.producersTail = undefined;\n    node.recomputing = true;\n  }\n  return setActiveConsumer(node);\n}\n\n/**\n * Finalize this consumer's state after a reactive computation has run.\n *\n * Must be called by subclasses which represent reactive computations, after those computations\n * have finished.\n */\nexport function consumerAfterComputation(\n  node: ReactiveNode | null,\n  prevConsumer: ReactiveNode | null,\n): void {\n  setActiveConsumer(prevConsumer);\n\n  if (!node) {\n    return;\n  }\n\n  node.recomputing = false;\n\n  // We've finished incrementally rebuilding the producers list, now if there are any producers\n  // that are after producersTail, they are stale and should be removed.\n  const producersTail = node.producersTail as ReactiveLink | undefined;\n  let toRemove = producersTail !== undefined ? producersTail.nextProducer : node.producers;\n  if (toRemove !== undefined) {\n    if (consumerIsLive(node)) {\n      // For each stale link, we first unlink it from the producers list of consumers\n      do {\n        toRemove = producerRemoveLiveConsumerLink(toRemove);\n      } while (toRemove !== undefined);\n    }\n\n    // Now, we can truncate the producers list to remove all stale links.\n    if (producersTail !== undefined) {\n      producersTail.nextProducer = undefined;\n    } else {\n      node.producers = undefined;\n    }\n  }\n}\n\n/**\n * Determine whether this consumer has any dependencies which have changed since the last time\n * they were read.\n */\nexport function consumerPollProducersForChange(node: ReactiveNode): boolean {\n  // Poll producers for change.\n  for (let link = node.producers; link !== undefined; link = link.nextProducer) {\n    const producer = link.producer;\n    const seenVersion = link.lastReadVersion;\n\n    // First check the versions. A mismatch means that the producer's value is known to have\n    // changed since the last time we read it.\n    if (seenVersion !== producer.version) {\n      return true;\n    }\n\n    // The producer's version is the same as the last time we read it, but it might itself be\n    // stale. Force the producer to recompute its version (calculating a new value if necessary).\n    producerUpdateValueVersion(producer);\n\n    // Now when we do this check, `producer.version` is guaranteed to be up to date, so if the\n    // versions still match then it has not changed since the last time we read it.\n    if (seenVersion !== producer.version) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Disconnect this consumer from the graph.\n */\nexport function consumerDestroy(node: ReactiveNode): void {\n  if (consumerIsLive(node)) {\n    // Drop all connections from the graph to this node.\n    let link = node.producers;\n    while (link !== undefined) {\n      link = producerRemoveLiveConsumerLink(link);\n    }\n  }\n\n  // Truncate all the linked lists to drop all connection from this node to the graph.\n  node.producers = undefined;\n  node.producersTail = undefined;\n  node.consumers = undefined;\n  node.consumersTail = undefined;\n}\n\n/**\n * Add `consumer` as a live consumer of this node.\n *\n * Note that this operation is potentially transitive. If this node becomes live, then it becomes\n * a live consumer of all of its current producers.\n */\nfunction producerAddLiveConsumer(node: ReactiveNode, link: ReactiveLink): void {\n  const consumersTail = node.consumersTail;\n  const wasLive = consumerIsLive(node);\n  if (consumersTail !== undefined) {\n    link.nextConsumer = consumersTail.nextConsumer;\n    consumersTail.nextConsumer = link;\n  } else {\n    link.nextConsumer = undefined;\n    node.consumers = link;\n  }\n  link.prevConsumer = consumersTail;\n  node.consumersTail = link;\n  if (!wasLive) {\n    for (\n      let link: ReactiveLink | undefined = node.producers;\n      link !== undefined;\n      link = link.nextProducer\n    ) {\n      producerAddLiveConsumer(link.producer, link);\n    }\n  }\n}\n\nfunction producerRemoveLiveConsumerLink(link: ReactiveLink): ReactiveLink | undefined {\n  const producer = link.producer;\n  const nextProducer = link.nextProducer;\n  const nextConsumer = link.nextConsumer;\n  const prevConsumer = link.prevConsumer;\n  link.nextConsumer = undefined;\n  link.prevConsumer = undefined;\n  if (nextConsumer !== undefined) {\n    nextConsumer.prevConsumer = prevConsumer;\n  } else {\n    producer.consumersTail = prevConsumer;\n  }\n  if (prevConsumer !== undefined) {\n    prevConsumer.nextConsumer = nextConsumer;\n  } else {\n    producer.consumers = nextConsumer;\n    if (!consumerIsLive(producer)) {\n      let producerLink = producer.producers;\n      while (producerLink !== undefined) {\n        producerLink = producerRemoveLiveConsumerLink(producerLink);\n      }\n    }\n  }\n  return nextProducer;\n}\n\nfunction consumerIsLive(node: ReactiveNode): boolean {\n  return node.consumerIsAlwaysLive || node.consumers !== undefined;\n}\n\nexport function runPostProducerCreatedFn(node: ReactiveNode): void {\n  postProducerCreatedFn?.(node);\n}\n\nexport function setPostProducerCreatedFn(fn: ReactiveHookFn | null): ReactiveHookFn | null {\n  const prev = postProducerCreatedFn;\n  postProducerCreatedFn = fn;\n  return prev;\n}\n\n// While a ReactiveNode is recomputing, it may not have destroyed previous links\n// This allows us to check if a given link will be destroyed by a reactivenode if it were to finish running immediately without accesing any more producers\nfunction isValidLink(checkLink: ReactiveLink, consumer: ReactiveNode): boolean {\n  const producersTail = consumer.producersTail;\n  if (producersTail !== undefined) {\n    let link = consumer.producers!;\n    do {\n      if (link === checkLink) {\n        return true;\n      }\n      if (link === producersTail) {\n        break;\n      }\n      link = link.nextProducer!;\n    } while (link !== undefined);\n  }\n  return false;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {defaultEquals, ValueEqualityFn} from './equality';\nimport {\n  consumerAfterComputation,\n  consumerBeforeComputation,\n  producerAccessed,\n  producerUpdateValueVersion,\n  REACTIVE_NODE,\n  ReactiveNode,\n  setActiveConsumer,\n  SIGNAL,\n  runPostProducerCreatedFn,\n} from './graph';\n\n// Required as the signals library is in a separate package, so we need to explicitly ensure the\n// global `ngDevMode` type is defined.\ndeclare const ngDevMode: boolean | undefined;\n\n/**\n * A computation, which derives a value from a declarative reactive expression.\n *\n * `Computed`s are both producers and consumers of reactivity.\n */\nexport interface ComputedNode<T> extends ReactiveNode {\n  /**\n   * Current value of the computation, or one of the sentinel values above (`UNSET`, `COMPUTING`,\n   * `ERROR`).\n   */\n  value: T;\n\n  /**\n   * If `value` is `ERRORED`, the error caught from the last computation attempt which will\n   * be re-thrown.\n   */\n  error: unknown;\n\n  /**\n   * The computation function which will produce a new value.\n   */\n  computation: () => T;\n\n  equal: ValueEqualityFn<T>;\n}\n\nexport type ComputedGetter<T> = (() => T) & {\n  [SIGNAL]: ComputedNode<T>;\n};\n\n/**\n * Create a computed signal which derives a reactive value from an expression.\n */\nexport function createComputed<T>(\n  computation: () => T,\n  equal?: ValueEqualityFn<T>,\n): ComputedGetter<T> {\n  const node: ComputedNode<T> = Object.create(COMPUTED_NODE);\n  node.computation = computation;\n\n  if (equal !== undefined) {\n    node.equal = equal;\n  }\n\n  const computed = () => {\n    // Check if the value needs updating before returning it.\n    producerUpdateValueVersion(node);\n\n    // Record that someone looked at this signal.\n    producerAccessed(node);\n\n    if (node.value === ERRORED) {\n      throw node.error;\n    }\n\n    return node.value;\n  };\n\n  (computed as ComputedGetter<T>)[SIGNAL] = node;\n  if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n    const debugName = node.debugName ? ' (' + node.debugName + ')' : '';\n    computed.toString = () => `[Computed${debugName}: ${node.value}]`;\n  }\n\n  runPostProducerCreatedFn(node);\n\n  return computed as unknown as ComputedGetter<T>;\n}\n\n/**\n * A dedicated symbol used before a computed value has been calculated for the first time.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nexport const UNSET: any = /* @__PURE__ */ Symbol('UNSET');\n\n/**\n * A dedicated symbol used in place of a computed signal value to indicate that a given computation\n * is in progress. Used to detect cycles in computation chains.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nexport const COMPUTING: any = /* @__PURE__ */ Symbol('COMPUTING');\n\n/**\n * A dedicated symbol used in place of a computed signal value to indicate that a given computation\n * failed. The thrown error is cached until the computation gets dirty again.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nexport const ERRORED: any = /* @__PURE__ */ Symbol('ERRORED');\n\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nconst COMPUTED_NODE = /* @__PURE__ */ (() => {\n  return {\n    ...REACTIVE_NODE,\n    value: UNSET,\n    dirty: true,\n    error: null,\n    equal: defaultEquals,\n    kind: 'computed',\n\n    producerMustRecompute(node: ComputedNode<unknown>): boolean {\n      // Force a recomputation if there's no current value, or if the current value is in the\n      // process of being calculated (which should throw an error).\n      return node.value === UNSET || node.value === COMPUTING;\n    },\n\n    producerRecomputeValue(node: ComputedNode<unknown>): void {\n      if (node.value === COMPUTING) {\n        // Our computation somehow led to a cyclic read of itself.\n        throw new Error(\n          typeof ngDevMode !== 'undefined' && ngDevMode ? 'Detected cycle in computations.' : '',\n        );\n      }\n\n      const oldValue = node.value;\n      node.value = COMPUTING;\n\n      const prevConsumer = consumerBeforeComputation(node);\n      let newValue: unknown;\n      let wasEqual = false;\n      try {\n        newValue = node.computation();\n        // We want to mark this node as errored if calling `equal` throws; however, we don't want\n        // to track any reactive reads inside `equal`.\n        setActiveConsumer(null);\n        wasEqual =\n          oldValue !== UNSET &&\n          oldValue !== ERRORED &&\n          newValue !== ERRORED &&\n          node.equal(oldValue, newValue);\n      } catch (err) {\n        newValue = ERRORED;\n        node.error = err;\n      } finally {\n        consumerAfterComputation(node, prevConsumer);\n      }\n\n      if (wasEqual) {\n        // No change to `valueVersion` - old and new values are\n        // semantically equivalent.\n        node.value = oldValue;\n        return;\n      }\n\n      node.value = newValue;\n      node.version++;\n    },\n  };\n})();\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport type {SignalNode} from './signal';\n\nfunction defaultThrowError(): never {\n  throw new Error();\n}\n\nlet throwInvalidWriteToSignalErrorFn: <T>(node: SignalNode<T>) => never = defaultThrowError;\n\nexport function throwInvalidWriteToSignalError<T>(node: SignalNode<T>) {\n  throwInvalidWriteToSignalErrorFn(node);\n}\n\nexport function setThrowInvalidWriteToSignalError(fn: <T>(node: SignalNode<T>) => never): void {\n  throwInvalidWriteToSignalErrorFn = fn;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {defaultEquals, ValueEqualityFn} from './equality';\nimport {throwInvalidWriteToSignalError} from './errors';\nimport {\n  producerAccessed,\n  producerIncrementEpoch,\n  producerNotifyConsumers,\n  producerUpdatesAllowed,\n  REACTIVE_NODE,\n  ReactiveNode,\n  ReactiveHookFn,\n  runPostProducerCreatedFn,\n  SIGNAL,\n} from './graph';\n\n// Required as the signals library is in a separate package, so we need to explicitly ensure the\n// global `ngDevMode` type is defined.\ndeclare const ngDevMode: boolean | undefined;\n\n/**\n * If set, called after `WritableSignal`s are updated.\n *\n * This hook can be used to achieve various effects, such as running effects synchronously as part\n * of setting a signal.\n */\nlet postSignalSetFn: ReactiveHookFn | null = null;\n\nexport interface SignalNode<T> extends ReactiveNode {\n  value: T;\n  equal: ValueEqualityFn<T>;\n}\n\nexport type SignalBaseGetter<T> = (() => T) & {readonly [SIGNAL]: unknown};\nexport type SignalSetter<T> = (newValue: T) => void;\nexport type SignalUpdater<T> = (updateFn: (value: T) => T) => void;\n\n// Note: Closure *requires* this to be an `interface` and not a type, which is why the\n// `SignalBaseGetter` type exists to provide the correct shape.\nexport interface SignalGetter<T> extends SignalBaseGetter<T> {\n  readonly [SIGNAL]: SignalNode<T>;\n}\n\n/**\n * Creates a `Signal` getter, setter, and updater function.\n */\nexport function createSignal<T>(\n  initialValue: T,\n  equal?: ValueEqualityFn<T>,\n): [SignalGetter<T>, SignalSetter<T>, SignalUpdater<T>] {\n  const node: SignalNode<T> = Object.create(SIGNAL_NODE);\n  node.value = initialValue;\n  if (equal !== undefined) {\n    node.equal = equal;\n  }\n  const getter = (() => signalGetFn(node)) as SignalGetter<T>;\n  (getter as any)[SIGNAL] = node;\n  if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n    const debugName = node.debugName ? ' (' + node.debugName + ')' : '';\n    getter.toString = () => `[Signal${debugName}: ${node.value}]`;\n  }\n\n  runPostProducerCreatedFn(node);\n  const set = (newValue: T) => signalSetFn(node, newValue);\n  const update = (updateFn: (value: T) => T) => signalUpdateFn(node, updateFn);\n  return [getter, set, update];\n}\n\nexport function setPostSignalSetFn(fn: ReactiveHookFn | null): ReactiveHookFn | null {\n  const prev = postSignalSetFn;\n  postSignalSetFn = fn;\n  return prev;\n}\n\nexport function signalGetFn<T>(node: SignalNode<T>): T {\n  producerAccessed(node);\n  return node.value;\n}\n\nexport function signalSetFn<T>(node: SignalNode<T>, newValue: T) {\n  if (!producerUpdatesAllowed()) {\n    throwInvalidWriteToSignalError(node);\n  }\n\n  if (!node.equal(node.value, newValue)) {\n    node.value = newValue;\n    signalValueChanged(node);\n  }\n}\n\nexport function signalUpdateFn<T>(node: SignalNode<T>, updater: (value: T) => T): void {\n  if (!producerUpdatesAllowed()) {\n    throwInvalidWriteToSignalError(node);\n  }\n\n  signalSetFn(node, updater(node.value));\n}\n\nexport function runPostSignalSetFn<T>(node: SignalNode<T>): void {\n  postSignalSetFn?.(node);\n}\n\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nexport const SIGNAL_NODE: SignalNode<unknown> = /* @__PURE__ */ (() => {\n  return {\n    ...REACTIVE_NODE,\n    equal: defaultEquals,\n    value: undefined,\n    kind: 'signal',\n  };\n})();\n\nfunction signalValueChanged<T>(node: SignalNode<T>): void {\n  node.version++;\n  producerIncrementEpoch();\n  producerNotifyConsumers(node);\n  postSignalSetFn?.(node);\n}\n"],"names":[],"mappings":";;;;;;AAaA;;AAEG;AACa,SAAA,aAAa,CAAI,CAAI,EAAE,CAAI,EAAA;IACzC,OAAO,MAAM,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;AACxB;;ACNA;;;;AAIG;AACH,IAAI,cAAc,GAAwB,IAAI;AAC9C,IAAI,mBAAmB,GAAG,KAAK;AAI/B;;AAEG;AACH,IAAI,KAAK,GAAY,CAAY;AAIjC;;AAEG;AACH,IAAI,qBAAqB,GAA0B,IAAI;AAEvD;;;;AAIG;AACU,MAAA,MAAM,mBAAkC,MAAM,CAAC,QAAQ;AAE9D,SAAU,iBAAiB,CAAC,QAA6B,EAAA;IAC7D,MAAM,IAAI,GAAG,cAAc;IAC3B,cAAc,GAAG,QAAQ;AACzB,IAAA,OAAO,IAAI;AACb;SAEgB,iBAAiB,GAAA;AAC/B,IAAA,OAAO,cAAc;AACvB;SAEgB,qBAAqB,GAAA;AACnC,IAAA,OAAO,mBAAmB;AAC5B;AAMM,SAAU,UAAU,CAAC,KAAc,EAAA;AACvC,IAAA,OAAQ,KAA2B,CAAC,MAAM,CAAC,KAAK,SAAS;AAC3D;AAEa,MAAA,aAAa,GAAiB;AACzC,IAAA,OAAO,EAAE,CAAY;AACrB,IAAA,cAAc,EAAE,CAAY;AAC5B,IAAA,KAAK,EAAE,KAAK;AACZ,IAAA,SAAS,EAAE,SAAS;AACpB,IAAA,aAAa,EAAE,SAAS;AACxB,IAAA,SAAS,EAAE,SAAS;AACpB,IAAA,aAAa,EAAE,SAAS;AACxB,IAAA,WAAW,EAAE,KAAK;AAClB,IAAA,yBAAyB,EAAE,KAAK;AAChC,IAAA,oBAAoB,EAAE,KAAK;AAC3B,IAAA,IAAI,EAAE,SAAS;AACf,IAAA,qBAAqB,EAAE,MAAM,KAAK;AAClC,IAAA,sBAAsB,EAAE,MAAK,GAAG;AAChC,IAAA,mBAAmB,EAAE,MAAK,GAAG;AAC7B,IAAA,oBAAoB,EAAE,MAAK,GAAG;;AAiHhC;;AAEG;AACG,SAAU,gBAAgB,CAAC,IAAkB,EAAA;IACjD,IAAI,mBAAmB,EAAE;QACvB,MAAM,IAAI,KAAK,CACb,OAAO,SAAS,KAAK,WAAW,IAAI;AAClC,cAAE,CAAwD,sDAAA;cACxD,EAAE,CACP;;AAGH,IAAA,IAAI,cAAc,KAAK,IAAI,EAAE;;QAE3B;;AAGF,IAAA,cAAc,CAAC,oBAAoB,CAAC,IAAI,CAAC;AAEzC,IAAA,MAAM,gBAAgB,GAAG,cAAc,CAAC,aAAa;;;IAIrD,IAAI,gBAAgB,KAAK,SAAS,IAAI,gBAAgB,CAAC,QAAQ,KAAK,IAAI,EAAE;QACxE;;IAGF,IAAI,gBAAgB,GAA6B,SAAS;AAC1D,IAAA,MAAM,aAAa,GAAG,cAAc,CAAC,WAAW;IAChD,IAAI,aAAa,EAAE;;;;;QAMjB,gBAAgB;AACd,YAAA,gBAAgB,KAAK,SAAS,GAAG,gBAAgB,CAAC,YAAY,GAAG,cAAc,CAAC,SAAS;QAC3F,IAAI,gBAAgB,KAAK,SAAS,IAAI,gBAAgB,CAAC,QAAQ,KAAK,IAAI,EAAE;;;AAGxE,YAAA,cAAc,CAAC,aAAa,GAAG,gBAAgB;AAC/C,YAAA,gBAAgB,CAAC,eAAe,GAAG,IAAI,CAAC,OAAO;YAC/C;;;AAIJ,IAAA,MAAM,gBAAgB,GAAG,IAAI,CAAC,aAAa;;;IAI3C,IACE,gBAAgB,KAAK,SAAS;QAC9B,gBAAgB,CAAC,QAAQ,KAAK,cAAc;;SAE3C,CAAC,aAAa,IAAI,WAAW,CAAC,gBAAgB,EAAE,cAAc,CAAC,CAAC,EACjE;;QAEA;;;AAIF,IAAA,MAAM,MAAM,GAAG,cAAc,CAAC,cAAc,CAAC;AAC7C,IAAA,MAAM,OAAO,GAAG;AACd,QAAA,QAAQ,EAAE,IAAI;AACd,QAAA,QAAQ,EAAE,cAAc;;;AAGxB,QAAA,YAAY,EAAE,gBAAgB;AAC9B,QAAA,YAAY,EAAE,gBAAgB;QAC9B,eAAe,EAAE,IAAI,CAAC,OAAO;AAC7B,QAAA,YAAY,EAAE,SAAS;KACxB;AACD,IAAA,cAAc,CAAC,aAAa,GAAG,OAAO;AACtC,IAAA,IAAI,gBAAgB,KAAK,SAAS,EAAE;AAClC,QAAA,gBAAgB,CAAC,YAAY,GAAG,OAAO;;SAClC;AACL,QAAA,cAAc,CAAC,SAAS,GAAG,OAAO;;IAGpC,IAAI,MAAM,EAAE;AACV,QAAA,uBAAuB,CAAC,IAAI,EAAE,OAAO,CAAC;;AAE1C;AAEA;;;;AAIG;SACa,sBAAsB,GAAA;AACpC,IAAA,KAAK,EAAE;AACT;AAEA;;AAEG;AACG,SAAU,0BAA0B,CAAC,IAAkB,EAAA;IAC3D,IAAI,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE;;;QAGvC;;IAGF,IAAI,CAAC,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,cAAc,KAAK,KAAK,EAAE;;;;QAIhD;;AAGF,IAAA,IAAI,CAAC,IAAI,CAAC,qBAAqB,CAAC,IAAI,CAAC,IAAI,CAAC,8BAA8B,CAAC,IAAI,CAAC,EAAE;;;QAG9E,iBAAiB,CAAC,IAAI,CAAC;QACvB;;AAGF,IAAA,IAAI,CAAC,sBAAsB,CAAC,IAAI,CAAC;;IAGjC,iBAAiB,CAAC,IAAI,CAAC;AACzB;AAEA;;AAEG;AACG,SAAU,uBAAuB,CAAC,IAAkB,EAAA;AACxD,IAAA,IAAI,IAAI,CAAC,SAAS,KAAK,SAAS,EAAE;QAChC;;;IAIF,MAAM,IAAI,GAAG,mBAAmB;IAChC,mBAAmB,GAAG,IAAI;AAC1B,IAAA,IAAI;AACF,QAAA,KACE,IAAI,IAAI,GAA6B,IAAI,CAAC,SAAS,EACnD,IAAI,KAAK,SAAS,EAClB,IAAI,GAAG,IAAI,CAAC,YAAY,EACxB;AACA,YAAA,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ;AAC9B,YAAA,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE;gBACnB,iBAAiB,CAAC,QAAQ,CAAC;;;;YAGvB;QACR,mBAAmB,GAAG,IAAI;;AAE9B;AAEA;;;AAGG;SACa,sBAAsB,GAAA;AACpC,IAAA,OAAO,cAAc,EAAE,yBAAyB,KAAK,KAAK;AAC5D;AAEM,SAAU,iBAAiB,CAAC,IAAkB,EAAA;AAClD,IAAA,IAAI,CAAC,KAAK,GAAG,IAAI;IACjB,uBAAuB,CAAC,IAAI,CAAC;AAC7B,IAAA,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC;AAClC;AAEM,SAAU,iBAAiB,CAAC,IAAkB,EAAA;AAClD,IAAA,IAAI,CAAC,KAAK,GAAG,KAAK;AAClB,IAAA,IAAI,CAAC,cAAc,GAAG,KAAK;AAC7B;AAEA;;;;;AAKG;AACG,SAAU,yBAAyB,CAAC,IAAyB,EAAA;IACjE,IAAI,IAAI,EAAE;AACR,QAAA,IAAI,CAAC,aAAa,GAAG,SAAS;AAC9B,QAAA,IAAI,CAAC,WAAW,GAAG,IAAI;;AAEzB,IAAA,OAAO,iBAAiB,CAAC,IAAI,CAAC;AAChC;AAEA;;;;;AAKG;AACa,SAAA,wBAAwB,CACtC,IAAyB,EACzB,YAAiC,EAAA;IAEjC,iBAAiB,CAAC,YAAY,CAAC;IAE/B,IAAI,CAAC,IAAI,EAAE;QACT;;AAGF,IAAA,IAAI,CAAC,WAAW,GAAG,KAAK;;;AAIxB,IAAA,MAAM,aAAa,GAAG,IAAI,CAAC,aAAyC;AACpE,IAAA,IAAI,QAAQ,GAAG,aAAa,KAAK,SAAS,GAAG,aAAa,CAAC,YAAY,GAAG,IAAI,CAAC,SAAS;AACxF,IAAA,IAAI,QAAQ,KAAK,SAAS,EAAE;AAC1B,QAAA,IAAI,cAAc,CAAC,IAAI,CAAC,EAAE;;AAExB,YAAA,GAAG;AACD,gBAAA,QAAQ,GAAG,8BAA8B,CAAC,QAAQ,CAAC;AACrD,aAAC,QAAQ,QAAQ,KAAK,SAAS;;;AAIjC,QAAA,IAAI,aAAa,KAAK,SAAS,EAAE;AAC/B,YAAA,aAAa,CAAC,YAAY,GAAG,SAAS;;aACjC;AACL,YAAA,IAAI,CAAC,SAAS,GAAG,SAAS;;;AAGhC;AAEA;;;AAGG;AACG,SAAU,8BAA8B,CAAC,IAAkB,EAAA;;AAE/D,IAAA,KAAK,IAAI,IAAI,GAAG,IAAI,CAAC,SAAS,EAAE,IAAI,KAAK,SAAS,EAAE,IAAI,GAAG,IAAI,CAAC,YAAY,EAAE;AAC5E,QAAA,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ;AAC9B,QAAA,MAAM,WAAW,GAAG,IAAI,CAAC,eAAe;;;AAIxC,QAAA,IAAI,WAAW,KAAK,QAAQ,CAAC,OAAO,EAAE;AACpC,YAAA,OAAO,IAAI;;;;QAKb,0BAA0B,CAAC,QAAQ,CAAC;;;AAIpC,QAAA,IAAI,WAAW,KAAK,QAAQ,CAAC,OAAO,EAAE;AACpC,YAAA,OAAO,IAAI;;;AAIf,IAAA,OAAO,KAAK;AACd;AAEA;;AAEG;AACG,SAAU,eAAe,CAAC,IAAkB,EAAA;AAChD,IAAA,IAAI,cAAc,CAAC,IAAI,CAAC,EAAE;;AAExB,QAAA,IAAI,IAAI,GAAG,IAAI,CAAC,SAAS;AACzB,QAAA,OAAO,IAAI,KAAK,SAAS,EAAE;AACzB,YAAA,IAAI,GAAG,8BAA8B,CAAC,IAAI,CAAC;;;;AAK/C,IAAA,IAAI,CAAC,SAAS,GAAG,SAAS;AAC1B,IAAA,IAAI,CAAC,aAAa,GAAG,SAAS;AAC9B,IAAA,IAAI,CAAC,SAAS,GAAG,SAAS;AAC1B,IAAA,IAAI,CAAC,aAAa,GAAG,SAAS;AAChC;AAEA;;;;;AAKG;AACH,SAAS,uBAAuB,CAAC,IAAkB,EAAE,IAAkB,EAAA;AACrE,IAAA,MAAM,aAAa,GAAG,IAAI,CAAC,aAAa;AACxC,IAAA,MAAM,OAAO,GAAG,cAAc,CAAC,IAAI,CAAC;AACpC,IAAA,IAAI,aAAa,KAAK,SAAS,EAAE;AAC/B,QAAA,IAAI,CAAC,YAAY,GAAG,aAAa,CAAC,YAAY;AAC9C,QAAA,aAAa,CAAC,YAAY,GAAG,IAAI;;SAC5B;AACL,QAAA,IAAI,CAAC,YAAY,GAAG,SAAS;AAC7B,QAAA,IAAI,CAAC,SAAS,GAAG,IAAI;;AAEvB,IAAA,IAAI,CAAC,YAAY,GAAG,aAAa;AACjC,IAAA,IAAI,CAAC,aAAa,GAAG,IAAI;IACzB,IAAI,CAAC,OAAO,EAAE;AACZ,QAAA,KACE,IAAI,IAAI,GAA6B,IAAI,CAAC,SAAS,EACnD,IAAI,KAAK,SAAS,EAClB,IAAI,GAAG,IAAI,CAAC,YAAY,EACxB;AACA,YAAA,uBAAuB,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC;;;AAGlD;AAEA,SAAS,8BAA8B,CAAC,IAAkB,EAAA;AACxD,IAAA,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ;AAC9B,IAAA,MAAM,YAAY,GAAG,IAAI,CAAC,YAAY;AACtC,IAAA,MAAM,YAAY,GAAG,IAAI,CAAC,YAAY;AACtC,IAAA,MAAM,YAAY,GAAG,IAAI,CAAC,YAAY;AACtC,IAAA,IAAI,CAAC,YAAY,GAAG,SAAS;AAC7B,IAAA,IAAI,CAAC,YAAY,GAAG,SAAS;AAC7B,IAAA,IAAI,YAAY,KAAK,SAAS,EAAE;AAC9B,QAAA,YAAY,CAAC,YAAY,GAAG,YAAY;;SACnC;AACL,QAAA,QAAQ,CAAC,aAAa,GAAG,YAAY;;AAEvC,IAAA,IAAI,YAAY,KAAK,SAAS,EAAE;AAC9B,QAAA,YAAY,CAAC,YAAY,GAAG,YAAY;;SACnC;AACL,QAAA,QAAQ,CAAC,SAAS,GAAG,YAAY;AACjC,QAAA,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,EAAE;AAC7B,YAAA,IAAI,YAAY,GAAG,QAAQ,CAAC,SAAS;AACrC,YAAA,OAAO,YAAY,KAAK,SAAS,EAAE;AACjC,gBAAA,YAAY,GAAG,8BAA8B,CAAC,YAAY,CAAC;;;;AAIjE,IAAA,OAAO,YAAY;AACrB;AAEA,SAAS,cAAc,CAAC,IAAkB,EAAA;IACxC,OAAO,IAAI,CAAC,oBAAoB,IAAI,IAAI,CAAC,SAAS,KAAK,SAAS;AAClE;AAEM,SAAU,wBAAwB,CAAC,IAAkB,EAAA;AACzD,IAAA,qBAAqB,GAAG,IAAI,CAAC;AAC/B;AAEM,SAAU,wBAAwB,CAAC,EAAyB,EAAA;IAChE,MAAM,IAAI,GAAG,qBAAqB;IAClC,qBAAqB,GAAG,EAAE;AAC1B,IAAA,OAAO,IAAI;AACb;AAEA;AACA;AACA,SAAS,WAAW,CAAC,SAAuB,EAAE,QAAsB,EAAA;AAClE,IAAA,MAAM,aAAa,GAAG,QAAQ,CAAC,aAAa;AAC5C,IAAA,IAAI,aAAa,KAAK,SAAS,EAAE;AAC/B,QAAA,IAAI,IAAI,GAAG,QAAQ,CAAC,SAAU;AAC9B,QAAA,GAAG;AACD,YAAA,IAAI,IAAI,KAAK,SAAS,EAAE;AACtB,gBAAA,OAAO,IAAI;;AAEb,YAAA,IAAI,IAAI,KAAK,aAAa,EAAE;gBAC1B;;AAEF,YAAA,IAAI,GAAG,IAAI,CAAC,YAAa;AAC3B,SAAC,QAAQ,IAAI,KAAK,SAAS;;AAE7B,IAAA,OAAO,KAAK;AACd;;AC7eA;;AAEG;AACa,SAAA,cAAc,CAC5B,WAAoB,EACpB,KAA0B,EAAA;IAE1B,MAAM,IAAI,GAAoB,MAAM,CAAC,MAAM,CAAC,aAAa,CAAC;AAC1D,IAAA,IAAI,CAAC,WAAW,GAAG,WAAW;AAE9B,IAAA,IAAI,KAAK,KAAK,SAAS,EAAE;AACvB,QAAA,IAAI,CAAC,KAAK,GAAG,KAAK;;IAGpB,MAAM,QAAQ,GAAG,MAAK;;QAEpB,0BAA0B,CAAC,IAAI,CAAC;;QAGhC,gBAAgB,CAAC,IAAI,CAAC;AAEtB,QAAA,IAAI,IAAI,CAAC,KAAK,KAAK,OAAO,EAAE;YAC1B,MAAM,IAAI,CAAC,KAAK;;QAGlB,OAAO,IAAI,CAAC,KAAK;AACnB,KAAC;AAEA,IAAA,QAA8B,CAAC,MAAM,CAAC,GAAG,IAAI;AAC9C,IAAA,IAAI,OAAO,SAAS,KAAK,WAAW,IAAI,SAAS,EAAE;AACjD,QAAA,MAAM,SAAS,GAAG,IAAI,CAAC,SAAS,GAAG,IAAI,GAAG,IAAI,CAAC,SAAS,GAAG,GAAG,GAAG,EAAE;AACnE,QAAA,QAAQ,CAAC,QAAQ,GAAG,MAAM,CAAY,SAAA,EAAA,SAAS,CAAK,EAAA,EAAA,IAAI,CAAC,KAAK,GAAG;;IAGnE,wBAAwB,CAAC,IAAI,CAAC;AAE9B,IAAA,OAAO,QAAwC;AACjD;AAEA;;;AAGG;AACU,MAAA,KAAK,mBAAwB,MAAM,CAAC,OAAO;AAExD;;;;AAIG;AACU,MAAA,SAAS,mBAAwB,MAAM,CAAC,WAAW;AAEhE;;;;AAIG;AACU,MAAA,OAAO,mBAAwB,MAAM,CAAC,SAAS;AAE5D;AACA;AACA;AACA,MAAM,aAAa,mBAAmB,CAAC,MAAK;IAC1C,OAAO;AACL,QAAA,GAAG,aAAa;AAChB,QAAA,KAAK,EAAE,KAAK;AACZ,QAAA,KAAK,EAAE,IAAI;AACX,QAAA,KAAK,EAAE,IAAI;AACX,QAAA,KAAK,EAAE,aAAa;AACpB,QAAA,IAAI,EAAE,UAAU;AAEhB,QAAA,qBAAqB,CAAC,IAA2B,EAAA;;;YAG/C,OAAO,IAAI,CAAC,KAAK,KAAK,KAAK,IAAI,IAAI,CAAC,KAAK,KAAK,SAAS;SACxD;AAED,QAAA,sBAAsB,CAAC,IAA2B,EAAA;AAChD,YAAA,IAAI,IAAI,CAAC,KAAK,KAAK,SAAS,EAAE;;AAE5B,gBAAA,MAAM,IAAI,KAAK,CACb,OAAO,SAAS,KAAK,WAAW,IAAI,SAAS,GAAG,iCAAiC,GAAG,EAAE,CACvF;;AAGH,YAAA,MAAM,QAAQ,GAAG,IAAI,CAAC,KAAK;AAC3B,YAAA,IAAI,CAAC,KAAK,GAAG,SAAS;AAEtB,YAAA,MAAM,YAAY,GAAG,yBAAyB,CAAC,IAAI,CAAC;AACpD,YAAA,IAAI,QAAiB;YACrB,IAAI,QAAQ,GAAG,KAAK;AACpB,YAAA,IAAI;AACF,gBAAA,QAAQ,GAAG,IAAI,CAAC,WAAW,EAAE;;;gBAG7B,iBAAiB,CAAC,IAAI,CAAC;gBACvB,QAAQ;AACN,oBAAA,QAAQ,KAAK,KAAK;AAClB,wBAAA,QAAQ,KAAK,OAAO;AACpB,wBAAA,QAAQ,KAAK,OAAO;AACpB,wBAAA,IAAI,CAAC,KAAK,CAAC,QAAQ,EAAE,QAAQ,CAAC;;YAChC,OAAO,GAAG,EAAE;gBACZ,QAAQ,GAAG,OAAO;AAClB,gBAAA,IAAI,CAAC,KAAK,GAAG,GAAG;;oBACR;AACR,gBAAA,wBAAwB,CAAC,IAAI,EAAE,YAAY,CAAC;;YAG9C,IAAI,QAAQ,EAAE;;;AAGZ,gBAAA,IAAI,CAAC,KAAK,GAAG,QAAQ;gBACrB;;AAGF,YAAA,IAAI,CAAC,KAAK,GAAG,QAAQ;YACrB,IAAI,CAAC,OAAO,EAAE;SACf;KACF;AACH,CAAC,GAAG;;ACpKJ,SAAS,iBAAiB,GAAA;IACxB,MAAM,IAAI,KAAK,EAAE;AACnB;AAEA,IAAI,gCAAgC,GAAsC,iBAAiB;AAErF,SAAU,8BAA8B,CAAI,IAAmB,EAAA;IACnE,gCAAgC,CAAC,IAAI,CAAC;AACxC;AAEM,SAAU,iCAAiC,CAAC,EAAqC,EAAA;IACrF,gCAAgC,GAAG,EAAE;AACvC;;ACIA;;;;;AAKG;AACH,IAAI,eAAe,GAA0B,IAAI;AAiBjD;;AAEG;AACa,SAAA,YAAY,CAC1B,YAAe,EACf,KAA0B,EAAA;IAE1B,MAAM,IAAI,GAAkB,MAAM,CAAC,MAAM,CAAC,WAAW,CAAC;AACtD,IAAA,IAAI,CAAC,KAAK,GAAG,YAAY;AACzB,IAAA,IAAI,KAAK,KAAK,SAAS,EAAE;AACvB,QAAA,IAAI,CAAC,KAAK,GAAG,KAAK;;IAEpB,MAAM,MAAM,IAAI,MAAM,WAAW,CAAC,IAAI,CAAC,CAAoB;AAC1D,IAAA,MAAc,CAAC,MAAM,CAAC,GAAG,IAAI;AAC9B,IAAA,IAAI,OAAO,SAAS,KAAK,WAAW,IAAI,SAAS,EAAE;AACjD,QAAA,MAAM,SAAS,GAAG,IAAI,CAAC,SAAS,GAAG,IAAI,GAAG,IAAI,CAAC,SAAS,GAAG,GAAG,GAAG,EAAE;AACnE,QAAA,MAAM,CAAC,QAAQ,GAAG,MAAM,CAAU,OAAA,EAAA,SAAS,CAAK,EAAA,EAAA,IAAI,CAAC,KAAK,GAAG;;IAG/D,wBAAwB,CAAC,IAAI,CAAC;AAC9B,IAAA,MAAM,GAAG,GAAG,CAAC,QAAW,KAAK,WAAW,CAAC,IAAI,EAAE,QAAQ,CAAC;AACxD,IAAA,MAAM,MAAM,GAAG,CAAC,QAAyB,KAAK,cAAc,CAAC,IAAI,EAAE,QAAQ,CAAC;AAC5E,IAAA,OAAO,CAAC,MAAM,EAAE,GAAG,EAAE,MAAM,CAAC;AAC9B;AAEM,SAAU,kBAAkB,CAAC,EAAyB,EAAA;IAC1D,MAAM,IAAI,GAAG,eAAe;IAC5B,eAAe,GAAG,EAAE;AACpB,IAAA,OAAO,IAAI;AACb;AAEM,SAAU,WAAW,CAAI,IAAmB,EAAA;IAChD,gBAAgB,CAAC,IAAI,CAAC;IACtB,OAAO,IAAI,CAAC,KAAK;AACnB;AAEgB,SAAA,WAAW,CAAI,IAAmB,EAAE,QAAW,EAAA;AAC7D,IAAA,IAAI,CAAC,sBAAsB,EAAE,EAAE;QAC7B,8BAA8B,CAAC,IAAI,CAAC;;AAGtC,IAAA,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,EAAE,QAAQ,CAAC,EAAE;AACrC,QAAA,IAAI,CAAC,KAAK,GAAG,QAAQ;QACrB,kBAAkB,CAAC,IAAI,CAAC;;AAE5B;AAEgB,SAAA,cAAc,CAAI,IAAmB,EAAE,OAAwB,EAAA;AAC7E,IAAA,IAAI,CAAC,sBAAsB,EAAE,EAAE;QAC7B,8BAA8B,CAAC,IAAI,CAAC;;IAGtC,WAAW,CAAC,IAAI,EAAE,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;AACxC;AAEM,SAAU,kBAAkB,CAAI,IAAmB,EAAA;AACvD,IAAA,eAAe,GAAG,IAAI,CAAC;AACzB;AAEA;AACA;AACA;MACa,WAAW,mBAAwC,CAAC,MAAK;IACpE,OAAO;AACL,QAAA,GAAG,aAAa;AAChB,QAAA,KAAK,EAAE,aAAa;AACpB,QAAA,KAAK,EAAE,SAAS;AAChB,QAAA,IAAI,EAAE,QAAQ;KACf;AACH,CAAC;AAED,SAAS,kBAAkB,CAAI,IAAmB,EAAA;IAChD,IAAI,CAAC,OAAO,EAAE;AACd,IAAA,sBAAsB,EAAE;IACxB,uBAAuB,CAAC,IAAI,CAAC;AAC7B,IAAA,eAAe,GAAG,IAAI,CAAC;AACzB;;;;"}
{"version":3,"file":"_effect-chunk.mjs","sources":["../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/core/primitives/signals/src/graph.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/core/primitives/signals/src/computed.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/core/primitives/signals/src/errors.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/core/primitives/signals/src/signal.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/core/primitives/signals/src/effect.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\n// Required as the signals library is in a separate package, so we need to explicitly ensure the\n// global `ngDevMode` type is defined.\ndeclare const ngDevMode: boolean | undefined;\n\n/**\n * The currently active consumer `ReactiveNode`, if running code in a reactive context.\n *\n * Change this via `setActiveConsumer`.\n */\nlet activeConsumer: ReactiveNode | null = null;\nlet inNotificationPhase = false;\n\ntype Version = number & {__brand: 'Version'};\n\n/**\n * Global epoch counter. Incremented whenever a source signal is set.\n */\nlet epoch: Version = 1 as Version;\n\nexport type ReactiveHookFn = (node: ReactiveNode) => void;\n\n/**\n * If set, called after a producer `ReactiveNode` is created.\n */\nlet postProducerCreatedFn: ReactiveHookFn | null = null;\n\n/**\n * Symbol used to tell `Signal`s apart from other functions.\n *\n * This can be used to auto-unwrap signals in various cases, or to auto-wrap non-signal values.\n */\nexport const SIGNAL: unique symbol = /* @__PURE__ */ Symbol('SIGNAL');\n\nexport function setActiveConsumer(consumer: ReactiveNode | null): ReactiveNode | null {\n  const prev = activeConsumer;\n  activeConsumer = consumer;\n  return prev;\n}\n\nexport function getActiveConsumer(): ReactiveNode | null {\n  return activeConsumer;\n}\n\nexport function isInNotificationPhase(): boolean {\n  return inNotificationPhase;\n}\n\nexport interface Reactive {\n  [SIGNAL]: ReactiveNode;\n}\n\nexport function isReactive(value: unknown): value is Reactive {\n  return (value as Partial<Reactive>)[SIGNAL] !== undefined;\n}\n\nexport const REACTIVE_NODE: ReactiveNode = {\n  version: 0 as Version,\n  lastCleanEpoch: 0 as Version,\n  dirty: false,\n  producers: undefined,\n  producersTail: undefined,\n  consumers: undefined,\n  consumersTail: undefined,\n  recomputing: false,\n  consumerAllowSignalWrites: false,\n  consumerIsAlwaysLive: false,\n  kind: 'unknown',\n  producerMustRecompute: () => false,\n  producerRecomputeValue: () => {},\n  consumerMarkedDirty: () => {},\n  consumerOnSignalRead: () => {},\n};\n\ninterface ReactiveLink {\n  producer: ReactiveNode;\n  consumer: ReactiveNode;\n  lastReadVersion: number;\n  prevConsumer: ReactiveLink | undefined;\n  nextConsumer: ReactiveLink | undefined;\n  nextProducer: ReactiveLink | undefined;\n}\n\nexport type ReactiveNodeKind =\n  | 'signal'\n  | 'computed'\n  | 'effect'\n  | 'template'\n  | 'linkedSignal'\n  | 'afterRenderEffectPhase'\n  | 'unknown';\n\n/**\n * A producer and/or consumer which participates in the reactive graph.\n *\n * Producer `ReactiveNode`s which are accessed when a consumer `ReactiveNode` is the\n * `activeConsumer` are tracked as dependencies of that consumer.\n *\n * Certain consumers are also tracked as \"live\" consumers and create edges in the other direction,\n * from producer to consumer. These edges are used to propagate change notifications when a\n * producer's value is updated.\n *\n * A `ReactiveNode` may be both a producer and consumer.\n */\nexport interface ReactiveNode {\n  /**\n   * Version of the value that this node produces.\n   *\n   * This is incremented whenever a new value is produced by this node which is not equal to the\n   * previous value (by whatever definition of equality is in use).\n   */\n  version: Version;\n\n  /**\n   * Epoch at which this node is verified to be clean.\n   *\n   * This allows skipping of some polling operations in the case where no signals have been set\n   * since this node was last read.\n   */\n  lastCleanEpoch: Version;\n\n  /**\n   * Whether this node (in its consumer capacity) is dirty.\n   *\n   * Only live consumers become dirty, when receiving a change notification from a dependency\n   * producer.\n   */\n  dirty: boolean;\n\n  /**\n   * Whether this node is currently rebuilding its producer list.\n   */\n  recomputing: boolean;\n\n  /**\n   * Producers which are dependencies of this consumer.\n   */\n  producers: ReactiveLink | undefined;\n\n  /**\n   * Points to the last linked list node in the `producers` linked list.\n   *\n   * When this node is recomputing, this is used to track the producers that we have accessed so far.\n   */\n  producersTail: ReactiveLink | undefined;\n\n  /**\n   * Linked list of consumers of this producer that are \"live\" (they require push notifications).\n   *\n   * The length of this list is effectively our reference count for this node.\n   */\n  consumers: ReactiveLink | undefined;\n  consumersTail: ReactiveLink | undefined;\n\n  /**\n   * Whether writes to signals are allowed when this consumer is the `activeConsumer`.\n   *\n   * This is used to enforce guardrails such as preventing writes to writable signals in the\n   * computation function of computed signals, which is supposed to be pure.\n   */\n  consumerAllowSignalWrites: boolean;\n\n  readonly consumerIsAlwaysLive: boolean;\n\n  /**\n   * Tracks whether producers need to recompute their value independently of the reactive graph (for\n   * example, if no initial value has been computed).\n   */\n  producerMustRecompute(node: unknown): boolean;\n  producerRecomputeValue(node: unknown): void;\n  consumerMarkedDirty(node: unknown): void;\n\n  /**\n   * Called when a signal is read within this consumer.\n   */\n  consumerOnSignalRead(node: unknown): void;\n\n  /**\n   * A debug name for the reactive node. Used in Angular DevTools to identify the node.\n   */\n  debugName?: string;\n\n  /**\n   * Kind of node. Example: 'signal', 'computed', 'input', 'effect'.\n   *\n   * ReactiveNode has this as 'unknown' by default, but derived node types should override this to\n   * make available the kind of signal that particular instance of a ReactiveNode represents.\n   *\n   * Used in Angular DevTools to identify the kind of signal.\n   */\n  kind: ReactiveNodeKind;\n}\n\n/**\n * Called by implementations when a producer's signal is read.\n */\nexport function producerAccessed(node: ReactiveNode): void {\n  if (inNotificationPhase) {\n    throw new Error(\n      typeof ngDevMode !== 'undefined' && ngDevMode\n        ? `Assertion error: signal read during notification phase`\n        : '',\n    );\n  }\n\n  if (activeConsumer === null) {\n    // Accessed outside of a reactive context, so nothing to record.\n    return;\n  }\n\n  activeConsumer.consumerOnSignalRead(node);\n\n  const prevProducerLink = activeConsumer.producersTail;\n\n  // If the last producer we accessed is the same as the current one, we can skip adding a new\n  // link\n  if (prevProducerLink !== undefined && prevProducerLink.producer === node) {\n    return;\n  }\n\n  let nextProducerLink: ReactiveLink | undefined = undefined;\n  const isRecomputing = activeConsumer.recomputing;\n  if (isRecomputing) {\n    // If we're incrementally rebuilding the producers list, we want to check if the next producer\n    // in the list is the same as the one we're trying to add.\n\n    // If the previous producer is defined, then the next producer is just the one that follows it.\n    // Otherwise, we should check the head of the producers list (the first node that we accessed the last time this consumer was run).\n    nextProducerLink =\n      prevProducerLink !== undefined ? prevProducerLink.nextProducer : activeConsumer.producers;\n    if (nextProducerLink !== undefined && nextProducerLink.producer === node) {\n      // If the next producer is the same as the one we're trying to add, we can just update the\n      // last read version, update the tail of the producers list of this rerun, and return.\n      activeConsumer.producersTail = nextProducerLink;\n      nextProducerLink.lastReadVersion = node.version;\n      return;\n    }\n  }\n\n  const prevConsumerLink = node.consumersTail;\n\n  // If the producer we're accessing already has a link to this consumer, we can skip adding a new\n  // link. This can short circuit the creation of a new link in the case where the consumer reads alternating ReeactiveNodes\n  if (\n    prevConsumerLink !== undefined &&\n    prevConsumerLink.consumer === activeConsumer &&\n    // However, we have to make sure that the link we've discovered isn't from a node that is incrementally rebuilding its producer list\n    (!isRecomputing || isValidLink(prevConsumerLink, activeConsumer))\n  ) {\n    // If we found an existing link to the consumer we can just return.\n    return;\n  }\n\n  // If we got here, it means that we need to create a new link between the producer and the consumer.\n  const isLive = consumerIsLive(activeConsumer);\n  const newLink = {\n    producer: node,\n    consumer: activeConsumer,\n    // instead of eagerly destroying the previous link, we delay until we've finished recomputing\n    // the producers list, so that we can destroy all of the old links at once.\n    nextProducer: nextProducerLink,\n    prevConsumer: prevConsumerLink,\n    lastReadVersion: node.version,\n    nextConsumer: undefined,\n  };\n  activeConsumer.producersTail = newLink;\n  if (prevProducerLink !== undefined) {\n    prevProducerLink.nextProducer = newLink;\n  } else {\n    activeConsumer.producers = newLink;\n  }\n\n  if (isLive) {\n    producerAddLiveConsumer(node, newLink);\n  }\n}\n\n/**\n * Increment the global epoch counter.\n *\n * Called by source producers (that is, not computeds) whenever their values change.\n */\nexport function producerIncrementEpoch(): void {\n  epoch++;\n}\n\n/**\n * Ensure this producer's `version` is up-to-date.\n */\nexport function producerUpdateValueVersion(node: ReactiveNode): void {\n  if (consumerIsLive(node) && !node.dirty) {\n    // A live consumer will be marked dirty by producers, so a clean state means that its version\n    // is guaranteed to be up-to-date.\n    return;\n  }\n\n  if (!node.dirty && node.lastCleanEpoch === epoch) {\n    // Even non-live consumers can skip polling if they previously found themselves to be clean at\n    // the current epoch, since their dependencies could not possibly have changed (such a change\n    // would've increased the epoch).\n    return;\n  }\n\n  if (!node.producerMustRecompute(node) && !consumerPollProducersForChange(node)) {\n    // None of our producers report a change since the last time they were read, so no\n    // recomputation of our value is necessary, and we can consider ourselves clean.\n    producerMarkClean(node);\n    return;\n  }\n\n  node.producerRecomputeValue(node);\n\n  // After recomputing the value, we're no longer dirty.\n  producerMarkClean(node);\n}\n\n/**\n * Propagate a dirty notification to live consumers of this producer.\n */\nexport function producerNotifyConsumers(node: ReactiveNode): void {\n  if (node.consumers === undefined) {\n    return;\n  }\n\n  // Prevent signal reads when we're updating the graph\n  const prev = inNotificationPhase;\n  inNotificationPhase = true;\n  try {\n    for (\n      let link: ReactiveLink | undefined = node.consumers;\n      link !== undefined;\n      link = link.nextConsumer\n    ) {\n      const consumer = link.consumer;\n      if (!consumer.dirty) {\n        consumerMarkDirty(consumer);\n      }\n    }\n  } finally {\n    inNotificationPhase = prev;\n  }\n}\n\n/**\n * Whether this `ReactiveNode` in its producer capacity is currently allowed to initiate updates,\n * based on the current consumer context.\n */\nexport function producerUpdatesAllowed(): boolean {\n  return activeConsumer?.consumerAllowSignalWrites !== false;\n}\n\nexport function consumerMarkDirty(node: ReactiveNode): void {\n  node.dirty = true;\n  producerNotifyConsumers(node);\n  node.consumerMarkedDirty?.(node);\n}\n\nexport function producerMarkClean(node: ReactiveNode): void {\n  node.dirty = false;\n  node.lastCleanEpoch = epoch;\n}\n\n/**\n * Prepare this consumer to run a computation in its reactive context and set\n * it as the active consumer.\n *\n * Must be called by subclasses which represent reactive computations, before those computations\n * begin.\n */\nexport function consumerBeforeComputation(node: ReactiveNode | null): ReactiveNode | null {\n  if (node) resetConsumerBeforeComputation(node);\n\n  return setActiveConsumer(node);\n}\n\n/**\n * Prepare this consumer to run a computation in its reactive context.\n *\n * We expose this mainly for code where we manually batch effects into a single\n * consumer. In those cases we may wish to \"reopen\" a consumer multiple times\n * in initial render before finalizing it. Most code should just call\n * `consumerBeforeComputation` instead of calling this directly.\n */\nexport function resetConsumerBeforeComputation(node: ReactiveNode): void {\n  node.producersTail = undefined;\n  node.recomputing = true;\n}\n\n/**\n * Finalize this consumer's state and set previous consumer as the active consumer after a\n * reactive computation has run.\n *\n * Must be called by subclasses which represent reactive computations, after those computations\n * have finished.\n */\nexport function consumerAfterComputation(\n  node: ReactiveNode | null,\n  prevConsumer: ReactiveNode | null,\n): void {\n  setActiveConsumer(prevConsumer);\n\n  if (node) finalizeConsumerAfterComputation(node);\n}\n\n/**\n * Finalize this consumer's state after a reactive computation has run.\n *\n * We expose this mainly for code where we manually batch effects into a single\n * consumer. In those cases we may wish to \"reopen\" a consumer multiple times\n * in initial render before finalizing it. Most code should just call\n * `consumerAfterComputation` instead of calling this directly.\n */\nexport function finalizeConsumerAfterComputation(node: ReactiveNode): void {\n  node.recomputing = false;\n\n  // We've finished incrementally rebuilding the producers list, now if there are any producers\n  // that are after producersTail, they are stale and should be removed.\n  const producersTail = node.producersTail as ReactiveLink | undefined;\n  let toRemove = producersTail !== undefined ? producersTail.nextProducer : node.producers;\n  if (toRemove !== undefined) {\n    if (consumerIsLive(node)) {\n      // For each stale link, we first unlink it from the producers list of consumers\n      do {\n        toRemove = producerRemoveLiveConsumerLink(toRemove);\n      } while (toRemove !== undefined);\n    }\n\n    // Now, we can truncate the producers list to remove all stale links.\n    if (producersTail !== undefined) {\n      producersTail.nextProducer = undefined;\n    } else {\n      node.producers = undefined;\n    }\n  }\n}\n\n/**\n * Determine whether this consumer has any dependencies which have changed since the last time\n * they were read.\n */\nexport function consumerPollProducersForChange(node: ReactiveNode): boolean {\n  // Poll producers for change.\n  for (let link = node.producers; link !== undefined; link = link.nextProducer) {\n    const producer = link.producer;\n    const seenVersion = link.lastReadVersion;\n\n    // First check the versions. A mismatch means that the producer's value is known to have\n    // changed since the last time we read it.\n    if (seenVersion !== producer.version) {\n      return true;\n    }\n\n    // The producer's version is the same as the last time we read it, but it might itself be\n    // stale. Force the producer to recompute its version (calculating a new value if necessary).\n    producerUpdateValueVersion(producer);\n\n    // Now when we do this check, `producer.version` is guaranteed to be up to date, so if the\n    // versions still match then it has not changed since the last time we read it.\n    if (seenVersion !== producer.version) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Disconnect this consumer from the graph.\n */\nexport function consumerDestroy(node: ReactiveNode): void {\n  if (consumerIsLive(node)) {\n    // Drop all connections from the graph to this node.\n    let link = node.producers;\n    while (link !== undefined) {\n      link = producerRemoveLiveConsumerLink(link);\n    }\n  }\n\n  // Truncate all the linked lists to drop all connection from this node to the graph.\n  node.producers = undefined;\n  node.producersTail = undefined;\n  node.consumers = undefined;\n  node.consumersTail = undefined;\n}\n\n/**\n * Add `consumer` as a live consumer of this node.\n *\n * Note that this operation is potentially transitive. If this node becomes live, then it becomes\n * a live consumer of all of its current producers.\n */\nfunction producerAddLiveConsumer(node: ReactiveNode, link: ReactiveLink): void {\n  const consumersTail = node.consumersTail;\n  const wasLive = consumerIsLive(node);\n  if (consumersTail !== undefined) {\n    link.nextConsumer = consumersTail.nextConsumer;\n    consumersTail.nextConsumer = link;\n  } else {\n    link.nextConsumer = undefined;\n    node.consumers = link;\n  }\n  link.prevConsumer = consumersTail;\n  node.consumersTail = link;\n  if (!wasLive) {\n    for (\n      let link: ReactiveLink | undefined = node.producers;\n      link !== undefined;\n      link = link.nextProducer\n    ) {\n      producerAddLiveConsumer(link.producer, link);\n    }\n  }\n}\n\nfunction producerRemoveLiveConsumerLink(link: ReactiveLink): ReactiveLink | undefined {\n  const producer = link.producer;\n  const nextProducer = link.nextProducer;\n  const nextConsumer = link.nextConsumer;\n  const prevConsumer = link.prevConsumer;\n  link.nextConsumer = undefined;\n  link.prevConsumer = undefined;\n  if (nextConsumer !== undefined) {\n    nextConsumer.prevConsumer = prevConsumer;\n  } else {\n    producer.consumersTail = prevConsumer;\n  }\n  if (prevConsumer !== undefined) {\n    prevConsumer.nextConsumer = nextConsumer;\n  } else {\n    producer.consumers = nextConsumer;\n    if (!consumerIsLive(producer)) {\n      let producerLink = producer.producers;\n      while (producerLink !== undefined) {\n        producerLink = producerRemoveLiveConsumerLink(producerLink);\n      }\n    }\n  }\n  return nextProducer;\n}\n\nfunction consumerIsLive(node: ReactiveNode): boolean {\n  return node.consumerIsAlwaysLive || node.consumers !== undefined;\n}\n\nexport function runPostProducerCreatedFn(node: ReactiveNode): void {\n  postProducerCreatedFn?.(node);\n}\n\nexport function setPostProducerCreatedFn(fn: ReactiveHookFn | null): ReactiveHookFn | null {\n  const prev = postProducerCreatedFn;\n  postProducerCreatedFn = fn;\n  return prev;\n}\n\n// While a ReactiveNode is recomputing, it may not have destroyed previous links\n// This allows us to check if a given link will be destroyed by a reactivenode if it were to finish running immediately without accesing any more producers\nfunction isValidLink(checkLink: ReactiveLink, consumer: ReactiveNode): boolean {\n  const producersTail = consumer.producersTail;\n  if (producersTail !== undefined) {\n    let link = consumer.producers!;\n    do {\n      if (link === checkLink) {\n        return true;\n      }\n      if (link === producersTail) {\n        break;\n      }\n      link = link.nextProducer!;\n    } while (link !== undefined);\n  }\n  return false;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {defaultEquals, ValueEqualityFn} from './equality';\nimport {\n  consumerAfterComputation,\n  consumerBeforeComputation,\n  producerAccessed,\n  producerUpdateValueVersion,\n  REACTIVE_NODE,\n  ReactiveNode,\n  setActiveConsumer,\n  SIGNAL,\n  runPostProducerCreatedFn,\n} from './graph';\n\n// Required as the signals library is in a separate package, so we need to explicitly ensure the\n// global `ngDevMode` type is defined.\ndeclare const ngDevMode: boolean | undefined;\n\n/**\n * A computation, which derives a value from a declarative reactive expression.\n *\n * `Computed`s are both producers and consumers of reactivity.\n */\nexport interface ComputedNode<T> extends ReactiveNode {\n  /**\n   * Current value of the computation, or one of the sentinel values above (`UNSET`, `COMPUTING`,\n   * `ERROR`).\n   */\n  value: T;\n\n  /**\n   * If `value` is `ERRORED`, the error caught from the last computation attempt which will\n   * be re-thrown.\n   */\n  error: unknown;\n\n  /**\n   * The computation function which will produce a new value.\n   */\n  computation: () => T;\n\n  equal: ValueEqualityFn<T>;\n}\n\nexport type ComputedGetter<T> = (() => T) & {\n  [SIGNAL]: ComputedNode<T>;\n};\n\n/**\n * Create a computed signal which derives a reactive value from an expression.\n */\nexport function createComputed<T>(\n  computation: () => T,\n  equal?: ValueEqualityFn<T>,\n): ComputedGetter<T> {\n  const node: ComputedNode<T> = Object.create(COMPUTED_NODE);\n  node.computation = computation;\n\n  if (equal !== undefined) {\n    node.equal = equal;\n  }\n\n  const computed = () => {\n    // Check if the value needs updating before returning it.\n    producerUpdateValueVersion(node);\n\n    // Record that someone looked at this signal.\n    producerAccessed(node);\n\n    if (node.value === ERRORED) {\n      throw node.error;\n    }\n\n    return node.value;\n  };\n\n  (computed as ComputedGetter<T>)[SIGNAL] = node;\n  if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n    const debugName = node.debugName ? ' (' + node.debugName + ')' : '';\n    computed.toString = () => `[Computed${debugName}: ${node.value}]`;\n  }\n\n  runPostProducerCreatedFn(node);\n\n  return computed as unknown as ComputedGetter<T>;\n}\n\n/**\n * A dedicated symbol used before a computed value has been calculated for the first time.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nexport const UNSET: any = /* @__PURE__ */ Symbol('UNSET');\n\n/**\n * A dedicated symbol used in place of a computed signal value to indicate that a given computation\n * is in progress. Used to detect cycles in computation chains.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nexport const COMPUTING: any = /* @__PURE__ */ Symbol('COMPUTING');\n\n/**\n * A dedicated symbol used in place of a computed signal value to indicate that a given computation\n * failed. The thrown error is cached until the computation gets dirty again.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nexport const ERRORED: any = /* @__PURE__ */ Symbol('ERRORED');\n\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nconst COMPUTED_NODE = /* @__PURE__ */ (() => {\n  return {\n    ...REACTIVE_NODE,\n    value: UNSET,\n    dirty: true,\n    error: null,\n    equal: defaultEquals,\n    kind: 'computed',\n\n    producerMustRecompute(node: ComputedNode<unknown>): boolean {\n      // Force a recomputation if there's no current value, or if the current value is in the\n      // process of being calculated (which should throw an error).\n      return node.value === UNSET || node.value === COMPUTING;\n    },\n\n    producerRecomputeValue(node: ComputedNode<unknown>): void {\n      if (node.value === COMPUTING) {\n        // Our computation somehow led to a cyclic read of itself.\n        throw new Error(\n          typeof ngDevMode !== 'undefined' && ngDevMode ? 'Detected cycle in computations.' : '',\n        );\n      }\n\n      const oldValue = node.value;\n      node.value = COMPUTING;\n\n      const prevConsumer = consumerBeforeComputation(node);\n      let newValue: unknown;\n      let wasEqual = false;\n      try {\n        newValue = node.computation();\n        // We want to mark this node as errored if calling `equal` throws; however, we don't want\n        // to track any reactive reads inside `equal`.\n        setActiveConsumer(null);\n        wasEqual =\n          oldValue !== UNSET &&\n          oldValue !== ERRORED &&\n          newValue !== ERRORED &&\n          node.equal(oldValue, newValue);\n      } catch (err) {\n        newValue = ERRORED;\n        node.error = err;\n      } finally {\n        consumerAfterComputation(node, prevConsumer);\n      }\n\n      if (wasEqual) {\n        // No change to `valueVersion` - old and new values are\n        // semantically equivalent.\n        node.value = oldValue;\n        return;\n      }\n\n      node.value = newValue;\n      node.version++;\n    },\n  };\n})();\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport type {SignalNode} from './signal';\n\nfunction defaultThrowError(): never {\n  throw new Error();\n}\n\nlet throwInvalidWriteToSignalErrorFn: <T>(node: SignalNode<T>) => never = defaultThrowError;\n\nexport function throwInvalidWriteToSignalError<T>(node: SignalNode<T>) {\n  throwInvalidWriteToSignalErrorFn(node);\n}\n\nexport function setThrowInvalidWriteToSignalError(fn: <T>(node: SignalNode<T>) => never): void {\n  throwInvalidWriteToSignalErrorFn = fn;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {defaultEquals, ValueEqualityFn} from './equality';\nimport {throwInvalidWriteToSignalError} from './errors';\nimport {\n  producerAccessed,\n  producerIncrementEpoch,\n  producerNotifyConsumers,\n  producerUpdatesAllowed,\n  REACTIVE_NODE,\n  ReactiveNode,\n  ReactiveHookFn,\n  runPostProducerCreatedFn,\n  SIGNAL,\n} from './graph';\n\n// Required as the signals library is in a separate package, so we need to explicitly ensure the\n// global `ngDevMode` type is defined.\ndeclare const ngDevMode: boolean | undefined;\n\n/**\n * If set, called after `WritableSignal`s are updated.\n *\n * This hook can be used to achieve various effects, such as running effects synchronously as part\n * of setting a signal.\n */\nlet postSignalSetFn: ReactiveHookFn | null = null;\n\nexport interface SignalNode<T> extends ReactiveNode {\n  value: T;\n  equal: ValueEqualityFn<T>;\n}\n\nexport type SignalBaseGetter<T> = (() => T) & {readonly [SIGNAL]: unknown};\nexport type SignalSetter<T> = (newValue: T) => void;\nexport type SignalUpdater<T> = (updateFn: (value: T) => T) => void;\n\n// Note: Closure *requires* this to be an `interface` and not a type, which is why the\n// `SignalBaseGetter` type exists to provide the correct shape.\nexport interface SignalGetter<T> extends SignalBaseGetter<T> {\n  readonly [SIGNAL]: SignalNode<T>;\n}\n\n/**\n * Creates a `Signal` getter, setter, and updater function.\n */\nexport function createSignal<T>(\n  initialValue: T,\n  equal?: ValueEqualityFn<T>,\n): [SignalGetter<T>, SignalSetter<T>, SignalUpdater<T>] {\n  const node: SignalNode<T> = Object.create(SIGNAL_NODE);\n  node.value = initialValue;\n  if (equal !== undefined) {\n    node.equal = equal;\n  }\n  const getter = (() => signalGetFn(node)) as SignalGetter<T>;\n  (getter as any)[SIGNAL] = node;\n  if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n    const debugName = node.debugName ? ' (' + node.debugName + ')' : '';\n    getter.toString = () => `[Signal${debugName}: ${node.value}]`;\n  }\n\n  runPostProducerCreatedFn(node);\n  const set = (newValue: T) => signalSetFn(node, newValue);\n  const update = (updateFn: (value: T) => T) => signalUpdateFn(node, updateFn);\n  return [getter, set, update];\n}\n\nexport function setPostSignalSetFn(fn: ReactiveHookFn | null): ReactiveHookFn | null {\n  const prev = postSignalSetFn;\n  postSignalSetFn = fn;\n  return prev;\n}\n\nexport function signalGetFn<T>(node: SignalNode<T>): T {\n  producerAccessed(node);\n  return node.value;\n}\n\nexport function signalSetFn<T>(node: SignalNode<T>, newValue: T) {\n  if (!producerUpdatesAllowed()) {\n    throwInvalidWriteToSignalError(node);\n  }\n\n  if (!node.equal(node.value, newValue)) {\n    node.value = newValue;\n    signalValueChanged(node);\n  }\n}\n\nexport function signalUpdateFn<T>(node: SignalNode<T>, updater: (value: T) => T): void {\n  if (!producerUpdatesAllowed()) {\n    throwInvalidWriteToSignalError(node);\n  }\n\n  signalSetFn(node, updater(node.value));\n}\n\nexport function runPostSignalSetFn<T>(node: SignalNode<T>): void {\n  postSignalSetFn?.(node);\n}\n\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nexport const SIGNAL_NODE: SignalNode<unknown> = /* @__PURE__ */ (() => {\n  return {\n    ...REACTIVE_NODE,\n    equal: defaultEquals,\n    value: undefined,\n    kind: 'signal',\n  };\n})();\n\nfunction signalValueChanged<T>(node: SignalNode<T>): void {\n  node.version++;\n  producerIncrementEpoch();\n  producerNotifyConsumers(node);\n  postSignalSetFn?.(node);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  consumerAfterComputation,\n  consumerBeforeComputation,\n  consumerPollProducersForChange,\n  REACTIVE_NODE,\n  ReactiveNode,\n} from './graph';\n\n/**\n * An effect can, optionally, register a cleanup function. If registered, the cleanup is executed\n * before the next effect run. The cleanup function makes it possible to \"cancel\" any work that the\n * previous effect run might have started.\n */\nexport type EffectCleanupFn = () => void;\n\n/**\n * A callback passed to the effect function that makes it possible to register cleanup logic.\n */\nexport type EffectCleanupRegisterFn = (cleanupFn: EffectCleanupFn) => void;\n\nexport interface BaseEffectNode extends ReactiveNode {\n  fn: () => void;\n  destroy(): void;\n  cleanup(): void;\n  run(): void;\n}\n\nexport const BASE_EFFECT_NODE: Omit<BaseEffectNode, 'fn' | 'destroy' | 'cleanup' | 'run'> =\n  /* @__PURE__ */ (() => ({\n    ...REACTIVE_NODE,\n    consumerIsAlwaysLive: true,\n    consumerAllowSignalWrites: true,\n    dirty: true,\n    kind: 'effect',\n  }))();\n\nexport function runEffect(node: BaseEffectNode) {\n  node.dirty = false;\n  if (node.version > 0 && !consumerPollProducersForChange(node)) {\n    return;\n  }\n  node.version++;\n  const prevNode = consumerBeforeComputation(node);\n  try {\n    node.cleanup();\n    node.fn();\n  } finally {\n    consumerAfterComputation(node, prevNode);\n  }\n}\n"],"names":["inNotificationPhase","SIGNAL","Symbol","setActiveConsumer","consumer","prev","activeConsumer","getActiveConsumer","isInNotificationPhase","isReactive","value","undefined","REACTIVE_NODE","lastCleanEpoch","consumers","consumerAllowSignalWrites","consumerIsAlwaysLive","producerMustRecompute","producerRecomputeValue","consumerMarkedDirty","consumerOnSignalRead","producerAccessed","node","ngDevMode","prevProducerLink","producer","nextProducerLink","nextProducer","producers","consumersTail","isRecomputing","isValidLink","prevConsumerLink","isLive","consumerIsLive","lastReadVersion","version","nextConsumer","producersTail","newLink","epoch","producerUpdateValueVersion","dirty","consumerPollProducersForChange","producerNotifyConsumers","link","consumerMarkDirty","producerUpdatesAllowed","producerMarkClean","consumerBeforeComputation","computation","equal","computed","ERRORED","error","debugName","defaultThrowError","postSignalSetFn","getter","toString","runPostProducerCreatedFn","set","newValue","signalSetFn","update","updateFn","signalUpdateFn","setPostSignalSetFn","fn","signalGetFn"],"mappings":"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"}
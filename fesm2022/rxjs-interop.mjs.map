{"version":3,"file":"rxjs-interop.mjs","sources":["../../../../../../packages/core/rxjs-interop/src/from_observable.ts","../../../../../../packages/core/rxjs-interop/src/from_signal.ts","../../../../../../packages/core/rxjs-interop/src/take_until_destroyed.ts","../../../../../../packages/core/rxjs-interop/rxjs-interop.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertInInjectionContext, computed, DestroyRef, inject, signal, Signal, WritableSignal} from '@angular/core';\nimport {Observable} from 'rxjs';\n\n/**\n * Get the current value of an `Observable` as a reactive `Signal`.\n *\n * `fromObservable` returns a `Signal` which provides synchronous reactive access to values produced\n * by the given `Observable`, by subscribing to that `Observable`. The returned `Signal` will always\n * have the most recent value emitted by the subscription, and will throw an error if the\n * `Observable` errors.\n *\n * The subscription will last for the lifetime of the current injection context. That is, if\n * `fromObservable` is called from a component context, the subscription will be cleaned up when the\n * component is destroyed. When called outside of a component, the current `EnvironmentInjector`'s\n * lifetime will be used (which is typically the lifetime of the application itself).\n *\n * If the `Observable` does not produce a value before the `Signal` is read, the `Signal` will throw\n * an error. To avoid this, use a synchronous `Observable` (potentially created with the `startWith`\n * operator) or pass an initial value to `fromObservable` as the second argument.\n *\n * `fromObservable` must be called in an injection context.\n */\nexport function fromObservable<T>(source: Observable<T>): Signal<T>;\n\n/**\n * Get the current value of an `Observable` as a reactive `Signal`.\n *\n * `fromObservable` returns a `Signal` which provides synchronous reactive access to values produced\n * by the given `Observable`, by subscribing to that `Observable`. The returned `Signal` will always\n * have the most recent value emitted by the subscription, and will throw an error if the\n * `Observable` errors.\n *\n * The subscription will last for the lifetime of the current injection context. That is, if\n * `fromObservable` is called from a component context, the subscription will be cleaned up when the\n * component is destroyed. When called outside of a component, the current `EnvironmentInjector`'s\n * lifetime will be used (which is typically the lifetime of the application itself).\n *\n * Before the `Observable` emits its first value, the `Signal` will return the configured\n * `initialValue`. If the `Observable` is known to produce a value before the `Signal` will be read,\n * `initialValue` does not need to be passed.\n *\n * `fromObservable` must be called in an injection context.\n *\n * @developerPreview\n */\nexport function fromObservable<T, U extends T|null|undefined>(\n    // fromObservable(Observable<Animal>) -> Signal<Cat>\n    source: Observable<T>, initialValue: U): Signal<T|U>;\nexport function fromObservable<T, U = never>(source: Observable<T>, initialValue?: U): Signal<T|U> {\n  assertInInjectionContext(fromObservable);\n\n  // Note: T is the Observable value type, and U is the initial value type. They don't have to be\n  // the same - the returned signal gives values of type `T`.\n  let state: WritableSignal<State<T|U>>;\n  if (initialValue === undefined && arguments.length !== 2) {\n    // No initial value was passed, so initially the signal is in a `NoValue` state and will throw\n    // if accessed.\n    state = signal({kind: StateKind.NoValue});\n  } else {\n    // An initial value was passed, so use it.\n    state = signal<State<T|U>>({kind: StateKind.Value, value: initialValue!});\n  }\n\n  const sub = source.subscribe({\n    next: value => state.set({kind: StateKind.Value, value}),\n    error: error => state.set({kind: StateKind.Error, error}),\n    // Completion of the Observable is meaningless to the signal. Signals don't have a concept of\n    // \"complete\".\n  });\n\n  // Unsubscribe when the current context is destroyed.\n  inject(DestroyRef).onDestroy(sub.unsubscribe.bind(sub));\n\n  // The actual returned signal is a `computed` of the `State` signal, which maps the various states\n  // to either values or errors.\n  return computed(() => {\n    const current = state();\n    switch (current.kind) {\n      case StateKind.Value:\n        return current.value;\n      case StateKind.Error:\n        throw current.error;\n      case StateKind.NoValue:\n        // TODO(alxhub): use a RuntimeError when we finalize the error semantics\n        throw new Error(`fromObservable() signal read before the Observable emitted`);\n    }\n  });\n}\n\nconst enum StateKind {\n  NoValue,\n  Value,\n  Error,\n}\n\ninterface NoValueState {\n  kind: StateKind.NoValue;\n}\n\ninterface ValueState<T> {\n  kind: StateKind.Value;\n  value: T;\n}\n\ninterface ErrorState {\n  kind: StateKind.Error;\n  error: unknown;\n}\n\ntype State<T> = NoValueState|ValueState<T>|ErrorState;\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertInInjectionContext, effect, inject, Injector, Signal} from '@angular/core';\nimport {Observable} from 'rxjs';\n\n/**\n * Options for `fromSignal`.\n *\n * @developerPreview\n */\nexport interface FromSignalOptions {\n  /**\n   * The `Injector` to use when creating the effect.\n   *\n   * If this isn't specified, the current injection context will be used.\n   */\n  injector?: Injector;\n}\n\n/**\n * Exposes the value of an Angular `Signal` as an RxJS `Observable`.\n *\n * The signal's value will be propagated into the `Observable`'s subscribers using an `effect`.\n *\n * `fromSignal` must be called in an injection context.\n *\n * @developerPreview\n */\nexport function fromSignal<T>(\n    source: Signal<T>,\n    options?: FromSignalOptions,\n    ): Observable<T> {\n  !options?.injector && assertInInjectionContext(fromSignal);\n  const injector = options?.injector ?? inject(Injector);\n\n  // Creating a new `Observable` allows the creation of the effect to be lazy. This allows for all\n  // references to `source` to be dropped if the `Observable` is fully unsubscribed and thrown away.\n  return new Observable(observer => {\n    const watcher = effect(() => {\n      try {\n        observer.next(source());\n      } catch (err) {\n        observer.error(err);\n      }\n    }, {injector, manualCleanup: true});\n    return () => watcher.destroy();\n  });\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertInInjectionContext, DestroyRef, inject} from '@angular/core';\nimport {MonoTypeOperatorFunction, Observable} from 'rxjs';\nimport {takeUntil} from 'rxjs/operators';\n\n/**\n * Operator which completes the Observable when the calling context (component, directive, service,\n * etc) is destroyed.\n *\n * @param destroyRef optionally, the `DestroyRef` representing the current context. This can be\n *     passed explicitly to use `takeUntilDestroyed` outside of an injection context. Otherwise, the\n * current `DestroyRef` is injected.\n *\n * @developerPreview\n */\nexport function takeUntilDestroyed<T>(destroyRef?: DestroyRef): MonoTypeOperatorFunction<T> {\n  if (!destroyRef) {\n    assertInInjectionContext(takeUntilDestroyed);\n    destroyRef = inject(DestroyRef);\n  }\n\n  const destroyed$ = new Observable<void>(observer => {\n    destroyRef!.onDestroy(observer.next.bind(observer));\n  });\n\n  return <T>(source: Observable<T>) => {\n    return source.pipe(takeUntil(destroyed$));\n  };\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":[],"mappings":"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"}
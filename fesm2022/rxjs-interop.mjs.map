{"version":3,"file":"rxjs-interop.mjs","sources":["../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/core/rxjs-interop/src/take_until_destroyed.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/core/rxjs-interop/src/output_from_observable.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/core/rxjs-interop/src/output_to_observable.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/core/rxjs-interop/src/pending_until_event.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/core/rxjs-interop/src/rx_resource.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {assertInInjectionContext, DestroyRef, inject} from '../../src/core';\nimport {MonoTypeOperatorFunction, Observable} from 'rxjs';\nimport {takeUntil} from 'rxjs/operators';\n\n/**\n * Operator which completes the Observable when the calling context (component, directive, service,\n * etc) is destroyed.\n *\n * @param destroyRef optionally, the `DestroyRef` representing the current context. This can be\n *     passed explicitly to use `takeUntilDestroyed` outside of an [injection\n * context](guide/di/dependency-injection-context). Otherwise, the current `DestroyRef` is injected.\n *\n * @publicApi 19.0\n */\nexport function takeUntilDestroyed<T>(destroyRef?: DestroyRef): MonoTypeOperatorFunction<T> {\n  if (!destroyRef) {\n    ngDevMode && assertInInjectionContext(takeUntilDestroyed);\n    destroyRef = inject(DestroyRef);\n  }\n\n  const destroyed$ = new Observable<void>((subscriber) => {\n    if (destroyRef.destroyed) {\n      subscriber.next();\n      return;\n    }\n    const unregisterFn = destroyRef.onDestroy(subscriber.next.bind(subscriber));\n    return unregisterFn;\n  });\n\n  return <T>(source: Observable<T>) => {\n    return source.pipe(takeUntil(destroyed$));\n  };\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  assertInInjectionContext,\n  DestroyRef,\n  inject,\n  OutputOptions,\n  OutputRef,\n  OutputRefSubscription,\n  ɵRuntimeError,\n  ɵRuntimeErrorCode,\n} from '../../src/core';\nimport {Observable} from 'rxjs';\n\nimport {takeUntilDestroyed} from './take_until_destroyed';\n\n/**\n * Implementation of `OutputRef` that emits values from\n * an RxJS observable source.\n *\n * @internal\n */\nclass OutputFromObservableRef<T> implements OutputRef<T> {\n  private destroyed = false;\n\n  destroyRef = inject(DestroyRef);\n\n  constructor(private source: Observable<T>) {\n    this.destroyRef.onDestroy(() => {\n      this.destroyed = true;\n    });\n  }\n\n  subscribe(callbackFn: (value: T) => void): OutputRefSubscription {\n    if (this.destroyed) {\n      throw new ɵRuntimeError(\n        ɵRuntimeErrorCode.OUTPUT_REF_DESTROYED,\n        ngDevMode &&\n          'Unexpected subscription to destroyed `OutputRef`. ' +\n            'The owning directive/component is destroyed.',\n      );\n    }\n\n    // Stop yielding more values when the directive/component is already destroyed.\n    const subscription = this.source.pipe(takeUntilDestroyed(this.destroyRef)).subscribe({\n      next: (value) => callbackFn(value),\n    });\n\n    return {\n      unsubscribe: () => subscription.unsubscribe(),\n    };\n  }\n}\n\n/**\n * Declares an Angular output that is using an RxJS observable as a source\n * for events dispatched to parent subscribers.\n *\n * The behavior for an observable as source is defined as followed:\n *    1. New values are forwarded to the Angular output (next notifications).\n *    2. Errors notifications are not handled by Angular. You need to handle these manually.\n *       For example by using `catchError`.\n *    3. Completion notifications stop the output from emitting new values.\n *\n * @usageNotes\n * Initialize an output in your directive by declaring a\n * class field and initializing it with the `outputFromObservable()` function.\n *\n * ```ts\n * @Directive({..})\n * export class MyDir {\n *   nameChange$ = <some-observable>;\n *   nameChange = outputFromObservable(this.nameChange$);\n * }\n * ```\n *\n * @publicApi 19.0\n */\nexport function outputFromObservable<T>(\n  observable: Observable<T>,\n  opts?: OutputOptions,\n): OutputRef<T> {\n  ngDevMode && assertInInjectionContext(outputFromObservable);\n  return new OutputFromObservableRef<T>(observable);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {OutputRef, ɵgetOutputDestroyRef} from '../../src/core';\nimport {Observable} from 'rxjs';\n\n/**\n * Converts an Angular output declared via `output()` or `outputFromObservable()`\n * to an observable.\n * It creates an observable that represents the stream of \"events firing\" in an output.\n *\n * You can subscribe to the output via `Observable.subscribe` then.\n *\n * @publicApi 19.0\n */\nexport function outputToObservable<T>(ref: OutputRef<T>): Observable<T> {\n  const destroyRef = ɵgetOutputDestroyRef(ref);\n\n  return new Observable<T>((observer) => {\n    // Complete the observable upon directive/component destroy.\n    // Note: May be `undefined` if an `EventEmitter` is declared outside\n    // of an injection context.\n    const unregisterOnDestroy = destroyRef?.onDestroy(() => observer.complete());\n\n    const subscription = ref.subscribe((v) => observer.next(v));\n    return () => {\n      subscription.unsubscribe();\n      unregisterOnDestroy?.();\n    };\n  });\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {assertInInjectionContext, PendingTasks, inject, Injector} from '../../src/core';\nimport {MonoTypeOperatorFunction, Observable} from 'rxjs';\n\n/**\n * Operator which makes the application unstable until the observable emits, completes, errors, or is unsubscribed.\n *\n * Use this operator in observables whose subscriptions are important for rendering and should be included in SSR serialization.\n *\n * @param injector The `Injector` to use during creation. If this is not provided, the current injection context will be used instead (via `inject`).\n *\n * @developerPreview 20.0\n */\nexport function pendingUntilEvent<T>(injector?: Injector): MonoTypeOperatorFunction<T> {\n  if (injector === undefined) {\n    ngDevMode && assertInInjectionContext(pendingUntilEvent);\n    injector = inject(Injector);\n  }\n  const taskService = injector.get(PendingTasks);\n\n  return (sourceObservable) => {\n    return new Observable<T>((originalSubscriber) => {\n      // create a new task on subscription\n      const removeTask = taskService.add();\n\n      let cleanedUp = false;\n      function cleanupTask() {\n        if (cleanedUp) {\n          return;\n        }\n\n        removeTask();\n        cleanedUp = true;\n      }\n\n      const innerSubscription = sourceObservable.subscribe({\n        next: (v) => {\n          originalSubscriber.next(v);\n          cleanupTask();\n        },\n        complete: () => {\n          originalSubscriber.complete();\n          cleanupTask();\n        },\n        error: (e) => {\n          originalSubscriber.error(e);\n          cleanupTask();\n        },\n      });\n      innerSubscription.add(() => {\n        originalSubscriber.unsubscribe();\n        cleanupTask();\n      });\n      return innerSubscription;\n    });\n  };\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  assertInInjectionContext,\n  resource,\n  ResourceLoaderParams,\n  ResourceRef,\n  Signal,\n  signal,\n  BaseResourceOptions,\n  ɵRuntimeError,\n  ɵRuntimeErrorCode,\n  ResourceStreamItem,\n} from '../../src/core';\nimport {Observable, Subscription} from 'rxjs';\nimport {encapsulateResourceError} from '../../src/resource/resource';\n\n/**\n * Like `ResourceOptions` but uses an RxJS-based `loader`.\n *\n * @experimental\n */\nexport interface RxResourceOptions<T, R> extends BaseResourceOptions<T, R> {\n  stream: (params: ResourceLoaderParams<R>) => Observable<T>;\n}\n\n/**\n * Like `resource` but uses an RxJS based `loader` which maps the request to an `Observable` of the\n * resource's value.\n *\n * @experimental\n */\nexport function rxResource<T, R>(\n  opts: RxResourceOptions<T, R> & {defaultValue: NoInfer<T>},\n): ResourceRef<T>;\n\n/**\n * Like `resource` but uses an RxJS based `loader` which maps the request to an `Observable` of the\n * resource's value.\n *\n * @experimental\n */\nexport function rxResource<T, R>(opts: RxResourceOptions<T, R>): ResourceRef<T | undefined>;\nexport function rxResource<T, R>(opts: RxResourceOptions<T, R>): ResourceRef<T | undefined> {\n  if (ngDevMode && !opts?.injector) {\n    assertInInjectionContext(rxResource);\n  }\n  return resource<T, R>({\n    ...opts,\n    loader: undefined,\n    stream: (params) => {\n      let sub: Subscription | undefined;\n\n      // Track the abort listener so it can be removed if the Observable completes (as a memory\n      // optimization).\n      const onAbort = () => sub?.unsubscribe();\n      params.abortSignal.addEventListener('abort', onAbort);\n\n      // Start off stream as undefined.\n      const stream = signal<ResourceStreamItem<T>>({value: undefined as T});\n      let resolve: ((value: Signal<ResourceStreamItem<T>>) => void) | undefined;\n      const promise = new Promise<Signal<ResourceStreamItem<T>>>((r) => (resolve = r));\n\n      function send(value: ResourceStreamItem<T>): void {\n        stream.set(value);\n        resolve?.(stream);\n        resolve = undefined;\n      }\n\n      // TODO(alxhub): remove after g3 updated to rename loader -> stream\n      const streamFn = opts.stream ?? (opts as {loader?: RxResourceOptions<T, R>['stream']}).loader;\n      if (streamFn === undefined) {\n        throw new ɵRuntimeError(\n          ɵRuntimeErrorCode.MUST_PROVIDE_STREAM_OPTION,\n          ngDevMode && `Must provide \\`stream\\` option.`,\n        );\n      }\n\n      sub = streamFn(params).subscribe({\n        next: (value) => send({value}),\n        error: (error: unknown) => {\n          send({error: encapsulateResourceError(error)});\n          params.abortSignal.removeEventListener('abort', onAbort);\n        },\n        complete: () => {\n          if (resolve) {\n            send({\n              error: new ɵRuntimeError(\n                ɵRuntimeErrorCode.RESOURCE_COMPLETED_BEFORE_PRODUCING_VALUE,\n                ngDevMode && 'Resource completed before producing a value',\n              ),\n            });\n          }\n          params.abortSignal.removeEventListener('abort', onAbort);\n        },\n      });\n\n      return promise;\n    },\n  });\n}\n"],"names":["next","unregisterFn","destroyRef","onDestroy","subscriber","bind","source","callbackFn","destroyed","ɵRuntimeError","ngDevMode","unregisterOnDestroy","observer","complete","ref","subscribe","v","subscription","unsubscribe","Observable","originalSubscriber","removeTask","taskService","add","cleanedUp","sourceObservable","cleanupTask","error","e","resource","opts","loader","undefined"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;gBAgCI,CAAAA,IAAA,EAAA;AACA,MAAA;AACA;AACF,IAAA,MAAAC,YAAE,GAAAC,UAAA,CAAAC,SAAA,CAAAC,UAAA,CAAAJ,IAAA,CAAAK,IAAA,CAAAD,UAAA,CAAA,CAAA;;AAIF,GAAA,CAAA;AACFE,EAAAA,OAAAA,MAAA,IAAA;;;;;6BCC6B,CAAA;EAIjBA,MAAA;;;;;IAOP,IAAAJ,CAAAA,UAAA,CAAAC,SAAA,CAAA,MAAA;uBAEM,IAAA;AAMX,KAAA,CAAA;AALM;YAEJI,UAAA,EAAA;AAGF,IAAA,IAAA,IAAA,CAAAC,SAAA,EAAA;AAAA,MAAA,MAAA,IAAAC,YAAA,CAAAC,GAAAA,EAAAA,SAAA;;;;;;;;;;;;;;;;;;IC9BI,MAAAC,mBAAA,GAAAT,UAAA,EAAAC,SAAA,CAAAS,MAAAA,QAAA,CAAAC,QAAA,EAAA,CAAA;sBACc,GAAAC,GAAA,CAAAC,SAAc,CAAAC,CAAA,IAAAJ,QAAA,CAAAZ,IAAA,CAAAgB,CAAA,CAAA,CAAA;iBACP;MAErBC,YAAA,CAAAC,WAAA,EAAA;MACJP,mBAAA,IAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ICLM,OAAAQ,IAAAA,UAAA,CAAAC,kBAAoC,IAAA;AAGpC,MAAA,MAAAC,UAAA,GAAAC,WAAA,CAAAC,GAAoB,EAAA;mBACd,GAAA,KAAA;;qBAEJ,EAAA;;;QAMFF,UAAA,EAAA;AACEG,QAAAA,SAAA,GAAM,IAAE;AAEN;6BACD,GAAAC,gBAAA,CAAAV,SAAA,CAAA;mBACO;;UAENW,WAAA,EAAA;AAEF,SAAA;QACEb,QAAA,EAAAA,MAAA;AACAO,UAAAA,kBAAA,CAAAP,QAAA,EAAA;UAEHa,WAAA,EAAA;AACD,SAAA;;UAEEN,kBAAA,CAAAO,KAAA,CAAAC,CAAA,CAAA;UACFF,WAAA,EAAA;AACA;;AAEH,MAAA,iBAAA,CAAAH,GAAA,CAAA,MAAA;AACHH,QAAAA,kBAAA,CAAAF,WAAA,EAAA;;;;;;;;;;;;ACVE,EAAA,OAAAW,QAAA,CAAA;AAEE,IAAA,GACAC,IAAA;AAeIC,IAAAA,MAAA,EAAAC,SAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}
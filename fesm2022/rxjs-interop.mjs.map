{"version":3,"file":"rxjs-interop.mjs","sources":["../../../../../../packages/core/rxjs-interop/src/take_until_destroyed.ts","../../../../../../packages/core/rxjs-interop/src/output_from_observable.ts","../../../../../../packages/core/rxjs-interop/src/output_to_observable.ts","../../../../../../packages/core/rxjs-interop/src/to_observable.ts","../../../../../../packages/core/rxjs-interop/src/to_signal.ts","../../../../../../packages/core/rxjs-interop/src/pending_until_event.ts","../../../../../../packages/core/rxjs-interop/src/rx_resource.ts","../../../../../../packages/core/rxjs-interop/rxjs-interop.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {assertInInjectionContext, DestroyRef, inject} from '@angular/core';\nimport {MonoTypeOperatorFunction, Observable} from 'rxjs';\nimport {takeUntil} from 'rxjs/operators';\n\n/**\n * Operator which completes the Observable when the calling context (component, directive, service,\n * etc) is destroyed.\n *\n * @param destroyRef optionally, the `DestroyRef` representing the current context. This can be\n *     passed explicitly to use `takeUntilDestroyed` outside of an [injection\n * context](guide/di/dependency-injection-context). Otherwise, the current `DestroyRef` is injected.\n *\n * @publicApi\n */\nexport function takeUntilDestroyed<T>(destroyRef?: DestroyRef): MonoTypeOperatorFunction<T> {\n  if (!destroyRef) {\n    assertInInjectionContext(takeUntilDestroyed);\n    destroyRef = inject(DestroyRef);\n  }\n\n  const destroyed$ = new Observable<void>((observer) => {\n    const unregisterFn = destroyRef!.onDestroy(observer.next.bind(observer));\n    return unregisterFn;\n  });\n\n  return <T>(source: Observable<T>) => {\n    return source.pipe(takeUntil(destroyed$));\n  };\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  assertInInjectionContext,\n  DestroyRef,\n  inject,\n  OutputOptions,\n  OutputRef,\n  OutputRefSubscription,\n  ɵRuntimeError,\n  ɵRuntimeErrorCode,\n} from '@angular/core';\nimport {Observable} from 'rxjs';\n\nimport {takeUntilDestroyed} from './take_until_destroyed';\n\n/**\n * Implementation of `OutputRef` that emits values from\n * an RxJS observable source.\n *\n * @internal\n */\nclass OutputFromObservableRef<T> implements OutputRef<T> {\n  private destroyed = false;\n\n  destroyRef = inject(DestroyRef);\n\n  constructor(private source: Observable<T>) {\n    this.destroyRef.onDestroy(() => {\n      this.destroyed = true;\n    });\n  }\n\n  subscribe(callbackFn: (value: T) => void): OutputRefSubscription {\n    if (this.destroyed) {\n      throw new ɵRuntimeError(\n        ɵRuntimeErrorCode.OUTPUT_REF_DESTROYED,\n        ngDevMode &&\n          'Unexpected subscription to destroyed `OutputRef`. ' +\n            'The owning directive/component is destroyed.',\n      );\n    }\n\n    // Stop yielding more values when the directive/component is already destroyed.\n    const subscription = this.source.pipe(takeUntilDestroyed(this.destroyRef)).subscribe({\n      next: (value) => callbackFn(value),\n    });\n\n    return {\n      unsubscribe: () => subscription.unsubscribe(),\n    };\n  }\n}\n\n/**\n * Declares an Angular output that is using an RxJS observable as a source\n * for events dispatched to parent subscribers.\n *\n * The behavior for an observable as source is defined as followed:\n *    1. New values are forwarded to the Angular output (next notifications).\n *    2. Errors notifications are not handled by Angular. You need to handle these manually.\n *       For example by using `catchError`.\n *    3. Completion notifications stop the output from emitting new values.\n *\n * @usageNotes\n * Initialize an output in your directive by declaring a\n * class field and initializing it with the `outputFromObservable()` function.\n *\n * ```ts\n * @Directive({..})\n * export class MyDir {\n *   nameChange$ = <some-observable>;\n *   nameChange = outputFromObservable(this.nameChange$);\n * }\n * ```\n *\n * @publicApi\n */\nexport function outputFromObservable<T>(\n  observable: Observable<T>,\n  opts?: OutputOptions,\n): OutputRef<T> {\n  ngDevMode && assertInInjectionContext(outputFromObservable);\n  return new OutputFromObservableRef<T>(observable);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {OutputRef, ɵgetOutputDestroyRef} from '@angular/core';\nimport {Observable} from 'rxjs';\n\n/**\n * Converts an Angular output declared via `output()` or `outputFromObservable()`\n * to an observable.\n *\n * You can subscribe to the output via `Observable.subscribe` then.\n *\n * @publicApi\n */\nexport function outputToObservable<T>(ref: OutputRef<T>): Observable<T> {\n  const destroyRef = ɵgetOutputDestroyRef(ref);\n\n  return new Observable<T>((observer) => {\n    // Complete the observable upon directive/component destroy.\n    // Note: May be `undefined` if an `EventEmitter` is declared outside\n    // of an injection context.\n    destroyRef?.onDestroy(() => observer.complete());\n\n    const subscription = ref.subscribe((v) => observer.next(v));\n    return () => subscription.unsubscribe();\n  });\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  assertInInjectionContext,\n  DestroyRef,\n  effect,\n  inject,\n  Injector,\n  Signal,\n  untracked,\n  ɵmicrotaskEffect as microtaskEffect,\n} from '@angular/core';\nimport {Observable, ReplaySubject} from 'rxjs';\n\n/**\n * Options for `toObservable`.\n *\n * @developerPreview\n */\nexport interface ToObservableOptions {\n  /**\n   * The `Injector` to use when creating the underlying `effect` which watches the signal.\n   *\n   * If this isn't specified, the current [injection context](guide/di/dependency-injection-context)\n   * will be used.\n   */\n  injector?: Injector;\n}\n\n/**\n * Exposes the value of an Angular `Signal` as an RxJS `Observable`.\n *\n * The signal's value will be propagated into the `Observable`'s subscribers using an `effect`.\n *\n * `toObservable` must be called in an injection context unless an injector is provided via options.\n *\n * @developerPreview\n */\nexport function toObservable<T>(source: Signal<T>, options?: ToObservableOptions): Observable<T> {\n  !options?.injector && assertInInjectionContext(toObservable);\n  const injector = options?.injector ?? inject(Injector);\n  const subject = new ReplaySubject<T>(1);\n\n  const watcher = effect(\n    () => {\n      let value: T;\n      try {\n        value = source();\n      } catch (err) {\n        untracked(() => subject.error(err));\n        return;\n      }\n      untracked(() => subject.next(value));\n    },\n    {injector, manualCleanup: true},\n  );\n\n  injector.get(DestroyRef).onDestroy(() => {\n    watcher.destroy();\n    subject.complete();\n  });\n\n  return subject.asObservable();\n}\n\nexport function toObservableMicrotask<T>(\n  source: Signal<T>,\n  options?: ToObservableOptions,\n): Observable<T> {\n  !options?.injector && assertInInjectionContext(toObservable);\n  const injector = options?.injector ?? inject(Injector);\n  const subject = new ReplaySubject<T>(1);\n\n  const watcher = microtaskEffect(\n    () => {\n      let value: T;\n      try {\n        value = source();\n      } catch (err) {\n        untracked(() => subject.error(err));\n        return;\n      }\n      untracked(() => subject.next(value));\n    },\n    {injector, manualCleanup: true},\n  );\n\n  injector.get(DestroyRef).onDestroy(() => {\n    watcher.destroy();\n    subject.complete();\n  });\n\n  return subject.asObservable();\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  assertInInjectionContext,\n  assertNotInReactiveContext,\n  computed,\n  DestroyRef,\n  inject,\n  Injector,\n  signal,\n  Signal,\n  WritableSignal,\n  ɵRuntimeError,\n  ɵRuntimeErrorCode,\n} from '@angular/core';\nimport {ValueEqualityFn} from '@angular/core/primitives/signals';\nimport {Observable, Subscribable} from 'rxjs';\n\n/**\n * Options for `toSignal`.\n *\n * @publicApi\n */\nexport interface ToSignalOptions<T> {\n  /**\n   * Initial value for the signal produced by `toSignal`.\n   *\n   * This will be the value of the signal until the observable emits its first value.\n   */\n  initialValue?: unknown;\n\n  /**\n   * Whether to require that the observable emits synchronously when `toSignal` subscribes.\n   *\n   * If this is `true`, `toSignal` will assert that the observable produces a value immediately upon\n   * subscription. Setting this option removes the need to either deal with `undefined` in the\n   * signal type or provide an `initialValue`, at the cost of a runtime error if this requirement is\n   * not met.\n   */\n  requireSync?: boolean;\n\n  /**\n   * `Injector` which will provide the `DestroyRef` used to clean up the Observable subscription.\n   *\n   * If this is not provided, a `DestroyRef` will be retrieved from the current [injection\n   * context](guide/di/dependency-injection-context), unless manual cleanup is requested.\n   */\n  injector?: Injector;\n\n  /**\n   * Whether the subscription should be automatically cleaned up (via `DestroyRef`) when\n   * `toSignal`'s creation context is destroyed.\n   *\n   * If manual cleanup is enabled, then `DestroyRef` is not used, and the subscription will persist\n   * until the `Observable` itself completes.\n   */\n  manualCleanup?: boolean;\n\n  /**\n   * Whether `toSignal` should throw errors from the Observable error channel back to RxJS, where\n   * they'll be processed as uncaught exceptions.\n   *\n   * In practice, this means that the signal returned by `toSignal` will keep returning the last\n   * good value forever, as Observables which error produce no further values. This option emulates\n   * the behavior of the `async` pipe.\n   */\n  rejectErrors?: boolean;\n\n  /**\n   * A comparison function which defines equality for values emitted by the observable.\n   *\n   * Equality comparisons are executed against the initial value if one is provided.\n   */\n  equal?: ValueEqualityFn<T>;\n}\n\n// Base case: no options -> `undefined` in the result type.\nexport function toSignal<T>(source: Observable<T> | Subscribable<T>): Signal<T | undefined>;\n// Options with `undefined` initial value and no `requiredSync` -> `undefined`.\nexport function toSignal<T>(\n  source: Observable<T> | Subscribable<T>,\n  options: NoInfer<ToSignalOptions<T | undefined>> & {\n    initialValue?: undefined;\n    requireSync?: false;\n  },\n): Signal<T | undefined>;\n// Options with `null` initial value -> `null`.\nexport function toSignal<T>(\n  source: Observable<T> | Subscribable<T>,\n  options: NoInfer<ToSignalOptions<T | null>> & {initialValue?: null; requireSync?: false},\n): Signal<T | null>;\n// Options with `undefined` initial value and `requiredSync` -> strict result type.\nexport function toSignal<T>(\n  source: Observable<T> | Subscribable<T>,\n  options: NoInfer<ToSignalOptions<T>> & {initialValue?: undefined; requireSync: true},\n): Signal<T>;\n// Options with a more specific initial value type.\nexport function toSignal<T, const U extends T>(\n  source: Observable<T> | Subscribable<T>,\n  options: NoInfer<ToSignalOptions<T | U>> & {initialValue: U; requireSync?: false},\n): Signal<T | U>;\n\n/**\n * Get the current value of an `Observable` as a reactive `Signal`.\n *\n * `toSignal` returns a `Signal` which provides synchronous reactive access to values produced\n * by the given `Observable`, by subscribing to that `Observable`. The returned `Signal` will always\n * have the most recent value emitted by the subscription, and will throw an error if the\n * `Observable` errors.\n *\n * With `requireSync` set to `true`, `toSignal` will assert that the `Observable` produces a value\n * immediately upon subscription. No `initialValue` is needed in this case, and the returned signal\n * does not include an `undefined` type.\n *\n * By default, the subscription will be automatically cleaned up when the current [injection\n * context](guide/di/dependency-injection-context) is destroyed. For example, when `toSignal` is\n * called during the construction of a component, the subscription will be cleaned up when the\n * component is destroyed. If an injection context is not available, an explicit `Injector` can be\n * passed instead.\n *\n * If the subscription should persist until the `Observable` itself completes, the `manualCleanup`\n * option can be specified instead, which disables the automatic subscription teardown. No injection\n * context is needed in this configuration as well.\n *\n * @developerPreview\n */\nexport function toSignal<T, U = undefined>(\n  source: Observable<T> | Subscribable<T>,\n  options?: ToSignalOptions<T | U> & {initialValue?: U},\n): Signal<T | U> {\n  ngDevMode &&\n    assertNotInReactiveContext(\n      toSignal,\n      'Invoking `toSignal` causes new subscriptions every time. ' +\n        'Consider moving `toSignal` outside of the reactive context and read the signal value where needed.',\n    );\n\n  const requiresCleanup = !options?.manualCleanup;\n  requiresCleanup && !options?.injector && assertInInjectionContext(toSignal);\n  const cleanupRef = requiresCleanup\n    ? (options?.injector?.get(DestroyRef) ?? inject(DestroyRef))\n    : null;\n\n  const equal = makeToSignalEqual(options?.equal);\n\n  // Note: T is the Observable value type, and U is the initial value type. They don't have to be\n  // the same - the returned signal gives values of type `T`.\n  let state: WritableSignal<State<T | U>>;\n  if (options?.requireSync) {\n    // Initially the signal is in a `NoValue` state.\n    state = signal({kind: StateKind.NoValue}, {equal});\n  } else {\n    // If an initial value was passed, use it. Otherwise, use `undefined` as the initial value.\n    state = signal<State<T | U>>(\n      {kind: StateKind.Value, value: options?.initialValue as U},\n      {equal},\n    );\n  }\n\n  // Note: This code cannot run inside a reactive context (see assertion above). If we'd support\n  // this, we would subscribe to the observable outside of the current reactive context, avoiding\n  // that side-effect signal reads/writes are attribute to the current consumer. The current\n  // consumer only needs to be notified when the `state` signal changes through the observable\n  // subscription. Additional context (related to async pipe):\n  // https://github.com/angular/angular/pull/50522.\n  const sub = source.subscribe({\n    next: (value) => state.set({kind: StateKind.Value, value}),\n    error: (error) => {\n      if (options?.rejectErrors) {\n        // Kick the error back to RxJS. It will be caught and rethrown in a macrotask, which causes\n        // the error to end up as an uncaught exception.\n        throw error;\n      }\n      state.set({kind: StateKind.Error, error});\n    },\n    // Completion of the Observable is meaningless to the signal. Signals don't have a concept of\n    // \"complete\".\n  });\n\n  if (options?.requireSync && state().kind === StateKind.NoValue) {\n    throw new ɵRuntimeError(\n      ɵRuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT,\n      (typeof ngDevMode === 'undefined' || ngDevMode) &&\n        '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.',\n    );\n  }\n\n  // Unsubscribe when the current context is destroyed, if requested.\n  cleanupRef?.onDestroy(sub.unsubscribe.bind(sub));\n\n  // The actual returned signal is a `computed` of the `State` signal, which maps the various states\n  // to either values or errors.\n  return computed(\n    () => {\n      const current = state();\n      switch (current.kind) {\n        case StateKind.Value:\n          return current.value;\n        case StateKind.Error:\n          throw current.error;\n        case StateKind.NoValue:\n          // This shouldn't really happen because the error is thrown on creation.\n          throw new ɵRuntimeError(\n            ɵRuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT,\n            (typeof ngDevMode === 'undefined' || ngDevMode) &&\n              '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.',\n          );\n      }\n    },\n    {equal: options?.equal},\n  );\n}\n\nfunction makeToSignalEqual<T>(\n  userEquality: ValueEqualityFn<T> = Object.is,\n): ValueEqualityFn<State<T>> {\n  return (a, b) =>\n    a.kind === StateKind.Value && b.kind === StateKind.Value && userEquality(a.value, b.value);\n}\n\nconst enum StateKind {\n  NoValue,\n  Value,\n  Error,\n}\n\ninterface NoValueState {\n  kind: StateKind.NoValue;\n}\n\ninterface ValueState<T> {\n  kind: StateKind.Value;\n  value: T;\n}\n\ninterface ErrorState {\n  kind: StateKind.Error;\n  error: unknown;\n}\n\ntype State<T> = NoValueState | ValueState<T> | ErrorState;\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertInInjectionContext, PendingTasks, inject, Injector} from '@angular/core';\nimport {MonoTypeOperatorFunction, Observable} from 'rxjs';\n\n/**\n * Operator which makes the application unstable until the observable emits, complets, errors, or is unsubscribed.\n *\n * Use this operator in observables whose subscriptions are important for rendering and should be included in SSR serialization.\n *\n * @param injector The `Injector` to use during creation. If this is not provided, the current injection context will be used instead (via `inject`).\n *\n * @experimental\n */\nexport function pendingUntilEvent<T>(injector?: Injector): MonoTypeOperatorFunction<T> {\n  if (injector === undefined) {\n    assertInInjectionContext(pendingUntilEvent);\n    injector = inject(Injector);\n  }\n  const taskService = injector.get(PendingTasks);\n\n  return (sourceObservable) => {\n    return new Observable<T>((originalSubscriber) => {\n      // create a new task on subscription\n      const removeTask = taskService.add();\n\n      let cleanedUp = false;\n      function cleanupTask() {\n        if (cleanedUp) {\n          return;\n        }\n\n        removeTask();\n        cleanedUp = true;\n      }\n\n      const innerSubscription = sourceObservable.subscribe({\n        next: (v) => {\n          originalSubscriber.next(v);\n          cleanupTask();\n        },\n        complete: () => {\n          originalSubscriber.complete();\n          cleanupTask();\n        },\n        error: (e) => {\n          originalSubscriber.error(e);\n          cleanupTask();\n        },\n      });\n      innerSubscription.add(() => {\n        originalSubscriber.unsubscribe();\n        cleanupTask();\n      });\n      return innerSubscription;\n    });\n  };\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  assertInInjectionContext,\n  ResourceOptions,\n  resource,\n  ResourceLoaderParams,\n  ResourceRef,\n} from '@angular/core';\nimport {Observable, Subject} from 'rxjs';\nimport {take, takeUntil} from 'rxjs/operators';\n\n/**\n * Like `ResourceOptions` but uses an RxJS-based `loader`.\n *\n * @experimental\n */\nexport interface RxResourceOptions<T, R> extends Omit<ResourceOptions<T, R>, 'loader'> {\n  loader: (params: ResourceLoaderParams<R>) => Observable<T>;\n}\n\n/**\n * Like `resource` but uses an RxJS based `loader` which maps the request to an `Observable` of the\n * resource's value. Like `firstValueFrom`, only the first emission of the Observable is considered.\n *\n * @experimental\n */\nexport function rxResource<T, R>(opts: RxResourceOptions<T, R>): ResourceRef<T> {\n  opts?.injector || assertInInjectionContext(rxResource);\n  return resource<T, R>({\n    ...opts,\n    loader: (params) => {\n      const cancelled = new Subject<void>();\n      params.abortSignal.addEventListener('abort', () => cancelled.next());\n\n      // Note: this is identical to `firstValueFrom` which we can't use,\n      // because at the time of writing, `core` still supports rxjs 6.x.\n      return new Promise<T>((resolve, reject) => {\n        opts\n          .loader(params)\n          .pipe(take(1), takeUntil(cancelled))\n          .subscribe({\n            next: resolve,\n            error: reject,\n            complete: () => reject(new Error('Resource completed before producing a value')),\n          });\n      });\n    },\n  });\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":["microtaskEffect"],"mappings":"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"}
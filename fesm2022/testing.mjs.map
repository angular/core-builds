{"version":3,"file":"testing.mjs","sources":["../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/core/testing/src/async.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/core/testing/src/application_error_handler.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/core/testing/src/defer.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/core/testing/src/test_bed_common.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/core/testing/src/component_fixture.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/core/testing/src/fake_async.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/core/testing/src/metadata_overrider.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/core/testing/src/resolvers.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/core/testing/src/test_bed_compiler.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/core/testing/src/test_bed.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/core/primitives/dom-navigation/testing/fake_navigation.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/core/testing/src/test_hooks.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/core/testing/src/logger.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n/**\n * Wraps a test function in an asynchronous test zone. The test will automatically\n * complete when all asynchronous calls within this zone are done. Can be used\n * to wrap an {@link inject} call.\n *\n * Example:\n *\n * ```ts\n * it('...', waitForAsync(inject([AClass], (object) => {\n *   object.doSomething.then(() => {\n *     expect(...);\n *   })\n * })));\n * ```\n *\n * @publicApi\n */\nexport function waitForAsync(fn: Function): (done: any) => any {\n  const _Zone: any = typeof Zone !== 'undefined' ? Zone : null;\n  if (!_Zone) {\n    return function () {\n      return Promise.reject(\n        'Zone is needed for the waitForAsync() test helper but could not be found. ' +\n          'Please make sure that your environment includes zone.js',\n      );\n    };\n  }\n  const asyncTest = _Zone && _Zone[_Zone.__symbol__('asyncTest')];\n  if (typeof asyncTest === 'function') {\n    return asyncTest(fn);\n  }\n  return function () {\n    return Promise.reject(\n      'zone-testing.js is needed for the async() test helper but could not be found. ' +\n        'Please make sure that your environment includes zone.js/testing',\n    );\n  };\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ErrorHandler, inject, NgZone, Injectable, EnvironmentInjector} from '../../src/core';\n\nexport const RETHROW_APPLICATION_ERRORS_DEFAULT = true;\n\n@Injectable()\nexport class TestBedApplicationErrorHandler {\n  private readonly zone = inject(NgZone);\n  private readonly injector = inject(EnvironmentInjector);\n  private userErrorHandler?: ErrorHandler;\n  readonly whenStableRejectFunctions: Set<(e: unknown) => void> = new Set();\n\n  handleError(e: unknown) {\n    try {\n      this.zone.runOutsideAngular(() => {\n        this.userErrorHandler ??= this.injector.get(ErrorHandler);\n        this.userErrorHandler.handleError(e);\n      });\n    } catch (userError: unknown) {\n      e = userError;\n    }\n\n    // Instead of throwing the error when there are outstanding `fixture.whenStable` promises,\n    // reject those promises with the error. This allows developers to write\n    // expectAsync(fix.whenStable()).toBeRejected();\n    if (this.whenStableRejectFunctions.size > 0) {\n      for (const fn of this.whenStableRejectFunctions.values()) {\n        fn(e);\n      }\n      this.whenStableRejectFunctions.clear();\n    } else {\n      throw e;\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  ɵCONTAINER_HEADER_OFFSET as CONTAINER_HEADER_OFFSET,\n  ɵDeferBlockDetails as DeferBlockDetails,\n  ɵDeferBlockState as DeferBlockState,\n  ɵgetDeferBlocks as getDeferBlocks,\n  ɵrenderDeferBlockState as renderDeferBlockState,\n  ɵtriggerResourceLoading as triggerResourceLoading,\n} from '../../src/core';\n\nimport type {ComponentFixture} from './component_fixture';\n\n/**\n * Represents an individual defer block for testing purposes.\n *\n * @publicApi\n */\nexport class DeferBlockFixture {\n  /** @docs-private */\n  constructor(\n    private block: DeferBlockDetails,\n    private componentFixture: ComponentFixture<unknown>,\n  ) {}\n\n  /**\n   * Renders the specified state of the defer fixture.\n   * @param state the defer state to render\n   */\n  async render(state: DeferBlockState): Promise<void> {\n    if (!hasStateTemplate(state, this.block)) {\n      const stateAsString = getDeferBlockStateNameFromEnum(state);\n      throw new Error(\n        `Tried to render this defer block in the \\`${stateAsString}\\` state, ` +\n          `but there was no @${stateAsString.toLowerCase()} block defined in a template.`,\n      );\n    }\n    if (state === DeferBlockState.Complete) {\n      await triggerResourceLoading(this.block.tDetails, this.block.lView, this.block.tNode);\n    }\n    // If the `render` method is used explicitly - skip timer-based scheduling for\n    // `@placeholder` and `@loading` blocks and render them immediately.\n    const skipTimerScheduling = true;\n    renderDeferBlockState(state, this.block.tNode, this.block.lContainer, skipTimerScheduling);\n    this.componentFixture.detectChanges();\n  }\n\n  /**\n   * Retrieves all nested child defer block fixtures\n   * in a given defer block.\n   */\n  getDeferBlocks(): Promise<DeferBlockFixture[]> {\n    const deferBlocks: DeferBlockDetails[] = [];\n    // An LContainer that represents a defer block has at most 1 view, which is\n    // located right after an LContainer header. Get a hold of that view and inspect\n    // it for nested defer blocks.\n    const deferBlockFixtures = [];\n    if (this.block.lContainer.length >= CONTAINER_HEADER_OFFSET) {\n      const lView = this.block.lContainer[CONTAINER_HEADER_OFFSET];\n      getDeferBlocks(lView, deferBlocks);\n      for (const block of deferBlocks) {\n        deferBlockFixtures.push(new DeferBlockFixture(block, this.componentFixture));\n      }\n    }\n    return Promise.resolve(deferBlockFixtures);\n  }\n}\n\nfunction hasStateTemplate(state: DeferBlockState, block: DeferBlockDetails) {\n  switch (state) {\n    case DeferBlockState.Placeholder:\n      return block.tDetails.placeholderTmplIndex !== null;\n    case DeferBlockState.Loading:\n      return block.tDetails.loadingTmplIndex !== null;\n    case DeferBlockState.Error:\n      return block.tDetails.errorTmplIndex !== null;\n    case DeferBlockState.Complete:\n      return true;\n    default:\n      return false;\n  }\n}\n\nfunction getDeferBlockStateNameFromEnum(state: DeferBlockState) {\n  switch (state) {\n    case DeferBlockState.Placeholder:\n      return 'Placeholder';\n    case DeferBlockState.Loading:\n      return 'Loading';\n    case DeferBlockState.Error:\n      return 'Error';\n    default:\n      return 'Main';\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  InjectionToken,\n  SchemaMetadata,\n  ɵDeferBlockBehavior as DeferBlockBehavior,\n} from '../../src/core';\n\n/** Whether test modules should be torn down by default. */\nexport const TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT = true;\n\n/** Whether unknown elements in templates should throw by default. */\nexport const THROW_ON_UNKNOWN_ELEMENTS_DEFAULT = false;\n\n/** Whether unknown properties in templates should throw by default. */\nexport const THROW_ON_UNKNOWN_PROPERTIES_DEFAULT = false;\n\n/** Whether defer blocks should use manual triggering or play through normally. */\nexport const DEFER_BLOCK_DEFAULT_BEHAVIOR = DeferBlockBehavior.Playthrough;\n\n/** Whether animations are enabled or disabled. */\nexport const ANIMATIONS_ENABLED_DEFAULT = false;\n\n/**\n * An abstract class for inserting the root test component element in a platform independent way.\n *\n * @publicApi\n */\nexport class TestComponentRenderer {\n  insertRootElement(rootElementId: string, tagName?: string) {}\n  removeAllRootElements?() {}\n}\n\n/**\n * @publicApi\n */\nexport const ComponentFixtureAutoDetect = new InjectionToken<boolean>('ComponentFixtureAutoDetect');\n\n/**\n * @publicApi\n */\nexport const ComponentFixtureNoNgZone = new InjectionToken<boolean>('ComponentFixtureNoNgZone');\n\n/**\n * @publicApi\n */\nexport interface TestModuleMetadata {\n  providers?: any[];\n  declarations?: any[];\n  imports?: any[];\n  schemas?: Array<SchemaMetadata | any[]>;\n  teardown?: ModuleTeardownOptions;\n  /**\n   * Whether NG0304 runtime errors should be thrown when unknown elements are present in component's\n   * template. Defaults to `false`, where the error is simply logged. If set to `true`, the error is\n   * thrown.\n   * @see [NG8001](/errors/NG8001) for the description of the problem and how to fix it\n   */\n  errorOnUnknownElements?: boolean;\n  /**\n   * Whether errors should be thrown when unknown properties are present in component's template.\n   * Defaults to `false`, where the error is simply logged.\n   * If set to `true`, the error is thrown.\n   * @see [NG8002](/errors/NG8002) for the description of the error and how to fix it\n   */\n  errorOnUnknownProperties?: boolean;\n\n  /**\n   * Whether errors that happen during application change detection should be rethrown.\n   *\n   * When `true`, errors that are caught during application change detection will\n   * be reported to the `ErrorHandler` and rethrown to prevent them from going\n   * unnoticed in tests.\n   *\n   * When `false`, errors are only forwarded to the `ErrorHandler`, which by default\n   * simply logs them to the console.\n   *\n   * Defaults to `true`.\n   */\n  rethrowApplicationErrors?: boolean;\n\n  /**\n   * Whether defer blocks should behave with manual triggering or play through normally.\n   * Defaults to `manual`.\n   */\n  deferBlockBehavior?: DeferBlockBehavior;\n\n  /**\n   * Whether to infer the tag name of test components from their selectors.\n   * Otherwise `div` will be used as the tag name for test components.\n   */\n  inferTagName?: boolean;\n\n  /**\n   * Whether animate.enter / animate.leave should trigger as normal or be disabled.\n   * Defaults to `false`.\n   */\n  animationsEnabled?: boolean;\n}\n\n/**\n * @publicApi\n */\nexport interface TestEnvironmentOptions {\n  /**\n   * Configures the test module teardown behavior in `TestBed`.\n   */\n  teardown?: ModuleTeardownOptions;\n  /**\n   * Whether errors should be thrown when unknown elements are present in component's template.\n   * Defaults to `false`, where the error is simply logged.\n   * If set to `true`, the error is thrown.\n   * @see [NG8001](/errors/NG8001) for the description of the error and how to fix it\n   */\n  errorOnUnknownElements?: boolean;\n  /**\n   * Whether errors should be thrown when unknown properties are present in component's template.\n   * Defaults to `false`, where the error is simply logged.\n   * If set to `true`, the error is thrown.\n   * @see [NG8002](/errors/NG8002) for the description of the error and how to fix it\n   */\n  errorOnUnknownProperties?: boolean;\n}\n\n/**\n * Configures the test module teardown behavior in `TestBed`.\n * @publicApi\n */\nexport interface ModuleTeardownOptions {\n  /** Whether the test module should be destroyed after every test. Defaults to `true`. */\n  destroyAfterEach: boolean;\n\n  /** Whether errors during test module destruction should be re-thrown. Defaults to `true`. */\n  rethrowErrors?: boolean;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Subscription} from 'rxjs';\nimport {\n  ApplicationRef,\n  ChangeDetectorRef,\n  ComponentRef,\n  DebugElement,\n  ɵDeferBlockDetails as DeferBlockDetails,\n  ɵEffectScheduler as EffectScheduler,\n  ElementRef,\n  getDebugNode,\n  ɵgetDeferBlocks as getDeferBlocks,\n  inject,\n  NgZone,\n  ɵNoopNgZone as NoopNgZone,\n  RendererFactory2,\n  ViewRef,\n  ɵZONELESS_ENABLED as ZONELESS_ENABLED,\n  ɵChangeDetectionScheduler,\n  ɵNotificationSource,\n} from '../../src/core';\nimport {PendingTasksInternal} from '../../src/pending_tasks_internal';\n\nimport {TestBedApplicationErrorHandler} from './application_error_handler';\nimport {DeferBlockFixture} from './defer';\nimport {ComponentFixtureAutoDetect, ComponentFixtureNoNgZone} from './test_bed_common';\n\ninterface TestAppRef {\n  allTestViews: Set<ViewRef>;\n  includeAllTestViews: boolean;\n  autoDetectTestViews: Set<ViewRef>;\n}\n\n/**\n * Fixture for debugging and testing a component.\n *\n * @publicApi\n */\nexport class ComponentFixture<T> {\n  /**\n   * The DebugElement associated with the root element of this component.\n   */\n  debugElement: DebugElement;\n\n  /**\n   * The instance of the root component class.\n   */\n  componentInstance: T;\n\n  /**\n   * The native element at the root of the component.\n   */\n  nativeElement: any;\n\n  /**\n   * The ElementRef for the element at the root of the component.\n   */\n  elementRef: ElementRef;\n\n  /**\n   * The ChangeDetectorRef for the component\n   */\n  changeDetectorRef: ChangeDetectorRef;\n\n  private _renderer: RendererFactory2 | null | undefined;\n  private _isDestroyed: boolean = false;\n  /** @internal */\n  protected readonly _noZoneOptionIsSet = inject(ComponentFixtureNoNgZone, {optional: true});\n  /** @internal */\n  protected _ngZone: NgZone = this._noZoneOptionIsSet ? new NoopNgZone() : inject(NgZone);\n  // Inject ApplicationRef to ensure NgZone stableness causes after render hooks to run\n  // This will likely happen as a result of fixture.detectChanges because it calls ngZone.run\n  // This is a crazy way of doing things but hey, it's the world we live in.\n  // The zoneless scheduler should instead do this more imperatively by attaching\n  // the `ComponentRef` to `ApplicationRef` and calling `appRef.tick` as the `detectChanges`\n  // behavior.\n  /** @internal */\n  protected readonly _appRef = inject(ApplicationRef);\n  private readonly _testAppRef = this._appRef as unknown as TestAppRef;\n  private readonly pendingTasks = inject(PendingTasksInternal);\n  private readonly appErrorHandler = inject(TestBedApplicationErrorHandler);\n  private readonly zonelessEnabled = inject(ZONELESS_ENABLED);\n  private readonly scheduler = inject(ɵChangeDetectionScheduler);\n  private readonly rootEffectScheduler = inject(EffectScheduler);\n  private readonly autoDetectDefault = this.zonelessEnabled ? true : false;\n  private autoDetect =\n    inject(ComponentFixtureAutoDetect, {optional: true}) ?? this.autoDetectDefault;\n\n  private subscriptions = new Subscription();\n\n  // TODO(atscott): Remove this from public API\n  ngZone = this._noZoneOptionIsSet ? null : this._ngZone;\n\n  /** @docs-private */\n  constructor(public componentRef: ComponentRef<T>) {\n    this.changeDetectorRef = componentRef.changeDetectorRef;\n    this.elementRef = componentRef.location;\n    this.debugElement = <DebugElement>getDebugNode(this.elementRef.nativeElement);\n    this.componentInstance = componentRef.instance;\n    this.nativeElement = this.elementRef.nativeElement;\n    this.componentRef = componentRef;\n\n    this._testAppRef.allTestViews.add(this.componentRef.hostView);\n    if (this.autoDetect) {\n      this._testAppRef.autoDetectTestViews.add(this.componentRef.hostView);\n      this.scheduler?.notify(ɵNotificationSource.ViewAttached);\n      this.scheduler?.notify(ɵNotificationSource.MarkAncestorsForTraversal);\n    }\n    this.componentRef.hostView.onDestroy(() => {\n      this._testAppRef.allTestViews.delete(this.componentRef.hostView);\n      this._testAppRef.autoDetectTestViews.delete(this.componentRef.hostView);\n    });\n    // Create subscriptions outside the NgZone so that the callbacks run outside\n    // of NgZone.\n    this._ngZone.runOutsideAngular(() => {\n      this.subscriptions.add(\n        this._ngZone.onError.subscribe({\n          next: (error: any) => {\n            // The rethrow here is to ensure that errors don't go unreported. Since `NgZone.onHandleError` returns `false`,\n            // ZoneJS will not throw the error coming out of a task. Instead, the handling is defined by\n            // the chain of parent delegates and whether they indicate the error is handled in some way (by returning `false`).\n            // Unfortunately, 'onError' does not forward the information about whether the error was handled by a parent zone\n            // so cannot know here whether throwing is appropriate. As a half-solution, we can check to see if we're inside\n            // a fakeAsync context, which we know has its own error handling.\n            // https://github.com/angular/angular/blob/db2f2d99c82aae52d8a0ae46616c6411d070b35e/packages/zone.js/lib/zone-spec/fake-async-test.ts#L783-L784\n            // https://github.com/angular/angular/blob/db2f2d99c82aae52d8a0ae46616c6411d070b35e/packages/zone.js/lib/zone-spec/fake-async-test.ts#L473-L478\n            if (typeof Zone === 'undefined' || Zone.current.get('FakeAsyncTestZoneSpec')) {\n              return;\n            }\n            throw error;\n          },\n        }),\n      );\n    });\n  }\n\n  /**\n   * Trigger a change detection cycle for the component.\n   */\n  detectChanges(checkNoChanges = true): void {\n    const originalCheckNoChanges = this.componentRef.changeDetectorRef.checkNoChanges;\n    try {\n      if (!checkNoChanges) {\n        this.componentRef.changeDetectorRef.checkNoChanges = () => {};\n      }\n\n      if (this.zonelessEnabled) {\n        try {\n          this._testAppRef.includeAllTestViews = true;\n          this._appRef.tick();\n        } finally {\n          this._testAppRef.includeAllTestViews = false;\n        }\n      } else {\n        // Run the change detection inside the NgZone so that any async tasks as part of the change\n        // detection are captured by the zone and can be waited for in isStable.\n        this._ngZone.run(() => {\n          // Flush root effects before `detectChanges()`, to emulate the sequencing of `tick()`.\n          this.rootEffectScheduler.flush();\n          this.changeDetectorRef.detectChanges();\n          this.checkNoChanges();\n        });\n      }\n    } finally {\n      this.componentRef.changeDetectorRef.checkNoChanges = originalCheckNoChanges;\n    }\n  }\n\n  /**\n   * Do a change detection run to make sure there were no changes.\n   */\n  checkNoChanges(): void {\n    this.changeDetectorRef.checkNoChanges();\n  }\n\n  /**\n   * Set whether the fixture should autodetect changes.\n   *\n   * Also runs detectChanges once so that any existing change is detected.\n   *\n   * @param autoDetect Whether to autodetect changes. By default, `true`.\n   * @deprecated For `autoDetect: true`, use `autoDetectChanges()`.\n   * We have not seen a use-case for `autoDetect: false` but `changeDetectorRef.detach()` is a close equivalent.\n   */\n  autoDetectChanges(autoDetect: boolean): void;\n  /**\n   * Enables automatically synchronizing the view, as it would in an application.\n   *\n   * Also runs detectChanges once so that any existing change is detected.\n   */\n  autoDetectChanges(): void;\n  autoDetectChanges(autoDetect = true): void {\n    if (!autoDetect && this.zonelessEnabled) {\n      throw new Error('Cannot set autoDetect to false with zoneless change detection.');\n    }\n    if (this._noZoneOptionIsSet && !this.zonelessEnabled) {\n      throw new Error('Cannot call autoDetectChanges when ComponentFixtureNoNgZone is set.');\n    }\n\n    if (autoDetect) {\n      this._testAppRef.autoDetectTestViews.add(this.componentRef.hostView);\n    } else {\n      this._testAppRef.autoDetectTestViews.delete(this.componentRef.hostView);\n    }\n\n    this.autoDetect = autoDetect;\n    this.detectChanges();\n  }\n\n  /**\n   * Return whether the fixture is currently stable or has async tasks that have not been completed\n   * yet.\n   */\n  isStable(): boolean {\n    return !this.pendingTasks.hasPendingTasks;\n  }\n\n  /**\n   * Get a promise that resolves when the fixture is stable.\n   *\n   * This can be used to resume testing after events have triggered asynchronous activity or\n   * asynchronous change detection.\n   */\n  whenStable(): Promise<any> {\n    if (this.isStable()) {\n      return Promise.resolve(false);\n    }\n\n    return new Promise((resolve, reject) => {\n      this.appErrorHandler.whenStableRejectFunctions.add(reject);\n      this._appRef.whenStable().then(() => {\n        this.appErrorHandler.whenStableRejectFunctions.delete(reject);\n        resolve(true);\n      });\n    });\n  }\n\n  /**\n   * Retrieves all defer block fixtures in the component fixture.\n   */\n  getDeferBlocks(): Promise<DeferBlockFixture[]> {\n    const deferBlocks: DeferBlockDetails[] = [];\n    const lView = (this.componentRef.hostView as any)['_lView'];\n    getDeferBlocks(lView, deferBlocks);\n\n    const deferBlockFixtures = [];\n    for (const block of deferBlocks) {\n      deferBlockFixtures.push(new DeferBlockFixture(block, this));\n    }\n\n    return Promise.resolve(deferBlockFixtures);\n  }\n\n  private _getRenderer() {\n    if (this._renderer === undefined) {\n      this._renderer = this.componentRef.injector.get(RendererFactory2, null);\n    }\n    return this._renderer as RendererFactory2 | null;\n  }\n\n  /**\n   * Get a promise that resolves when the ui state is stable following animations.\n   */\n  whenRenderingDone(): Promise<any> {\n    const renderer = this._getRenderer();\n    if (renderer && renderer.whenRenderingDone) {\n      return renderer.whenRenderingDone();\n    }\n    return this.whenStable();\n  }\n\n  /**\n   * Trigger component destruction.\n   */\n  destroy(): void {\n    this.subscriptions.unsubscribe();\n    this._testAppRef.autoDetectTestViews.delete(this.componentRef.hostView);\n    this._testAppRef.allTestViews.delete(this.componentRef.hostView);\n    if (!this._isDestroyed) {\n      this.componentRef.destroy();\n      this._isDestroyed = true;\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\n// Needed for the global `Zone` ambient types to be available.\nimport type {} from 'zone.js';\n\nconst _Zone: any = typeof Zone !== 'undefined' ? Zone : null;\nfunction getFakeAsyncTestModule() {\n  return _Zone && _Zone[_Zone.__symbol__('fakeAsyncTest')];\n}\n\nfunction withFakeAsyncTestModule(fn: (fakeAsyncTestModule: any) => any): any {\n  const fakeAsyncTestModule = getFakeAsyncTestModule();\n  if (!fakeAsyncTestModule) {\n    throw new Error(`zone-testing.js is needed for the fakeAsync() test helper but could not be found.\n        Please make sure that your environment includes zone.js/testing`);\n  }\n  return fn(fakeAsyncTestModule);\n}\n\n/**\n * Clears out the shared fake async zone for a test.\n * To be called in a global `beforeEach`.\n *\n * @publicApi\n */\nexport function resetFakeAsyncZone(): void {\n  withFakeAsyncTestModule((v) => v.resetFakeAsyncZone());\n}\n\nexport function resetFakeAsyncZoneIfExists(): void {\n  if (getFakeAsyncTestModule() && (Zone as any)['ProxyZoneSpec']?.isLoaded()) {\n    getFakeAsyncTestModule().resetFakeAsyncZone();\n  }\n}\n\n/**\n * Wraps a function to be executed in the `fakeAsync` zone:\n * - Microtasks are manually executed by calling `flushMicrotasks()`.\n * - Timers are synchronous; `tick()` simulates the asynchronous passage of time.\n *\n * Can be used to wrap `inject()` calls.\n *\n * @param fn The function that you want to wrap in the `fakeAsync` zone.\n * @param options\n *   - flush: When true, will drain the macrotask queue after the test function completes.\n *     When false, will throw an exception at the end of the function if there are pending timers.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/testing/ts/fake_async.ts region='basic'}\n *\n *\n * @returns The function wrapped to be executed in the `fakeAsync` zone.\n * Any arguments passed when calling this returned function will be passed through to the `fn`\n * function in the parameters when it is called.\n *\n * @publicApi\n */\nexport function fakeAsync(fn: Function, options?: {flush?: boolean}): (...args: any[]) => any {\n  return withFakeAsyncTestModule((v) => v.fakeAsync(fn, options));\n}\n\n/**\n * Simulates the asynchronous passage of time for the timers in the `fakeAsync` zone.\n *\n * The microtasks queue is drained at the very start of this function and after any timer callback\n * has been executed.\n *\n * @param millis The number of milliseconds to advance the virtual timer.\n * @param tickOptions The options to pass to the `tick()` function.\n *\n * @usageNotes\n *\n * The `tick()` option is a flag called `processNewMacroTasksSynchronously`,\n * which determines whether or not to invoke new macroTasks.\n *\n * If you provide a `tickOptions` object, but do not specify a\n * `processNewMacroTasksSynchronously` property (`tick(100, {})`),\n * then `processNewMacroTasksSynchronously` defaults to true.\n *\n * If you omit the `tickOptions` parameter (`tick(100))`), then\n * `tickOptions` defaults to `{processNewMacroTasksSynchronously: true}`.\n *\n * ### Example\n *\n * {@example core/testing/ts/fake_async.ts region='basic'}\n *\n * The following example includes a nested timeout (new macroTask), and\n * the `tickOptions` parameter is allowed to default. In this case,\n * `processNewMacroTasksSynchronously` defaults to true, and the nested\n * function is executed on each tick.\n *\n * ```ts\n * it ('test with nested setTimeout', fakeAsync(() => {\n *   let nestedTimeoutInvoked = false;\n *   function funcWithNestedTimeout() {\n *     setTimeout(() => {\n *       nestedTimeoutInvoked = true;\n *     });\n *   };\n *   setTimeout(funcWithNestedTimeout);\n *   tick();\n *   expect(nestedTimeoutInvoked).toBe(true);\n * }));\n * ```\n *\n * In the following case, `processNewMacroTasksSynchronously` is explicitly\n * set to false, so the nested timeout function is not invoked.\n *\n * ```ts\n * it ('test with nested setTimeout', fakeAsync(() => {\n *   let nestedTimeoutInvoked = false;\n *   function funcWithNestedTimeout() {\n *     setTimeout(() => {\n *       nestedTimeoutInvoked = true;\n *     });\n *   };\n *   setTimeout(funcWithNestedTimeout);\n *   tick(0, {processNewMacroTasksSynchronously: false});\n *   expect(nestedTimeoutInvoked).toBe(false);\n * }));\n * ```\n *\n *\n * @publicApi\n */\nexport function tick(\n  millis: number = 0,\n  tickOptions: {processNewMacroTasksSynchronously: boolean} = {\n    processNewMacroTasksSynchronously: true,\n  },\n): void {\n  return withFakeAsyncTestModule((m) => m.tick(millis, tickOptions));\n}\n\n/**\n * Flushes any pending microtasks and simulates the asynchronous passage of time for the timers in\n * the `fakeAsync` zone by\n * draining the macrotask queue until it is empty.\n *\n * @param maxTurns The maximum number of times the scheduler attempts to clear its queue before\n *     throwing an error.\n * @returns The simulated time elapsed, in milliseconds.\n *\n * @publicApi\n */\nexport function flush(maxTurns?: number): number {\n  return withFakeAsyncTestModule((m) => m.flush(maxTurns));\n}\n\n/**\n * Discard all remaining periodic tasks.\n *\n * @publicApi\n */\nexport function discardPeriodicTasks(): void {\n  return withFakeAsyncTestModule((m) => m.discardPeriodicTasks());\n}\n\n/**\n * Flush any pending microtasks.\n *\n * @publicApi\n */\nexport function flushMicrotasks(): void {\n  return withFakeAsyncTestModule((m) => m.flushMicrotasks());\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ɵstringify as stringify} from '../../src/core';\n\nimport {MetadataOverride} from './metadata_override';\n\ntype StringMap = {\n  [key: string]: any;\n};\n\nlet _nextReferenceId = 0;\n\nexport class MetadataOverrider {\n  private _references = new Map<any, string>();\n  /**\n   * Creates a new instance for the given metadata class\n   * based on an old instance and overrides.\n   */\n  overrideMetadata<C extends T, T>(\n    metadataClass: {new (options: T): C},\n    oldMetadata: C,\n    override: MetadataOverride<T>,\n  ): C {\n    const props: StringMap = {};\n    if (oldMetadata) {\n      _valueProps(oldMetadata).forEach((prop) => (props[prop] = (<any>oldMetadata)[prop]));\n    }\n\n    if (override.set) {\n      if (override.remove || override.add) {\n        throw new Error(`Cannot set and add/remove ${stringify(metadataClass)} at the same time!`);\n      }\n      setMetadata(props, override.set);\n    }\n    if (override.remove) {\n      removeMetadata(props, override.remove, this._references);\n    }\n    if (override.add) {\n      addMetadata(props, override.add);\n    }\n    return new metadataClass(<any>props);\n  }\n}\n\nfunction removeMetadata(metadata: StringMap, remove: any, references: Map<any, string>) {\n  const removeObjects = new Set<string>();\n  for (const prop in remove) {\n    const removeValue = remove[prop];\n    if (Array.isArray(removeValue)) {\n      removeValue.forEach((value: any) => {\n        removeObjects.add(_propHashKey(prop, value, references));\n      });\n    } else {\n      removeObjects.add(_propHashKey(prop, removeValue, references));\n    }\n  }\n\n  for (const prop in metadata) {\n    const propValue = metadata[prop];\n    if (Array.isArray(propValue)) {\n      metadata[prop] = propValue.filter(\n        (value: any) => !removeObjects.has(_propHashKey(prop, value, references)),\n      );\n    } else {\n      if (removeObjects.has(_propHashKey(prop, propValue, references))) {\n        metadata[prop] = undefined;\n      }\n    }\n  }\n}\n\nfunction addMetadata(metadata: StringMap, add: any) {\n  for (const prop in add) {\n    const addValue = add[prop];\n    const propValue = metadata[prop];\n    if (propValue != null && Array.isArray(propValue)) {\n      metadata[prop] = propValue.concat(addValue);\n    } else {\n      metadata[prop] = addValue;\n    }\n  }\n}\n\nfunction setMetadata(metadata: StringMap, set: any) {\n  for (const prop in set) {\n    metadata[prop] = set[prop];\n  }\n}\n\nfunction _propHashKey(propName: any, propValue: any, references: Map<any, string>): string {\n  let nextObjectId = 0;\n  const objectIds = new Map<object, string>();\n  const replacer = (key: any, value: any) => {\n    if (value !== null && typeof value === 'object') {\n      if (objectIds.has(value)) {\n        return objectIds.get(value);\n      }\n      // Record an id for this object such that any later references use the object's id instead\n      // of the object itself, in order to break cyclic pointers in objects.\n      objectIds.set(value, `ɵobj#${nextObjectId++}`);\n\n      // The first time an object is seen the object itself is serialized.\n      return value;\n    } else if (typeof value === 'function') {\n      value = _serializeReference(value, references);\n    }\n    return value;\n  };\n\n  return `${propName}:${JSON.stringify(propValue, replacer)}`;\n}\n\nfunction _serializeReference(ref: any, references: Map<any, string>): string {\n  let id = references.get(ref);\n  if (!id) {\n    id = `${stringify(ref)}${_nextReferenceId++}`;\n    references.set(ref, id);\n  }\n  return id;\n}\n\nfunction _valueProps(obj: any): string[] {\n  const props: string[] = [];\n  // regular public props\n  Object.keys(obj).forEach((prop) => {\n    if (!prop.startsWith('_')) {\n      props.push(prop);\n    }\n  });\n\n  // getters\n  let proto = obj;\n  while ((proto = Object.getPrototypeOf(proto))) {\n    Object.keys(proto).forEach((protoProp) => {\n      const desc = Object.getOwnPropertyDescriptor(proto, protoProp);\n      if (!protoProp.startsWith('_') && desc && 'get' in desc) {\n        props.push(protoProp);\n      }\n    });\n  }\n  return props;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  Component,\n  Directive,\n  NgModule,\n  Pipe,\n  Type,\n  ɵReflectionCapabilities as ReflectionCapabilities,\n} from '../../src/core';\n\nimport {MetadataOverride} from './metadata_override';\nimport {MetadataOverrider} from './metadata_overrider';\n\nconst reflection = new ReflectionCapabilities();\n\n/**\n * Base interface to resolve `@Component`, `@Directive`, `@Pipe` and `@NgModule`.\n */\nexport interface Resolver<T> {\n  addOverride(type: Type<any>, override: MetadataOverride<T>): void;\n  setOverrides(overrides: Array<[Type<any>, MetadataOverride<T>]>): void;\n  resolve(type: Type<any>): T | null;\n}\n\n/**\n * Allows to override ivy metadata for tests (via the `TestBed`).\n */\nabstract class OverrideResolver<T> implements Resolver<T> {\n  private overrides = new Map<Type<any>, MetadataOverride<T>[]>();\n  private resolved = new Map<Type<any>, T | null>();\n\n  abstract get type(): any;\n\n  addOverride(type: Type<any>, override: MetadataOverride<T>) {\n    const overrides = this.overrides.get(type) || [];\n    overrides.push(override);\n    this.overrides.set(type, overrides);\n    this.resolved.delete(type);\n  }\n\n  setOverrides(overrides: Array<[Type<any>, MetadataOverride<T>]>) {\n    this.overrides.clear();\n    overrides.forEach(([type, override]) => {\n      this.addOverride(type, override);\n    });\n  }\n\n  getAnnotation(type: Type<any>): T | null {\n    const annotations = reflection.annotations(type);\n    // Try to find the nearest known Type annotation and make sure that this annotation is an\n    // instance of the type we are looking for, so we can use it for resolution. Note: there might\n    // be multiple known annotations found due to the fact that Components can extend Directives (so\n    // both Directive and Component annotations would be present), so we always check if the known\n    // annotation has the right type.\n    for (let i = annotations.length - 1; i >= 0; i--) {\n      const annotation = annotations[i];\n      const isKnownType =\n        annotation instanceof Directive ||\n        annotation instanceof Component ||\n        annotation instanceof Pipe ||\n        annotation instanceof NgModule;\n      if (isKnownType) {\n        return annotation instanceof this.type ? (annotation as unknown as T) : null;\n      }\n    }\n    return null;\n  }\n\n  resolve(type: Type<any>): T | null {\n    let resolved: T | null = this.resolved.get(type) || null;\n\n    if (!resolved) {\n      resolved = this.getAnnotation(type);\n      if (resolved) {\n        const overrides = this.overrides.get(type);\n        if (overrides) {\n          const overrider = new MetadataOverrider();\n          overrides.forEach((override) => {\n            resolved = overrider.overrideMetadata(this.type, resolved!, override);\n          });\n        }\n      }\n      this.resolved.set(type, resolved);\n    }\n\n    return resolved;\n  }\n}\n\nexport class DirectiveResolver extends OverrideResolver<Directive> {\n  override get type() {\n    return Directive;\n  }\n}\n\nexport class ComponentResolver extends OverrideResolver<Component> {\n  override get type() {\n    return Component;\n  }\n}\n\nexport class PipeResolver extends OverrideResolver<Pipe> {\n  override get type() {\n    return Pipe;\n  }\n}\n\nexport class NgModuleResolver extends OverrideResolver<NgModule> {\n  override get type() {\n    return NgModule;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ResourceLoader} from '@angular/compiler';\nimport {\n  ApplicationInitStatus,\n  ɵINTERNAL_APPLICATION_ERROR_HANDLER as INTERNAL_APPLICATION_ERROR_HANDLER,\n  Compiler,\n  COMPILER_OPTIONS,\n  Component,\n  Directive,\n  Injector,\n  inject,\n  InjectorType,\n  LOCALE_ID,\n  ModuleWithComponentFactories,\n  ModuleWithProviders,\n  NgModule,\n  NgModuleFactory,\n  Pipe,\n  PlatformRef,\n  Provider,\n  resolveForwardRef,\n  StaticProvider,\n  Type,\n  ɵclearResolutionOfComponentResourcesQueue,\n  ɵcompileComponent as compileComponent,\n  ɵcompileDirective as compileDirective,\n  ɵcompileNgModuleDefs as compileNgModuleDefs,\n  ɵcompilePipe as compilePipe,\n  ɵDEFAULT_LOCALE_ID as DEFAULT_LOCALE_ID,\n  ɵDEFER_BLOCK_CONFIG as DEFER_BLOCK_CONFIG,\n  ɵdepsTracker as depsTracker,\n  ɵDirectiveDef as DirectiveDef,\n  ɵgenerateStandaloneInDeclarationsError,\n  ɵgetAsyncClassMetadataFn as getAsyncClassMetadataFn,\n  ɵgetInjectableDef as getInjectableDef,\n  ɵInternalEnvironmentProviders as InternalEnvironmentProviders,\n  ɵprovideZonelessChangeDetectionInternal as provideZonelessChangeDetectionInternal,\n  ɵisComponentDefPendingResolution,\n  ɵisEnvironmentProviders as isEnvironmentProviders,\n  ɵNG_COMP_DEF as NG_COMP_DEF,\n  ɵNG_DIR_DEF as NG_DIR_DEF,\n  ɵNG_INJ_DEF as NG_INJ_DEF,\n  ɵNG_MOD_DEF as NG_MOD_DEF,\n  ɵNG_PIPE_DEF as NG_PIPE_DEF,\n  ɵNgModuleFactory as R3NgModuleFactory,\n  ɵNgModuleTransitiveScopes as NgModuleTransitiveScopes,\n  ɵNgModuleType as NgModuleType,\n  ɵpatchComponentDefWithScope as patchComponentDefWithScope,\n  ɵRender3ComponentFactory as ComponentFactory,\n  ɵRender3NgModuleRef as NgModuleRef,\n  ɵresolveComponentResources,\n  ɵrestoreComponentResolutionQueue,\n  ɵsetLocaleId as setLocaleId,\n  ɵtransitiveScopesFor as transitiveScopesFor,\n  ɵɵInjectableDeclaration as InjectableDeclaration,\n  NgZone,\n  ErrorHandler,\n  ENVIRONMENT_INITIALIZER,\n  ɵANIMATIONS_DISABLED as ANIMATIONS_DISABLED,\n} from '../../src/core';\n\nimport {ComponentDef, ComponentType} from '../../src/render3';\n\nimport {MetadataOverride} from './metadata_override';\nimport {\n  ComponentResolver,\n  DirectiveResolver,\n  NgModuleResolver,\n  PipeResolver,\n  Resolver,\n} from './resolvers';\nimport {\n  ANIMATIONS_ENABLED_DEFAULT,\n  DEFER_BLOCK_DEFAULT_BEHAVIOR,\n  TestModuleMetadata,\n} from './test_bed_common';\nimport {\n  RETHROW_APPLICATION_ERRORS_DEFAULT,\n  TestBedApplicationErrorHandler,\n} from './application_error_handler';\n\nenum TestingModuleOverride {\n  DECLARATION,\n  OVERRIDE_TEMPLATE,\n}\n\nfunction isTestingModuleOverride(value: unknown): value is TestingModuleOverride {\n  return (\n    value === TestingModuleOverride.DECLARATION || value === TestingModuleOverride.OVERRIDE_TEMPLATE\n  );\n}\n\nfunction assertNoStandaloneComponents(\n  types: Type<any>[],\n  resolver: Resolver<any>,\n  location: string,\n) {\n  types.forEach((type) => {\n    if (!getAsyncClassMetadataFn(type)) {\n      const component = resolver.resolve(type);\n      if (component && (component.standalone == null || component.standalone)) {\n        throw new Error(ɵgenerateStandaloneInDeclarationsError(type, location));\n      }\n    }\n  });\n}\n\n// Resolvers for Angular decorators\ntype Resolvers = {\n  module: Resolver<NgModule>;\n  component: Resolver<Directive>;\n  directive: Resolver<Component>;\n  pipe: Resolver<Pipe>;\n};\n\ninterface CleanupOperation {\n  fieldName: string;\n  object: any;\n  originalValue: unknown;\n}\n\nexport class TestBedCompiler {\n  private originalComponentResolutionQueue: Map<Type<any>, Component> | null = null;\n\n  // Testing module configuration\n  private declarations: Type<any>[] = [];\n  private imports: Type<any>[] = [];\n  private providers: Provider[] = [];\n  private schemas: any[] = [];\n\n  // Queues of components/directives/pipes that should be recompiled.\n  private pendingComponents = new Set<Type<any>>();\n  private pendingDirectives = new Set<Type<any>>();\n  private pendingPipes = new Set<Type<any>>();\n\n  // Set of components with async metadata, i.e. components with `@defer` blocks\n  // in their templates.\n  private componentsWithAsyncMetadata = new Set<Type<unknown>>();\n\n  // Keep track of all components and directives, so we can patch Providers onto defs later.\n  private seenComponents = new Set<Type<any>>();\n  private seenDirectives = new Set<Type<any>>();\n\n  // Keep track of overridden modules, so that we can collect all affected ones in the module tree.\n  private overriddenModules = new Set<NgModuleType<any>>();\n\n  // Store resolved styles for Components that have template overrides present and `styleUrls`\n  // defined at the same time.\n  private existingComponentStyles = new Map<Type<any>, string[]>();\n\n  private resolvers: Resolvers = initResolvers();\n\n  // Map of component type to an NgModule that declares it.\n  //\n  // There are a couple special cases:\n  // - for standalone components, the module scope value is `null`\n  // - when a component is declared in `TestBed.configureTestingModule()` call or\n  //   a component's template is overridden via `TestBed.overrideTemplateUsingTestingModule()`.\n  //   we use a special value from the `TestingModuleOverride` enum.\n  private componentToModuleScope = new Map<Type<any>, Type<any> | TestingModuleOverride | null>();\n\n  // Map that keeps initial version of component/directive/pipe defs in case\n  // we compile a Type again, thus overriding respective static fields. This is\n  // required to make sure we restore defs to their initial states between test runs.\n  // Note: one class may have multiple defs (for example: ɵmod and ɵinj in case of an\n  // NgModule), store all of them in a map.\n  private initialNgDefs = new Map<Type<any>, Map<string, PropertyDescriptor | undefined>>();\n\n  // Array that keeps cleanup operations for initial versions of component/directive/pipe/module\n  // defs in case TestBed makes changes to the originals.\n  private defCleanupOps: CleanupOperation[] = [];\n\n  private _injector: Injector | null = null;\n  private compilerProviders: Provider[] | null = null;\n\n  private providerOverrides: Provider[] = [];\n  private rootProviderOverrides: Provider[] = [];\n  // Overrides for injectables with `{providedIn: SomeModule}` need to be tracked and added to that\n  // module's provider list.\n  private providerOverridesByModule = new Map<InjectorType<any>, Provider[]>();\n  private providerOverridesByToken = new Map<any, Provider>();\n  private scopesWithOverriddenProviders = new Set<Type<any>>();\n\n  private testModuleType: NgModuleType<any>;\n  private testModuleRef: NgModuleRef<any> | null = null;\n\n  private animationsEnabled = ANIMATIONS_ENABLED_DEFAULT;\n  private deferBlockBehavior = DEFER_BLOCK_DEFAULT_BEHAVIOR;\n  private rethrowApplicationTickErrors = RETHROW_APPLICATION_ERRORS_DEFAULT;\n\n  constructor(\n    private platform: PlatformRef,\n    private additionalModuleTypes: Type<any> | Type<any>[],\n  ) {\n    class DynamicTestModule {}\n    this.testModuleType = DynamicTestModule as any;\n  }\n\n  setCompilerProviders(providers: Provider[] | null): void {\n    this.compilerProviders = providers;\n    this._injector = null;\n  }\n\n  configureTestingModule(moduleDef: TestModuleMetadata): void {\n    // Enqueue any compilation tasks for the directly declared component.\n    if (moduleDef.declarations !== undefined) {\n      // Verify that there are no standalone components\n      assertNoStandaloneComponents(\n        moduleDef.declarations,\n        this.resolvers.component,\n        '\"TestBed.configureTestingModule\" call',\n      );\n      this.queueTypeArray(moduleDef.declarations, TestingModuleOverride.DECLARATION);\n      this.declarations.push(...moduleDef.declarations);\n    }\n\n    // Enqueue any compilation tasks for imported modules.\n    if (moduleDef.imports !== undefined) {\n      this.queueTypesFromModulesArray(moduleDef.imports);\n      this.imports.push(...moduleDef.imports);\n    }\n\n    if (moduleDef.providers !== undefined) {\n      this.providers.push(...moduleDef.providers);\n    }\n\n    if (moduleDef.schemas !== undefined) {\n      this.schemas.push(...moduleDef.schemas);\n    }\n\n    this.deferBlockBehavior = moduleDef.deferBlockBehavior ?? DEFER_BLOCK_DEFAULT_BEHAVIOR;\n    this.animationsEnabled = moduleDef.animationsEnabled ?? ANIMATIONS_ENABLED_DEFAULT;\n    this.rethrowApplicationTickErrors =\n      moduleDef.rethrowApplicationErrors ?? RETHROW_APPLICATION_ERRORS_DEFAULT;\n  }\n\n  overrideModule(ngModule: Type<any>, override: MetadataOverride<NgModule>): void {\n    depsTracker.clearScopeCacheFor(ngModule);\n    this.overriddenModules.add(ngModule as NgModuleType<any>);\n\n    // Compile the module right away.\n    this.resolvers.module.addOverride(ngModule, override);\n    const metadata = this.resolvers.module.resolve(ngModule);\n    if (metadata === null) {\n      throw invalidTypeError(ngModule.name, 'NgModule');\n    }\n\n    this.recompileNgModule(ngModule, metadata);\n\n    // At this point, the module has a valid module def (ɵmod), but the override may have introduced\n    // new declarations or imported modules. Ingest any possible new types and add them to the\n    // current queue.\n    this.queueTypesFromModulesArray([ngModule]);\n  }\n\n  overrideComponent(component: Type<any>, override: MetadataOverride<Component>): void {\n    this.verifyNoStandaloneFlagOverrides(component, override);\n    this.resolvers.component.addOverride(component, override);\n    this.pendingComponents.add(component);\n\n    // If this is a component with async metadata (i.e. a component with a `@defer` block\n    // in a template) - store it for future processing.\n    this.maybeRegisterComponentWithAsyncMetadata(component);\n  }\n\n  overrideDirective(directive: Type<any>, override: MetadataOverride<Directive>): void {\n    this.verifyNoStandaloneFlagOverrides(directive, override);\n    this.resolvers.directive.addOverride(directive, override);\n    this.pendingDirectives.add(directive);\n  }\n\n  overridePipe(pipe: Type<any>, override: MetadataOverride<Pipe>): void {\n    this.verifyNoStandaloneFlagOverrides(pipe, override);\n    this.resolvers.pipe.addOverride(pipe, override);\n    this.pendingPipes.add(pipe);\n  }\n\n  private verifyNoStandaloneFlagOverrides(\n    type: Type<any>,\n    override: MetadataOverride<Component | Directive | Pipe>,\n  ) {\n    if (\n      override.add?.hasOwnProperty('standalone') ||\n      override.set?.hasOwnProperty('standalone') ||\n      override.remove?.hasOwnProperty('standalone')\n    ) {\n      throw new Error(\n        `An override for the ${type.name} class has the \\`standalone\\` flag. ` +\n          `Changing the \\`standalone\\` flag via TestBed overrides is not supported.`,\n      );\n    }\n  }\n\n  overrideProvider(\n    token: any,\n    provider: {useFactory?: Function; useValue?: any; deps?: any[]; multi?: boolean},\n  ): void {\n    let providerDef: Provider;\n    if (provider.useFactory !== undefined) {\n      providerDef = {\n        provide: token,\n        useFactory: provider.useFactory,\n        deps: provider.deps || [],\n        multi: provider.multi,\n      };\n    } else if (provider.useValue !== undefined) {\n      providerDef = {provide: token, useValue: provider.useValue, multi: provider.multi};\n    } else {\n      providerDef = {provide: token};\n    }\n\n    const injectableDef: InjectableDeclaration<any> | null =\n      typeof token !== 'string' ? getInjectableDef(token) : null;\n    const providedIn = injectableDef === null ? null : resolveForwardRef(injectableDef.providedIn);\n    const overridesBucket =\n      providedIn === 'root' ? this.rootProviderOverrides : this.providerOverrides;\n    overridesBucket.push(providerDef);\n\n    // Keep overrides grouped by token as well for fast lookups using token\n    this.providerOverridesByToken.set(token, providerDef);\n    if (injectableDef !== null && providedIn !== null && typeof providedIn !== 'string') {\n      const existingOverrides = this.providerOverridesByModule.get(providedIn);\n      if (existingOverrides !== undefined) {\n        existingOverrides.push(providerDef);\n      } else {\n        this.providerOverridesByModule.set(providedIn, [providerDef]);\n      }\n    }\n  }\n\n  overrideTemplateUsingTestingModule(type: Type<any>, template: string): void {\n    const def = (type as any)[NG_COMP_DEF];\n    const hasStyleUrls = (): boolean => {\n      const metadata = this.resolvers.component.resolve(type)! as Component;\n      return !!metadata.styleUrl || !!metadata.styleUrls?.length;\n    };\n    const overrideStyleUrls = !!def && !ɵisComponentDefPendingResolution(type) && hasStyleUrls();\n\n    // In Ivy, compiling a component does not require knowing the module providing the\n    // component's scope, so overrideTemplateUsingTestingModule can be implemented purely via\n    // overrideComponent. Important: overriding template requires full Component re-compilation,\n    // which may fail in case styleUrls are also present (thus Component is considered as required\n    // resolution). In order to avoid this, we preemptively set styleUrls to an empty array,\n    // preserve current styles available on Component def and restore styles back once compilation\n    // is complete.\n    const override = overrideStyleUrls\n      ? {template, styles: [], styleUrls: [], styleUrl: undefined}\n      : {template};\n    this.overrideComponent(type, {set: override});\n\n    if (overrideStyleUrls && def.styles && def.styles.length > 0) {\n      this.existingComponentStyles.set(type, def.styles);\n    }\n\n    // Set the component's scope to be the testing module.\n    this.componentToModuleScope.set(type, TestingModuleOverride.OVERRIDE_TEMPLATE);\n  }\n\n  private async resolvePendingComponentsWithAsyncMetadata() {\n    if (this.componentsWithAsyncMetadata.size === 0) return;\n\n    const promises = [];\n    for (const component of this.componentsWithAsyncMetadata) {\n      const asyncMetadataFn = getAsyncClassMetadataFn(component);\n      if (asyncMetadataFn) {\n        promises.push(asyncMetadataFn());\n      }\n    }\n    this.componentsWithAsyncMetadata.clear();\n\n    const resolvedDeps = await Promise.all(promises);\n    const flatResolvedDeps = resolvedDeps.flat(2);\n    this.queueTypesFromModulesArray(flatResolvedDeps);\n\n    // Loaded standalone components might contain imports of NgModules\n    // with providers, make sure we override providers there too.\n    for (const component of flatResolvedDeps) {\n      this.applyProviderOverridesInScope(component);\n    }\n  }\n\n  async compileComponents(): Promise<void> {\n    this.clearComponentResolutionQueue();\n\n    // Wait for all async metadata for components that were\n    // overridden, we need resolved metadata to perform an override\n    // and re-compile a component.\n    await this.resolvePendingComponentsWithAsyncMetadata();\n\n    // Verify that there were no standalone components present in the `declarations` field\n    // during the `TestBed.configureTestingModule` call. We perform this check here in addition\n    // to the logic in the `configureTestingModule` function, since at this point we have\n    // all async metadata resolved.\n    assertNoStandaloneComponents(\n      this.declarations,\n      this.resolvers.component,\n      '\"TestBed.configureTestingModule\" call',\n    );\n\n    // Run compilers for all queued types.\n    let needsAsyncResources = this.compileTypesSync();\n\n    // compileComponents() should not be async unless it needs to be.\n    if (needsAsyncResources) {\n      let resourceLoader: ResourceLoader;\n      let resolver = (url: string): Promise<string> => {\n        if (!resourceLoader) {\n          resourceLoader = this.injector.get(ResourceLoader);\n        }\n        return Promise.resolve(resourceLoader.get(url));\n      };\n      await ɵresolveComponentResources(resolver);\n    }\n  }\n\n  finalize(): NgModuleRef<any> {\n    // One last compile\n    this.compileTypesSync();\n\n    // Create the testing module itself.\n    this.compileTestModule();\n\n    this.applyTransitiveScopes();\n\n    this.applyProviderOverrides();\n\n    // Patch previously stored `styles` Component values (taken from ɵcmp), in case these\n    // Components have `styleUrls` fields defined and template override was requested.\n    this.patchComponentsWithExistingStyles();\n\n    // Clear the componentToModuleScope map, so that future compilations don't reset the scope of\n    // every component.\n    this.componentToModuleScope.clear();\n\n    const parentInjector = this.platform.injector;\n    this.testModuleRef = new NgModuleRef(this.testModuleType, parentInjector, []);\n\n    // ApplicationInitStatus.runInitializers() is marked @internal to core.\n    // Cast it to any before accessing it.\n    (this.testModuleRef.injector.get(ApplicationInitStatus) as any).runInitializers();\n\n    // Set locale ID after running app initializers, since locale information might be updated while\n    // running initializers. This is also consistent with the execution order while bootstrapping an\n    // app (see `packages/core/src/application_ref.ts` file).\n    const localeId = this.testModuleRef.injector.get(LOCALE_ID, DEFAULT_LOCALE_ID);\n    setLocaleId(localeId);\n\n    return this.testModuleRef;\n  }\n\n  /**\n   * @internal\n   */\n  _compileNgModuleSync(moduleType: Type<any>): void {\n    this.queueTypesFromModulesArray([moduleType]);\n    this.compileTypesSync();\n    this.applyProviderOverrides();\n    this.applyProviderOverridesInScope(moduleType);\n    this.applyTransitiveScopes();\n  }\n\n  /**\n   * @internal\n   */\n  async _compileNgModuleAsync(moduleType: Type<any>): Promise<void> {\n    this.queueTypesFromModulesArray([moduleType]);\n    await this.compileComponents();\n    this.applyProviderOverrides();\n    this.applyProviderOverridesInScope(moduleType);\n    this.applyTransitiveScopes();\n  }\n\n  /**\n   * @internal\n   */\n  _getModuleResolver(): Resolver<NgModule> {\n    return this.resolvers.module;\n  }\n\n  /**\n   * @internal\n   */\n  _getComponentFactories(moduleType: NgModuleType): ComponentFactory<any>[] {\n    return maybeUnwrapFn(moduleType.ɵmod.declarations).reduce((factories, declaration) => {\n      const componentDef = (declaration as any).ɵcmp;\n      componentDef && factories.push(new ComponentFactory(componentDef, this.testModuleRef!));\n      return factories;\n    }, [] as ComponentFactory<any>[]);\n  }\n\n  private compileTypesSync(): boolean {\n    // Compile all queued components, directives, pipes.\n    let needsAsyncResources = false;\n    this.pendingComponents.forEach((declaration) => {\n      if (getAsyncClassMetadataFn(declaration)) {\n        throw new Error(\n          `Component '${declaration.name}' has unresolved metadata. ` +\n            `Please call \\`await TestBed.compileComponents()\\` before running this test.`,\n        );\n      }\n\n      needsAsyncResources = needsAsyncResources || ɵisComponentDefPendingResolution(declaration);\n\n      const metadata = this.resolvers.component.resolve(declaration);\n      if (metadata === null) {\n        throw invalidTypeError(declaration.name, 'Component');\n      }\n\n      this.maybeStoreNgDef(NG_COMP_DEF, declaration);\n      depsTracker.clearScopeCacheFor(declaration);\n      compileComponent(declaration, metadata);\n    });\n    this.pendingComponents.clear();\n\n    this.pendingDirectives.forEach((declaration) => {\n      const metadata = this.resolvers.directive.resolve(declaration);\n      if (metadata === null) {\n        throw invalidTypeError(declaration.name, 'Directive');\n      }\n      this.maybeStoreNgDef(NG_DIR_DEF, declaration);\n      compileDirective(declaration, metadata);\n    });\n    this.pendingDirectives.clear();\n\n    this.pendingPipes.forEach((declaration) => {\n      const metadata = this.resolvers.pipe.resolve(declaration);\n      if (metadata === null) {\n        throw invalidTypeError(declaration.name, 'Pipe');\n      }\n      this.maybeStoreNgDef(NG_PIPE_DEF, declaration);\n      compilePipe(declaration, metadata);\n    });\n    this.pendingPipes.clear();\n\n    return needsAsyncResources;\n  }\n\n  private applyTransitiveScopes(): void {\n    if (this.overriddenModules.size > 0) {\n      // Module overrides (via `TestBed.overrideModule`) might affect scopes that were previously\n      // calculated and stored in `transitiveCompileScopes`. If module overrides are present,\n      // collect all affected modules and reset scopes to force their re-calculation.\n      const testingModuleDef = (this.testModuleType as any)[NG_MOD_DEF];\n      const affectedModules = this.collectModulesAffectedByOverrides(testingModuleDef.imports);\n      if (affectedModules.size > 0) {\n        affectedModules.forEach((moduleType) => {\n          depsTracker.clearScopeCacheFor(moduleType);\n        });\n      }\n    }\n\n    const moduleToScope = new Map<Type<any> | TestingModuleOverride, NgModuleTransitiveScopes>();\n    const getScopeOfModule = (\n      moduleType: Type<any> | TestingModuleOverride,\n    ): NgModuleTransitiveScopes => {\n      if (!moduleToScope.has(moduleType)) {\n        const isTestingModule = isTestingModuleOverride(moduleType);\n        const realType = isTestingModule ? this.testModuleType : (moduleType as Type<any>);\n        moduleToScope.set(moduleType, transitiveScopesFor(realType));\n      }\n      return moduleToScope.get(moduleType)!;\n    };\n\n    this.componentToModuleScope.forEach((moduleType, componentType) => {\n      if (moduleType !== null) {\n        const moduleScope = getScopeOfModule(moduleType);\n        this.storeFieldOfDefOnType(componentType, NG_COMP_DEF, 'directiveDefs');\n        this.storeFieldOfDefOnType(componentType, NG_COMP_DEF, 'pipeDefs');\n        patchComponentDefWithScope(getComponentDef(componentType)!, moduleScope);\n      }\n      // `tView` that is stored on component def contains information about directives and pipes\n      // that are in the scope of this component. Patching component scope will cause `tView` to be\n      // changed. Store original `tView` before patching scope, so the `tView` (including scope\n      // information) is restored back to its previous/original state before running next test.\n      // Resetting `tView` is also needed for cases when we apply provider overrides and those\n      // providers are defined on component's level, in which case they may end up included into\n      // `tView.blueprint`.\n      this.storeFieldOfDefOnType(componentType, NG_COMP_DEF, 'tView');\n    });\n\n    this.componentToModuleScope.clear();\n  }\n\n  private applyProviderOverrides(): void {\n    const maybeApplyOverrides = (field: string) => (type: Type<any>) => {\n      const resolver = field === NG_COMP_DEF ? this.resolvers.component : this.resolvers.directive;\n      const metadata = resolver.resolve(type)!;\n      if (this.hasProviderOverrides(metadata.providers)) {\n        this.patchDefWithProviderOverrides(type, field);\n      }\n    };\n    this.seenComponents.forEach(maybeApplyOverrides(NG_COMP_DEF));\n    this.seenDirectives.forEach(maybeApplyOverrides(NG_DIR_DEF));\n\n    this.seenComponents.clear();\n    this.seenDirectives.clear();\n  }\n\n  /**\n   * Applies provider overrides to a given type (either an NgModule or a standalone component)\n   * and all imported NgModules and standalone components recursively.\n   */\n  private applyProviderOverridesInScope(type: Type<any>): void {\n    const hasScope = isStandaloneComponent(type) || isNgModule(type);\n\n    // The function can be re-entered recursively while inspecting dependencies\n    // of an NgModule or a standalone component. Exit early if we come across a\n    // type that can not have a scope (directive or pipe) or the type is already\n    // processed earlier.\n    if (!hasScope || this.scopesWithOverriddenProviders.has(type)) {\n      return;\n    }\n    this.scopesWithOverriddenProviders.add(type);\n\n    // NOTE: the line below triggers JIT compilation of the module injector,\n    // which also invokes verification of the NgModule semantics, which produces\n    // detailed error messages. The fact that the code relies on this line being\n    // present here is suspicious and should be refactored in a way that the line\n    // below can be moved (for ex. after an early exit check below).\n    const injectorDef: any = (type as any)[NG_INJ_DEF];\n\n    // No provider overrides, exit early.\n    if (this.providerOverridesByToken.size === 0) return;\n\n    if (isStandaloneComponent(type)) {\n      // Visit all component dependencies and override providers there.\n      const def = getComponentDef(type);\n      const dependencies = maybeUnwrapFn(def.dependencies ?? []);\n      for (const dependency of dependencies) {\n        this.applyProviderOverridesInScope(dependency);\n      }\n    } else {\n      const providers: Array<Provider | InternalEnvironmentProviders> = [\n        ...injectorDef.providers,\n        ...(this.providerOverridesByModule.get(type as InjectorType<any>) || []),\n      ];\n      if (this.hasProviderOverrides(providers)) {\n        this.maybeStoreNgDef(NG_INJ_DEF, type);\n\n        this.storeFieldOfDefOnType(type, NG_INJ_DEF, 'providers');\n        injectorDef.providers = this.getOverriddenProviders(providers);\n      }\n\n      // Apply provider overrides to imported modules recursively\n      const moduleDef = (type as any)[NG_MOD_DEF];\n      const imports = maybeUnwrapFn(moduleDef.imports);\n      for (const importedModule of imports) {\n        this.applyProviderOverridesInScope(importedModule);\n      }\n      // Also override the providers on any ModuleWithProviders imports since those don't appear in\n      // the moduleDef.\n      for (const importedModule of flatten(injectorDef.imports)) {\n        if (isModuleWithProviders(importedModule)) {\n          this.defCleanupOps.push({\n            object: importedModule,\n            fieldName: 'providers',\n            originalValue: importedModule.providers,\n          });\n          importedModule.providers = this.getOverriddenProviders(\n            importedModule.providers as Array<Provider | InternalEnvironmentProviders>,\n          );\n        }\n      }\n    }\n  }\n\n  private patchComponentsWithExistingStyles(): void {\n    this.existingComponentStyles.forEach(\n      (styles, type) => ((type as any)[NG_COMP_DEF].styles = styles),\n    );\n    this.existingComponentStyles.clear();\n  }\n\n  private queueTypeArray(arr: any[], moduleType: Type<any> | TestingModuleOverride): void {\n    for (const value of arr) {\n      if (Array.isArray(value)) {\n        this.queueTypeArray(value, moduleType);\n      } else {\n        this.queueType(value, moduleType);\n      }\n    }\n  }\n\n  private recompileNgModule(ngModule: Type<any>, metadata: NgModule): void {\n    // Cache the initial ngModuleDef as it will be overwritten.\n    this.maybeStoreNgDef(NG_MOD_DEF, ngModule);\n    this.maybeStoreNgDef(NG_INJ_DEF, ngModule);\n\n    compileNgModuleDefs(ngModule as NgModuleType<any>, metadata);\n  }\n\n  private maybeRegisterComponentWithAsyncMetadata(type: Type<unknown>) {\n    const asyncMetadataFn = getAsyncClassMetadataFn(type);\n    if (asyncMetadataFn) {\n      this.componentsWithAsyncMetadata.add(type);\n    }\n  }\n\n  private queueType(type: Type<any>, moduleType: Type<any> | TestingModuleOverride | null): void {\n    // If this is a component with async metadata (i.e. a component with a `@defer` block\n    // in a template) - store it for future processing.\n    this.maybeRegisterComponentWithAsyncMetadata(type);\n\n    const component = this.resolvers.component.resolve(type);\n    if (component) {\n      // Check whether a give Type has respective NG def (ɵcmp) and compile if def is\n      // missing. That might happen in case a class without any Angular decorators extends another\n      // class where Component/Directive/Pipe decorator is defined.\n      if (ɵisComponentDefPendingResolution(type) || !type.hasOwnProperty(NG_COMP_DEF)) {\n        this.pendingComponents.add(type);\n      }\n      this.seenComponents.add(type);\n\n      // Keep track of the module which declares this component, so later the component's scope\n      // can be set correctly. If the component has already been recorded here, then one of several\n      // cases is true:\n      // * the module containing the component was imported multiple times (common).\n      // * the component is declared in multiple modules (which is an error).\n      // * the component was in 'declarations' of the testing module, and also in an imported module\n      //   in which case the module scope will be TestingModuleOverride.DECLARATION.\n      // * overrideTemplateUsingTestingModule was called for the component in which case the module\n      //   scope will be TestingModuleOverride.OVERRIDE_TEMPLATE.\n      //\n      // If the component was previously in the testing module's 'declarations' (meaning the\n      // current value is TestingModuleOverride.DECLARATION), then `moduleType` is the component's\n      // real module, which was imported. This pattern is understood to mean that the component\n      // should use its original scope, but that the testing module should also contain the\n      // component in its scope.\n      if (\n        !this.componentToModuleScope.has(type) ||\n        this.componentToModuleScope.get(type) === TestingModuleOverride.DECLARATION\n      ) {\n        this.componentToModuleScope.set(type, moduleType);\n      }\n      return;\n    }\n\n    const directive = this.resolvers.directive.resolve(type);\n    if (directive) {\n      if (!type.hasOwnProperty(NG_DIR_DEF)) {\n        this.pendingDirectives.add(type);\n      }\n      this.seenDirectives.add(type);\n      return;\n    }\n\n    const pipe = this.resolvers.pipe.resolve(type);\n    if (pipe && !type.hasOwnProperty(NG_PIPE_DEF)) {\n      this.pendingPipes.add(type);\n      return;\n    }\n  }\n\n  private queueTypesFromModulesArray(arr: any[]): void {\n    // Because we may encounter the same NgModule or a standalone Component while processing\n    // the dependencies of an NgModule or a standalone Component, we cache them in this set so we\n    // can skip ones that have already been seen encountered. In some test setups, this caching\n    // resulted in 10X runtime improvement.\n    const processedDefs = new Set();\n    const queueTypesFromModulesArrayRecur = (arr: any[]): void => {\n      for (const value of arr) {\n        if (Array.isArray(value)) {\n          queueTypesFromModulesArrayRecur(value);\n        } else if (hasNgModuleDef(value)) {\n          const def = value.ɵmod;\n          if (processedDefs.has(def)) {\n            continue;\n          }\n          processedDefs.add(def);\n          // Look through declarations, imports, and exports, and queue\n          // everything found there.\n          this.queueTypeArray(maybeUnwrapFn(def.declarations), value);\n          queueTypesFromModulesArrayRecur(maybeUnwrapFn(def.imports));\n          queueTypesFromModulesArrayRecur(maybeUnwrapFn(def.exports));\n        } else if (isModuleWithProviders(value)) {\n          queueTypesFromModulesArrayRecur([value.ngModule]);\n        } else if (isStandaloneComponent(value)) {\n          this.queueType(value, null);\n          const def = getComponentDef(value);\n\n          if (processedDefs.has(def)) {\n            continue;\n          }\n          processedDefs.add(def);\n\n          const dependencies = maybeUnwrapFn(def.dependencies ?? []);\n          dependencies.forEach((dependency) => {\n            // Note: in AOT, the `dependencies` might also contain regular\n            // (NgModule-based) Component, Directive and Pipes, so we handle\n            // them separately and proceed with recursive process for standalone\n            // Components and NgModules only.\n            if (isStandaloneComponent(dependency) || hasNgModuleDef(dependency)) {\n              queueTypesFromModulesArrayRecur([dependency]);\n            } else {\n              this.queueType(dependency, null);\n            }\n          });\n        }\n      }\n    };\n    queueTypesFromModulesArrayRecur(arr);\n  }\n\n  // When module overrides (via `TestBed.overrideModule`) are present, it might affect all modules\n  // that import (even transitively) an overridden one. For all affected modules we need to\n  // recalculate their scopes for a given test run and restore original scopes at the end. The goal\n  // of this function is to collect all affected modules in a set for further processing. Example:\n  // if we have the following module hierarchy: A -> B -> C (where `->` means `imports`) and module\n  // `C` is overridden, we consider `A` and `B` as affected, since their scopes might become\n  // invalidated with the override.\n  private collectModulesAffectedByOverrides(arr: any[]): Set<NgModuleType<any>> {\n    const seenModules = new Set<NgModuleType<any>>();\n    const affectedModules = new Set<NgModuleType<any>>();\n    const calcAffectedModulesRecur = (arr: any[], path: NgModuleType<any>[]): void => {\n      for (const value of arr) {\n        if (Array.isArray(value)) {\n          // If the value is an array, just flatten it (by invoking this function recursively),\n          // keeping \"path\" the same.\n          calcAffectedModulesRecur(value, path);\n        } else if (hasNgModuleDef(value)) {\n          if (seenModules.has(value)) {\n            // If we've seen this module before and it's included into \"affected modules\" list, mark\n            // the whole path that leads to that module as affected, but do not descend into its\n            // imports, since we already examined them before.\n            if (affectedModules.has(value)) {\n              path.forEach((item) => affectedModules.add(item));\n            }\n            continue;\n          }\n          seenModules.add(value);\n          if (this.overriddenModules.has(value)) {\n            path.forEach((item) => affectedModules.add(item));\n          }\n          // Examine module imports recursively to look for overridden modules.\n          const moduleDef = (value as any)[NG_MOD_DEF];\n          calcAffectedModulesRecur(maybeUnwrapFn(moduleDef.imports), path.concat(value));\n        }\n      }\n    };\n    calcAffectedModulesRecur(arr, []);\n    return affectedModules;\n  }\n\n  /**\n   * Preserve an original def (such as ɵmod, ɵinj, etc) before applying an override.\n   * Note: one class may have multiple defs (for example: ɵmod and ɵinj in case of\n   * an NgModule). If there is a def in a set already, don't override it, since\n   * an original one should be restored at the end of a test.\n   */\n  private maybeStoreNgDef(prop: string, type: Type<any>) {\n    if (!this.initialNgDefs.has(type)) {\n      this.initialNgDefs.set(type, new Map());\n    }\n    const currentDefs = this.initialNgDefs.get(type)!;\n    if (!currentDefs.has(prop)) {\n      const currentDef = Object.getOwnPropertyDescriptor(type, prop);\n      currentDefs.set(prop, currentDef);\n    }\n  }\n\n  private storeFieldOfDefOnType(type: Type<any>, defField: string, fieldName: string): void {\n    const def: any = (type as any)[defField];\n    const originalValue: any = def[fieldName];\n    this.defCleanupOps.push({object: def, fieldName, originalValue});\n  }\n\n  /**\n   * Clears current components resolution queue, but stores the state of the queue, so we can\n   * restore it later. Clearing the queue is required before we try to compile components (via\n   * `TestBed.compileComponents`), so that component defs are in sync with the resolution queue.\n   */\n  private clearComponentResolutionQueue() {\n    if (this.originalComponentResolutionQueue === null) {\n      this.originalComponentResolutionQueue = new Map();\n    }\n    ɵclearResolutionOfComponentResourcesQueue().forEach((value, key) =>\n      this.originalComponentResolutionQueue!.set(key, value),\n    );\n  }\n\n  /*\n   * Restores component resolution queue to the previously saved state. This operation is performed\n   * as a part of restoring the state after completion of the current set of tests (that might\n   * potentially mutate the state).\n   */\n  private restoreComponentResolutionQueue() {\n    if (this.originalComponentResolutionQueue !== null) {\n      ɵrestoreComponentResolutionQueue(this.originalComponentResolutionQueue);\n      this.originalComponentResolutionQueue = null;\n    }\n  }\n\n  restoreOriginalState(): void {\n    // Process cleanup ops in reverse order so the field's original value is restored correctly (in\n    // case there were multiple overrides for the same field).\n    forEachRight(this.defCleanupOps, (op: CleanupOperation) => {\n      op.object[op.fieldName] = op.originalValue;\n    });\n    // Restore initial component/directive/pipe defs\n    this.initialNgDefs.forEach(\n      (defs: Map<string, PropertyDescriptor | undefined>, type: Type<any>) => {\n        depsTracker.clearScopeCacheFor(type);\n        defs.forEach((descriptor, prop) => {\n          if (!descriptor) {\n            // Delete operations are generally undesirable since they have performance\n            // implications on objects they were applied to. In this particular case, situations\n            // where this code is invoked should be quite rare to cause any noticeable impact,\n            // since it's applied only to some test cases (for example when class with no\n            // annotations extends some @Component) when we need to clear 'ɵcmp' field on a given\n            // class to restore its original state (before applying overrides and running tests).\n            delete (type as any)[prop];\n          } else {\n            Object.defineProperty(type, prop, descriptor);\n          }\n        });\n      },\n    );\n    this.initialNgDefs.clear();\n    this.scopesWithOverriddenProviders.clear();\n    this.restoreComponentResolutionQueue();\n    // Restore the locale ID to the default value, this shouldn't be necessary but we never know\n    setLocaleId(DEFAULT_LOCALE_ID);\n  }\n\n  private compileTestModule(): void {\n    class RootScopeModule {}\n    compileNgModuleDefs(RootScopeModule as NgModuleType<any>, {\n      providers: [\n        ...this.rootProviderOverrides,\n        provideZonelessChangeDetectionInternal(),\n        TestBedApplicationErrorHandler,\n        {\n          provide: ENVIRONMENT_INITIALIZER,\n          multi: true,\n          useValue: () => {\n            inject(ErrorHandler);\n          },\n        },\n      ],\n    });\n\n    const providers = [\n      {provide: Compiler, useFactory: () => new R3TestCompiler(this)},\n      {provide: DEFER_BLOCK_CONFIG, useValue: {behavior: this.deferBlockBehavior}},\n      {\n        provide: ANIMATIONS_DISABLED,\n        useValue: !this.animationsEnabled,\n      },\n      {\n        provide: INTERNAL_APPLICATION_ERROR_HANDLER,\n        useFactory: () => {\n          if (this.rethrowApplicationTickErrors) {\n            const handler = inject(TestBedApplicationErrorHandler);\n            return (e: unknown) => {\n              handler.handleError(e);\n            };\n          } else {\n            const userErrorHandler = inject(ErrorHandler);\n            const ngZone = inject(NgZone);\n            return (e: unknown) => ngZone.runOutsideAngular(() => userErrorHandler.handleError(e));\n          }\n        },\n      },\n      ...this.providers,\n      ...this.providerOverrides,\n    ];\n    const imports = [RootScopeModule, this.additionalModuleTypes, this.imports || []];\n\n    compileNgModuleDefs(\n      this.testModuleType,\n      {\n        declarations: this.declarations,\n        imports,\n        schemas: this.schemas,\n        providers,\n      },\n      /* allowDuplicateDeclarationsInRoot */ true,\n    );\n\n    this.applyProviderOverridesInScope(this.testModuleType);\n  }\n\n  get injector(): Injector {\n    if (this._injector !== null) {\n      return this._injector;\n    }\n\n    const providers: StaticProvider[] = [];\n    const compilerOptions = this.platform.injector.get(COMPILER_OPTIONS, []);\n    compilerOptions.forEach((opts) => {\n      if (opts.providers) {\n        providers.push(opts.providers);\n      }\n    });\n    if (this.compilerProviders !== null) {\n      providers.push(...(this.compilerProviders as StaticProvider[]));\n    }\n\n    this._injector = Injector.create({providers, parent: this.platform.injector});\n    return this._injector;\n  }\n\n  // get overrides for a specific provider (if any)\n  private getSingleProviderOverrides(provider: Provider): Provider | null {\n    const token = getProviderToken(provider);\n    return this.providerOverridesByToken.get(token) || null;\n  }\n\n  private getProviderOverrides(\n    providers?: Array<Provider | InternalEnvironmentProviders>,\n  ): Provider[] {\n    if (!providers || !providers.length || this.providerOverridesByToken.size === 0) return [];\n    // There are two flattening operations here. The inner flattenProviders() operates on the\n    // metadata's providers and applies a mapping function which retrieves overrides for each\n    // incoming provider. The outer flatten() then flattens the produced overrides array. If this is\n    // not done, the array can contain other empty arrays (e.g. `[[], []]`) which leak into the\n    // providers array and contaminate any error messages that might be generated.\n    return flatten(\n      flattenProviders(\n        providers,\n        (provider: Provider) => this.getSingleProviderOverrides(provider) || [],\n      ),\n    );\n  }\n\n  private getOverriddenProviders(\n    providers?: Array<Provider | InternalEnvironmentProviders>,\n  ): Provider[] {\n    if (!providers || !providers.length || this.providerOverridesByToken.size === 0) return [];\n\n    const flattenedProviders = flattenProviders(providers);\n    const overrides = this.getProviderOverrides(flattenedProviders);\n    const overriddenProviders = [...flattenedProviders, ...overrides];\n    const final: Provider[] = [];\n    const seenOverriddenProviders = new Set<Provider>();\n\n    // We iterate through the list of providers in reverse order to make sure provider overrides\n    // take precedence over the values defined in provider list. We also filter out all providers\n    // that have overrides, keeping overridden values only. This is needed, since presence of a\n    // provider with `ngOnDestroy` hook will cause this hook to be registered and invoked later.\n    forEachRight(overriddenProviders, (provider: any) => {\n      const token: any = getProviderToken(provider);\n      if (this.providerOverridesByToken.has(token)) {\n        if (!seenOverriddenProviders.has(token)) {\n          seenOverriddenProviders.add(token);\n          // Treat all overridden providers as `{multi: false}` (even if it's a multi-provider) to\n          // make sure that provided override takes highest precedence and is not combined with\n          // other instances of the same multi provider.\n          final.unshift({...provider, multi: false});\n        }\n      } else {\n        final.unshift(provider);\n      }\n    });\n    return final;\n  }\n\n  private hasProviderOverrides(\n    providers?: Array<Provider | InternalEnvironmentProviders>,\n  ): boolean {\n    return this.getProviderOverrides(providers).length > 0;\n  }\n\n  private patchDefWithProviderOverrides(declaration: Type<any>, field: string): void {\n    const def = (declaration as any)[field];\n    if (def && def.providersResolver) {\n      this.maybeStoreNgDef(field, declaration);\n\n      const resolver = def.providersResolver;\n      const processProvidersFn = (providers: Provider[]) => this.getOverriddenProviders(providers);\n      this.storeFieldOfDefOnType(declaration, field, 'providersResolver');\n      def.providersResolver = (ngDef: DirectiveDef<any>) => resolver(ngDef, processProvidersFn);\n    }\n  }\n}\n\nfunction initResolvers(): Resolvers {\n  return {\n    module: new NgModuleResolver(),\n    component: new ComponentResolver(),\n    directive: new DirectiveResolver(),\n    pipe: new PipeResolver(),\n  };\n}\n\nfunction isStandaloneComponent<T>(value: Type<T>): value is ComponentType<T> {\n  const def = getComponentDef(value);\n  return !!def?.standalone;\n}\n\nfunction getComponentDef(value: ComponentType<unknown>): ComponentDef<unknown>;\nfunction getComponentDef(value: Type<unknown>): ComponentDef<unknown> | null;\nfunction getComponentDef(value: Type<unknown>): ComponentDef<unknown> | null {\n  return (value as any).ɵcmp ?? null;\n}\n\nfunction hasNgModuleDef<T>(value: Type<T>): value is NgModuleType<T> {\n  return value.hasOwnProperty('ɵmod');\n}\n\nfunction isNgModule<T>(value: Type<T>): boolean {\n  return hasNgModuleDef(value);\n}\n\nfunction maybeUnwrapFn<T>(maybeFn: (() => T) | T): T {\n  return maybeFn instanceof Function ? maybeFn() : maybeFn;\n}\n\nfunction flatten<T>(values: any[]): T[] {\n  const out: T[] = [];\n  values.forEach((value) => {\n    if (Array.isArray(value)) {\n      out.push(...flatten<T>(value));\n    } else {\n      out.push(value);\n    }\n  });\n  return out;\n}\n\nfunction identityFn<T>(value: T): T {\n  return value;\n}\n\nfunction flattenProviders<T>(\n  providers: Array<Provider | InternalEnvironmentProviders>,\n  mapFn: (provider: Provider) => T,\n): T[];\nfunction flattenProviders(providers: Array<Provider | InternalEnvironmentProviders>): Provider[];\nfunction flattenProviders(\n  providers: Array<Provider | InternalEnvironmentProviders>,\n  mapFn: (provider: Provider) => any = identityFn,\n): any[] {\n  const out: any[] = [];\n  for (let provider of providers) {\n    if (isEnvironmentProviders(provider)) {\n      provider = provider.ɵproviders;\n    }\n    if (Array.isArray(provider)) {\n      out.push(...flattenProviders(provider, mapFn));\n    } else {\n      out.push(mapFn(provider));\n    }\n  }\n  return out;\n}\n\nfunction getProviderField(provider: Provider, field: string) {\n  return provider && typeof provider === 'object' && (provider as any)[field];\n}\n\nfunction getProviderToken(provider: Provider) {\n  return getProviderField(provider, 'provide') || provider;\n}\n\nfunction isModuleWithProviders(value: any): value is ModuleWithProviders<any> {\n  return value.hasOwnProperty('ngModule');\n}\n\nfunction forEachRight<T>(values: T[], fn: (value: T, idx: number) => void): void {\n  for (let idx = values.length - 1; idx >= 0; idx--) {\n    fn(values[idx], idx);\n  }\n}\n\nfunction invalidTypeError(name: string, expectedType: string): Error {\n  return new Error(`${name} class doesn't have @${expectedType} decorator or is missing metadata.`);\n}\n\nclass R3TestCompiler implements Compiler {\n  constructor(private testBed: TestBedCompiler) {}\n\n  compileModuleSync<T>(moduleType: Type<T>): NgModuleFactory<T> {\n    this.testBed._compileNgModuleSync(moduleType);\n    return new R3NgModuleFactory(moduleType);\n  }\n\n  async compileModuleAsync<T>(moduleType: Type<T>): Promise<NgModuleFactory<T>> {\n    await this.testBed._compileNgModuleAsync(moduleType);\n    return new R3NgModuleFactory(moduleType);\n  }\n\n  compileModuleAndAllComponentsSync<T>(moduleType: Type<T>): ModuleWithComponentFactories<T> {\n    const ngModuleFactory = this.compileModuleSync(moduleType);\n    const componentFactories = this.testBed._getComponentFactories(moduleType as NgModuleType<T>);\n    return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);\n  }\n\n  async compileModuleAndAllComponentsAsync<T>(\n    moduleType: Type<T>,\n  ): Promise<ModuleWithComponentFactories<T>> {\n    const ngModuleFactory = await this.compileModuleAsync(moduleType);\n    const componentFactories = this.testBed._getComponentFactories(moduleType as NgModuleType<T>);\n    return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);\n  }\n\n  clearCache(): void {}\n\n  clearCacheFor(type: Type<any>): void {}\n\n  getModuleId(moduleType: Type<any>): string | undefined {\n    const meta = this.testBed._getModuleResolver().resolve(moduleType);\n    return (meta && meta.id) || undefined;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\n// The formatter and CI disagree on how this import statement should be formatted. Both try to keep\n// it on one line, too, which has gotten very hard to read & manage. So disable the formatter for\n// this statement only.\n\nimport {\n  ApplicationRef,\n  Binding,\n  Component,\n  ɵRender3ComponentFactory as ComponentFactory,\n  ComponentRef,\n  ɵDeferBlockBehavior as DeferBlockBehavior,\n  Directive,\n  EnvironmentInjector,\n  ɵflushModuleScopingQueueAsMuchAsPossible as flushModuleScopingQueueAsMuchAsPossible,\n  ɵgetAsyncClassMetadataFn as getAsyncClassMetadataFn,\n  ɵgetUnknownElementStrictMode as getUnknownElementStrictMode,\n  ɵgetUnknownPropertyStrictMode as getUnknownPropertyStrictMode,\n  InjectOptions,\n  Injector,\n  NgModule,\n  ɵRender3NgModuleRef as NgModuleRef,\n  NgZone,\n  Pipe,\n  PlatformRef,\n  ProviderToken,\n  ɵresetCompiledComponents as resetCompiledComponents,\n  runInInjectionContext,\n  ɵsetAllowDuplicateNgModuleIdsForTest as setAllowDuplicateNgModuleIdsForTest,\n  ɵsetUnknownElementStrictMode as setUnknownElementStrictMode,\n  ɵsetUnknownPropertyStrictMode as setUnknownPropertyStrictMode,\n  ɵstringify as stringify,\n  Type,\n  ɵinferTagNameFromDefinition as inferTagNameFromDefinition,\n  ɵgetComponentDef as getComponentDef,\n} from '../../src/core';\n\nimport {ComponentFixture} from './component_fixture';\nimport {MetadataOverride} from './metadata_override';\nimport {\n  ANIMATIONS_ENABLED_DEFAULT,\n  ComponentFixtureNoNgZone,\n  DEFER_BLOCK_DEFAULT_BEHAVIOR,\n  ModuleTeardownOptions,\n  TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT,\n  TestComponentRenderer,\n  TestEnvironmentOptions,\n  TestModuleMetadata,\n  THROW_ON_UNKNOWN_ELEMENTS_DEFAULT,\n  THROW_ON_UNKNOWN_PROPERTIES_DEFAULT,\n} from './test_bed_common';\nimport {TestBedCompiler} from './test_bed_compiler';\n\n/**\n * Static methods implemented by the `TestBed`.\n *\n * @publicApi\n */\nexport interface TestBedStatic extends TestBed {\n  new (...args: any[]): TestBed;\n}\n\n/**\n * Options that can be configured for a test component.\n *\n * @publicApi\n */\nexport interface TestComponentOptions {\n  /** Bindings to apply to the test component. */\n  bindings?: Binding[];\n\n  /**\n   * Whether to infer the tag name of the test component from its selector.\n   * Otherwise `div` will be used as its tag name.\n   */\n  inferTagName?: boolean;\n}\n\n/**\n * @publicApi\n */\nexport interface TestBed {\n  get platform(): PlatformRef;\n\n  get ngModule(): Type<any> | Type<any>[];\n\n  /**\n   * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n   * angular module. These are common to every test in the suite.\n   *\n   * This may only be called once, to set up the common providers for the current test\n   * suite on the current platform. If you absolutely need to change the providers,\n   * first use `resetTestEnvironment`.\n   *\n   * Test modules and platforms for individual platforms are available from\n   * '@angular/<platform_name>/testing'.\n   */\n  initTestEnvironment(\n    ngModule: Type<any> | Type<any>[],\n    platform: PlatformRef,\n    options?: TestEnvironmentOptions,\n  ): void;\n\n  /**\n   * Reset the providers for the test injector.\n   */\n  resetTestEnvironment(): void;\n\n  resetTestingModule(): TestBed;\n\n  configureCompiler(config: {providers?: any[]; useJit?: boolean}): void;\n\n  configureTestingModule(moduleDef: TestModuleMetadata): TestBed;\n\n  compileComponents(): Promise<any>;\n\n  inject<T>(\n    token: ProviderToken<T>,\n    notFoundValue: undefined,\n    options: InjectOptions & {\n      optional?: false;\n    },\n  ): T;\n  inject<T>(\n    token: ProviderToken<T>,\n    notFoundValue: null | undefined,\n    options: InjectOptions,\n  ): T | null;\n  inject<T>(token: ProviderToken<T>, notFoundValue?: T, options?: InjectOptions): T;\n\n  /**\n   * Runs the given function in the `EnvironmentInjector` context of `TestBed`.\n   *\n   * @see {@link https://angular.dev/api/core/EnvironmentInjector#runInContext}\n   */\n  runInInjectionContext<T>(fn: () => T): T;\n\n  execute(tokens: any[], fn: Function, context?: any): any;\n\n  overrideModule(ngModule: Type<any>, override: MetadataOverride<NgModule>): TestBed;\n\n  overrideComponent(component: Type<any>, override: MetadataOverride<Component>): TestBed;\n\n  overrideDirective(directive: Type<any>, override: MetadataOverride<Directive>): TestBed;\n\n  overridePipe(pipe: Type<any>, override: MetadataOverride<Pipe>): TestBed;\n\n  overrideTemplate(component: Type<any>, template: string): TestBed;\n\n  /**\n   * Overwrites all providers for the given token with the given provider definition.\n   */\n  overrideProvider(\n    token: any,\n    provider: {useFactory: Function; deps: any[]; multi?: boolean},\n  ): TestBed;\n  overrideProvider(token: any, provider: {useValue: any; multi?: boolean}): TestBed;\n  overrideProvider(\n    token: any,\n    provider: {useFactory?: Function; useValue?: any; deps?: any[]; multi?: boolean},\n  ): TestBed;\n\n  overrideTemplateUsingTestingModule(component: Type<any>, template: string): TestBed;\n\n  createComponent<T>(component: Type<T>, options?: TestComponentOptions): ComponentFixture<T>;\n\n  /**\n   * Execute any pending effects.\n   *\n   * @deprecated use `TestBed.tick()` instead\n   */\n  flushEffects(): void;\n\n  /**\n   * Execute any pending work required to synchronize model to the UI.\n   *\n   * @publicApi 20.0\n   */\n  tick(): void;\n}\n\nlet _nextRootElementId = 0;\n\n/**\n * Returns a singleton of the `TestBed` class.\n *\n * @publicApi\n */\nexport function getTestBed(): TestBed {\n  return TestBedImpl.INSTANCE;\n}\n\n/**\n * @description\n * Configures and initializes environment for unit testing and provides methods for\n * creating components and services in unit tests.\n *\n * TestBed is the primary api for writing unit tests for Angular applications and libraries.\n */\nexport class TestBedImpl implements TestBed {\n  private static _INSTANCE: TestBedImpl | null = null;\n\n  static get INSTANCE(): TestBedImpl {\n    return (TestBedImpl._INSTANCE = TestBedImpl._INSTANCE || new TestBedImpl());\n  }\n\n  /**\n   * Teardown options that have been configured at the environment level.\n   * Used as a fallback if no instance-level options have been provided.\n   */\n  private static _environmentTeardownOptions: ModuleTeardownOptions | undefined;\n\n  /**\n   * \"Error on unknown elements\" option that has been configured at the environment level.\n   * Used as a fallback if no instance-level option has been provided.\n   */\n  private static _environmentErrorOnUnknownElementsOption: boolean | undefined;\n\n  /**\n   * \"Error on unknown properties\" option that has been configured at the environment level.\n   * Used as a fallback if no instance-level option has been provided.\n   */\n  private static _environmentErrorOnUnknownPropertiesOption: boolean | undefined;\n\n  /**\n   * Teardown options that have been configured at the `TestBed` instance level.\n   * These options take precedence over the environment-level ones.\n   */\n  private _instanceTeardownOptions: ModuleTeardownOptions | undefined;\n\n  /**\n   * Defer block behavior option that specifies whether defer blocks will be triggered manually\n   * or set to play through.\n   */\n  private _instanceDeferBlockBehavior = DEFER_BLOCK_DEFAULT_BEHAVIOR;\n\n  /**\n   * Animations behavior option that specifies whether animations are enabled or disabled.\n   */\n  private _instanceAnimationsEnabled = ANIMATIONS_ENABLED_DEFAULT;\n\n  /**\n   * \"Error on unknown elements\" option that has been configured at the `TestBed` instance level.\n   * This option takes precedence over the environment-level one.\n   */\n  private _instanceErrorOnUnknownElementsOption: boolean | undefined;\n\n  /**\n   * \"Error on unknown properties\" option that has been configured at the `TestBed` instance level.\n   * This option takes precedence over the environment-level one.\n   */\n  private _instanceErrorOnUnknownPropertiesOption: boolean | undefined;\n\n  /**\n   * Stores the previous \"Error on unknown elements\" option value,\n   * allowing to restore it in the reset testing module logic.\n   */\n  private _previousErrorOnUnknownElementsOption: boolean | undefined;\n\n  /**\n   * Stores the previous \"Error on unknown properties\" option value,\n   * allowing to restore it in the reset testing module logic.\n   */\n  private _previousErrorOnUnknownPropertiesOption: boolean | undefined;\n\n  /**\n   * Stores the value for `inferTagName` from the testing module.\n   */\n  private _instanceInferTagName: boolean | undefined;\n\n  /**\n   * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n   * angular module. These are common to every test in the suite.\n   *\n   * This may only be called once, to set up the common providers for the current test\n   * suite on the current platform. If you absolutely need to change the providers,\n   * first use `resetTestEnvironment`.\n   *\n   * Test modules and platforms for individual platforms are available from\n   * '@angular/<platform_name>/testing'.\n   *\n   * @publicApi\n   */\n  static initTestEnvironment(\n    ngModule: Type<any> | Type<any>[],\n    platform: PlatformRef,\n    options?: TestEnvironmentOptions,\n  ): TestBed {\n    const testBed = TestBedImpl.INSTANCE;\n    testBed.initTestEnvironment(ngModule, platform, options);\n    return testBed;\n  }\n\n  /**\n   * Reset the providers for the test injector.\n   *\n   * @publicApi\n   */\n  static resetTestEnvironment(): void {\n    TestBedImpl.INSTANCE.resetTestEnvironment();\n  }\n\n  static configureCompiler(config: {providers?: any[]; useJit?: boolean}): TestBed {\n    return TestBedImpl.INSTANCE.configureCompiler(config);\n  }\n\n  /**\n   * Allows overriding default providers, directives, pipes, modules of the test injector,\n   * which are defined in test_injector.js\n   */\n  static configureTestingModule(moduleDef: TestModuleMetadata): TestBed {\n    return TestBedImpl.INSTANCE.configureTestingModule(moduleDef);\n  }\n\n  /**\n   * Compile components with a `templateUrl` for the test's NgModule.\n   * It is necessary to call this function\n   * as fetching urls is asynchronous.\n   */\n  static compileComponents(): Promise<any> {\n    return TestBedImpl.INSTANCE.compileComponents();\n  }\n\n  static overrideModule(ngModule: Type<any>, override: MetadataOverride<NgModule>): TestBed {\n    return TestBedImpl.INSTANCE.overrideModule(ngModule, override);\n  }\n\n  static overrideComponent(component: Type<any>, override: MetadataOverride<Component>): TestBed {\n    return TestBedImpl.INSTANCE.overrideComponent(component, override);\n  }\n\n  static overrideDirective(directive: Type<any>, override: MetadataOverride<Directive>): TestBed {\n    return TestBedImpl.INSTANCE.overrideDirective(directive, override);\n  }\n\n  static overridePipe(pipe: Type<any>, override: MetadataOverride<Pipe>): TestBed {\n    return TestBedImpl.INSTANCE.overridePipe(pipe, override);\n  }\n\n  static overrideTemplate(component: Type<any>, template: string): TestBed {\n    return TestBedImpl.INSTANCE.overrideTemplate(component, template);\n  }\n\n  /**\n   * Overrides the template of the given component, compiling the template\n   * in the context of the TestingModule.\n   *\n   * Note: This works for JIT and AOTed components as well.\n   */\n  static overrideTemplateUsingTestingModule(component: Type<any>, template: string): TestBed {\n    return TestBedImpl.INSTANCE.overrideTemplateUsingTestingModule(component, template);\n  }\n\n  static overrideProvider(\n    token: any,\n    provider: {\n      useFactory: Function;\n      deps: any[];\n    },\n  ): TestBed;\n  static overrideProvider(token: any, provider: {useValue: any}): TestBed;\n  static overrideProvider(\n    token: any,\n    provider: {\n      useFactory?: Function;\n      useValue?: any;\n      deps?: any[];\n    },\n  ): TestBed {\n    return TestBedImpl.INSTANCE.overrideProvider(token, provider);\n  }\n\n  static inject<T>(\n    token: ProviderToken<T>,\n    notFoundValue: undefined,\n    options: InjectOptions & {\n      optional?: false;\n    },\n  ): T;\n  static inject<T>(\n    token: ProviderToken<T>,\n    notFoundValue: null | undefined,\n    options: InjectOptions,\n  ): T | null;\n  static inject<T>(token: ProviderToken<T>, notFoundValue?: T, options?: InjectOptions): T;\n  static inject<T>(\n    token: ProviderToken<T>,\n    notFoundValue?: T | null,\n    options?: InjectOptions,\n  ): T | null {\n    return TestBedImpl.INSTANCE.inject(token, notFoundValue, options);\n  }\n\n  /**\n   * Runs the given function in the `EnvironmentInjector` context of `TestBed`.\n   *\n   * @see {@link https://angular.dev/api/core/EnvironmentInjector#runInContext}\n   */\n  static runInInjectionContext<T>(fn: () => T): T {\n    return TestBedImpl.INSTANCE.runInInjectionContext(fn);\n  }\n\n  static createComponent<T>(\n    component: Type<T>,\n    options?: TestComponentOptions,\n  ): ComponentFixture<T> {\n    return TestBedImpl.INSTANCE.createComponent(component, options);\n  }\n\n  static resetTestingModule(): TestBed {\n    return TestBedImpl.INSTANCE.resetTestingModule();\n  }\n\n  static execute(tokens: any[], fn: Function, context?: any): any {\n    return TestBedImpl.INSTANCE.execute(tokens, fn, context);\n  }\n\n  static get platform(): PlatformRef {\n    return TestBedImpl.INSTANCE.platform;\n  }\n\n  static get ngModule(): Type<any> | Type<any>[] {\n    return TestBedImpl.INSTANCE.ngModule;\n  }\n\n  static flushEffects(): void {\n    return TestBedImpl.INSTANCE.tick();\n  }\n\n  static tick(): void {\n    return TestBedImpl.INSTANCE.tick();\n  }\n\n  // Properties\n\n  platform: PlatformRef = null!;\n  ngModule: Type<any> | Type<any>[] = null!;\n\n  private _compiler: TestBedCompiler | null = null;\n  private _testModuleRef: NgModuleRef<any> | null = null;\n\n  private _activeFixtures: ComponentFixture<any>[] = [];\n\n  /**\n   * Internal-only flag to indicate whether a module\n   * scoping queue has been checked and flushed already.\n   * @docs-private\n   */\n  globalCompilationChecked = false;\n\n  /**\n   * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n   * angular module. These are common to every test in the suite.\n   *\n   * This may only be called once, to set up the common providers for the current test\n   * suite on the current platform. If you absolutely need to change the providers,\n   * first use `resetTestEnvironment`.\n   *\n   * Test modules and platforms for individual platforms are available from\n   * '@angular/<platform_name>/testing'.\n   *\n   * @publicApi\n   */\n  initTestEnvironment(\n    ngModule: Type<any> | Type<any>[],\n    platform: PlatformRef,\n    options?: TestEnvironmentOptions,\n  ): void {\n    if (this.platform || this.ngModule) {\n      throw new Error('Cannot set base providers because it has already been called');\n    }\n\n    TestBedImpl._environmentTeardownOptions = options?.teardown;\n\n    TestBedImpl._environmentErrorOnUnknownElementsOption = options?.errorOnUnknownElements;\n\n    TestBedImpl._environmentErrorOnUnknownPropertiesOption = options?.errorOnUnknownProperties;\n\n    this.platform = platform;\n    this.ngModule = ngModule;\n    this._compiler = new TestBedCompiler(this.platform, this.ngModule);\n\n    // TestBed does not have an API which can reliably detect the start of a test, and thus could be\n    // used to track the state of the NgModule registry and reset it correctly. Instead, when we\n    // know we're in a testing scenario, we disable the check for duplicate NgModule registration\n    // completely.\n    setAllowDuplicateNgModuleIdsForTest(true);\n  }\n\n  /**\n   * Reset the providers for the test injector.\n   *\n   * @publicApi\n   */\n  resetTestEnvironment(): void {\n    this.resetTestingModule();\n    this._compiler = null;\n    this.platform = null!;\n    this.ngModule = null!;\n    TestBedImpl._environmentTeardownOptions = undefined;\n    setAllowDuplicateNgModuleIdsForTest(false);\n  }\n\n  resetTestingModule(): this {\n    this.checkGlobalCompilationFinished();\n    resetCompiledComponents();\n    if (this._compiler !== null) {\n      this.compiler.restoreOriginalState();\n    }\n    this._compiler = new TestBedCompiler(this.platform, this.ngModule);\n    // Restore the previous value of the \"error on unknown elements\" option\n    setUnknownElementStrictMode(\n      this._previousErrorOnUnknownElementsOption ?? THROW_ON_UNKNOWN_ELEMENTS_DEFAULT,\n    );\n    // Restore the previous value of the \"error on unknown properties\" option\n    setUnknownPropertyStrictMode(\n      this._previousErrorOnUnknownPropertiesOption ?? THROW_ON_UNKNOWN_PROPERTIES_DEFAULT,\n    );\n\n    // We have to chain a couple of try/finally blocks, because each step can\n    // throw errors and we don't want it to interrupt the next step and we also\n    // want an error to be thrown at the end.\n    try {\n      this.destroyActiveFixtures();\n    } finally {\n      try {\n        if (this.shouldTearDownTestingModule()) {\n          this.tearDownTestingModule();\n        }\n      } finally {\n        this._testModuleRef = null;\n        this._instanceTeardownOptions = undefined;\n        this._instanceErrorOnUnknownElementsOption = undefined;\n        this._instanceErrorOnUnknownPropertiesOption = undefined;\n        this._instanceInferTagName = undefined;\n        this._instanceDeferBlockBehavior = DEFER_BLOCK_DEFAULT_BEHAVIOR;\n        this._instanceAnimationsEnabled = ANIMATIONS_ENABLED_DEFAULT;\n      }\n    }\n    return this;\n  }\n\n  configureCompiler(config: {providers?: any[]; useJit?: boolean}): this {\n    if (config.useJit != null) {\n      throw new Error('JIT compiler is not configurable via TestBed APIs.');\n    }\n\n    if (config.providers !== undefined) {\n      this.compiler.setCompilerProviders(config.providers);\n    }\n    return this;\n  }\n\n  configureTestingModule(moduleDef: TestModuleMetadata): this {\n    this.assertNotInstantiated('TestBed.configureTestingModule', 'configure the test module');\n\n    // Trigger module scoping queue flush before executing other TestBed operations in a test.\n    // This is needed for the first test invocation to ensure that globally declared modules have\n    // their components scoped properly. See the `checkGlobalCompilationFinished` function\n    // description for additional info.\n    this.checkGlobalCompilationFinished();\n\n    // Always re-assign the options, even if they're undefined.\n    // This ensures that we don't carry them between tests.\n    this._instanceTeardownOptions = moduleDef.teardown;\n    this._instanceErrorOnUnknownElementsOption = moduleDef.errorOnUnknownElements;\n    this._instanceErrorOnUnknownPropertiesOption = moduleDef.errorOnUnknownProperties;\n    this._instanceInferTagName = moduleDef.inferTagName;\n    this._instanceDeferBlockBehavior = moduleDef.deferBlockBehavior ?? DEFER_BLOCK_DEFAULT_BEHAVIOR;\n    this._instanceAnimationsEnabled = moduleDef.animationsEnabled ?? ANIMATIONS_ENABLED_DEFAULT;\n    // Store the current value of the strict mode option,\n    // so we can restore it later\n    this._previousErrorOnUnknownElementsOption = getUnknownElementStrictMode();\n    setUnknownElementStrictMode(this.shouldThrowErrorOnUnknownElements());\n    this._previousErrorOnUnknownPropertiesOption = getUnknownPropertyStrictMode();\n    setUnknownPropertyStrictMode(this.shouldThrowErrorOnUnknownProperties());\n    this.compiler.configureTestingModule(moduleDef);\n    return this;\n  }\n\n  compileComponents(): Promise<any> {\n    return this.compiler.compileComponents();\n  }\n\n  inject<T>(\n    token: ProviderToken<T>,\n    notFoundValue: undefined,\n    options: InjectOptions & {\n      optional: true;\n    },\n  ): T | null;\n  inject<T>(token: ProviderToken<T>, notFoundValue?: T, options?: InjectOptions): T;\n  inject<T>(token: ProviderToken<T>, notFoundValue: null, options?: InjectOptions): T | null;\n  inject<T>(token: ProviderToken<T>, notFoundValue?: T | null, options?: InjectOptions): T | null {\n    if ((token as unknown) === TestBed) {\n      return this as any;\n    }\n    const UNDEFINED = {} as unknown as T;\n    const result = this.testModuleRef.injector.get(token, UNDEFINED, options);\n    return result === UNDEFINED\n      ? (this.compiler.injector.get(token, notFoundValue, options) as any)\n      : result;\n  }\n\n  runInInjectionContext<T>(fn: () => T): T {\n    return runInInjectionContext(this.inject(EnvironmentInjector), fn);\n  }\n\n  execute(tokens: any[], fn: Function, context?: any): any {\n    const params = tokens.map((t) => this.inject(t));\n    return fn.apply(context, params);\n  }\n\n  overrideModule(ngModule: Type<any>, override: MetadataOverride<NgModule>): this {\n    this.assertNotInstantiated('overrideModule', 'override module metadata');\n    this.compiler.overrideModule(ngModule, override);\n    return this;\n  }\n\n  overrideComponent(component: Type<any>, override: MetadataOverride<Component>): this {\n    this.assertNotInstantiated('overrideComponent', 'override component metadata');\n    this.compiler.overrideComponent(component, override);\n    return this;\n  }\n\n  overrideTemplateUsingTestingModule(component: Type<any>, template: string): this {\n    this.assertNotInstantiated(\n      'TestBed.overrideTemplateUsingTestingModule',\n      'Cannot override template when the test module has already been instantiated',\n    );\n    this.compiler.overrideTemplateUsingTestingModule(component, template);\n    return this;\n  }\n\n  overrideDirective(directive: Type<any>, override: MetadataOverride<Directive>): this {\n    this.assertNotInstantiated('overrideDirective', 'override directive metadata');\n    this.compiler.overrideDirective(directive, override);\n    return this;\n  }\n\n  overridePipe(pipe: Type<any>, override: MetadataOverride<Pipe>): this {\n    this.assertNotInstantiated('overridePipe', 'override pipe metadata');\n    this.compiler.overridePipe(pipe, override);\n    return this;\n  }\n\n  /**\n   * Overwrites all providers for the given token with the given provider definition.\n   */\n  overrideProvider(\n    token: any,\n    provider: {useFactory?: Function; useValue?: any; deps?: any[]},\n  ): this {\n    this.assertNotInstantiated('overrideProvider', 'override provider');\n    this.compiler.overrideProvider(token, provider);\n    return this;\n  }\n\n  overrideTemplate(component: Type<any>, template: string): TestBed {\n    return this.overrideComponent(component, {set: {template, templateUrl: null!}});\n  }\n\n  createComponent<T>(type: Type<T>, options?: TestComponentOptions): ComponentFixture<T> {\n    if (getAsyncClassMetadataFn(type)) {\n      throw new Error(\n        `Component '${type.name}' has unresolved metadata. ` +\n          `Please call \\`await TestBed.compileComponents()\\` before running this test.`,\n      );\n    }\n\n    // Note: injecting the renderer before accessing the definition appears to be load-bearing.\n    const testComponentRenderer = this.inject(TestComponentRenderer);\n    const shouldInferTagName = options?.inferTagName ?? this._instanceInferTagName ?? false;\n    const componentDef = getComponentDef(type);\n    const rootElId = `root${_nextRootElementId++}`;\n\n    if (!componentDef) {\n      throw new Error(`It looks like '${stringify(type)}' has not been compiled.`);\n    }\n\n    testComponentRenderer.insertRootElement(\n      rootElId,\n      shouldInferTagName ? inferTagNameFromDefinition(componentDef) : undefined,\n    );\n\n    const componentFactory = new ComponentFactory(componentDef);\n    const initComponent = () => {\n      const componentRef = componentFactory.create(\n        Injector.NULL,\n        [],\n        `#${rootElId}`,\n        this.testModuleRef,\n        undefined,\n        options?.bindings,\n      ) as ComponentRef<T>;\n      return this.runInInjectionContext(() => new ComponentFixture(componentRef));\n    };\n    const noNgZone = this.inject(ComponentFixtureNoNgZone, false);\n    const ngZone = noNgZone ? null : this.inject(NgZone, null);\n    const fixture = ngZone ? ngZone.run(initComponent) : initComponent();\n    this._activeFixtures.push(fixture);\n    return fixture;\n  }\n\n  /**\n   * @internal strip this from published d.ts files due to\n   * https://github.com/microsoft/TypeScript/issues/36216\n   */\n  private get compiler(): TestBedCompiler {\n    if (this._compiler === null) {\n      throw new Error(`Need to call TestBed.initTestEnvironment() first`);\n    }\n    return this._compiler;\n  }\n\n  /**\n   * @internal strip this from published d.ts files due to\n   * https://github.com/microsoft/TypeScript/issues/36216\n   */\n  private get testModuleRef(): NgModuleRef<any> {\n    if (this._testModuleRef === null) {\n      this._testModuleRef = this.compiler.finalize();\n    }\n    return this._testModuleRef;\n  }\n\n  private assertNotInstantiated(methodName: string, methodDescription: string) {\n    if (this._testModuleRef !== null) {\n      throw new Error(\n        `Cannot ${methodDescription} when the test module has already been instantiated. ` +\n          `Make sure you are not using \\`inject\\` before \\`${methodName}\\`.`,\n      );\n    }\n  }\n\n  /**\n   * Check whether the module scoping queue should be flushed, and flush it if needed.\n   *\n   * When the TestBed is reset, it clears the JIT module compilation queue, cancelling any\n   * in-progress module compilation. This creates a potential hazard - the very first time the\n   * TestBed is initialized (or if it's reset without being initialized), there may be pending\n   * compilations of modules declared in global scope. These compilations should be finished.\n   *\n   * To ensure that globally declared modules have their components scoped properly, this function\n   * is called whenever TestBed is initialized or reset. The _first_ time that this happens, prior\n   * to any other operations, the scoping queue is flushed.\n   */\n  private checkGlobalCompilationFinished(): void {\n    // Checking _testNgModuleRef is null should not be necessary, but is left in as an additional\n    // guard that compilations queued in tests (after instantiation) are never flushed accidentally.\n    if (!this.globalCompilationChecked && this._testModuleRef === null) {\n      flushModuleScopingQueueAsMuchAsPossible();\n    }\n    this.globalCompilationChecked = true;\n  }\n\n  private destroyActiveFixtures(): void {\n    let errorCount = 0;\n    this._activeFixtures.forEach((fixture) => {\n      try {\n        fixture.destroy();\n      } catch (e) {\n        errorCount++;\n        console.error('Error during cleanup of component', {\n          component: fixture.componentInstance,\n          stacktrace: e,\n        });\n      }\n    });\n    this._activeFixtures = [];\n\n    if (errorCount > 0 && this.shouldRethrowTeardownErrors()) {\n      throw Error(\n        `${errorCount} ${errorCount === 1 ? 'component' : 'components'} ` +\n          `threw errors during cleanup`,\n      );\n    }\n  }\n\n  shouldRethrowTeardownErrors(): boolean {\n    const instanceOptions = this._instanceTeardownOptions;\n    const environmentOptions = TestBedImpl._environmentTeardownOptions;\n\n    // If the new teardown behavior hasn't been configured, preserve the old behavior.\n    if (!instanceOptions && !environmentOptions) {\n      return TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT;\n    }\n\n    // Otherwise use the configured behavior or default to rethrowing.\n    return (\n      instanceOptions?.rethrowErrors ??\n      environmentOptions?.rethrowErrors ??\n      this.shouldTearDownTestingModule()\n    );\n  }\n\n  shouldThrowErrorOnUnknownElements(): boolean {\n    // Check if a configuration has been provided to throw when an unknown element is found\n    return (\n      this._instanceErrorOnUnknownElementsOption ??\n      TestBedImpl._environmentErrorOnUnknownElementsOption ??\n      THROW_ON_UNKNOWN_ELEMENTS_DEFAULT\n    );\n  }\n\n  shouldThrowErrorOnUnknownProperties(): boolean {\n    // Check if a configuration has been provided to throw when an unknown property is found\n    return (\n      this._instanceErrorOnUnknownPropertiesOption ??\n      TestBedImpl._environmentErrorOnUnknownPropertiesOption ??\n      THROW_ON_UNKNOWN_PROPERTIES_DEFAULT\n    );\n  }\n\n  shouldTearDownTestingModule(): boolean {\n    return (\n      this._instanceTeardownOptions?.destroyAfterEach ??\n      TestBedImpl._environmentTeardownOptions?.destroyAfterEach ??\n      TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT\n    );\n  }\n\n  getDeferBlockBehavior(): DeferBlockBehavior {\n    return this._instanceDeferBlockBehavior;\n  }\n\n  getAnimationsEnabled(): boolean {\n    return this._instanceAnimationsEnabled;\n  }\n\n  tearDownTestingModule() {\n    // If the module ref has already been destroyed, we won't be able to get a test renderer.\n    if (this._testModuleRef === null) {\n      return;\n    }\n    // Resolve the renderer ahead of time, because we want to remove the root elements as the very\n    // last step, but the injector will be destroyed as a part of the module ref destruction.\n    const testRenderer = this.inject(TestComponentRenderer);\n    try {\n      this._testModuleRef.destroy();\n    } catch (e) {\n      if (this.shouldRethrowTeardownErrors()) {\n        throw e;\n      } else {\n        console.error('Error during cleanup of a testing module', {\n          component: this._testModuleRef.instance,\n          stacktrace: e,\n        });\n      }\n    } finally {\n      testRenderer.removeAllRootElements?.();\n    }\n  }\n\n  /**\n   * Execute any pending effects by executing any pending work required to synchronize model to the UI.\n   *\n   * @deprecated use `TestBed.tick()` instead\n   */\n  flushEffects(): void {\n    this.tick();\n  }\n\n  /**\n   * Execute any pending work required to synchronize model to the UI.\n   *\n   * @publicApi\n   */\n  tick(): void {\n    const appRef = this.inject(ApplicationRef);\n    try {\n      // TODO(atscott): ApplicationRef.tick should set includeAllTestViews to true itself rather than doing this here and in ComponentFixture\n      // The behavior should be that TestBed.tick, ComponentFixture.detectChanges, and ApplicationRef.tick all result in the test fixtures\n      // getting synchronized, regardless of whether they are autoDetect: true.\n      // Automatic scheduling (zone or zoneless) will call _tick which will _not_ include fixtures with autoDetect: false\n      (appRef as any).includeAllTestViews = true;\n      appRef.tick();\n    } finally {\n      (appRef as any).includeAllTestViews = false;\n    }\n  }\n}\n\n/**\n * @description\n * Configures and initializes environment for unit testing and provides methods for\n * creating components and services in unit tests.\n *\n * `TestBed` is the primary api for writing unit tests for Angular applications and libraries.\n *\n * @publicApi\n */\nexport const TestBed: TestBedStatic = TestBedImpl;\n\n/**\n * Allows injecting dependencies in `beforeEach()` and `it()`. Note: this function\n * (imported from the `@angular/core/testing` package) can **only** be used to inject dependencies\n * in tests. To inject dependencies in your application code, use the [`inject`](api/core/inject)\n * function from the `@angular/core` package instead.\n *\n * Example:\n *\n * ```ts\n * beforeEach(inject([Dependency, AClass], (dep, object) => {\n *   // some code that uses `dep` and `object`\n *   // ...\n * }));\n *\n * it('...', inject([AClass], (object) => {\n *   object.doSomething();\n *   expect(...);\n * })\n * ```\n *\n * @publicApi\n */\nexport function inject(tokens: any[], fn: Function): () => any {\n  const testBed = TestBedImpl.INSTANCE;\n  // Not using an arrow function to preserve context passed from call site\n  return function (this: unknown) {\n    return testBed.execute(tokens, fn, this);\n  };\n}\n\n/**\n * @publicApi\n */\nexport class InjectSetupWrapper {\n  constructor(private _moduleDef: () => TestModuleMetadata) {}\n\n  private _addModule() {\n    const moduleDef = this._moduleDef();\n    if (moduleDef) {\n      TestBedImpl.configureTestingModule(moduleDef);\n    }\n  }\n\n  inject(tokens: any[], fn: Function): () => any {\n    const self = this;\n    // Not using an arrow function to preserve context passed from call site\n    return function (this: unknown) {\n      self._addModule();\n      return inject(tokens, fn).call(this);\n    };\n  }\n}\n\n/**\n * @publicApi\n */\nexport function withModule(moduleDef: TestModuleMetadata): InjectSetupWrapper;\nexport function withModule(moduleDef: TestModuleMetadata, fn: Function): () => any;\nexport function withModule(\n  moduleDef: TestModuleMetadata,\n  fn?: Function | null,\n): (() => any) | InjectSetupWrapper {\n  if (fn) {\n    // Not using an arrow function to preserve context passed from call site\n    return function (this: unknown) {\n      const testBed = TestBedImpl.INSTANCE;\n      if (moduleDef) {\n        testBed.configureTestingModule(moduleDef);\n      }\n      return fn.apply(this);\n    };\n  }\n  return new InjectSetupWrapper(() => moduleDef);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  NavigationNavigateOptions,\n  NavigationTypeString,\n  NavigationOptions,\n  NavigateEvent,\n  NavigationCurrentEntryChangeEvent,\n  NavigationTransition,\n  NavigationUpdateCurrentEntryOptions,\n  NavigationReloadOptions,\n  NavigationResult,\n  NavigationHistoryEntry,\n  NavigationInterceptOptions,\n  NavigationDestination,\n  Navigation,\n} from '../src/navigation_types';\n\n/**\n * Fake implementation of user agent history and navigation behavior. This is a\n * high-fidelity implementation of browser behavior that attempts to emulate\n * things like traversal delay.\n */\nexport class FakeNavigation implements Navigation {\n  /**\n   * The fake implementation of an entries array. Only same-document entries\n   * allowed.\n   */\n  private readonly entriesArr: FakeNavigationHistoryEntry[] = [];\n\n  /**\n   * The current active entry index into `entriesArr`.\n   */\n  private currentEntryIndex = 0;\n\n  /**\n   * The current navigate event.\n   * @internal\n   */\n  navigateEvent: InternalFakeNavigateEvent | null = null;\n\n  /**\n   * A Map of pending traversals, so that traversals to the same entry can be\n   * re-used.\n   */\n  private readonly traversalQueue = new Map<string, InternalNavigationResult>();\n\n  /**\n   * A Promise that resolves when the previous traversals have finished. Used to\n   * simulate the cross-process communication necessary for traversals.\n   */\n  private nextTraversal = Promise.resolve();\n\n  /**\n   * A prospective current active entry index, which includes unresolved\n   * traversals. Used by `go` to determine where navigations are intended to go.\n   */\n  private prospectiveEntryIndex = 0;\n\n  /**\n   * A test-only option to make traversals synchronous, rather than emulate\n   * cross-process communication.\n   */\n  private synchronousTraversals = false;\n\n  /** Whether to allow a call to setInitialEntryForTesting. */\n  private canSetInitialEntry = true;\n\n  /**\n   * `EventTarget` to dispatch events.\n   * @internal\n   */\n  eventTarget: EventTarget;\n\n  /** The next unique id for created entries. Replace recreates this id. */\n  private nextId = 0;\n\n  /** The next unique key for created entries. Replace inherits this id. */\n  private nextKey = 0;\n\n  /** Whether this fake is disposed. */\n  private disposed = false;\n\n  /** Equivalent to `navigation.currentEntry`. */\n  get currentEntry(): FakeNavigationHistoryEntry {\n    return this.entriesArr[this.currentEntryIndex];\n  }\n\n  get canGoBack(): boolean {\n    return this.currentEntryIndex > 0;\n  }\n\n  get canGoForward(): boolean {\n    return this.currentEntryIndex < this.entriesArr.length - 1;\n  }\n\n  private readonly createEventTarget: () => EventTarget;\n  private readonly _window: Pick<\n    Window,\n    'addEventListener' | 'removeEventListener' | 'dispatchEvent'\n  >;\n  get window(): Pick<Window, 'addEventListener' | 'removeEventListener'> {\n    return this._window;\n  }\n\n  constructor(doc: Document, startURL: `http${string}`) {\n    this.createEventTarget = () => {\n      try {\n        // `document.createElement` because NodeJS `EventTarget` is\n        // incompatible with Domino's `Event`. That is, attempting to\n        // dispatch an event created by Domino's patched `Event` will\n        // throw an error since it is not an instance of a real Node\n        // `Event`.\n        return doc.createElement('div');\n      } catch {\n        // Fallback to a basic EventTarget if `document.createElement`\n        // fails. This can happen with tests that pass in a value for document\n        // that is stubbed.\n        return new EventTarget();\n      }\n    };\n    this._window = document.defaultView ?? this.createEventTarget();\n    this.eventTarget = this.createEventTarget();\n    // First entry.\n    this.setInitialEntryForTesting(startURL);\n  }\n\n  /**\n   * Sets the initial entry.\n   */\n  setInitialEntryForTesting(\n    url: `http${string}`,\n    options: {historyState: unknown; state?: unknown} = {historyState: null},\n  ): void {\n    if (!this.canSetInitialEntry) {\n      throw new Error(\n        'setInitialEntryForTesting can only be called before any ' + 'navigation has occurred',\n      );\n    }\n    const currentInitialEntry = this.entriesArr[0];\n    this.entriesArr[0] = new FakeNavigationHistoryEntry(this.eventTarget, new URL(url).toString(), {\n      index: 0,\n      key: currentInitialEntry?.key ?? String(this.nextKey++),\n      id: currentInitialEntry?.id ?? String(this.nextId++),\n      sameDocument: true,\n      historyState: options?.historyState,\n      state: options.state,\n    });\n  }\n\n  /** Returns whether the initial entry is still eligible to be set. */\n  canSetInitialEntryForTesting(): boolean {\n    return this.canSetInitialEntry;\n  }\n\n  /**\n   * Sets whether to emulate traversals as synchronous rather than\n   * asynchronous.\n   */\n  setSynchronousTraversalsForTesting(synchronousTraversals: boolean): void {\n    this.synchronousTraversals = synchronousTraversals;\n  }\n\n  /** Equivalent to `navigation.entries()`. */\n  entries(): FakeNavigationHistoryEntry[] {\n    return this.entriesArr.slice();\n  }\n\n  /** Equivalent to `navigation.navigate()`. */\n  navigate(url: string, options?: NavigationNavigateOptions): FakeNavigationResult {\n    const fromUrl = new URL(this.currentEntry.url!);\n    const toUrl = new URL(url, this.currentEntry.url!);\n\n    let navigationType: NavigationTypeString;\n    if (!options?.history || options.history === 'auto') {\n      // Auto defaults to push, but if the URLs are the same, is a replace.\n      if (fromUrl.toString() === toUrl.toString()) {\n        navigationType = 'replace';\n      } else {\n        navigationType = 'push';\n      }\n    } else {\n      navigationType = options.history;\n    }\n\n    const hashChange = isHashChange(fromUrl, toUrl);\n\n    const destination = new FakeNavigationDestination({\n      url: toUrl.toString(),\n      state: options?.state,\n      sameDocument: hashChange,\n      historyState: null,\n    });\n    const result = new InternalNavigationResult(this);\n\n    const intercepted = this.userAgentNavigate(destination, result, {\n      navigationType,\n      cancelable: true,\n      canIntercept: true,\n      // Always false for navigate().\n      userInitiated: false,\n      hashChange,\n      info: options?.info,\n    });\n    if (!intercepted) {\n      this.updateNavigationEntriesForSameDocumentNavigation(this.navigateEvent!);\n    }\n\n    return {\n      committed: result.committed,\n      finished: result.finished,\n    };\n  }\n\n  /** Equivalent to `history.pushState()`. */\n  pushState(data: unknown, title: string, url?: string): void {\n    this.pushOrReplaceState('push', data, title, url);\n  }\n\n  /** Equivalent to `history.replaceState()`. */\n  replaceState(data: unknown, title: string, url?: string): void {\n    this.pushOrReplaceState('replace', data, title, url);\n  }\n\n  private pushOrReplaceState(\n    navigationType: NavigationTypeString,\n    data: unknown,\n    _title: string,\n    url?: string,\n  ): void {\n    const fromUrl = new URL(this.currentEntry.url!);\n    const toUrl = url ? new URL(url, this.currentEntry.url!) : fromUrl;\n\n    const hashChange = isHashChange(fromUrl, toUrl);\n\n    const destination = new FakeNavigationDestination({\n      url: toUrl.toString(),\n      sameDocument: true, // history.pushState/replaceState are always same-document\n      historyState: data,\n      state: undefined, // No Navigation API state directly from history.pushState\n    });\n    const result = new InternalNavigationResult(this);\n\n    const intercepted = this.userAgentNavigate(destination, result, {\n      navigationType,\n      cancelable: true,\n      canIntercept: true,\n      // Always false for pushState() or replaceState().\n      userInitiated: false,\n      hashChange,\n    });\n    if (intercepted) {\n      return;\n    }\n    this.updateNavigationEntriesForSameDocumentNavigation(this.navigateEvent!);\n  }\n\n  /** Equivalent to `navigation.traverseTo()`. */\n  traverseTo(key: string, options?: NavigationOptions): FakeNavigationResult {\n    const fromUrl = new URL(this.currentEntry.url!);\n    const entry = this.findEntry(key);\n    if (!entry) {\n      const domException = new DOMException('Invalid key', 'InvalidStateError');\n      const committed = Promise.reject(domException);\n      const finished = Promise.reject(domException);\n      committed.catch(() => {});\n      finished.catch(() => {});\n      return {\n        committed,\n        finished,\n      };\n    }\n    if (entry === this.currentEntry) {\n      return {\n        committed: Promise.resolve(this.currentEntry),\n        finished: Promise.resolve(this.currentEntry),\n      };\n    }\n    if (this.traversalQueue.has(entry.key)) {\n      const existingResult = this.traversalQueue.get(entry.key)!;\n      return {\n        committed: existingResult.committed,\n        finished: existingResult.finished,\n      };\n    }\n\n    const hashChange = isHashChange(fromUrl, new URL(entry.url!, this.currentEntry.url!));\n    const destination = new FakeNavigationDestination({\n      url: entry.url!,\n      state: entry.getState(),\n      historyState: entry.getHistoryState(),\n      key: entry.key,\n      id: entry.id,\n      index: entry.index,\n      sameDocument: entry.sameDocument,\n    });\n    this.prospectiveEntryIndex = entry.index;\n    const result = new InternalNavigationResult(this);\n    this.traversalQueue.set(entry.key, result);\n    this.runTraversal(() => {\n      this.traversalQueue.delete(entry.key);\n      const intercepted = this.userAgentNavigate(destination, result, {\n        navigationType: 'traverse',\n        cancelable: true,\n        canIntercept: true,\n        // Always false for traverseTo().\n        userInitiated: false,\n        hashChange,\n        info: options?.info,\n      });\n      if (!intercepted) {\n        this.userAgentTraverse(this.navigateEvent!);\n      }\n    });\n    return {\n      committed: result.committed,\n      finished: result.finished,\n    };\n  }\n\n  /** Equivalent to `navigation.back()`. */\n  back(options?: NavigationOptions): FakeNavigationResult {\n    if (this.currentEntryIndex === 0) {\n      const domException = new DOMException('Cannot go back', 'InvalidStateError');\n      const committed = Promise.reject(domException);\n      const finished = Promise.reject(domException);\n      committed.catch(() => {});\n      finished.catch(() => {});\n      return {\n        committed,\n        finished,\n      };\n    }\n    const entry = this.entriesArr[this.currentEntryIndex - 1];\n    return this.traverseTo(entry.key, options);\n  }\n\n  /** Equivalent to `navigation.forward()`. */\n  forward(options?: NavigationOptions): FakeNavigationResult {\n    if (this.currentEntryIndex === this.entriesArr.length - 1) {\n      const domException = new DOMException('Cannot go forward', 'InvalidStateError');\n      const committed = Promise.reject(domException);\n      const finished = Promise.reject(domException);\n      committed.catch(() => {});\n      finished.catch(() => {});\n      return {\n        committed,\n        finished,\n      };\n    }\n    const entry = this.entriesArr[this.currentEntryIndex + 1];\n    return this.traverseTo(entry.key, options);\n  }\n\n  /**\n   * Equivalent to `history.go()`.\n   * Note that this method does not actually work precisely to how Chrome\n   * does, instead choosing a simpler model with less unexpected behavior.\n   * Chrome has a few edge case optimizations, for instance with repeated\n   * `back(); forward()` chains it collapses certain traversals.\n   */\n  go(direction: number): void {\n    const targetIndex = this.prospectiveEntryIndex + direction;\n    if (targetIndex >= this.entriesArr.length || targetIndex < 0) {\n      return;\n    }\n    this.prospectiveEntryIndex = targetIndex;\n    this.runTraversal(() => {\n      // Check again that destination is in the entries array.\n      if (targetIndex >= this.entriesArr.length || targetIndex < 0) {\n        return;\n      }\n      const fromUrl = new URL(this.currentEntry.url!);\n      const entry = this.entriesArr[targetIndex];\n      const hashChange = isHashChange(fromUrl, new URL(entry.url!, this.currentEntry.url!));\n      const destination = new FakeNavigationDestination({\n        url: entry.url!,\n        state: entry.getState(),\n        historyState: entry.getHistoryState(),\n        key: entry.key,\n        id: entry.id,\n        index: entry.index,\n        sameDocument: entry.sameDocument,\n      });\n      const result = new InternalNavigationResult(this);\n      const intercepted = this.userAgentNavigate(destination, result, {\n        navigationType: 'traverse',\n        cancelable: true,\n        canIntercept: true,\n        // Always false for go().\n        userInitiated: false,\n        hashChange,\n      });\n      if (!intercepted) {\n        this.userAgentTraverse(this.navigateEvent!);\n      }\n    });\n  }\n\n  /** Runs a traversal synchronously or asynchronously */\n  private runTraversal(traversal: () => void) {\n    if (this.synchronousTraversals) {\n      traversal();\n      return;\n    }\n\n    // Each traversal occupies a single timeout resolution.\n    // This means that Promises added to commit and finish should resolve\n    // before the next traversal.\n    this.nextTraversal = this.nextTraversal.then(() => {\n      return new Promise<void>((resolve) => {\n        setTimeout(() => {\n          resolve();\n          traversal();\n        });\n      });\n    });\n  }\n\n  /** Equivalent to `navigation.addEventListener()`. */\n  addEventListener(\n    type: string,\n    callback: EventListenerOrEventListenerObject,\n    options?: AddEventListenerOptions | boolean,\n  ): void {\n    this.eventTarget.addEventListener(type, callback, options);\n  }\n\n  /** Equivalent to `navigation.removeEventListener()`. */\n  removeEventListener(\n    type: string,\n    callback: EventListenerOrEventListenerObject,\n    options?: EventListenerOptions | boolean,\n  ): void {\n    this.eventTarget.removeEventListener(type, callback, options);\n  }\n\n  /** Equivalent to `navigation.dispatchEvent()` */\n  dispatchEvent(event: Event): boolean {\n    return this.eventTarget.dispatchEvent(event);\n  }\n\n  /** Cleans up resources. */\n  dispose(): void {\n    // Recreate eventTarget to release current listeners.\n    this.eventTarget = this.createEventTarget();\n    this.disposed = true;\n  }\n\n  /** Returns whether this fake is disposed. */\n  isDisposed(): boolean {\n    return this.disposed;\n  }\n\n  abortOngoingNavigation(eventToAbort: InternalFakeNavigateEvent, reason?: Error) {\n    if (this.navigateEvent !== eventToAbort) {\n      return;\n    }\n    if (this.navigateEvent.abortController.signal.aborted) {\n      return;\n    }\n    const abortReason = reason ?? new DOMException('Navigation aborted', 'AbortError');\n    this.navigateEvent.cancel(abortReason);\n  }\n\n  /**\n   * Implementation for all navigations and traversals.\n   * @returns true if the event was intercepted, otherwise false\n   */\n  private userAgentNavigate(\n    destination: FakeNavigationDestination,\n    result: InternalNavigationResult,\n    options: InternalNavigateOptions,\n  ): boolean {\n    // The first navigation should disallow any future calls to set the initial\n    // entry.\n    this.canSetInitialEntry = false;\n    if (this.navigateEvent) {\n      this.abortOngoingNavigation(\n        this.navigateEvent,\n        new DOMException('Navigation superseded by a new navigation.', 'AbortError'),\n      );\n    }\n    // TODO(atscott): Disposing doesn't really do much because new requests are still processed\n    // if (this.disposed) {\n    //   return false;\n    // }\n    const dispatchResultIsTrueIfNoInterception = dispatchNavigateEvent({\n      navigationType: options.navigationType,\n      cancelable: options.cancelable,\n      canIntercept: options.canIntercept,\n      userInitiated: options.userInitiated,\n      hashChange: options.hashChange,\n      destination,\n      info: options.info,\n      sameDocument: destination.sameDocument,\n      result,\n    });\n    return !dispatchResultIsTrueIfNoInterception;\n  }\n\n  /**\n   * Implementation for a push or replace navigation.\n   * https://whatpr.org/html/10919/browsing-the-web.html#url-and-history-update-steps\n   * https://whatpr.org/html/10919/nav-history-apis.html#update-the-navigation-api-entries-for-a-same-document-navigation\n   * @internal\n   */\n  urlAndHistoryUpdateSteps(navigateEvent: InternalFakeNavigateEvent) {\n    this.updateNavigationEntriesForSameDocumentNavigation(navigateEvent);\n  }\n\n  /**\n   * Implementation for a traverse navigation.\n   *\n   * https://whatpr.org/html/10919/browsing-the-web.html#apply-the-traverse-history-step\n   * ...\n   * > Let updateDocument be an algorithm step which performs update document for history step application given targetEntry's document, targetEntry, changingNavigableContinuation's update-only, scriptHistoryLength, scriptHistoryIndex, navigationType, entriesForNavigationAPI, and previousEntry.\n   * > If targetEntry's document is equal to displayedDocument, then perform updateDocument.\n   * https://whatpr.org/html/10919/browsing-the-web.html#update-document-for-history-step-application\n   * which then goes to https://whatpr.org/html/10919/nav-history-apis.html#update-the-navigation-api-entries-for-a-same-document-navigation\n   * @internal\n   */\n  userAgentTraverse(navigateEvent: InternalFakeNavigateEvent) {\n    const oldUrl = this.currentEntry.url!;\n    this.updateNavigationEntriesForSameDocumentNavigation(navigateEvent);\n    // Happens as part of \"updating the document\" steps https://whatpr.org/html/10919/browsing-the-web.html#updating-the-document\n    const popStateEvent = createPopStateEvent({\n      state: navigateEvent.destination.getHistoryState(),\n    });\n    this._window.dispatchEvent(popStateEvent);\n    if (navigateEvent.hashChange) {\n      const hashchangeEvent = createHashChangeEvent(oldUrl, this.currentEntry.url!);\n      this._window.dispatchEvent(hashchangeEvent);\n    }\n  }\n\n  /**\n   * https://whatpr.org/html/10919/nav-history-apis.html#update-the-navigation-api-entries-for-a-same-document-navigation\n   * @internal\n   */\n  updateNavigationEntriesForSameDocumentNavigation({\n    destination,\n    navigationType,\n    result,\n  }: InternalFakeNavigateEvent) {\n    const oldCurrentNHE = this.currentEntry;\n    const disposedNHEs = [];\n    if (navigationType === 'traverse') {\n      this.currentEntryIndex = destination.index;\n      if (this.currentEntryIndex === -1) {\n        throw new Error('unexpected current entry index');\n      }\n    } else if (navigationType === 'push') {\n      this.currentEntryIndex++;\n      this.prospectiveEntryIndex = this.currentEntryIndex; // prospectiveEntryIndex isn't in the spec but is an implementation detail\n      disposedNHEs.push(...this.entriesArr.splice(this.currentEntryIndex));\n    } else if (navigationType === 'replace') {\n      disposedNHEs.push(oldCurrentNHE);\n    }\n    if (navigationType === 'push' || navigationType === 'replace') {\n      const index = this.currentEntryIndex;\n      const key =\n        navigationType === 'push'\n          ? String(this.nextKey++)\n          : (oldCurrentNHE?.key ?? String(this.nextKey++));\n      const newNHE = new FakeNavigationHistoryEntry(this.eventTarget, destination.url, {\n        id: String(this.nextId++),\n        key,\n        index,\n        sameDocument: true,\n        state: destination.getState(),\n        historyState: destination.getHistoryState(),\n      });\n      this.entriesArr[this.currentEntryIndex] = newNHE;\n    }\n    result.committedResolve(this.currentEntry);\n    const currentEntryChangeEvent = createFakeNavigationCurrentEntryChangeEvent({\n      from: oldCurrentNHE,\n      navigationType: navigationType,\n    });\n    this.eventTarget.dispatchEvent(currentEntryChangeEvent);\n    for (const disposedNHE of disposedNHEs) {\n      disposedNHE.dispose();\n    }\n  }\n\n  /** Utility method for finding entries with the given `key`. */\n  private findEntry(key: string) {\n    for (const entry of this.entriesArr) {\n      if (entry.key === key) return entry;\n    }\n    return undefined;\n  }\n\n  set onnavigate(\n    // tslint:disable-next-line:no-any\n    _handler: ((this: Navigation, ev: NavigateEvent) => any) | null,\n  ) {\n    throw new Error('unimplemented');\n  }\n\n  // tslint:disable-next-line:no-any\n  get onnavigate(): ((this: Navigation, ev: NavigateEvent) => any) | null {\n    throw new Error('unimplemented');\n  }\n\n  set oncurrententrychange(\n    _handler: // tslint:disable-next-line:no-any\n    ((this: Navigation, ev: NavigationCurrentEntryChangeEvent) => any) | null,\n  ) {\n    throw new Error('unimplemented');\n  }\n\n  get oncurrententrychange(): // tslint:disable-next-line:no-any\n  ((this: Navigation, ev: NavigationCurrentEntryChangeEvent) => any) | null {\n    throw new Error('unimplemented');\n  }\n\n  set onnavigatesuccess(\n    // tslint:disable-next-line:no-any\n    _handler: ((this: Navigation, ev: Event) => any) | null,\n  ) {\n    throw new Error('unimplemented');\n  }\n\n  // tslint:disable-next-line:no-any\n  get onnavigatesuccess(): ((this: Navigation, ev: Event) => any) | null {\n    throw new Error('unimplemented');\n  }\n\n  set onnavigateerror(\n    // tslint:disable-next-line:no-any\n    _handler: ((this: Navigation, ev: ErrorEvent) => any) | null,\n  ) {\n    throw new Error('unimplemented');\n  }\n\n  // tslint:disable-next-line:no-any\n  get onnavigateerror(): ((this: Navigation, ev: ErrorEvent) => any) | null {\n    throw new Error('unimplemented');\n  }\n\n  private _transition: NavigationTransition | null = null;\n  /** @internal */\n  set transition(t: NavigationTransition | null) {\n    this._transition = t;\n  }\n  get transition(): NavigationTransition | null {\n    return this._transition;\n  }\n\n  updateCurrentEntry(_options: NavigationUpdateCurrentEntryOptions): void {\n    throw new Error('unimplemented');\n  }\n\n  reload(_options?: NavigationReloadOptions): NavigationResult {\n    throw new Error('unimplemented');\n  }\n}\n\n/**\n * Fake equivalent of the `NavigationResult` interface with\n * `FakeNavigationHistoryEntry`.\n */\ninterface FakeNavigationResult extends NavigationResult {\n  readonly committed: Promise<FakeNavigationHistoryEntry>;\n  readonly finished: Promise<FakeNavigationHistoryEntry>;\n}\n\n/**\n * Fake equivalent of `NavigationHistoryEntry`.\n */\nexport class FakeNavigationHistoryEntry implements NavigationHistoryEntry {\n  readonly sameDocument: boolean;\n\n  readonly id: string;\n  readonly key: string;\n  readonly index: number;\n  private readonly state: unknown;\n  private readonly historyState: unknown;\n\n  // tslint:disable-next-line:no-any\n  ondispose: ((this: NavigationHistoryEntry, ev: Event) => any) | null = null;\n\n  constructor(\n    private eventTarget: EventTarget,\n    readonly url: string | null,\n    {\n      id,\n      key,\n      index,\n      sameDocument,\n      state,\n      historyState,\n    }: {\n      id: string;\n      key: string;\n      index: number;\n      sameDocument: boolean;\n      historyState: unknown;\n      state?: unknown;\n    },\n  ) {\n    this.id = id;\n    this.key = key;\n    this.index = index;\n    this.sameDocument = sameDocument;\n    this.state = state;\n    this.historyState = historyState;\n  }\n\n  getState(): unknown {\n    // Budget copy.\n    return this.state ? (JSON.parse(JSON.stringify(this.state)) as unknown) : this.state;\n  }\n\n  getHistoryState(): unknown {\n    // Budget copy.\n    return this.historyState\n      ? (JSON.parse(JSON.stringify(this.historyState)) as unknown)\n      : this.historyState;\n  }\n\n  addEventListener(\n    type: string,\n    callback: EventListenerOrEventListenerObject,\n    options?: AddEventListenerOptions | boolean,\n  ): void {\n    this.eventTarget.addEventListener(type, callback, options);\n  }\n\n  removeEventListener(\n    type: string,\n    callback: EventListenerOrEventListenerObject,\n    options?: EventListenerOptions | boolean,\n  ): void {\n    this.eventTarget.removeEventListener(type, callback, options);\n  }\n\n  dispatchEvent(event: Event): boolean {\n    return this.eventTarget.dispatchEvent(event);\n  }\n\n  /** internal */\n  dispose() {\n    const disposeEvent = new Event('disposed');\n    this.dispatchEvent(disposeEvent);\n    // release current listeners\n    this.eventTarget = null!;\n  }\n}\n\n/** `NavigationInterceptOptions` with experimental commit option. */\nexport interface ExperimentalNavigationInterceptOptions extends NavigationInterceptOptions {\n  precommitHandler?: (controller: NavigationPrecommitController) => Promise<void>;\n}\n\nexport interface NavigationPrecommitController {\n  redirect: (url: string, options?: NavigationNavigateOptions) => void;\n}\n\nexport interface ExperimentalNavigateEvent extends NavigateEvent {\n  intercept(options?: ExperimentalNavigationInterceptOptions): void;\n\n  precommitHandler?: () => Promise<void>;\n}\n\n/**\n * Fake equivalent of `NavigateEvent`.\n */\nexport interface FakeNavigateEvent extends ExperimentalNavigateEvent {\n  readonly destination: FakeNavigationDestination;\n}\n\ninterface InternalFakeNavigateEvent extends FakeNavigateEvent {\n  readonly sameDocument: boolean;\n  readonly result: InternalNavigationResult;\n  interceptionState: 'none' | 'intercepted' | 'committed' | 'scrolled' | 'finished';\n  scrollBehavior: 'after-transition' | 'manual' | null;\n  focusResetBehavior: 'after-transition' | 'manual' | null;\n\n  abortController: AbortController;\n  cancel(reason: Error): void;\n}\n\n/**\n * Create a fake equivalent of `NavigateEvent`. This is not a class because ES5\n * transpiled JavaScript cannot extend native Event.\n *\n * https://html.spec.whatwg.org/multipage/nav-history-apis.html#navigate-event-firing\n */\nfunction dispatchNavigateEvent({\n  cancelable,\n  canIntercept,\n  userInitiated,\n  hashChange,\n  navigationType,\n  destination,\n  info,\n  sameDocument,\n  result,\n}: {\n  cancelable: boolean;\n  canIntercept: boolean;\n  userInitiated: boolean;\n  hashChange: boolean;\n  navigationType: NavigationTypeString;\n  destination: FakeNavigationDestination;\n  info: unknown;\n  sameDocument: boolean;\n  result: InternalNavigationResult;\n}) {\n  const {navigation} = result;\n\n  const eventAbortController = new AbortController();\n  const event = new Event('navigate', {bubbles: false, cancelable}) as {\n    -readonly [P in keyof InternalFakeNavigateEvent]: InternalFakeNavigateEvent[P];\n  };\n\n  event.navigationType = navigationType;\n  event.destination = destination;\n  event.canIntercept = canIntercept;\n  event.userInitiated = userInitiated;\n  event.hashChange = hashChange;\n  event.signal = eventAbortController.signal;\n  event.abortController = eventAbortController;\n  event.info = info;\n  event.focusResetBehavior = null;\n  event.scrollBehavior = null;\n  event.interceptionState = 'none';\n  event.downloadRequest = null;\n  event.formData = null;\n  event.result = result;\n  event.sameDocument = sameDocument;\n\n  let precommitHandlers: Array<(controller: NavigationPrecommitController) => Promise<void>> = [];\n  let handlers: Array<() => Promise<void>> = [];\n\n  // https://whatpr.org/html/10919/nav-history-apis.html#dom-navigateevent-intercept\n  event.intercept = function (\n    this: InternalFakeNavigateEvent,\n    options?: ExperimentalNavigationInterceptOptions,\n  ): void {\n    if (!this.canIntercept) {\n      throw new DOMException(`Cannot intercept when canIntercept is 'false'`, 'SecurityError');\n    }\n    this.interceptionState = 'intercepted';\n    event.sameDocument = true;\n    const precommitHandler = options?.precommitHandler;\n    if (precommitHandler) {\n      if (!this.cancelable) {\n        throw new DOMException(\n          `Cannot use precommitHandler when cancelable is 'false'`,\n          'InvalidStateError',\n        );\n      }\n      precommitHandlers.push(precommitHandler);\n    }\n    if (event.interceptionState !== 'none' && event.interceptionState !== 'intercepted') {\n      throw new Error('Event interceptionState should be \"none\" or \"intercepted\"');\n    }\n    event.interceptionState = 'intercepted';\n    const handler = options?.handler;\n    if (handler) {\n      handlers.push(handler);\n    }\n    // override old options with new ones. UA _may_ report a console warning if new options differ from previous\n    event.focusResetBehavior = options?.focusReset ?? event.focusResetBehavior;\n    event.scrollBehavior = options?.scroll ?? event.scrollBehavior;\n  };\n\n  // https://whatpr.org/html/10919/nav-history-apis.html#dom-navigateevent-scroll\n  event.scroll = function (this: InternalFakeNavigateEvent): void {\n    if (event.interceptionState !== 'committed') {\n      throw new DOMException(\n        `Failed to execute 'scroll' on 'NavigateEvent': scroll() must be ` +\n          `called after commit() and interception options must specify manual scroll.`,\n        'InvalidStateError',\n      );\n    }\n    processScrollBehavior(event);\n  };\n\n  // https://whatpr.org/html/10919/nav-history-apis.html#dom-navigationprecommitcontroller-redirect\n  function redirect(url: string, options: NavigationNavigateOptions = {}) {\n    if (event.interceptionState === 'none') {\n      throw new Error('cannot redirect when event is not intercepted');\n    }\n    if (event.interceptionState !== 'intercepted') {\n      throw new DOMException(\n        `cannot redirect when event is not in 'intercepted' state`,\n        'InvalidStateError',\n      );\n    }\n    if (event.navigationType !== 'push' && event.navigationType !== 'replace') {\n      throw new DOMException(\n        `cannot redirect when navigationType is not 'push' or 'replace`,\n        'InvalidStateError',\n      );\n    }\n    const destinationUrl = new URL(url, navigation.currentEntry.url!);\n    if (options.history === 'push' || options.history === 'replace') {\n      event.navigationType = options.history;\n    }\n    if (options.hasOwnProperty('state')) {\n      event.destination.state = options.state;\n    }\n    event.destination.url = destinationUrl.href;\n    if (options.hasOwnProperty('info')) {\n      event.info = options.info;\n    }\n  }\n\n  // https://whatpr.org/html/10919/nav-history-apis.html#inner-navigate-event-firing-algorithm\n  // \"Let commit be the following steps:\"\n  function commit() {\n    if (result.signal.aborted) {\n      return;\n    }\n    (navigation.transition as InternalNavigationTransition)?.committedResolve();\n    if (event.interceptionState === 'intercepted') {\n      event.interceptionState = 'committed';\n      switch (event.navigationType) {\n        case 'push':\n        case 'replace': {\n          navigation.urlAndHistoryUpdateSteps(event);\n          break;\n        }\n        case 'reload': {\n          navigation.updateNavigationEntriesForSameDocumentNavigation(event);\n          break;\n        }\n        case 'traverse': {\n          navigation.userAgentTraverse(event);\n          break;\n        }\n      }\n    }\n    const promisesList = handlers.map((handler) => handler());\n    if (promisesList.length === 0) {\n      promisesList.push(Promise.resolve());\n    }\n    Promise.all(promisesList)\n      .then(() => {\n        // Follows steps outlined under \"Wait for all of promisesList, with the following success steps:\"\n        // in the spec https://html.spec.whatwg.org/multipage/nav-history-apis.html#navigate-event-firing.\n        if (result.signal.aborted) {\n          return;\n        }\n        if (event !== navigation.navigateEvent) {\n          if (!result.signal.aborted && result.committedTo) {\n            result.finishedReject(\n              new DOMException('Navigation superseded before handler completion', 'AbortError'),\n            );\n          }\n          return;\n        }\n        navigation.navigateEvent = null;\n        finishNavigationEvent(event, true);\n        result.finishedResolve();\n        const navigatesuccessEvent = new Event('navigatesuccess', {\n          bubbles: false,\n          cancelable: false,\n        });\n        navigation.eventTarget.dispatchEvent(navigatesuccessEvent);\n        (navigation.transition as InternalNavigationTransition)?.finishedResolve();\n        navigation.transition = null;\n      })\n      .catch((reason) => {\n        if (!event.abortController.signal.aborted) {\n          event.cancel(reason);\n        }\n      });\n  }\n\n  // Internal only.\n  // https://whatpr.org/html/10919/nav-history-apis.html#inner-navigate-event-firing-algorithm\n  // \"Let cancel be the following steps given reason\"\n  event.cancel = function (this: InternalFakeNavigateEvent, reason: Error) {\n    if (result.signal.aborted) {\n      return;\n    }\n    this.abortController.abort(reason);\n    const isCurrentGlobalNavigationEvent = this === navigation.navigateEvent;\n    if (isCurrentGlobalNavigationEvent) {\n      navigation.navigateEvent = null;\n    }\n    if (this.interceptionState !== 'intercepted' && this.interceptionState !== 'finished') {\n      finishNavigationEvent(this, false);\n    } else if (this.interceptionState === 'intercepted') {\n      this.interceptionState = 'finished';\n    }\n    result.committedReject(reason);\n    result.finishedReject(reason);\n    const navigateerrorEvent = new Event('navigateerror', {\n      bubbles: false,\n      cancelable,\n    }) as ErrorEvent;\n    (navigateerrorEvent as unknown as {error: Error}).error = reason;\n    navigation.eventTarget.dispatchEvent(navigateerrorEvent);\n    const transition = navigation.transition as InternalNavigationTransition | undefined;\n    transition?.committedReject(reason);\n    transition?.finishedReject(reason);\n    navigation.transition = null;\n  };\n\n  function dispatch() {\n    navigation.navigateEvent = event;\n    const dispatchResult = navigation.eventTarget.dispatchEvent(event);\n\n    if (event.interceptionState === 'intercepted') {\n      if (!navigation.currentEntry) {\n        event.cancel(\n          new DOMException(\n            'Cannot create transition without a currentEntry for intercepted navigation.',\n            'InvalidStateError',\n          ),\n        );\n        return;\n      }\n      const transition = new InternalNavigationTransition(navigation.currentEntry, navigationType);\n      navigation.transition = transition;\n      // Mark transition.finished as handled (Spec Step 33.4)\n      transition.finished.catch(() => {});\n      transition.committed.catch(() => {});\n    }\n    if (!dispatchResult && event.cancelable) {\n      if (!event.abortController.signal.aborted) {\n        event.cancel(\n          new DOMException('Navigation prevented by event.preventDefault()', 'AbortError'),\n        );\n      }\n    } else {\n      if (precommitHandlers.length === 0) {\n        commit();\n      } else {\n        const precommitController: NavigationPrecommitController = {redirect};\n        const precommitPromisesList = precommitHandlers.map((handler) => {\n          let p: Promise<void>;\n          try {\n            p = handler(precommitController);\n          } catch (e) {\n            p = Promise.reject(e);\n          }\n          p.catch(() => {});\n          return p;\n        });\n        Promise.all(precommitPromisesList)\n          .then(() => commit())\n          .catch((reason: Error) => {\n            if (event.abortController.signal.aborted) {\n              return;\n            }\n            if (navigation.transition) {\n              (navigation.transition as InternalNavigationTransition).committedReject(reason);\n            }\n            event.cancel(reason);\n          });\n      }\n    }\n  }\n\n  dispatch();\n  return event.interceptionState === 'none';\n}\n\n/** https://whatpr.org/html/10919/nav-history-apis.html#navigateevent-finish */\nfunction finishNavigationEvent(event: InternalFakeNavigateEvent, didFulfill: boolean) {\n  if (event.interceptionState === 'finished') {\n    throw new Error('Attempting to finish navigation event that was already finished');\n  }\n  if (event.interceptionState === 'intercepted') {\n    if (didFulfill === true) {\n      throw new Error('didFulfill should be false');\n    }\n    event.interceptionState = 'finished';\n    return;\n  }\n  if (event.interceptionState === 'none') {\n    return;\n  }\n  potentiallyResetFocus(event);\n  if (didFulfill) {\n    potentiallyResetScroll(event);\n  }\n  event.interceptionState = 'finished';\n}\n\n/** https://whatpr.org/html/10919/nav-history-apis.html#potentially-reset-the-focus */\nfunction potentiallyResetFocus(event: InternalFakeNavigateEvent) {\n  if (event.interceptionState !== 'committed' && event.interceptionState !== 'scrolled') {\n    throw new Error('cannot reset focus if navigation event is not committed or scrolled');\n  }\n  if (event.focusResetBehavior === 'manual') {\n    return;\n  }\n  // TODO(atscott): the rest of the steps\n}\n\nfunction potentiallyResetScroll(event: InternalFakeNavigateEvent) {\n  if (event.interceptionState !== 'committed' && event.interceptionState !== 'scrolled') {\n    throw new Error('cannot reset scroll if navigation event is not committed or scrolled');\n  }\n  if (event.interceptionState === 'scrolled' || event.scrollBehavior === 'manual') {\n    return;\n  }\n  processScrollBehavior(event);\n}\n\n/* https://whatpr.org/html/10919/nav-history-apis.html#process-scroll-behavior */\nfunction processScrollBehavior(event: InternalFakeNavigateEvent) {\n  if (event.interceptionState !== 'committed') {\n    throw new Error('invalid event interception state when processing scroll behavior');\n  }\n  event.interceptionState = 'scrolled';\n  // TODO(atscott): the rest of the steps\n}\n\n/** Fake equivalent of `NavigationCurrentEntryChangeEvent`. */\nexport interface FakeNavigationCurrentEntryChangeEvent extends NavigationCurrentEntryChangeEvent {\n  readonly from: FakeNavigationHistoryEntry;\n}\n\n/**\n * Create a fake equivalent of `NavigationCurrentEntryChange`. This does not use\n * a class because ES5 transpiled JavaScript cannot extend native Event.\n */\nfunction createFakeNavigationCurrentEntryChangeEvent({\n  from,\n  navigationType,\n}: {\n  from: FakeNavigationHistoryEntry;\n  navigationType: NavigationTypeString;\n}) {\n  const event = new Event('currententrychange', {\n    bubbles: false,\n    cancelable: false,\n  }) as {\n    -readonly [P in keyof NavigationCurrentEntryChangeEvent]: NavigationCurrentEntryChangeEvent[P];\n  };\n  event.from = from;\n  event.navigationType = navigationType;\n  return event as FakeNavigationCurrentEntryChangeEvent;\n}\n\n/**\n * Create a fake equivalent of `PopStateEvent`. This does not use a class\n * because ES5 transpiled JavaScript cannot extend native Event.\n */\nfunction createPopStateEvent({state}: {state: unknown}) {\n  const event = new Event('popstate', {\n    bubbles: false,\n    cancelable: false,\n  }) as {-readonly [P in keyof PopStateEvent]: PopStateEvent[P]};\n  event.state = state;\n  return event as PopStateEvent;\n}\n\nfunction createHashChangeEvent(newURL: string, oldURL: string) {\n  const event = new Event('hashchange', {\n    bubbles: false,\n    cancelable: false,\n  }) as {-readonly [P in keyof HashChangeEvent]: HashChangeEvent[P]};\n  event.newURL = newURL;\n  event.oldURL = oldURL;\n  return event as HashChangeEvent;\n}\n\n/**\n * Fake equivalent of `NavigationDestination`.\n */\nexport class FakeNavigationDestination implements NavigationDestination {\n  url: string;\n  readonly sameDocument: boolean;\n  readonly key: string | null;\n  readonly id: string | null;\n  readonly index: number;\n\n  state?: unknown;\n  private readonly historyState: unknown;\n\n  constructor({\n    url,\n    sameDocument,\n    historyState,\n    state,\n    key = null,\n    id = null,\n    index = -1,\n  }: {\n    url: string;\n    sameDocument: boolean;\n    historyState: unknown;\n    state?: unknown;\n    key?: string | null;\n    id?: string | null;\n    index?: number;\n  }) {\n    this.url = url;\n    this.sameDocument = sameDocument;\n    this.state = state;\n    this.historyState = historyState;\n    this.key = key;\n    this.id = id;\n    this.index = index;\n  }\n\n  getState(): unknown {\n    return this.state;\n  }\n\n  getHistoryState(): unknown {\n    return this.historyState;\n  }\n}\n\n/** Utility function to determine whether two UrlLike have the same hash. */\nfunction isHashChange(from: URL, to: URL): boolean {\n  return (\n    to.hash !== from.hash &&\n    to.hostname === from.hostname &&\n    to.pathname === from.pathname &&\n    to.search === from.search\n  );\n}\n\nclass InternalNavigationTransition implements NavigationTransition {\n  readonly finished: Promise<void>;\n  readonly committed: Promise<void>;\n  finishedResolve!: () => void;\n  finishedReject!: (reason: Error) => void;\n  committedResolve!: () => void;\n  committedReject!: (reason: Error) => void;\n  constructor(\n    readonly from: NavigationHistoryEntry,\n    readonly navigationType: NavigationTypeString,\n  ) {\n    this.finished = new Promise<void>((resolve, reject) => {\n      this.finishedReject = reject;\n      this.finishedResolve = resolve;\n    });\n    this.committed = new Promise<void>((resolve, reject) => {\n      this.committedReject = reject;\n      this.committedResolve = resolve;\n    });\n    // All rejections are handled.\n    this.finished.catch(() => {});\n    this.committed.catch(() => {});\n  }\n}\n\n/**\n * Internal utility class for representing the result of a navigation.\n * Generally equivalent to the \"apiMethodTracker\" in the spec.\n */\nclass InternalNavigationResult {\n  committedTo: FakeNavigationHistoryEntry | null = null;\n  committedResolve!: (entry: FakeNavigationHistoryEntry) => void;\n  committedReject!: (reason: Error) => void;\n  finishedResolve!: () => void;\n  finishedReject!: (reason: Error) => void;\n  readonly committed: Promise<FakeNavigationHistoryEntry>;\n  readonly finished: Promise<FakeNavigationHistoryEntry>;\n  get signal(): AbortSignal {\n    return this.abortController.signal;\n  }\n  private readonly abortController = new AbortController();\n\n  constructor(readonly navigation: FakeNavigation) {\n    this.committed = new Promise<FakeNavigationHistoryEntry>((resolve, reject) => {\n      this.committedResolve = (entry) => {\n        this.committedTo = entry;\n        resolve(entry);\n      };\n      this.committedReject = reject;\n    });\n\n    this.finished = new Promise<FakeNavigationHistoryEntry>((resolve, reject) => {\n      this.finishedResolve = () => {\n        if (this.committedTo === null) {\n          throw new Error(\n            'NavigateEvent should have been committed before resolving finished promise.',\n          );\n        }\n        resolve(this.committedTo);\n      };\n      this.finishedReject = (reason: Error) => {\n        reject(reason);\n        this.abortController.abort(reason);\n      };\n    });\n    // All rejections are handled.\n    this.committed.catch(() => {});\n    this.finished.catch(() => {});\n  }\n}\n\n/** Internal options for performing a navigate. */\ninterface InternalNavigateOptions {\n  navigationType: NavigationTypeString;\n  cancelable: boolean;\n  canIntercept: boolean;\n  userInitiated: boolean;\n  hashChange: boolean;\n  info?: unknown;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\n/**\n * Public Test Library for unit testing Angular applications. Assumes that you are running\n * with Jasmine, Mocha, or a similar framework which exports a beforeEach function and\n * allows tests to be asynchronous by either returning a promise or using a 'done' parameter.\n */\n\nimport {resetFakeAsyncZoneIfExists} from './fake_async';\nimport {TestBedImpl} from './test_bed';\n\n// Reset the test providers and the fake async zone before each test.\n// We keep a guard because somehow this file can make it into a bundle and be executed\n// beforeEach is only defined when executing the tests\nglobalThis.beforeEach?.(getCleanupHook(false));\n\n// We provide both a `beforeEach` and `afterEach`, because the updated behavior for\n// tearing down the module is supposed to run after the test so that we can associate\n// teardown errors with the correct test.\n// We keep a guard because somehow this file can make it into a bundle and be executed\n// afterEach is only defined when executing the tests\nglobalThis.afterEach?.(getCleanupHook(true));\n\nexport function getCleanupHook(expectedTeardownValue: boolean): VoidFunction {\n  return () => {\n    const testBed = TestBedImpl.INSTANCE;\n    if (testBed.shouldTearDownTestingModule() === expectedTeardownValue) {\n      testBed.resetTestingModule();\n      resetFakeAsyncZoneIfExists();\n    }\n  };\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Injectable} from '../../src/core';\n\n@Injectable()\nexport class Log<T = string> {\n  logItems: T[];\n\n  constructor() {\n    this.logItems = [];\n  }\n\n  add(value: T): void {\n    this.logItems.push(value);\n  }\n\n  fn(value: T) {\n    return () => {\n      this.logItems.push(value);\n    };\n  }\n\n  clear(): void {\n    this.logItems = [];\n  }\n\n  result(): string {\n    return this.logItems.join('; ');\n  }\n}\n"],"names":["asyncTest","_Zone","__symbol__","fn","Promise","reject","userErrorHandler","whenStableRejectFunctions","Set","zone","runOutsideAngular","injector","get","ErrorHandler","handleError","e","userError","size","values","DeferBlockFixture","block","render","state","hasStateTemplate","Error","stateAsString","componentFixture","detectChanges","deferBlocks","lContainer","length","CONTAINER_HEADER_OFFSET","lView","getDeferBlocks","deferBlockFixtures","push","resolve","DeferBlockState","Placeholder","Loading","errorTmplIndex","Complete","THROW_ON_UNKNOWN_PROPERTIES_DEFAULT","ANIMATIONS_ENABLED_DEFAULT","TestComponentRenderer","insertRootElement","rootElementId","tagName","ComponentFixture","componentRef","componentInstance","nativeElement","changeDetectorRef","_noZoneOptionIsSet","inject","ComponentFixtureNoNgZone","optional","NoopNgZone","NgZone","pendingTasks","PendingTasksInternal","appErrorHandler","TestBedApplicationErrorHandler","zonelessEnabled","ZONELESS_ENABLED","autoDetectDefault","ComponentFixtureAutoDetect","Subscription","_ngZone","constructor","elementRef","location","instance","_testAppRef","allTestViews","add","hostView","autoDetect","autoDetectTestViews","notify","onDestroy","delete","onError","subscribe","Zone","current","error","checkNoChanges","originalCheckNoChanges","includeAllTestViews","_appRef","tick","run","rootEffectScheduler","flush","isStable","hasPendingTasks","resetFakeAsyncZone","withFakeAsyncTestModule","v","overrideMetadata","metadataClass","oldMetadata","override","props","remove","stringify","setMetadata","set","removeMetadata","_references","metadata","references","removeObjects","prop","removeValue","forEach","value","_propHashKey","propValue","filter","has","undefined","addMetadata","Array","isArray","addValue","nextObjectId","objectIds","Map","replacer","key","propName","JSON","_serializeReference","ref","id","_nextReferenceId","OverrideResolver","overrides","resolved","addOverride","type","setOverrides","clear","annotations","reflection","i","annotation","isKnownType","Directive","Component","Pipe","NgModule","getAnnotation","overrider","MetadataOverrider","TestingModuleOverride","DECLARATION","OVERRIDE_TEMPLATE","assertNoStandaloneComponents","types","resolver","getAsyncClassMetadataFn","component","standalone","ɵgenerateStandaloneInDeclarationsError","TestBedCompiler","declarations","imports","schemas","pendingComponents","pendingPipes","componentsWithAsyncMetadata","seenComponents","seenDirectives","resolvers","initResolvers","componentToModuleScope","initialNgDefs","defCleanupOps","compilerProviders","providerOverrides","rootProviderOverrides","providerOverridesByModule","providerOverridesByToken","scopesWithOverriddenProviders","rethrowApplicationTickErrors","RETHROW_APPLICATION_ERRORS_DEFAULT","platform","additionalModuleTypes","DynamicTestModule","testModuleType","setCompilerProviders","providers","_injector","configureTestingModule","moduleDef","queueTypeArray","deferBlockBehavior","DEFER_BLOCK_DEFAULT_BEHAVIOR","animationsEnabled","rethrowApplicationErrors","overrideModule","ngModule","overriddenModules","module","name","recompileNgModule","overrideComponent","verifyNoStandaloneFlagOverrides","overrideDirective","directive","overridePipe","pipe","hasOwnProperty","overrideProvider","token","provider","providerDef","useFactory","provide","deps","useValue","multi","injectableDef","getInjectableDef","providedIn","resolveForwardRef","overridesBucket","existingOverrides","overrideTemplateUsingTestingModule","template","def","NG_COMP_DEF","hasStyleUrls","styleUrl","styleUrls","overrideStyleUrls","styles","existingComponentStyles","resolvePendingComponentsWithAsyncMetadata","asyncMetadataFn","promises","resolvedDeps","all","flat","queueTypesFromModulesArray","applyProviderOverridesInScope","compileComponents","needsAsyncResources","compileTypesSync","resourceLoader","ResourceLoader","ɵresolveComponentResources","compileTestModule","patchComponentsWithExistingStyles","parentInjector","testModuleRef","NgModuleRef","LOCALE_ID","DEFAULT_LOCALE_ID","setLocaleId","localeId","_compileNgModuleSync","moduleType","_compileNgModuleAsync","_getModuleResolver","ɵmod","reduce","factories","declaration","componentDef","ɵcmp","ɵisComponentDefPendingResolution","compilePipe","testingModuleDef","NG_MOD_DEF","affectedModules","moduleToScope","getScopeOfModule","isTestingModuleOverride","realType","isTestingModule","transitiveScopesFor","componentType","storeFieldOfDefOnType","patchComponentDefWithScope","getComponentDef","moduleScope","field","maybeApplyOverrides","NG_DIR_DEF","hasScope","isStandaloneComponent","isNgModule","dependencies","maybeUnwrapFn","dependency","injectorDef","getOverriddenProviders","importedModule","flatten","isModuleWithProviders","object","fieldName","arr","NG_INJ_DEF","maybeRegisterComponentWithAsyncMetadata","NG_PIPE_DEF","queueTypesFromModulesArrayRecur","processedDefs","exports","queueType","hasNgModuleDef","calcAffectedModulesRecur","path","seenModules","item","concat","maybeStoreNgDef","currentDef","Object","getOwnPropertyDescriptor","currentDefs","defField","originalValue","clearComponentResolutionQueue","originalComponentResolutionQueue","ɵrestoreComponentResolutionQueue","restoreOriginalState","op","defs","descriptor","defineProperty","RootScopeModule","provideZonelessChangeDetectionInternal","ENVIRONMENT_INITIALIZER","_nextRootElementId","TestBedImpl","_environmentTeardownOptions","resetTestEnvironment","INSTANCE","overrideTemplate","notFoundValue","options","runInInjectionContext","resetTestingModule","execute","context","_testModuleRef","globalCompilationChecked","_environmentErrorOnUnknownPropertiesOption","errorOnUnknownProperties","_compiler","setAllowDuplicateNgModuleIdsForTest","resetCompiledComponents","compiler","setUnknownElementStrictMode","_previousErrorOnUnknownElementsOption","THROW_ON_UNKNOWN_ELEMENTS_DEFAULT","setUnknownPropertyStrictMode","_previousErrorOnUnknownPropertiesOption","destroyActiveFixtures","shouldTearDownTestingModule","_instanceErrorOnUnknownElementsOption","_instanceErrorOnUnknownPropertiesOption","_instanceAnimationsEnabled","useJit","assertNotInstantiated","shouldThrowErrorOnUnknownElements","getUnknownPropertyStrictMode","TestBed","result","UNDEFINED","EnvironmentInjector","params","tokens","map","t","apply","canSetInitialEntry","eventTarget","entriesArr","currentEntryIndex","canGoBack","createEventTarget","_window","window","doc","startURL","EventTarget","document","defaultView","setInitialEntryForTesting","url","historyState","String","nextKey","currentInitialEntry","nextId","sameDocument","canSetInitialEntryForTesting","setSynchronousTraversalsForTesting","synchronousTraversals","navigate","toUrl","URL","currentEntry","navigationType","history","isHashChange","fromUrl","FakeNavigationDestination","toString","hashChange","InternalNavigationResult","intercepted","userAgentNavigate","destination","cancelable","canIntercept","info","committed","finished","pushOrReplaceState","data","title","_title","navigateEvent","traverseTo","entry","findEntry","catch","existingResult","traversalQueue","getState","getHistoryState","prospectiveEntryIndex","index","runTraversal","userAgentTraverse","back","domException","DOMException","go","direction","targetIndex","userInitiated","traversal","nextTraversal","then","addEventListener","callback","dispatchEvent","event","dispose","disposed","isDisposed","abortOngoingNavigation","eventToAbort","reason","abortController","signal","aborted","abortReason","cancel","dispatchResultIsTrueIfNoInterception","dispatchNavigateEvent","urlAndHistoryUpdateSteps","popStateEvent","hashchangeEvent","createHashChangeEvent","oldUrl","updateNavigationEntriesForSameDocumentNavigation","oldCurrentNHE","disposedNHEs","splice","newNHE","FakeNavigationHistoryEntry","createFakeNavigationCurrentEntryChangeEvent","currentEntryChangeEvent","disposedNHE","onnavigate","oncurrententrychange","_handler","onnavigatesuccess","onnavigateerror","_transition","transition","updateCurrentEntry","_options","reload","ondispose","parse","removeEventListener","disposeEvent","Event","navigation","eventAbortController","focusResetBehavior","scrollBehavior","interceptionState","downloadRequest","formData","precommitHandlers","intercept","precommitHandler","handler","handlers","focusReset","scroll","processScrollBehavior","redirect","destinationUrl","href","commit","promisesList","committedTo","finishedReject","finishNavigationEvent","finishedResolve","bubbles","navigatesuccessEvent","abort","isCurrentGlobalNavigationEvent","committedReject","navigateerrorEvent","dispatchResult","globalThis","afterEach","getCleanupHook","expectedTeardownValue","testBed","logItems"],"mappings":"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"}
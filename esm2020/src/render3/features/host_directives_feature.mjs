import { EMPTY_OBJ } from '../../util/empty';
/**
 * This feature add the host directives behavior to a directive definition by patching a
 * function onto it. The expectation is that the runtime will invoke the function during
 * directive matching.
 *
 * For example:
 * ```ts
 * class ComponentWithHostDirective {
 *   static ɵcmp = defineComponent({
 *    type: ComponentWithHostDirective,
 *    features: [ɵɵHostDirectivesFeature([
 *      SimpleHostDirective,
 *      {directive: AdvancedHostDirective, inputs: ['foo: alias'], outputs: ['bar']},
 *    ])]
 *  });
 * }
 * ```
 *
 * @codeGenApi
 */
export function ɵɵHostDirectivesFeature(rawHostDirectives) {
    const unwrappedHostDirectives = Array.isArray(rawHostDirectives) ? rawHostDirectives : rawHostDirectives();
    const hostDirectives = unwrappedHostDirectives.map(dir => typeof dir === 'function' ? { directive: dir, inputs: EMPTY_OBJ, outputs: EMPTY_OBJ } : {
        directive: dir.directive,
        inputs: bindingArrayToMap(dir.inputs),
        outputs: bindingArrayToMap(dir.outputs)
    });
    return (definition) => {
        // TODO(crisbeto): implement host directive matching logic.
        definition.applyHostDirectives =
            (tView, viewData, tNode, matches) => { };
    };
}
/**
 * Converts an array in the form of `['publicName', 'alias', 'otherPublicName', 'otherAlias']` into
 * a map in the form of `{publicName: 'alias', otherPublicName: 'otherAlias'}`.
 */
function bindingArrayToMap(bindings) {
    if (!bindings || bindings.length === 0) {
        return EMPTY_OBJ;
    }
    const result = {};
    for (let i = 1; i < bindings.length; i += 2) {
        result[bindings[i - 1]] = bindings[i];
    }
    return result;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaG9zdF9kaXJlY3RpdmVzX2ZlYXR1cmUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9jb3JlL3NyYy9yZW5kZXIzL2ZlYXR1cmVzL2hvc3RfZGlyZWN0aXZlc19mZWF0dXJlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQVFBLE9BQU8sRUFBQyxTQUFTLEVBQUMsTUFBTSxrQkFBa0IsQ0FBQztBQVkzQzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQW1CRztBQUNILE1BQU0sVUFBVSx1QkFBdUIsQ0FBQyxpQkFDZ0M7SUFDdEUsTUFBTSx1QkFBdUIsR0FDekIsS0FBSyxDQUFDLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztJQUMvRSxNQUFNLGNBQWMsR0FBRyx1QkFBdUIsQ0FBQyxHQUFHLENBQzlDLEdBQUcsQ0FBQyxFQUFFLENBQUMsT0FBTyxHQUFHLEtBQUssVUFBVSxDQUFDLENBQUMsQ0FBQyxFQUFDLFNBQVMsRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLFNBQVMsRUFBRSxPQUFPLEVBQUUsU0FBUyxFQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzNGLFNBQVMsRUFBRSxHQUFHLENBQUMsU0FBUztRQUN4QixNQUFNLEVBQUUsaUJBQWlCLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQztRQUNyQyxPQUFPLEVBQUUsaUJBQWlCLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQztLQUN4QyxDQUFDLENBQUM7SUFFUCxPQUFPLENBQUMsVUFBaUMsRUFBRSxFQUFFO1FBQzNDLDJEQUEyRDtRQUMzRCxVQUFVLENBQUMsbUJBQW1CO1lBQzFCLENBQUMsS0FBWSxFQUFFLFFBQWUsRUFBRSxLQUF3RCxFQUN2RixPQUFjLEVBQUUsRUFBRSxHQUFFLENBQUMsQ0FBQztJQUM3QixDQUFDLENBQUM7QUFDSixDQUFDO0FBRUQ7OztHQUdHO0FBQ0gsU0FBUyxpQkFBaUIsQ0FBQyxRQUE0QjtJQUNyRCxJQUFJLENBQUMsUUFBUSxJQUFJLFFBQVEsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1FBQ3RDLE9BQU8sU0FBUyxDQUFDO0tBQ2xCO0lBRUQsTUFBTSxNQUFNLEdBQW1DLEVBQUUsQ0FBQztJQUVsRCxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsUUFBUSxDQUFDLE1BQU0sRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFO1FBQzNDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ3ZDO0lBRUQsT0FBTyxNQUFNLENBQUM7QUFDaEIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuaW1wb3J0IHtUeXBlfSBmcm9tICcuLi8uLi9pbnRlcmZhY2UvdHlwZSc7XG5pbXBvcnQge0VNUFRZX09CSn0gZnJvbSAnLi4vLi4vdXRpbC9lbXB0eSc7XG5pbXBvcnQge0RpcmVjdGl2ZURlZn0gZnJvbSAnLi4vaW50ZXJmYWNlcy9kZWZpbml0aW9uJztcbmltcG9ydCB7VENvbnRhaW5lck5vZGUsIFRFbGVtZW50Q29udGFpbmVyTm9kZSwgVEVsZW1lbnROb2RlfSBmcm9tICcuLi9pbnRlcmZhY2VzL25vZGUnO1xuaW1wb3J0IHtMVmlldywgVFZpZXd9IGZyb20gJy4uL2ludGVyZmFjZXMvdmlldyc7XG5cbi8qKiBWYWx1ZXMgdGhhdCBjYW4gYmUgdXNlZCB0byBkZWZpbmUgYSBob3N0IGRpcmVjdGl2ZSB0aHJvdWdoIHRoZSBgSG9zdERpcmVjdGl2ZXNGZWF0dXJlYC4gKi9cbnR5cGUgSG9zdERpcmVjdGl2ZURlZmluaXRvbiA9IFR5cGU8dW5rbm93bj58e1xuICBkaXJlY3RpdmU6IFR5cGU8dW5rbm93bj47XG4gIGlucHV0cz86IHN0cmluZ1tdO1xuICBvdXRwdXRzPzogc3RyaW5nW107XG59O1xuXG4vKipcbiAqIFRoaXMgZmVhdHVyZSBhZGQgdGhlIGhvc3QgZGlyZWN0aXZlcyBiZWhhdmlvciB0byBhIGRpcmVjdGl2ZSBkZWZpbml0aW9uIGJ5IHBhdGNoaW5nIGFcbiAqIGZ1bmN0aW9uIG9udG8gaXQuIFRoZSBleHBlY3RhdGlvbiBpcyB0aGF0IHRoZSBydW50aW1lIHdpbGwgaW52b2tlIHRoZSBmdW5jdGlvbiBkdXJpbmdcbiAqIGRpcmVjdGl2ZSBtYXRjaGluZy5cbiAqXG4gKiBGb3IgZXhhbXBsZTpcbiAqIGBgYHRzXG4gKiBjbGFzcyBDb21wb25lbnRXaXRoSG9zdERpcmVjdGl2ZSB7XG4gKiAgIHN0YXRpYyDJtWNtcCA9IGRlZmluZUNvbXBvbmVudCh7XG4gKiAgICB0eXBlOiBDb21wb25lbnRXaXRoSG9zdERpcmVjdGl2ZSxcbiAqICAgIGZlYXR1cmVzOiBbybXJtUhvc3REaXJlY3RpdmVzRmVhdHVyZShbXG4gKiAgICAgIFNpbXBsZUhvc3REaXJlY3RpdmUsXG4gKiAgICAgIHtkaXJlY3RpdmU6IEFkdmFuY2VkSG9zdERpcmVjdGl2ZSwgaW5wdXRzOiBbJ2ZvbzogYWxpYXMnXSwgb3V0cHV0czogWydiYXInXX0sXG4gKiAgICBdKV1cbiAqICB9KTtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBjb2RlR2VuQXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiDJtcm1SG9zdERpcmVjdGl2ZXNGZWF0dXJlKHJhd0hvc3REaXJlY3RpdmVzOiBIb3N0RGlyZWN0aXZlRGVmaW5pdG9uW118XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCgpID0+IEhvc3REaXJlY3RpdmVEZWZpbml0b25bXSkpIHtcbiAgY29uc3QgdW53cmFwcGVkSG9zdERpcmVjdGl2ZXMgPVxuICAgICAgQXJyYXkuaXNBcnJheShyYXdIb3N0RGlyZWN0aXZlcykgPyByYXdIb3N0RGlyZWN0aXZlcyA6IHJhd0hvc3REaXJlY3RpdmVzKCk7XG4gIGNvbnN0IGhvc3REaXJlY3RpdmVzID0gdW53cmFwcGVkSG9zdERpcmVjdGl2ZXMubWFwKFxuICAgICAgZGlyID0+IHR5cGVvZiBkaXIgPT09ICdmdW5jdGlvbicgPyB7ZGlyZWN0aXZlOiBkaXIsIGlucHV0czogRU1QVFlfT0JKLCBvdXRwdXRzOiBFTVBUWV9PQkp9IDoge1xuICAgICAgICBkaXJlY3RpdmU6IGRpci5kaXJlY3RpdmUsXG4gICAgICAgIGlucHV0czogYmluZGluZ0FycmF5VG9NYXAoZGlyLmlucHV0cyksXG4gICAgICAgIG91dHB1dHM6IGJpbmRpbmdBcnJheVRvTWFwKGRpci5vdXRwdXRzKVxuICAgICAgfSk7XG5cbiAgcmV0dXJuIChkZWZpbml0aW9uOiBEaXJlY3RpdmVEZWY8dW5rbm93bj4pID0+IHtcbiAgICAvLyBUT0RPKGNyaXNiZXRvKTogaW1wbGVtZW50IGhvc3QgZGlyZWN0aXZlIG1hdGNoaW5nIGxvZ2ljLlxuICAgIGRlZmluaXRpb24uYXBwbHlIb3N0RGlyZWN0aXZlcyA9XG4gICAgICAgICh0VmlldzogVFZpZXcsIHZpZXdEYXRhOiBMVmlldywgdE5vZGU6IFRFbGVtZW50Tm9kZXxUQ29udGFpbmVyTm9kZXxURWxlbWVudENvbnRhaW5lck5vZGUsXG4gICAgICAgICBtYXRjaGVzOiBhbnlbXSkgPT4ge307XG4gIH07XG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gYXJyYXkgaW4gdGhlIGZvcm0gb2YgYFsncHVibGljTmFtZScsICdhbGlhcycsICdvdGhlclB1YmxpY05hbWUnLCAnb3RoZXJBbGlhcyddYCBpbnRvXG4gKiBhIG1hcCBpbiB0aGUgZm9ybSBvZiBge3B1YmxpY05hbWU6ICdhbGlhcycsIG90aGVyUHVibGljTmFtZTogJ290aGVyQWxpYXMnfWAuXG4gKi9cbmZ1bmN0aW9uIGJpbmRpbmdBcnJheVRvTWFwKGJpbmRpbmdzOiBzdHJpbmdbXXx1bmRlZmluZWQpIHtcbiAgaWYgKCFiaW5kaW5ncyB8fCBiaW5kaW5ncy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gRU1QVFlfT0JKO1xuICB9XG5cbiAgY29uc3QgcmVzdWx0OiB7W3B1YmxpY05hbWU6IHN0cmluZ106IHN0cmluZ30gPSB7fTtcblxuICBmb3IgKGxldCBpID0gMTsgaSA8IGJpbmRpbmdzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzdWx0W2JpbmRpbmdzW2kgLSAxXV0gPSBiaW5kaW5nc1tpXTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG4iXX0=
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { isRootView } from '../render3/interfaces/type_checks';
import { HEADER_OFFSET, TVIEW } from '../render3/interfaces/view';
import { makeStateKey, TransferState } from '../transfer_state';
import { assertDefined } from '../util/assert';
import { CONTAINERS, ELEMENT_CONTAINERS, NUM_ROOT_NODES } from './interfaces';
/**
 * The name of the key used in the TransferState collection,
 * where hydration information is located.
 */
const TRANSFER_STATE_TOKEN_ID = '__ÉµnghData__';
/**
 * Lookup key used to reference DOM hydration data (ngh) in `TransferState`.
 */
export const NGH_DATA_KEY = makeStateKey(TRANSFER_STATE_TOKEN_ID);
/**
 * The name of the attribute that would be added to host component
 * nodes and contain a reference to a particular slot in transferred
 * state that contains the necessary hydration info for this component.
 */
export const NGH_ATTR_NAME = 'ngh';
/**
 * Reference to a function that reads `ngh` attribute value from a given RNode
 * and retrieves hydration information from the TransferState using that value
 * as an index. Returns `null` by default, when hydration is not enabled.
 *
 * @param rNode Component's host element.
 * @param injector Injector that this component has access to.
 */
let _retrieveHydrationInfoImpl = (rNode, injector) => null;
export function retrieveHydrationInfoImpl(rNode, injector) {
    const nghAttrValue = rNode.getAttribute(NGH_ATTR_NAME);
    if (nghAttrValue == null)
        return null;
    let data = {};
    // An element might have an empty `ngh` attribute value (e.g. `<comp ngh="" />`),
    // which means that no special annotations are required. Do not attempt to read
    // from the TransferState in this case.
    if (nghAttrValue !== '') {
        const transferState = injector.get(TransferState, null, { optional: true });
        if (transferState !== null) {
            const nghData = transferState.get(NGH_DATA_KEY, []);
            // The nghAttrValue is always a number referencing an index
            // in the hydration TransferState data.
            data = nghData[Number(nghAttrValue)];
            // If the `ngh` attribute exists and has a non-empty value,
            // the hydration info *must* be present in the TransferState.
            // If there is no data for some reasons, this is an error.
            ngDevMode && assertDefined(data, 'Unable to retrieve hydration info from the TransferState.');
        }
    }
    const dehydratedView = {
        data,
        firstChild: rNode.firstChild ?? null,
    };
    // The `ngh` attribute is cleared from the DOM node now
    // that the data has been retrieved.
    rNode.removeAttribute(NGH_ATTR_NAME);
    // Note: don't check whether this node was claimed for hydration,
    // because this node might've been previously claimed while processing
    // template instructions.
    ngDevMode && markRNodeAsClaimedByHydration(rNode, /* checkIfAlreadyClaimed */ false);
    ngDevMode && ngDevMode.hydratedComponents++;
    return dehydratedView;
}
/**
 * Sets the implementation for the `retrieveNghInfo` function.
 */
export function enableRetrieveHydrationInfoImpl() {
    _retrieveHydrationInfoImpl = retrieveHydrationInfoImpl;
}
/**
 * Retrieves hydration info by reading the value from the `ngh` attribute
 * and accessing a corresponding slot in TransferState storage.
 */
export function retrieveHydrationInfo(rNode, injector) {
    return _retrieveHydrationInfoImpl(rNode, injector);
}
/**
 * Retrieves an instance of a component LView from a given ViewRef.
 * Returns an instance of a component LView or `null` in case of an embedded view.
 */
export function getComponentLViewForHydration(viewRef) {
    // Reading an internal field from `ViewRef` instance.
    let lView = viewRef._lView;
    const tView = lView[TVIEW];
    // A registered ViewRef might represent an instance of an
    // embedded view, in which case we do not need to annotate it.
    if (tView.type === 2 /* TViewType.Embedded */) {
        return null;
    }
    // Check if it's a root view and if so, retrieve component's
    // LView from the first slot after the header.
    if (isRootView(lView)) {
        lView = lView[HEADER_OFFSET];
    }
    return lView;
}
/**
 * Marks a node as "claimed" by hydration process.
 * This is needed to make assessments in tests whether
 * the hydration process handled all nodes.
 */
export function markRNodeAsClaimedByHydration(node, checkIfAlreadyClaimed = true) {
    if (!ngDevMode) {
        throw new Error('Calling `markRNodeAsClaimedByHydration` in prod mode ' +
            'is not supported and likely a mistake.');
    }
    if (checkIfAlreadyClaimed && isRNodeClaimedForHydration(node)) {
        throw new Error('Trying to claim a node, which was claimed already.');
    }
    node.__claimed = true;
    ngDevMode.hydratedNodes++;
}
export function isRNodeClaimedForHydration(node) {
    return !!node.__claimed;
}
export function setSegmentHead(hydrationInfo, index, node) {
    hydrationInfo.segmentHeads ?? (hydrationInfo.segmentHeads = {});
    hydrationInfo.segmentHeads[index] = node;
}
export function getSegmentHead(hydrationInfo, index) {
    return hydrationInfo.segmentHeads?.[index] ?? null;
}
/**
 * Returns the size of an <ng-container>, using either the information
 * serialized in `ELEMENT_CONTAINERS` (element container size) or by
 * computing the sum of root nodes in all dehydrated views in a given
 * container (in case this `<ng-container>` was also used as a view
 * container host node, e.g. <ng-container *ngIf>).
 */
export function getNgContainerSize(hydrationInfo, index) {
    const data = hydrationInfo.data;
    let size = data[ELEMENT_CONTAINERS]?.[index] ?? null;
    // If there is no serialized information available in the `ELEMENT_CONTAINERS` slot,
    // check if we have info about view containers at this location (e.g.
    // `<ng-container *ngIf>`) and use container size as a number of root nodes in this
    // element container.
    if (size === null && data[CONTAINERS]?.[index]) {
        size = calcSerializedContainerSize(hydrationInfo, index);
    }
    return size;
}
export function getSerializedContainerViews(hydrationInfo, index) {
    return hydrationInfo.data[CONTAINERS]?.[index] ?? null;
}
/**
 * Computes the size of a serialized container (the number of root nodes)
 * by calculating the sum of root nodes in all dehydrated views in this container.
 */
export function calcSerializedContainerSize(hydrationInfo, index) {
    const views = getSerializedContainerViews(hydrationInfo, index) ?? [];
    let numNodes = 0;
    for (let view of views) {
        numNodes += view[NUM_ROOT_NODES];
    }
    return numNodes;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9jb3JlL3NyYy9oeWRyYXRpb24vdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0E7Ozs7OztHQU1HO0FBS0gsT0FBTyxFQUFDLFVBQVUsRUFBQyxNQUFNLG1DQUFtQyxDQUFDO0FBQzdELE9BQU8sRUFBQyxhQUFhLEVBQVMsS0FBSyxFQUFZLE1BQU0sNEJBQTRCLENBQUM7QUFDbEYsT0FBTyxFQUFDLFlBQVksRUFBRSxhQUFhLEVBQUMsTUFBTSxtQkFBbUIsQ0FBQztBQUM5RCxPQUFPLEVBQUMsYUFBYSxFQUFDLE1BQU0sZ0JBQWdCLENBQUM7QUFFN0MsT0FBTyxFQUFDLFVBQVUsRUFBMkMsa0JBQWtCLEVBQUUsY0FBYyxFQUEwQyxNQUFNLGNBQWMsQ0FBQztBQUU5Sjs7O0dBR0c7QUFDSCxNQUFNLHVCQUF1QixHQUFHLGNBQWMsQ0FBQztBQUUvQzs7R0FFRztBQUNILE1BQU0sQ0FBQyxNQUFNLFlBQVksR0FBRyxZQUFZLENBQXdCLHVCQUF1QixDQUFDLENBQUM7QUFFekY7Ozs7R0FJRztBQUNILE1BQU0sQ0FBQyxNQUFNLGFBQWEsR0FBRyxLQUFLLENBQUM7QUFFbkM7Ozs7Ozs7R0FPRztBQUNILElBQUksMEJBQTBCLEdBQzFCLENBQUMsS0FBZSxFQUFFLFFBQWtCLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQztBQUVsRCxNQUFNLFVBQVUseUJBQXlCLENBQUMsS0FBZSxFQUFFLFFBQWtCO0lBRTNFLE1BQU0sWUFBWSxHQUFHLEtBQUssQ0FBQyxZQUFZLENBQUMsYUFBYSxDQUFDLENBQUM7SUFDdkQsSUFBSSxZQUFZLElBQUksSUFBSTtRQUFFLE9BQU8sSUFBSSxDQUFDO0lBRXRDLElBQUksSUFBSSxHQUFtQixFQUFFLENBQUM7SUFDOUIsaUZBQWlGO0lBQ2pGLCtFQUErRTtJQUMvRSx1Q0FBdUM7SUFDdkMsSUFBSSxZQUFZ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Q3RCLFFBQVEsSUFBSSxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7S0FDbEM7SUFDRCxPQUFPLFFBQVEsQ0FBQztBQUNsQixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuaW1wb3J0IHtJbmplY3Rvcn0gZnJvbSAnLi4vZGkvaW5qZWN0b3InO1xuaW1wb3J0IHtWaWV3UmVmfSBmcm9tICcuLi9saW5rZXIvdmlld19yZWYnO1xuaW1wb3J0IHtSRWxlbWVudCwgUk5vZGV9IGZyb20gJy4uL3JlbmRlcjMvaW50ZXJmYWNlcy9yZW5kZXJlcl9kb20nO1xuaW1wb3J0IHtpc1Jvb3RWaWV3fSBmcm9tICcuLi9yZW5kZXIzL2ludGVyZmFjZXMvdHlwZV9jaGVja3MnO1xuaW1wb3J0IHtIRUFERVJfT0ZGU0VULCBMVmlldywgVFZJRVcsIFRWaWV3VHlwZX0gZnJvbSAnLi4vcmVuZGVyMy9pbnRlcmZhY2VzL3ZpZXcnO1xuaW1wb3J0IHttYWtlU3RhdGVLZXksIFRyYW5zZmVyU3RhdGV9IGZyb20gJy4uL3RyYW5zZmVyX3N0YXRlJztcbmltcG9ydCB7YXNzZXJ0RGVmaW5lZH0gZnJvbSAnLi4vdXRpbC9hc3NlcnQnO1xuXG5pbXBvcnQge0NPTlRBSU5FUlMsIERlaHlkcmF0ZWRDb250YWluZXJWaWV3LCBEZWh5ZHJhdGVkVmlldywgRUxFTUVOVF9DT05UQUlORVJTLCBOVU1fUk9PVF9OT0RFUywgU2VyaWFsaXplZENvbnRhaW5lclZpZXcsIFNlcmlhbGl6ZWRWaWV3fSBmcm9tICcuL2ludGVyZmFjZXMnO1xuXG4vKipcbiAqIFRoZSBuYW1lIG9mIHRoZSBrZXkgdXNlZCBpbiB0aGUgVHJhbnNmZXJTdGF0ZSBjb2xsZWN0aW9uLFxuICogd2hlcmUgaHlkcmF0aW9uIGluZm9ybWF0aW9uIGlzIGxvY2F0ZWQuXG4gKi9cbmNvbnN0IFRSQU5TRkVSX1NUQVRFX1RPS0VOX0lEID0gJ19fybVuZ2hEYXRhX18nO1xuXG4vKipcbiAqIExvb2t1cCBrZXkgdXNlZCB0byByZWZlcmVuY2UgRE9NIGh5ZHJhdGlvbiBkYXRhIChuZ2gpIGluIGBUcmFuc2ZlclN0YXRlYC5cbiAqL1xuZXhwb3J0IGNvbnN0IE5HSF9EQVRBX0tFWSA9IG1ha2VTdGF0ZUtleTxBcnJheTxTZXJpYWxpemVkVmlldz4+KFRSQU5TRkVSX1NUQVRFX1RPS0VOX0lEKTtcblxuLyoqXG4gKiBUaGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlIHRoYXQgd291bGQgYmUgYWRkZWQgdG8gaG9zdCBjb21wb25lbnRcbiAqIG5vZGVzIGFuZCBjb250YWluIGEgcmVmZXJlbmNlIHRvIGEgcGFydGljdWxhciBzbG90IGluIHRyYW5zZmVycmVkXG4gKiBzdGF0ZSB0aGF0IGNvbnRhaW5zIHRoZSBuZWNlc3NhcnkgaHlkcmF0aW9uIGluZm8gZm9yIHRoaXMgY29tcG9uZW50LlxuICovXG5leHBvcnQgY29uc3QgTkdIX0FUVFJfTkFNRSA9ICduZ2gnO1xuXG4vKipcbiAqIFJlZmVyZW5jZSB0byBhIGZ1bmN0aW9uIHRoYXQgcmVhZHMgYG5naGAgYXR0cmlidXRlIHZhbHVlIGZyb20gYSBnaXZlbiBSTm9kZVxuICogYW5kIHJldHJpZXZlcyBoeWRyYXRpb24gaW5mb3JtYXRpb24gZnJvbSB0aGUgVHJhbnNmZXJTdGF0ZSB1c2luZyB0aGF0IHZhbHVlXG4gKiBhcyBhbiBpbmRleC4gUmV0dXJucyBgbnVsbGAgYnkgZGVmYXVsdCwgd2hlbiBoeWRyYXRpb24gaXMgbm90IGVuYWJsZWQuXG4gKlxuICogQHBhcmFtIHJOb2RlIENvbXBvbmVudCdzIGhvc3QgZWxlbWVudC5cbiAqIEBwYXJhbSBpbmplY3RvciBJbmplY3RvciB0aGF0IHRoaXMgY29tcG9uZW50IGhhcyBhY2Nlc3MgdG8uXG4gKi9cbmxldCBfcmV0cmlldmVIeWRyYXRpb25JbmZvSW1wbDogdHlwZW9mIHJldHJpZXZlSHlkcmF0aW9uSW5mb0ltcGwgPVxuICAgIChyTm9kZTogUkVsZW1lbnQsIGluamVjdG9yOiBJbmplY3RvcikgPT4gbnVsbDtcblxuZXhwb3J0IGZ1bmN0aW9uIHJldHJpZXZlSHlkcmF0aW9uSW5mb0ltcGwock5vZGU6IFJFbGVtZW50LCBpbmplY3RvcjogSW5qZWN0b3IpOiBEZWh5ZHJhdGVkVmlld3xcbiAgICBudWxsIHtcbiAgY29uc3QgbmdoQXR0clZhbHVlID0gck5vZGUuZ2V0QXR0cmlidXRlKE5HSF9BVFRSX05BTUUpO1xuICBpZiAobmdoQXR0clZhbHVlID09IG51bGwpIHJldHVybiBudWxsO1xuXG4gIGxldCBkYXRhOiBTZXJpYWxpemVkVmlldyA9IHt9O1xuICAvLyBBbiBlbGVtZW50IG1pZ2h0IGhhdmUgYW4gZW1wdHkgYG5naGAgYXR0cmlidXRlIHZhbHVlIChlLmcuIGA8Y29tcCBuZ2g9XCJcIiAvPmApLFxuICAvLyB3aGljaCBtZWFucyB0aGF0IG5vIHNwZWNpYWwgYW5ub3RhdGlvbnMgYXJlIHJlcXVpcmVkLiBEbyBub3QgYXR0ZW1wdCB0byByZWFkXG4gIC8vIGZyb20gdGhlIFRyYW5zZmVyU3RhdGUgaW4gdGhpcyBjYXNlLlxuICBpZiAobmdoQXR0clZhbHVlICE9PSAnJykge1xuICAgIGNvbnN0IHRyYW5zZmVyU3RhdGUgPSBpbmplY3Rvci5nZXQoVHJhbnNmZXJTdGF0ZSwgbnVsbCwge29wdGlvbmFsOiB0cnVlfSk7XG4gICAgaWYgKHRyYW5zZmVyU3RhdGUgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IG5naERhdGEgPSB0cmFuc2ZlclN0YXRlLmdldChOR0hfREFUQV9LRVksIFtdKTtcblxuICAgICAgLy8gVGhlIG5naEF0dHJWYWx1ZSBpcyBhbHdheXMgYSBudW1iZXIgcmVmZXJlbmNpbmcgYW4gaW5kZXhcbiAgICAgIC8vIGluIHRoZSBoeWRyYXRpb24gVHJhbnNmZXJTdGF0ZSBkYXRhLlxuICAgICAgZGF0YSA9IG5naERhdGFbTnVtYmVyKG5naEF0dHJWYWx1ZSldO1xuXG4gICAgICAvLyBJZiB0aGUgYG5naGAgYXR0cmlidXRlIGV4aXN0cyBhbmQgaGFzIGEgbm9uLWVtcHR5IHZhbHVlLFxuICAgICAgLy8gdGhlIGh5ZHJhdGlvbiBpbmZvICptdXN0KiBiZSBwcmVzZW50IGluIHRoZSBUcmFuc2ZlclN0YXRlLlxuICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gZGF0YSBmb3Igc29tZSByZWFzb25zLCB0aGlzIGlzIGFuIGVycm9yLlxuICAgICAgbmdEZXZNb2RlICYmIGFzc2VydERlZmluZWQoZGF0YSwgJ1VuYWJsZSB0byByZXRyaWV2ZSBoeWRyYXRpb24gaW5mbyBmcm9tIHRoZSBUcmFuc2ZlclN0YXRlLicpO1xuICAgIH1cbiAgfVxuICBjb25zdCBkZWh5ZHJhdGVkVmlldzogRGVoeWRyYXRlZFZpZXcgPSB7XG4gICAgZGF0YSxcbiAgICBmaXJzdENoaWxkOiByTm9kZS5maXJzdENoaWxkID8/IG51bGwsXG4gIH07XG4gIC8vIFRoZSBgbmdoYCBhdHRyaWJ1dGUgaXMgY2xlYXJlZCBmcm9tIHRoZSBET00gbm9kZSBub3dcbiAgLy8gdGhhdCB0aGUgZGF0YSBoYXMgYmVlbiByZXRyaWV2ZWQuXG4gIHJOb2RlLnJlbW92ZUF0dHJpYnV0ZShOR0hfQVRUUl9OQU1FKTtcblxuICAvLyBOb3RlOiBkb24ndCBjaGVjayB3aGV0aGVyIHRoaXMgbm9kZSB3YXMgY2xhaW1lZCBmb3IgaHlkcmF0aW9uLFxuICAvLyBiZWNhdXNlIHRoaXMgbm9kZSBtaWdodCd2ZSBiZWVuIHByZXZpb3VzbHkgY2xhaW1lZCB3aGlsZSBwcm9jZXNzaW5nXG4gIC8vIHRlbXBsYXRlIGluc3RydWN0aW9ucy5cbiAgbmdEZXZNb2RlICYmIG1hcmtSTm9kZUFzQ2xhaW1lZEJ5SHlkcmF0aW9uKHJOb2RlLCAvKiBjaGVja0lmQWxyZWFkeUNsYWltZWQgKi8gZmFsc2UpO1xuICBuZ0Rldk1vZGUgJiYgbmdEZXZNb2RlLmh5ZHJhdGVkQ29tcG9uZW50cysrO1xuXG4gIHJldHVybiBkZWh5ZHJhdGVkVmlldztcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIGByZXRyaWV2ZU5naEluZm9gIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5hYmxlUmV0cmlldmVIeWRyYXRpb25JbmZvSW1wbCgpIHtcbiAgX3JldHJpZXZlSHlkcmF0aW9uSW5mb0ltcGwgPSByZXRyaWV2ZUh5ZHJhdGlvbkluZm9JbXBsO1xufVxuXG4vKipcbiAqIFJldHJpZXZlcyBoeWRyYXRpb24gaW5mbyBieSByZWFkaW5nIHRoZSB2YWx1ZSBmcm9tIHRoZSBgbmdoYCBhdHRyaWJ1dGVcbiAqIGFuZCBhY2Nlc3NpbmcgYSBjb3JyZXNwb25kaW5nIHNsb3QgaW4gVHJhbnNmZXJTdGF0ZSBzdG9yYWdlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmV0cmlldmVIeWRyYXRpb25JbmZvKHJOb2RlOiBSRWxlbWVudCwgaW5qZWN0b3I6IEluamVjdG9yKTogRGVoeWRyYXRlZFZpZXd8bnVsbCB7XG4gIHJldHVybiBfcmV0cmlldmVIeWRyYXRpb25JbmZvSW1wbChyTm9kZSwgaW5qZWN0b3IpO1xufVxuXG4vKipcbiAqIFJldHJpZXZlcyBhbiBpbnN0YW5jZSBvZiBhIGNvbXBvbmVudCBMVmlldyBmcm9tIGEgZ2l2ZW4gVmlld1JlZi5cbiAqIFJldHVybnMgYW4gaW5zdGFuY2Ugb2YgYSBjb21wb25lbnQgTFZpZXcgb3IgYG51bGxgIGluIGNhc2Ugb2YgYW4gZW1iZWRkZWQgdmlldy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENvbXBvbmVudExWaWV3Rm9ySHlkcmF0aW9uKHZpZXdSZWY6IFZpZXdSZWYpOiBMVmlld3xudWxsIHtcbiAgLy8gUmVhZGluZyBhbiBpbnRlcm5hbCBmaWVsZCBmcm9tIGBWaWV3UmVmYCBpbnN0YW5jZS5cbiAgbGV0IGxWaWV3ID0gKHZpZXdSZWYgYXMgYW55KS5fbFZpZXcgYXMgTFZpZXc7XG4gIGNvbnN0IHRWaWV3ID0gbFZpZXdbVFZJRVddO1xuICAvLyBBIHJlZ2lzdGVyZWQgVmlld1JlZiBtaWdodCByZXByZXNlbnQgYW4gaW5zdGFuY2Ugb2YgYW5cbiAgLy8gZW1iZWRkZWQgdmlldywgaW4gd2hpY2ggY2FzZSB3ZSBkbyBub3QgbmVlZCB0byBhbm5vdGF0ZSBpdC5cbiAgaWYgKHRWaWV3LnR5cGUgPT09IFRWaWV3VHlwZS5FbWJlZGRlZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8vIENoZWNrIGlmIGl0J3MgYSByb290IHZpZXcgYW5kIGlmIHNvLCByZXRyaWV2ZSBjb21wb25lbnQnc1xuICAvLyBMVmlldyBmcm9tIHRoZSBmaXJzdCBzbG90IGFmdGVyIHRoZSBoZWFkZXIuXG4gIGlmIChpc1Jvb3RWaWV3KGxWaWV3KSkge1xuICAgIGxWaWV3ID0gbFZpZXdbSEVBREVSX09GRlNFVF07XG4gIH1cbiAgcmV0dXJuIGxWaWV3O1xufVxuXG4vKipcbiAqIEludGVybmFsIHR5cGUgdGhhdCByZXByZXNlbnRzIGEgY2xhaW1lZCBub2RlLlxuICogT25seSB1c2VkIGluIGRldiBtb2RlLlxuICovXG50eXBlIENsYWltZWROb2RlID0ge1xuICBfX2NsYWltZWQ/OiBib29sZWFuO1xufTtcblxuLyoqXG4gKiBNYXJrcyBhIG5vZGUgYXMgXCJjbGFpbWVkXCIgYnkgaHlkcmF0aW9uIHByb2Nlc3MuXG4gKiBUaGlzIGlzIG5lZWRlZCB0byBtYWtlIGFzc2Vzc21lbnRzIGluIHRlc3RzIHdoZXRoZXJcbiAqIHRoZSBoeWRyYXRpb24gcHJvY2VzcyBoYW5kbGVkIGFsbCBub2Rlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcmtSTm9kZUFzQ2xhaW1lZEJ5SHlkcmF0aW9uKG5vZGU6IFJOb2RlLCBjaGVja0lmQWxyZWFkeUNsYWltZWQgPSB0cnVlKSB7XG4gIGlmICghbmdEZXZNb2RlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnQ2FsbGluZyBgbWFya1JOb2RlQXNDbGFpbWVkQnlIeWRyYXRpb25gIGluIHByb2QgbW9kZSAnICtcbiAgICAgICAgJ2lzIG5vdCBzdXBwb3J0ZWQgYW5kIGxpa2VseSBhIG1pc3Rha2UuJyk7XG4gIH1cbiAgaWYgKGNoZWNrSWZBbHJlYWR5Q2xhaW1lZCAmJiBpc1JOb2RlQ2xhaW1lZEZvckh5ZHJhdGlvbihub2RlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJ5aW5nIHRvIGNsYWltIGEgbm9kZSwgd2hpY2ggd2FzIGNsYWltZWQgYWxyZWFkeS4nKTtcbiAgfVxuICAobm9kZSBhcyBDbGFpbWVkTm9kZSkuX19jbGFpbWVkID0gdHJ1ZTtcbiAgbmdEZXZNb2RlLmh5ZHJhdGVkTm9kZXMrKztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUk5vZGVDbGFpbWVkRm9ySHlkcmF0aW9uKG5vZGU6IFJOb2RlKTogYm9vbGVhbiB7XG4gIHJldHVybiAhIShub2RlIGFzIENsYWltZWROb2RlKS5fX2NsYWltZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRTZWdtZW50SGVhZChcbiAgICBoeWRyYXRpb25JbmZvOiBEZWh5ZHJhdGVkVmlldywgaW5kZXg6IG51bWJlciwgbm9kZTogUk5vZGV8bnVsbCk6IHZvaWQge1xuICBoeWRyYXRpb25JbmZvLnNlZ21lbnRIZWFkcyA/Pz0ge307XG4gIGh5ZHJhdGlvbkluZm8uc2VnbWVudEhlYWRzW2luZGV4XSA9IG5vZGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTZWdtZW50SGVhZChoeWRyYXRpb25JbmZvOiBEZWh5ZHJhdGVkVmlldywgaW5kZXg6IG51bWJlcik6IFJOb2RlfG51bGwge1xuICByZXR1cm4gaHlkcmF0aW9uSW5mby5zZWdtZW50SGVhZHM/LltpbmRleF0gPz8gbnVsbDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzaXplIG9mIGFuIDxuZy1jb250YWluZXI+LCB1c2luZyBlaXRoZXIgdGhlIGluZm9ybWF0aW9uXG4gKiBzZXJpYWxpemVkIGluIGBFTEVNRU5UX0NPTlRBSU5FUlNgIChlbGVtZW50IGNvbnRhaW5lciBzaXplKSBvciBieVxuICogY29tcHV0aW5nIHRoZSBzdW0gb2Ygcm9vdCBub2RlcyBpbiBhbGwgZGVoeWRyYXRlZCB2aWV3cyBpbiBhIGdpdmVuXG4gKiBjb250YWluZXIgKGluIGNhc2UgdGhpcyBgPG5nLWNvbnRhaW5lcj5gIHdhcyBhbHNvIHVzZWQgYXMgYSB2aWV3XG4gKiBjb250YWluZXIgaG9zdCBub2RlLCBlLmcuIDxuZy1jb250YWluZXIgKm5nSWY+KS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE5nQ29udGFpbmVyU2l6ZShoeWRyYXRpb25JbmZvOiBEZWh5ZHJhdGVkVmlldywgaW5kZXg6IG51bWJlcik6IG51bWJlcnxudWxsIHtcbiAgY29uc3QgZGF0YSA9IGh5ZHJhdGlvbkluZm8uZGF0YTtcbiAgbGV0IHNpemUgPSBkYXRhW0VMRU1FTlRfQ09OVEFJTkVSU10/LltpbmRleF0gPz8gbnVsbDtcbiAgLy8gSWYgdGhlcmUgaXMgbm8gc2VyaWFsaXplZCBpbmZvcm1hdGlvbiBhdmFpbGFibGUgaW4gdGhlIGBFTEVNRU5UX0NPTlRBSU5FUlNgIHNsb3QsXG4gIC8vIGNoZWNrIGlmIHdlIGhhdmUgaW5mbyBhYm91dCB2aWV3IGNvbnRhaW5lcnMgYXQgdGhpcyBsb2NhdGlvbiAoZS5nLlxuICAvLyBgPG5nLWNvbnRhaW5lciAqbmdJZj5gKSBhbmQgdXNlIGNvbnRhaW5lciBzaXplIGFzIGEgbnVtYmVyIG9mIHJvb3Qgbm9kZXMgaW4gdGhpc1xuICAvLyBlbGVtZW50IGNvbnRhaW5lci5cbiAgaWYgKHNpemUgPT09IG51bGwgJiYgZGF0YVtDT05UQUlORVJTXT8uW2luZGV4XSkge1xuICAgIHNpemUgPSBjYWxjU2VyaWFsaXplZENvbnRhaW5lclNpemUoaHlkcmF0aW9uSW5mbywgaW5kZXgpO1xuICB9XG4gIHJldHVybiBzaXplO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2VyaWFsaXplZENvbnRhaW5lclZpZXdzKFxuICAgIGh5ZHJhdGlvbkluZm86IERlaHlkcmF0ZWRWaWV3LCBpbmRleDogbnVtYmVyKTogU2VyaWFsaXplZENvbnRhaW5lclZpZXdbXXxudWxsIHtcbiAgcmV0dXJuIGh5ZHJhdGlvbkluZm8uZGF0YVtDT05UQUlORVJTXT8uW2luZGV4XSA/PyBudWxsO1xufVxuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBzaXplIG9mIGEgc2VyaWFsaXplZCBjb250YWluZXIgKHRoZSBudW1iZXIgb2Ygcm9vdCBub2RlcylcbiAqIGJ5IGNhbGN1bGF0aW5nIHRoZSBzdW0gb2Ygcm9vdCBub2RlcyBpbiBhbGwgZGVoeWRyYXRlZCB2aWV3cyBpbiB0aGlzIGNvbnRhaW5lci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGNTZXJpYWxpemVkQ29udGFpbmVyU2l6ZShoeWRyYXRpb25JbmZvOiBEZWh5ZHJhdGVkVmlldywgaW5kZXg6IG51bWJlcik6IG51bWJlciB7XG4gIGNvbnN0IHZpZXdzID0gZ2V0U2VyaWFsaXplZENvbnRhaW5lclZpZXdzKGh5ZHJhdGlvbkluZm8sIGluZGV4KSA/PyBbXTtcbiAgbGV0IG51bU5vZGVzID0gMDtcbiAgZm9yIChsZXQgdmlldyBvZiB2aWV3cykge1xuICAgIG51bU5vZGVzICs9IHZpZXdbTlVNX1JPT1RfTk9ERVNdO1xuICB9XG4gIHJldHVybiBudW1Ob2Rlcztcbn1cbiJdfQ==
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { isRootView } from '../render3/interfaces/type_checks';
import { HEADER_OFFSET, TVIEW } from '../render3/interfaces/view';
import { makeStateKey, TransferState } from '../transfer_state';
import { assertDefined } from '../util/assert';
/**
 * The name of the key used in the TransferState collection,
 * where hydration information is located.
 */
const TRANSFER_STATE_TOKEN_ID = '__ÉµnghData__';
/**
 * Lookup key used to reference DOM hydration data (ngh) in `TransferState`.
 */
export const NGH_DATA_KEY = makeStateKey(TRANSFER_STATE_TOKEN_ID);
/**
 * The name of the attribute that would be added to host component
 * nodes and contain a reference to a particular slot in transferred
 * state that contains the necessary hydration info for this component.
 */
export const NGH_ATTR_NAME = 'ngh';
/**
 * Reference to a function that reads `ngh` attribute value from a given RNode
 * and retrieves hydration information from the TransferState using that value
 * as an index. Returns `null` by default, when hydration is not enabled.
 *
 * @param rNode Component's host element.
 * @param injector Injector that this component has access to.
 */
let _retrieveHydrationInfoImpl = (rNode, injector) => null;
export function retrieveHydrationInfoImpl(rNode, injector) {
    const nghAttrValue = rNode.getAttribute(NGH_ATTR_NAME);
    if (nghAttrValue == null)
        return null;
    let data = {};
    // An element might have an empty `ngh` attribute value (e.g. `<comp ngh="" />`),
    // which means that no special annotations are required. Do not attempt to read
    // from the TransferState in this case.
    if (nghAttrValue !== '') {
        const transferState = injector.get(TransferState, null, { optional: true });
        if (transferState !== null) {
            const nghData = transferState.get(NGH_DATA_KEY, []);
            // The nghAttrValue is always a number referencing an index
            // in the hydration TransferState data.
            data = nghData[Number(nghAttrValue)];
            // If the `ngh` attribute exists and has a non-empty value,
            // the hydration info *must* be present in the TransferState.
            // If there is no data for some reasons, this is an error.
            ngDevMode && assertDefined(data, 'Unable to retrieve hydration info from the TransferState.');
        }
    }
    const dehydratedView = {
        data,
        firstChild: rNode.firstChild ?? null,
    };
    // The `ngh` attribute is cleared from the DOM node now
    // that the data has been retrieved.
    rNode.removeAttribute(NGH_ATTR_NAME);
    // Note: don't check whether this node was claimed for hydration,
    // because this node might've been previously claimed while processing
    // template instructions.
    ngDevMode && markRNodeAsClaimedByHydration(rNode, /* checkIfAlreadyClaimed */ false);
    ngDevMode && ngDevMode.hydratedComponents++;
    return dehydratedView;
}
/**
 * Sets the implementation for the `retrieveNghInfo` function.
 */
export function enableRetrieveHydrationInfoImpl() {
    _retrieveHydrationInfoImpl = retrieveHydrationInfoImpl;
}
/**
 * Retrieves hydration info by reading the value from the `ngh` attribute
 * and accessing a corresponding slot in TransferState storage.
 */
export function retrieveHydrationInfo(rNode, injector) {
    return _retrieveHydrationInfoImpl(rNode, injector);
}
/**
 * Retrieves an instance of a component LView from a given ViewRef.
 * Returns an instance of a component LView or `null` in case of an embedded view.
 */
export function getComponentLViewForHydration(viewRef) {
    // Reading an internal field from `ViewRef` instance.
    let lView = viewRef._lView;
    const tView = lView[TVIEW];
    // A registered ViewRef might represent an instance of an
    // embedded view, in which case we do not need to annotate it.
    if (tView.type === 2 /* TViewType.Embedded */) {
        return null;
    }
    // Check if it's a root view and if so, retrieve component's
    // LView from the first slot after the header.
    if (isRootView(lView)) {
        lView = lView[HEADER_OFFSET];
    }
    return lView;
}
/**
 * Marks a node as "claimed" by hydration process.
 * This is needed to make assessments in tests whether
 * the hydration process handled all nodes.
 */
export function markRNodeAsClaimedByHydration(node, checkIfAlreadyClaimed = true) {
    if (!ngDevMode) {
        throw new Error('Calling `markRNodeAsClaimedByHydration` in prod mode ' +
            'is not supported and likely a mistake.');
    }
    if (checkIfAlreadyClaimed && isRNodeClaimedForHydration(node)) {
        throw new Error('Trying to claim a node, which was claimed already.');
    }
    node.__claimed = true;
    ngDevMode.hydratedNodes++;
}
export function isRNodeClaimedForHydration(node) {
    return !!node.__claimed;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9jb3JlL3NyYy9oeWRyYXRpb24vdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0E7Ozs7OztHQU1HO0FBS0gsT0FBTyxFQUFDLFVBQVUsRUFBQyxNQUFNLG1DQUFtQyxDQUFDO0FBQzdELE9BQU8sRUFBQyxhQUFhLEVBQVMsS0FBSyxFQUFZLE1BQU0sNEJBQTRCLENBQUM7QUFDbEYsT0FBTyxFQUFDLFlBQVksRUFBRSxhQUFhLEVBQUMsTUFBTSxtQkFBbUIsQ0FBQztBQUM5RCxPQUFPLEVBQUMsYUFBYSxFQUFDLE1BQU0sZ0JBQWdCLENBQUM7QUFJN0M7OztHQUdHO0FBQ0gsTUFBTSx1QkFBdUIsR0FBRyxjQUFjLENBQUM7QUFFL0M7O0dBRUc7QUFDSCxNQUFNLENBQUMsTUFBTSxZQUFZLEdBQUcsWUFBWSxDQUF3Qix1QkFBdUIsQ0FBQyxDQUFDO0FBRXpGOzs7O0dBSUc7QUFDSCxNQUFNLENBQUMsTUFBTSxhQUFhLEdBQUcsS0FBSyxDQUFDO0FBRW5DOzs7Ozs7O0dBT0c7QUFDSCxJQUFJLDBCQUEwQixHQUMxQixDQUFDLEtBQWUsRUFBRSxRQUFrQixFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUM7QUFFbEQsTUFBTSxVQUFVLHlCQUF5QixDQUFDLEtBQWUsRUFBRSxRQUFrQjtJQUUzRSxNQUFNLFlBQVksR0FBRyxLQUFLLENBQUMsWUFBWSxDQUFDLGFBQWEsQ0FBQyxDQUFDO0lBQ3ZELElBQUksWUFBWSxJQUFJLElBQUk7UUFBRSxPQUFPLElBQUksQ0FBQztJQUV0QyxJQUFJLElBQUksR0FBbUIsRUFBRSxDQUFDO0lBQzlCLGlGQUFpRjtJQUNqRiwrRUFBK0U7SUFDL0UsdUNBQXVDO0lBQ3ZDLElBQUksWUFBWSxLQUFLLEVBQUUsRUFBRTtRQUN2QixNQUFNLGFBQWEsR0FBRyxRQUFRLENBQUMsR0FBRyxDQUFDLGFBQWEsRUFBRSxJQUFJLEVBQUUsRUFBQyxRQUFRLEVBQUUsSUFBSSxFQUFDLENBQUMsQ0FBQztRQUMxRSxJQUFJLGFBQWEsS0FBSyxJQUFJLEVBQUU7WUFDMUIsTUFBTSxPQUFPLEdBQUcsYUFBYSxDQUFDLEdBQUcsQ0FBQyxZQUFZLEVBQUUsRUFBRSxDQUFDLENBQUM7WUFFcEQsMkRBQTJEO1lBQzNELHVDQUF1QztZQUN2QyxJQUFJLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDO1lBRXJDLDJEQUEyRDtZQUMzRCw2REFBNkQ7WUFDN0QsMERBQTBEO1lBQzFELFNBQVMsSUFBSSxhQUFhLENBQUMsSUFBSSxFQUFFLDJEQUEyRCxDQUFDLENBQUM7U0FDL0Y7S0FDRjtJQUNELE1BQU0sY0FBYyxHQUFtQjtRQUNyQyxJQUFJO1FBQ0osVUFBVSxFQUFFLEtBQUssQ0FBQyxVQUFVLElBQUksSUFBSTtLQUNyQyxDQUFDO0lBQ0YsdURBQXVEO0lBQ3ZELG9DQUFvQztJQUNwQyxLQUFLLENBQUMsZUFBZSxDQUFDLGFBQWEsQ0FBQyxDQUFDO0lBRXJDLGlFQUFpRTtJQUNqRSxzRUFBc0U7SUFDdEUseUJBQXlCO0lBQ3pCLFNBQVMsSUFBSSw2QkFBNkIsQ0FBQyxLQUFLLEVBQUUsMkJBQTJCLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDckYsU0FBUyxJQUFJLFNBQVMsQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO0lBRTVDLE9BQU8sY0FBYyxDQUFDO0FBQ3hCLENBQUM7QUFFRDs7R0FFRztBQUNILE1BQU0sVUFBVSwrQkFBK0I7SUFDN0MsMEJBQTBCLEdBQUcseUJBQXlCLENBQUM7QUFDekQsQ0FBQztBQUVEOzs7R0FHRztBQUNILE1BQU0sVUFBVSxxQkFBcUIsQ0FBQyxLQUFlLEVBQUUsUUFBa0I7SUFDdkUsT0FBTywwQkFBMEIsQ0FBQyxLQUFLLEVBQUUsUUFBUSxDQUFDLENBQUM7QUFDckQsQ0FBQztBQUVEOzs7R0FHRztBQUNILE1BQU0sVUFBVSw2QkFBNkIsQ0FBQyxPQUFnQjtJQUM1RCxxREFBcUQ7SUFDckQsSUFBSSxLQUFLLEdBQUksT0FBZSxDQUFDLE1BQWUsQ0FBQztJQUM3QyxNQUFNLEtBQUssR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDM0IseURBQXlEO0lBQ3pELDhEQUE4RDtJQUM5RCxJQUFJLEtBQUssQ0FBQyxJQUFJLCtCQUF1QixFQUFFO1FBQ3JDLE9BQU8sSUFBSSxDQUFDO0tBQ2I7SUFDRCw0REFBNEQ7SUFDNUQsOENBQThDO0lBQzlDLElBQUksVUFBVSxDQUFDLEtBQUssQ0FBQyxFQUFFO1FBQ3JCLEtBQUssR0FBRyxLQUFLLENBQUMsYUFBYSxDQUFDLENBQUM7S0FDOUI7SUFDRCxPQUFPLEtBQUssQ0FBQztBQUNmLENBQUM7QUFVRDs7OztHQUlHO0FBQ0gsTUFBTSxVQUFVLDZCQUE2QixDQUFDLElBQVcsRUFBRSxxQkFBcUIsR0FBRyxJQUFJO0lBQ3JGLElBQUksQ0FBQyxTQUFTLEVBQUU7UUFDZCxNQUFNLElBQUksS0FBSyxDQUNYLHVEQUF1RDtZQUN2RCx3Q0FBd0MsQ0FBQyxDQUFDO0tBQy9DO0lBQ0QsSUFBSSxxQkFBcUIsSUFBSSwwQkFBMEIsQ0FBQyxJQUFJLENBQUMsRUFBRTtRQUM3RCxNQUFNLElBQUksS0FBSyxDQUFDLG9EQUFvRCxDQUFDLENBQUM7S0FDdkU7SUFDQSxJQUFvQixDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUM7SUFDdkMsU0FBUyxDQUFDLGFBQWEsRUFBRSxDQUFDO0FBQzVCLENBQUM7QUFFRCxNQUFNLFVBQVUsMEJBQTBCLENBQUMsSUFBVztJQUNwRCxPQUFPLENBQUMsQ0FBRSxJQUFvQixDQUFDLFNBQVMsQ0FBQztBQUMzQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuaW1wb3J0IHtJbmplY3Rvcn0gZnJvbSAnLi4vZGkvaW5qZWN0b3InO1xuaW1wb3J0IHtWaWV3UmVmfSBmcm9tICcuLi9saW5rZXIvdmlld19yZWYnO1xuaW1wb3J0IHtSRWxlbWVudCwgUk5vZGV9IGZyb20gJy4uL3JlbmRlcjMvaW50ZXJmYWNlcy9yZW5kZXJlcl9kb20nO1xuaW1wb3J0IHtpc1Jvb3RWaWV3fSBmcm9tICcuLi9yZW5kZXIzL2ludGVyZmFjZXMvdHlwZV9jaGVja3MnO1xuaW1wb3J0IHtIRUFERVJfT0ZGU0VULCBMVmlldywgVFZJRVcsIFRWaWV3VHlwZX0gZnJvbSAnLi4vcmVuZGVyMy9pbnRlcmZhY2VzL3ZpZXcnO1xuaW1wb3J0IHttYWtlU3RhdGVLZXksIFRyYW5zZmVyU3RhdGV9IGZyb20gJy4uL3RyYW5zZmVyX3N0YXRlJztcbmltcG9ydCB7YXNzZXJ0RGVmaW5lZH0gZnJvbSAnLi4vdXRpbC9hc3NlcnQnO1xuXG5pbXBvcnQge0RlaHlkcmF0ZWRWaWV3LCBTZXJpYWxpemVkVmlld30gZnJvbSAnLi9pbnRlcmZhY2VzJztcblxuLyoqXG4gKiBUaGUgbmFtZSBvZiB0aGUga2V5IHVzZWQgaW4gdGhlIFRyYW5zZmVyU3RhdGUgY29sbGVjdGlvbixcbiAqIHdoZXJlIGh5ZHJhdGlvbiBpbmZvcm1hdGlvbiBpcyBsb2NhdGVkLlxuICovXG5jb25zdCBUUkFOU0ZFUl9TVEFURV9UT0tFTl9JRCA9ICdfX8m1bmdoRGF0YV9fJztcblxuLyoqXG4gKiBMb29rdXAga2V5IHVzZWQgdG8gcmVmZXJlbmNlIERPTSBoeWRyYXRpb24gZGF0YSAobmdoKSBpbiBgVHJhbnNmZXJTdGF0ZWAuXG4gKi9cbmV4cG9ydCBjb25zdCBOR0hfREFUQV9LRVkgPSBtYWtlU3RhdGVLZXk8QXJyYXk8U2VyaWFsaXplZFZpZXc+PihUUkFOU0ZFUl9TVEFURV9UT0tFTl9JRCk7XG5cbi8qKlxuICogVGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZSB0aGF0IHdvdWxkIGJlIGFkZGVkIHRvIGhvc3QgY29tcG9uZW50XG4gKiBub2RlcyBhbmQgY29udGFpbiBhIHJlZmVyZW5jZSB0byBhIHBhcnRpY3VsYXIgc2xvdCBpbiB0cmFuc2ZlcnJlZFxuICogc3RhdGUgdGhhdCBjb250YWlucyB0aGUgbmVjZXNzYXJ5IGh5ZHJhdGlvbiBpbmZvIGZvciB0aGlzIGNvbXBvbmVudC5cbiAqL1xuZXhwb3J0IGNvbnN0IE5HSF9BVFRSX05BTUUgPSAnbmdoJztcblxuLyoqXG4gKiBSZWZlcmVuY2UgdG8gYSBmdW5jdGlvbiB0aGF0IHJlYWRzIGBuZ2hgIGF0dHJpYnV0ZSB2YWx1ZSBmcm9tIGEgZ2l2ZW4gUk5vZGVcbiAqIGFuZCByZXRyaWV2ZXMgaHlkcmF0aW9uIGluZm9ybWF0aW9uIGZyb20gdGhlIFRyYW5zZmVyU3RhdGUgdXNpbmcgdGhhdCB2YWx1ZVxuICogYXMgYW4gaW5kZXguIFJldHVybnMgYG51bGxgIGJ5IGRlZmF1bHQsIHdoZW4gaHlkcmF0aW9uIGlzIG5vdCBlbmFibGVkLlxuICpcbiAqIEBwYXJhbSByTm9kZSBDb21wb25lbnQncyBob3N0IGVsZW1lbnQuXG4gKiBAcGFyYW0gaW5qZWN0b3IgSW5qZWN0b3IgdGhhdCB0aGlzIGNvbXBvbmVudCBoYXMgYWNjZXNzIHRvLlxuICovXG5sZXQgX3JldHJpZXZlSHlkcmF0aW9uSW5mb0ltcGw6IHR5cGVvZiByZXRyaWV2ZUh5ZHJhdGlvbkluZm9JbXBsID1cbiAgICAock5vZGU6IFJFbGVtZW50LCBpbmplY3RvcjogSW5qZWN0b3IpID0+IG51bGw7XG5cbmV4cG9ydCBmdW5jdGlvbiByZXRyaWV2ZUh5ZHJhdGlvbkluZm9JbXBsKHJOb2RlOiBSRWxlbWVudCwgaW5qZWN0b3I6IEluamVjdG9yKTogRGVoeWRyYXRlZFZpZXd8XG4gICAgbnVsbCB7XG4gIGNvbnN0IG5naEF0dHJWYWx1ZSA9IHJOb2RlLmdldEF0dHJpYnV0ZShOR0hfQVRUUl9OQU1FKTtcbiAgaWYgKG5naEF0dHJWYWx1ZSA9PSBudWxsKSByZXR1cm4gbnVsbDtcblxuICBsZXQgZGF0YTogU2VyaWFsaXplZFZpZXcgPSB7fTtcbiAgLy8gQW4gZWxlbWVudCBtaWdodCBoYXZlIGFuIGVtcHR5IGBuZ2hgIGF0dHJpYnV0ZSB2YWx1ZSAoZS5nLiBgPGNvbXAgbmdoPVwiXCIgLz5gKSxcbiAgLy8gd2hpY2ggbWVhbnMgdGhhdCBubyBzcGVjaWFsIGFubm90YXRpb25zIGFyZSByZXF1aXJlZC4gRG8gbm90IGF0dGVtcHQgdG8gcmVhZFxuICAvLyBmcm9tIHRoZSBUcmFuc2ZlclN0YXRlIGluIHRoaXMgY2FzZS5cbiAgaWYgKG5naEF0dHJWYWx1ZSAhPT0gJycpIHtcbiAgICBjb25zdCB0cmFuc2ZlclN0YXRlID0gaW5qZWN0b3IuZ2V0KFRyYW5zZmVyU3RhdGUsIG51bGwsIHtvcHRpb25hbDogdHJ1ZX0pO1xuICAgIGlmICh0cmFuc2ZlclN0YXRlICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBuZ2hEYXRhID0gdHJhbnNmZXJTdGF0ZS5nZXQoTkdIX0RBVEFfS0VZLCBbXSk7XG5cbiAgICAgIC8vIFRoZSBuZ2hBdHRyVmFsdWUgaXMgYWx3YXlzIGEgbnVtYmVyIHJlZmVyZW5jaW5nIGFuIGluZGV4XG4gICAgICAvLyBpbiB0aGUgaHlkcmF0aW9uIFRyYW5zZmVyU3RhdGUgZGF0YS5cbiAgICAgIGRhdGEgPSBuZ2hEYXRhW051bWJlcihuZ2hBdHRyVmFsdWUpXTtcblxuICAgICAgLy8gSWYgdGhlIGBuZ2hgIGF0dHJpYnV0ZSBleGlzdHMgYW5kIGhhcyBhIG5vbi1lbXB0eSB2YWx1ZSxcbiAgICAgIC8vIHRoZSBoeWRyYXRpb24gaW5mbyAqbXVzdCogYmUgcHJlc2VudCBpbiB0aGUgVHJhbnNmZXJTdGF0ZS5cbiAgICAgIC8vIElmIHRoZXJlIGlzIG5vIGRhdGEgZm9yIHNvbWUgcmVhc29ucywgdGhpcyBpcyBhbiBlcnJvci5cbiAgICAgIG5nRGV2TW9kZSAmJiBhc3NlcnREZWZpbmVkKGRhdGEsICdVbmFibGUgdG8gcmV0cmlldmUgaHlkcmF0aW9uIGluZm8gZnJvbSB0aGUgVHJhbnNmZXJTdGF0ZS4nKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZGVoeWRyYXRlZFZpZXc6IERlaHlkcmF0ZWRWaWV3ID0ge1xuICAgIGRhdGEsXG4gICAgZmlyc3RDaGlsZDogck5vZGUuZmlyc3RDaGlsZCA/PyBudWxsLFxuICB9O1xuICAvLyBUaGUgYG5naGAgYXR0cmlidXRlIGlzIGNsZWFyZWQgZnJvbSB0aGUgRE9NIG5vZGUgbm93XG4gIC8vIHRoYXQgdGhlIGRhdGEgaGFzIGJlZW4gcmV0cmlldmVkLlxuICByTm9kZS5yZW1vdmVBdHRyaWJ1dGUoTkdIX0FUVFJfTkFNRSk7XG5cbiAgLy8gTm90ZTogZG9uJ3QgY2hlY2sgd2hldGhlciB0aGlzIG5vZGUgd2FzIGNsYWltZWQgZm9yIGh5ZHJhdGlvbixcbiAgLy8gYmVjYXVzZSB0aGlzIG5vZGUgbWlnaHQndmUgYmVlbiBwcmV2aW91c2x5IGNsYWltZWQgd2hpbGUgcHJvY2Vzc2luZ1xuICAvLyB0ZW1wbGF0ZSBpbnN0cnVjdGlvbnMuXG4gIG5nRGV2TW9kZSAmJiBtYXJrUk5vZGVBc0NsYWltZWRCeUh5ZHJhdGlvbihyTm9kZSwgLyogY2hlY2tJZkFscmVhZHlDbGFpbWVkICovIGZhbHNlKTtcbiAgbmdEZXZNb2RlICYmIG5nRGV2TW9kZS5oeWRyYXRlZENvbXBvbmVudHMrKztcblxuICByZXR1cm4gZGVoeWRyYXRlZFZpZXc7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgaW1wbGVtZW50YXRpb24gZm9yIHRoZSBgcmV0cmlldmVOZ2hJbmZvYCBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuYWJsZVJldHJpZXZlSHlkcmF0aW9uSW5mb0ltcGwoKSB7XG4gIF9yZXRyaWV2ZUh5ZHJhdGlvbkluZm9JbXBsID0gcmV0cmlldmVIeWRyYXRpb25JbmZvSW1wbDtcbn1cblxuLyoqXG4gKiBSZXRyaWV2ZXMgaHlkcmF0aW9uIGluZm8gYnkgcmVhZGluZyB0aGUgdmFsdWUgZnJvbSB0aGUgYG5naGAgYXR0cmlidXRlXG4gKiBhbmQgYWNjZXNzaW5nIGEgY29ycmVzcG9uZGluZyBzbG90IGluIFRyYW5zZmVyU3RhdGUgc3RvcmFnZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJldHJpZXZlSHlkcmF0aW9uSW5mbyhyTm9kZTogUkVsZW1lbnQsIGluamVjdG9yOiBJbmplY3Rvcik6IERlaHlkcmF0ZWRWaWV3fG51bGwge1xuICByZXR1cm4gX3JldHJpZXZlSHlkcmF0aW9uSW5mb0ltcGwock5vZGUsIGluamVjdG9yKTtcbn1cblxuLyoqXG4gKiBSZXRyaWV2ZXMgYW4gaW5zdGFuY2Ugb2YgYSBjb21wb25lbnQgTFZpZXcgZnJvbSBhIGdpdmVuIFZpZXdSZWYuXG4gKiBSZXR1cm5zIGFuIGluc3RhbmNlIG9mIGEgY29tcG9uZW50IExWaWV3IG9yIGBudWxsYCBpbiBjYXNlIG9mIGFuIGVtYmVkZGVkIHZpZXcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb21wb25lbnRMVmlld0Zvckh5ZHJhdGlvbih2aWV3UmVmOiBWaWV3UmVmKTogTFZpZXd8bnVsbCB7XG4gIC8vIFJlYWRpbmcgYW4gaW50ZXJuYWwgZmllbGQgZnJvbSBgVmlld1JlZmAgaW5zdGFuY2UuXG4gIGxldCBsVmlldyA9ICh2aWV3UmVmIGFzIGFueSkuX2xWaWV3IGFzIExWaWV3O1xuICBjb25zdCB0VmlldyA9IGxWaWV3W1RWSUVXXTtcbiAgLy8gQSByZWdpc3RlcmVkIFZpZXdSZWYgbWlnaHQgcmVwcmVzZW50IGFuIGluc3RhbmNlIG9mIGFuXG4gIC8vIGVtYmVkZGVkIHZpZXcsIGluIHdoaWNoIGNhc2Ugd2UgZG8gbm90IG5lZWQgdG8gYW5ub3RhdGUgaXQuXG4gIGlmICh0Vmlldy50eXBlID09PSBUVmlld1R5cGUuRW1iZWRkZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvLyBDaGVjayBpZiBpdCdzIGEgcm9vdCB2aWV3IGFuZCBpZiBzbywgcmV0cmlldmUgY29tcG9uZW50J3NcbiAgLy8gTFZpZXcgZnJvbSB0aGUgZmlyc3Qgc2xvdCBhZnRlciB0aGUgaGVhZGVyLlxuICBpZiAoaXNSb290VmlldyhsVmlldykpIHtcbiAgICBsVmlldyA9IGxWaWV3W0hFQURFUl9PRkZTRVRdO1xuICB9XG4gIHJldHVybiBsVmlldztcbn1cblxuLyoqXG4gKiBJbnRlcm5hbCB0eXBlIHRoYXQgcmVwcmVzZW50cyBhIGNsYWltZWQgbm9kZS5cbiAqIE9ubHkgdXNlZCBpbiBkZXYgbW9kZS5cbiAqL1xudHlwZSBDbGFpbWVkTm9kZSA9IHtcbiAgX19jbGFpbWVkPzogYm9vbGVhbjtcbn07XG5cbi8qKlxuICogTWFya3MgYSBub2RlIGFzIFwiY2xhaW1lZFwiIGJ5IGh5ZHJhdGlvbiBwcm9jZXNzLlxuICogVGhpcyBpcyBuZWVkZWQgdG8gbWFrZSBhc3Nlc3NtZW50cyBpbiB0ZXN0cyB3aGV0aGVyXG4gKiB0aGUgaHlkcmF0aW9uIHByb2Nlc3MgaGFuZGxlZCBhbGwgbm9kZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXJrUk5vZGVBc0NsYWltZWRCeUh5ZHJhdGlvbihub2RlOiBSTm9kZSwgY2hlY2tJZkFscmVhZHlDbGFpbWVkID0gdHJ1ZSkge1xuICBpZiAoIW5nRGV2TW9kZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0NhbGxpbmcgYG1hcmtSTm9kZUFzQ2xhaW1lZEJ5SHlkcmF0aW9uYCBpbiBwcm9kIG1vZGUgJyArXG4gICAgICAgICdpcyBub3Qgc3VwcG9ydGVkIGFuZCBsaWtlbHkgYSBtaXN0YWtlLicpO1xuICB9XG4gIGlmIChjaGVja0lmQWxyZWFkeUNsYWltZWQgJiYgaXNSTm9kZUNsYWltZWRGb3JIeWRyYXRpb24obm9kZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyeWluZyB0byBjbGFpbSBhIG5vZGUsIHdoaWNoIHdhcyBjbGFpbWVkIGFscmVhZHkuJyk7XG4gIH1cbiAgKG5vZGUgYXMgQ2xhaW1lZE5vZGUpLl9fY2xhaW1lZCA9IHRydWU7XG4gIG5nRGV2TW9kZS5oeWRyYXRlZE5vZGVzKys7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1JOb2RlQ2xhaW1lZEZvckh5ZHJhdGlvbihub2RlOiBSTm9kZSk6IGJvb2xlYW4ge1xuICByZXR1cm4gISEobm9kZSBhcyBDbGFpbWVkTm9kZSkuX19jbGFpbWVkO1xufVxuIl19
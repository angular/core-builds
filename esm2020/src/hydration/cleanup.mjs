/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { DEHYDRATED_VIEWS } from '../render3/interfaces/container';
import { PARENT, RENDERER } from '../render3/interfaces/view';
import { nativeRemoveNode } from '../render3/node_manipulation';
import { EMPTY_ARRAY } from '../util/empty';
import { validateSiblingNodeExists } from './error_handling';
import { NUM_ROOT_NODES } from './interfaces';
/**
 * Removes all dehydrated views from a given LContainer:
 * both in internal data structure, as well as removing
 * corresponding DOM nodes that belong to that dehydrated view.
 */
export function removeDehydratedViews(lContainer) {
    const views = lContainer[DEHYDRATED_VIEWS] ?? [];
    const parentLView = lContainer[PARENT];
    const renderer = parentLView[RENDERER];
    for (const view of views) {
        removeDehydratedView(view, renderer);
        ngDevMode && ngDevMode.dehydratedViewsRemoved++;
    }
    // Reset the value to an empty array to indicate that no
    // further processing of dehydrated views is needed for
    // this view container (i.e. do not trigger the lookup process
    // once again in case a `ViewContainerRef` is created later).
    lContainer[DEHYDRATED_VIEWS] = EMPTY_ARRAY;
}
/**
 * Helper function to remove all nodes from a dehydrated view.
 */
function removeDehydratedView(dehydratedView, renderer) {
    let nodesRemoved = 0;
    let currentRNode = dehydratedView.firstChild;
    if (currentRNode) {
        const numNodes = dehydratedView.data[NUM_ROOT_NODES];
        while (nodesRemoved < numNodes) {
            ngDevMode && validateSiblingNodeExists(currentRNode);
            const nextSibling = currentRNode.nextSibling;
            nativeRemoveNode(renderer, currentRNode, false);
            currentRNode = nextSibling;
            nodesRemoved++;
        }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xlYW51cC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL2NvcmUvc3JjL2h5ZHJhdGlvbi9jbGVhbnVwLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7R0FNRztBQUVILE9BQU8sRUFBQyxnQkFBZ0IsRUFBYSxNQUFNLGlDQUFpQyxDQUFDO0FBRzdFLE9BQU8sRUFBQyxNQUFNLEVBQUUsUUFBUSxFQUFDLE1BQU0sNEJBQTRCLENBQUM7QUFDNUQsT0FBTyxFQUFDLGdCQUFnQixFQUFDLE1BQU0sOEJBQThCLENBQUM7QUFDOUQsT0FBTyxFQUFDLFdBQVcsRUFBQyxNQUFNLGVBQWUsQ0FBQztBQUUxQyxPQUFPLEVBQUMseUJBQXlCLEVBQUMsTUFBTSxrQkFBa0IsQ0FBQztBQUMzRCxPQUFPLEVBQTBCLGNBQWMsRUFBQyxNQUFNLGNBQWMsQ0FBQztBQUVyRTs7OztHQUlHO0FBQ0gsTUFBTSxVQUFVLHFCQUFxQixDQUFDLFVBQXNCO0lBQzFELE1BQU0sS0FBSyxHQUFHLFVBQVUsQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLEVBQUUsQ0FBQztJQUNqRCxNQUFNLFdBQVcsR0FBRyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDdkMsTUFBTSxRQUFRLEdBQUcsV0FBVyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3ZDLEtBQUssTUFBTSxJQUFJLElBQUksS0FBSyxFQUFFO1FBQ3hCLG9CQUFvQixDQUFDLElBQUksRUFBRSxRQUFRLENBQUMsQ0FBQztRQUNyQyxTQUFTLElBQUksU0FBUyxDQUFDLHNCQUFzQixFQUFFLENBQUM7S0FDakQ7SUFDRCx3REFBd0Q7SUFDeEQsdURBQXVEO0lBQ3ZELDhEQUE4RDtJQUM5RCw2REFBNkQ7SUFDN0QsVUFBVSxDQUFDLGdCQUFnQixDQUFDLEdBQUcsV0FBVyxDQUFDO0FBQzdDLENBQUM7QUFFRDs7R0FFRztBQUNILFNBQVMsb0JBQW9CLENBQUMsY0FBdUMsRUFBRSxRQUFrQjtJQUN2RixJQUFJLFlBQVksR0FBRyxDQUFDLENBQUM7SUFDckIsSUFBSSxZQUFZLEdBQUcsY0FBYyxDQUFDLFVBQVUsQ0FBQztJQUM3QyxJQUFJLFlBQVksRUFBRTtRQUNoQixNQUFNLFFBQVEsR0FBRyxjQUFjLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDO1FBQ3JELE9BQU8sWUFBWSxHQUFHLFFBQVEsRUFBRTtZQUM5QixTQUFTLElBQUkseUJBQXlCLENBQUMsWUFBWSxDQUFDLENBQUM7WUFDckQsTUFBTSxXQUFXLEdBQVUsWUFBWSxDQUFDLFdBQVksQ0FBQztZQUNyRCxnQkFBZ0IsQ0FBQyxRQUFRLEVBQUUsWUFBWSxFQUFFLEtBQUssQ0FBQyxDQUFDO1lBQ2hELFlBQVksR0FBRyxXQUFXLENBQUM7WUFDM0IsWUFBWSxFQUFFLENBQUM7U0FDaEI7S0FDRjtBQUNILENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuaW1wb3J0IHtERUhZRFJBVEVEX1ZJRVdTLCBMQ29udGFpbmVyfSBmcm9tICcuLi9yZW5kZXIzL2ludGVyZmFjZXMvY29udGFpbmVyJztcbmltcG9ydCB7UmVuZGVyZXJ9IGZyb20gJy4uL3JlbmRlcjMvaW50ZXJmYWNlcy9yZW5kZXJlcic7XG5pbXBvcnQge1JOb2RlfSBmcm9tICcuLi9yZW5kZXIzL2ludGVyZmFjZXMvcmVuZGVyZXJfZG9tJztcbmltcG9ydCB7UEFSRU5ULCBSRU5ERVJFUn0gZnJvbSAnLi4vcmVuZGVyMy9pbnRlcmZhY2VzL3ZpZXcnO1xuaW1wb3J0IHtuYXRpdmVSZW1vdmVOb2RlfSBmcm9tICcuLi9yZW5kZXIzL25vZGVfbWFuaXB1bGF0aW9uJztcbmltcG9ydCB7RU1QVFlfQVJSQVl9IGZyb20gJy4uL3V0aWwvZW1wdHknO1xuXG5pbXBvcnQge3ZhbGlkYXRlU2libGluZ05vZGVFeGlzdHN9IGZyb20gJy4vZXJyb3JfaGFuZGxpbmcnO1xuaW1wb3J0IHtEZWh5ZHJhdGVkQ29udGFpbmVyVmlldywgTlVNX1JPT1RfTk9ERVN9IGZyb20gJy4vaW50ZXJmYWNlcyc7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwgZGVoeWRyYXRlZCB2aWV3cyBmcm9tIGEgZ2l2ZW4gTENvbnRhaW5lcjpcbiAqIGJvdGggaW4gaW50ZXJuYWwgZGF0YSBzdHJ1Y3R1cmUsIGFzIHdlbGwgYXMgcmVtb3ZpbmdcbiAqIGNvcnJlc3BvbmRpbmcgRE9NIG5vZGVzIHRoYXQgYmVsb25nIHRvIHRoYXQgZGVoeWRyYXRlZCB2aWV3LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlRGVoeWRyYXRlZFZpZXdzKGxDb250YWluZXI6IExDb250YWluZXIpIHtcbiAgY29uc3Qgdmlld3MgPSBsQ29udGFpbmVyW0RFSFlEUkFURURfVklFV1NdID8/IFtdO1xuICBjb25zdCBwYXJlbnRMVmlldyA9IGxDb250YWluZXJbUEFSRU5UXTtcbiAgY29uc3QgcmVuZGVyZXIgPSBwYXJlbnRMVmlld1tSRU5ERVJFUl07XG4gIGZvciAoY29uc3QgdmlldyBvZiB2aWV3cykge1xuICAgIHJlbW92ZURlaHlkcmF0ZWRWaWV3KHZpZXcsIHJlbmRlcmVyKTtcbiAgICBuZ0Rldk1vZGUgJiYgbmdEZXZNb2RlLmRlaHlkcmF0ZWRWaWV3c1JlbW92ZWQrKztcbiAgfVxuICAvLyBSZXNldCB0aGUgdmFsdWUgdG8gYW4gZW1wdHkgYXJyYXkgdG8gaW5kaWNhdGUgdGhhdCBub1xuICAvLyBmdXJ0aGVyIHByb2Nlc3Npbmcgb2YgZGVoeWRyYXRlZCB2aWV3cyBpcyBuZWVkZWQgZm9yXG4gIC8vIHRoaXMgdmlldyBjb250YWluZXIgKGkuZS4gZG8gbm90IHRyaWdnZXIgdGhlIGxvb2t1cCBwcm9jZXNzXG4gIC8vIG9uY2UgYWdhaW4gaW4gY2FzZSBhIGBWaWV3Q29udGFpbmVyUmVmYCBpcyBjcmVhdGVkIGxhdGVyKS5cbiAgbENvbnRhaW5lcltERUhZRFJBVEVEX1ZJRVdTXSA9IEVNUFRZX0FSUkFZO1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byByZW1vdmUgYWxsIG5vZGVzIGZyb20gYSBkZWh5ZHJhdGVkIHZpZXcuXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZURlaHlkcmF0ZWRWaWV3KGRlaHlkcmF0ZWRWaWV3OiBEZWh5ZHJhdGVkQ29udGFpbmVyVmlldywgcmVuZGVyZXI6IFJlbmRlcmVyKSB7XG4gIGxldCBub2Rlc1JlbW92ZWQgPSAwO1xuICBsZXQgY3VycmVudFJOb2RlID0gZGVoeWRyYXRlZFZpZXcuZmlyc3RDaGlsZDtcbiAgaWYgKGN1cnJlbnRSTm9kZSkge1xuICAgIGNvbnN0IG51bU5vZGVzID0gZGVoeWRyYXRlZFZpZXcuZGF0YVtOVU1fUk9PVF9OT0RFU107XG4gICAgd2hpbGUgKG5vZGVzUmVtb3ZlZCA8IG51bU5vZGVzKSB7XG4gICAgICBuZ0Rldk1vZGUgJiYgdmFsaWRhdGVTaWJsaW5nTm9kZUV4aXN0cyhjdXJyZW50Uk5vZGUpO1xuICAgICAgY29uc3QgbmV4dFNpYmxpbmc6IFJOb2RlID0gY3VycmVudFJOb2RlLm5leHRTaWJsaW5nITtcbiAgICAgIG5hdGl2ZVJlbW92ZU5vZGUocmVuZGVyZXIsIGN1cnJlbnRSTm9kZSwgZmFsc2UpO1xuICAgICAgY3VycmVudFJOb2RlID0gbmV4dFNpYmxpbmc7XG4gICAgICBub2Rlc1JlbW92ZWQrKztcbiAgICB9XG4gIH1cbn1cbiJdfQ==
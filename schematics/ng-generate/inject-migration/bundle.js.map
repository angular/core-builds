{
  "version": 3,
  "sources": ["../../../../../../../../packages/core/schematics/ng-generate/inject-migration/index.ts", "../../../../../../../../packages/core/schematics/utils/change_tracker.ts", "../../../../../../../../packages/core/schematics/utils/import_manager.ts", "../../../../../../../../packages/core/schematics/utils/typescript/compiler_host.ts", "../../../../../../../../packages/core/schematics/utils/typescript/parse_tsconfig.ts", "../../../../../../../../packages/core/schematics/ng-generate/inject-migration/migration.ts", "../../../../../../../../packages/core/schematics/ng-generate/inject-migration/analysis.ts", "../../../../../../../../packages/core/schematics/utils/typescript/decorators.ts", "../../../../../../../../packages/core/schematics/utils/typescript/imports.ts", "../../../../../../../../packages/core/schematics/utils/ng_decorators.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Rule, SchematicsException, Tree} from '@angular-devkit/schematics';\nimport {join, relative} from 'path';\n\nimport {normalizePath} from '../../utils/change_tracker';\nimport {canMigrateFile, createMigrationProgram} from '../../utils/typescript/compiler_host';\n\nimport {migrateFile, MigrationOptions} from './migration';\n\ninterface Options extends MigrationOptions {\n  path: string;\n}\n\nexport default function (options: Options): Rule {\n  return async (tree: Tree) => {\n    const basePath = process.cwd();\n    const pathToMigrate = normalizePath(join(basePath, options.path));\n    let allPaths = [];\n    if (pathToMigrate.trim() !== '') {\n      allPaths.push(pathToMigrate);\n    }\n\n    if (!allPaths.length) {\n      throw new SchematicsException(\n        'Could not find any tsconfig file. Cannot run the inject migration.',\n      );\n    }\n\n    for (const tsconfigPath of allPaths) {\n      runInjectMigration(tree, tsconfigPath, basePath, pathToMigrate, options);\n    }\n  };\n}\n\nfunction runInjectMigration(\n  tree: Tree,\n  tsconfigPath: string,\n  basePath: string,\n  pathToMigrate: string,\n  schematicOptions: Options,\n): void {\n  if (schematicOptions.path.startsWith('..')) {\n    throw new SchematicsException('Cannot run inject migration outside of the current project.');\n  }\n\n  const program = createMigrationProgram(tree, tsconfigPath, basePath);\n  const sourceFiles = program\n    .getSourceFiles()\n    .filter(\n      (sourceFile) =>\n        sourceFile.fileName.startsWith(pathToMigrate) &&\n        canMigrateFile(basePath, sourceFile, program),\n    );\n\n  if (sourceFiles.length === 0) {\n    throw new SchematicsException(\n      `Could not find any files to migrate under the path ${pathToMigrate}. Cannot run the inject migration.`,\n    );\n  }\n\n  for (const sourceFile of sourceFiles) {\n    const changes = migrateFile(sourceFile, schematicOptions);\n    const update = tree.beginUpdate(relative(basePath, sourceFile.fileName));\n\n    changes.forEach((change) => {\n      if (change.removeLength != null) {\n        update.remove(change.start, change.removeLength);\n      }\n      update.insertRight(change.start, change.text);\n    });\n\n    tree.commitUpdate(update);\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\n\nimport {ImportManager} from './import_manager';\n\n/** Function that can be used to remap a generated import. */\nexport type ImportRemapper = (moduleName: string, inFile: string) => string;\n\n/** Mapping between a source file and the changes that have to be applied to it. */\nexport type ChangesByFile = ReadonlyMap<ts.SourceFile, PendingChange[]>;\n\n/** Change that needs to be applied to a file. */\nexport interface PendingChange {\n  /** Index at which to start changing the file. */\n  start: number;\n  /**\n   * Amount of text that should be removed after the `start`.\n   * No text will be removed if omitted.\n   */\n  removeLength?: number;\n  /** New text that should be inserted. */\n  text: string;\n}\n\n/** Tracks changes that have to be made for specific files. */\nexport class ChangeTracker {\n  private readonly _changes = new Map<ts.SourceFile, PendingChange[]>();\n  private readonly _importManager: ImportManager;\n\n  constructor(\n    private _printer: ts.Printer,\n    private _importRemapper?: ImportRemapper,\n  ) {\n    this._importManager = new ImportManager(\n      (currentFile) => ({\n        addNewImport: (start, text) => this.insertText(currentFile, start, text),\n        updateExistingImport: (namedBindings, text) =>\n          this.replaceText(currentFile, namedBindings.getStart(), namedBindings.getWidth(), text),\n      }),\n      this._printer,\n    );\n  }\n\n  /**\n   * Tracks the insertion of some text.\n   * @param sourceFile File in which the text is being inserted.\n   * @param start Index at which the text is insert.\n   * @param text Text to be inserted.\n   */\n  insertText(sourceFile: ts.SourceFile, index: number, text: string): void {\n    this._trackChange(sourceFile, {start: index, text});\n  }\n\n  /**\n   * Replaces text within a file.\n   * @param sourceFile File in which to replace the text.\n   * @param start Index from which to replace the text.\n   * @param removeLength Length of the text being replaced.\n   * @param text Text to be inserted instead of the old one.\n   */\n  replaceText(sourceFile: ts.SourceFile, start: number, removeLength: number, text: string): void {\n    this._trackChange(sourceFile, {start, removeLength, text});\n  }\n\n  /**\n   * Replaces the text of an AST node with a new one.\n   * @param oldNode Node to be replaced.\n   * @param newNode New node to be inserted.\n   * @param emitHint Hint when formatting the text of the new node.\n   * @param sourceFileWhenPrinting File to use when printing out the new node. This is important\n   * when copying nodes from one file to another, because TypeScript might not output literal nodes\n   * without it.\n   */\n  replaceNode(\n    oldNode: ts.Node,\n    newNode: ts.Node,\n    emitHint = ts.EmitHint.Unspecified,\n    sourceFileWhenPrinting?: ts.SourceFile,\n  ): void {\n    const sourceFile = oldNode.getSourceFile();\n    this.replaceText(\n      sourceFile,\n      oldNode.getStart(),\n      oldNode.getWidth(),\n      this._printer.printNode(emitHint, newNode, sourceFileWhenPrinting || sourceFile),\n    );\n  }\n\n  /**\n   * Removes the text of an AST node from a file.\n   * @param node Node whose text should be removed.\n   */\n  removeNode(node: ts.Node): void {\n    this._trackChange(node.getSourceFile(), {\n      start: node.getStart(),\n      removeLength: node.getWidth(),\n      text: '',\n    });\n  }\n\n  /**\n   * Adds an import to a file.\n   * @param sourceFile File to which to add the import.\n   * @param symbolName Symbol being imported.\n   * @param moduleName Module from which the symbol is imported.\n   * @param alias Alias to use for the import.\n   * @param keepSymbolName Whether to keep the symbol name in the import.\n   */\n  addImport(\n    sourceFile: ts.SourceFile,\n    symbolName: string,\n    moduleName: string,\n    alias: string | null = null,\n    keepSymbolName = false,\n  ): ts.Expression {\n    if (this._importRemapper) {\n      moduleName = this._importRemapper(moduleName, sourceFile.fileName);\n    }\n\n    // It's common for paths to be manipulated with Node's `path` utilties which\n    // can yield a path with back slashes. Normalize them since outputting such\n    // paths will also cause TS to escape the forward slashes.\n    moduleName = normalizePath(moduleName);\n\n    return this._importManager.addImportToSourceFile(\n      sourceFile,\n      symbolName,\n      moduleName,\n      alias,\n      false,\n      keepSymbolName,\n    );\n  }\n\n  /**\n   * Gets the changes that should be applied to all the files in the migration.\n   * The changes are sorted in the order in which they should be applied.\n   */\n  recordChanges(): ChangesByFile {\n    this._importManager.recordChanges();\n    return this._changes;\n  }\n\n  /**\n   * Clear the tracked changes\n   */\n  clearChanges(): void {\n    this._changes.clear();\n  }\n\n  /**\n   * Adds a change to a `ChangesByFile` map.\n   * @param file File that the change is associated with.\n   * @param change Change to be added.\n   */\n  private _trackChange(file: ts.SourceFile, change: PendingChange): void {\n    const changes = this._changes.get(file);\n\n    if (changes) {\n      // Insert the changes in reverse so that they're applied in reverse order.\n      // This ensures that the offsets of subsequent changes aren't affected by\n      // previous changes changing the file's text.\n      const insertIndex = changes.findIndex((current) => current.start <= change.start);\n\n      if (insertIndex === -1) {\n        changes.push(change);\n      } else {\n        changes.splice(insertIndex, 0, change);\n      }\n    } else {\n      this._changes.set(file, [change]);\n    }\n  }\n}\n\n/** Normalizes a path to use posix separators. */\nexport function normalizePath(path: string): string {\n  return path.replace(/\\\\/g, '/');\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {dirname, resolve} from 'path';\nimport ts from 'typescript';\n\n/** Update recorder for managing imports. */\nexport interface ImportManagerUpdateRecorder {\n  addNewImport(start: number, importText: string): void;\n  updateExistingImport(namedBindings: ts.NamedImports, newNamedBindings: string): void;\n}\n\n/** Possible types of quotes for imports. */\nconst enum QuoteStyle {\n  Single,\n  Double,\n}\n\n/**\n * Import manager that can be used to add TypeScript imports to given source\n * files. The manager ensures that multiple transformations are applied properly\n * without shifted offsets and that similar existing import declarations are re-used.\n */\nexport class ImportManager {\n  /** Map of import declarations that need to be updated to include the given symbols. */\n  private updatedImports = new Map<\n    ts.ImportDeclaration,\n    {propertyName?: ts.Identifier; importName: ts.Identifier}[]\n  >();\n  /** Map of source-files and their previously used identifier names. */\n  private usedIdentifierNames = new Map<ts.SourceFile, string[]>();\n  /** Map of source files and the new imports that have to be added to them. */\n  private newImports: Map<\n    ts.SourceFile,\n    {\n      importStartIndex: number;\n      defaultImports: Map<string, ts.Identifier>;\n      namedImports: Map<string, ts.ImportSpecifier[]>;\n    }\n  > = new Map();\n  /** Map between a file and the implied quote style for imports. */\n  private quoteStyles: Record<string, QuoteStyle> = {};\n\n  /**\n   * Array of previously resolved symbol imports. Cache can be re-used to return\n   * the same identifier without checking the source-file again.\n   */\n  private importCache: {\n    sourceFile: ts.SourceFile;\n    symbolName: string | null;\n    alias: string | null;\n    moduleName: string;\n    identifier: ts.Identifier;\n  }[] = [];\n\n  constructor(\n    private getUpdateRecorder: (sf: ts.SourceFile) => ImportManagerUpdateRecorder,\n    private printer: ts.Printer,\n  ) {}\n\n  /**\n   * Adds an import to the given source-file and returns the TypeScript\n   * identifier that can be used to access the newly imported symbol.\n   */\n  addImportToSourceFile(\n    sourceFile: ts.SourceFile,\n    symbolName: string | null,\n    moduleName: string,\n    alias: string | null = null,\n    typeImport = false,\n    keepSymbolName = false,\n  ): ts.Expression {\n    const sourceDir = dirname(sourceFile.fileName);\n    let importStartIndex = 0;\n    let existingImport: ts.ImportDeclaration | null = null;\n\n    // In case the given import has been already generated previously, we just return\n    // the previous generated identifier in order to avoid duplicate generated imports.\n    const cachedImport = this.importCache.find(\n      (c) =>\n        c.sourceFile === sourceFile &&\n        c.symbolName === symbolName &&\n        c.moduleName === moduleName &&\n        c.alias === alias,\n    );\n    if (cachedImport) {\n      return cachedImport.identifier;\n    }\n\n    // Walk through all source-file top-level statements and search for import declarations\n    // that already match the specified \"moduleName\" and can be updated to import the\n    // given symbol. If no matching import can be found, the last import in the source-file\n    // will be used as starting point for a new import that will be generated.\n    for (let i = sourceFile.statements.length - 1; i >= 0; i--) {\n      const statement = sourceFile.statements[i];\n\n      if (\n        !ts.isImportDeclaration(statement) ||\n        !ts.isStringLiteral(statement.moduleSpecifier) ||\n        !statement.importClause\n      ) {\n        continue;\n      }\n\n      if (importStartIndex === 0) {\n        importStartIndex = this._getEndPositionOfNode(statement);\n      }\n\n      const moduleSpecifier = statement.moduleSpecifier.text;\n\n      if (\n        (moduleSpecifier.startsWith('.') &&\n          resolve(sourceDir, moduleSpecifier) !== resolve(sourceDir, moduleName)) ||\n        moduleSpecifier !== moduleName\n      ) {\n        continue;\n      }\n\n      if (statement.importClause.namedBindings) {\n        const namedBindings = statement.importClause.namedBindings;\n\n        // In case a \"Type\" symbol is imported, we can't use namespace imports\n        // because these only export symbols available at runtime (no types)\n        if (ts.isNamespaceImport(namedBindings) && !typeImport) {\n          return ts.factory.createPropertyAccessExpression(\n            ts.factory.createIdentifier(namedBindings.name.text),\n            ts.factory.createIdentifier(alias || symbolName || 'default'),\n          );\n        } else if (ts.isNamedImports(namedBindings) && symbolName) {\n          const existingElement = namedBindings.elements.find((e) => {\n            // TODO(crisbeto): if an alias conflicts with an existing import, it may cause invalid\n            // code to be generated. This is unlikely, but we may want to revisit it in the future.\n            if (alias) {\n              return e.propertyName && e.name.text === alias && e.propertyName.text === symbolName;\n            }\n            return e.propertyName ? e.propertyName.text === symbolName : e.name.text === symbolName;\n          });\n\n          if (existingElement) {\n            return ts.factory.createIdentifier(existingElement.name.text);\n          }\n\n          // In case the symbol could not be found in an existing import, we\n          // keep track of the import declaration as it can be updated to include\n          // the specified symbol name without having to create a new import.\n          existingImport = statement;\n        }\n      } else if (statement.importClause.name && !symbolName) {\n        return ts.factory.createIdentifier(statement.importClause.name.text);\n      }\n    }\n\n    if (existingImport) {\n      const {propertyName, name} = this._getImportParts(\n        sourceFile,\n        symbolName!,\n        alias,\n        keepSymbolName,\n      );\n\n      // Since it can happen that multiple classes need to be imported within the\n      // specified source file and we want to add the identifiers to the existing\n      // import declaration, we need to keep track of the updated import declarations.\n      // We can't directly update the import declaration for each identifier as this\n      // would throw off the recorder offsets. We need to keep track of the new identifiers\n      // for the import and perform the import transformation as batches per source-file.\n      this.updatedImports.set(\n        existingImport,\n        (this.updatedImports.get(existingImport) || []).concat({propertyName, importName: name}),\n      );\n\n      // Keep track of all updated imports so that we don't generate duplicate\n      // similar imports as these can't be statically analyzed in the source-file yet.\n      this.importCache.push({sourceFile, moduleName, symbolName, alias, identifier: name});\n\n      return name;\n    }\n\n    let identifier: ts.Identifier | null = null;\n\n    if (!this.newImports.has(sourceFile)) {\n      this.newImports.set(sourceFile, {\n        importStartIndex,\n        defaultImports: new Map(),\n        namedImports: new Map(),\n      });\n    }\n\n    if (symbolName) {\n      const {propertyName, name} = this._getImportParts(\n        sourceFile,\n        symbolName,\n        alias,\n        keepSymbolName,\n      );\n      const importMap = this.newImports.get(sourceFile)!.namedImports;\n      identifier = name;\n\n      if (!importMap.has(moduleName)) {\n        importMap.set(moduleName, []);\n      }\n\n      importMap.get(moduleName)!.push(ts.factory.createImportSpecifier(false, propertyName, name));\n    } else {\n      const importMap = this.newImports.get(sourceFile)!.defaultImports;\n      identifier = this._getUniqueIdentifier(sourceFile, 'defaultExport');\n      importMap.set(moduleName, identifier);\n    }\n\n    // Keep track of all generated imports so that we don't generate duplicate\n    // similar imports as these can't be statically analyzed in the source-file yet.\n    this.importCache.push({sourceFile, symbolName, moduleName, alias, identifier});\n\n    return identifier;\n  }\n\n  /**\n   * Stores the collected import changes within the appropriate update recorders. The\n   * updated imports can only be updated *once* per source-file because previous updates\n   * could otherwise shift the source-file offsets.\n   */\n  recordChanges() {\n    this.updatedImports.forEach((expressions, importDecl) => {\n      const sourceFile = importDecl.getSourceFile();\n      const recorder = this.getUpdateRecorder(sourceFile);\n      const namedBindings = importDecl.importClause!.namedBindings as ts.NamedImports;\n      const newNamedBindings = ts.factory.updateNamedImports(\n        namedBindings,\n        namedBindings.elements.concat(\n          expressions.map(({propertyName, importName}) =>\n            ts.factory.createImportSpecifier(false, propertyName, importName),\n          ),\n        ),\n      );\n\n      const newNamedBindingsText = this.printer.printNode(\n        ts.EmitHint.Unspecified,\n        newNamedBindings,\n        sourceFile,\n      );\n      recorder.updateExistingImport(namedBindings, newNamedBindingsText);\n    });\n\n    this.newImports.forEach(({importStartIndex, defaultImports, namedImports}, sourceFile) => {\n      const recorder = this.getUpdateRecorder(sourceFile);\n      const useSingleQuotes = this._getQuoteStyle(sourceFile) === QuoteStyle.Single;\n\n      defaultImports.forEach((identifier, moduleName) => {\n        const newImport = ts.factory.createImportDeclaration(\n          undefined,\n          ts.factory.createImportClause(false, identifier, undefined),\n          ts.factory.createStringLiteral(moduleName, useSingleQuotes),\n        );\n\n        recorder.addNewImport(\n          importStartIndex,\n          this._getNewImportText(importStartIndex, newImport, sourceFile),\n        );\n      });\n\n      namedImports.forEach((specifiers, moduleName) => {\n        const newImport = ts.factory.createImportDeclaration(\n          undefined,\n          ts.factory.createImportClause(\n            false,\n            undefined,\n            ts.factory.createNamedImports(specifiers),\n          ),\n          ts.factory.createStringLiteral(moduleName, useSingleQuotes),\n        );\n\n        recorder.addNewImport(\n          importStartIndex,\n          this._getNewImportText(importStartIndex, newImport, sourceFile),\n        );\n      });\n    });\n  }\n\n  /** Gets an unique identifier with a base name for the given source file. */\n  private _getUniqueIdentifier(sourceFile: ts.SourceFile, baseName: string): ts.Identifier {\n    if (this.isUniqueIdentifierName(sourceFile, baseName)) {\n      this._recordUsedIdentifier(sourceFile, baseName);\n      return ts.factory.createIdentifier(baseName);\n    }\n\n    let name = null;\n    let counter = 1;\n    do {\n      name = `${baseName}_${counter++}`;\n    } while (!this.isUniqueIdentifierName(sourceFile, name));\n\n    this._recordUsedIdentifier(sourceFile, name!);\n    return ts.factory.createIdentifier(name!);\n  }\n\n  /**\n   * Checks whether the specified identifier name is used within the given\n   * source file.\n   */\n  private isUniqueIdentifierName(sourceFile: ts.SourceFile, name: string) {\n    if (\n      this.usedIdentifierNames.has(sourceFile) &&\n      this.usedIdentifierNames.get(sourceFile)!.indexOf(name) !== -1\n    ) {\n      return false;\n    }\n\n    // Walk through the source file and search for an identifier matching\n    // the given name. In that case, it's not guaranteed that this name\n    // is unique in the given declaration scope and we just return false.\n    const nodeQueue: ts.Node[] = [sourceFile];\n    while (nodeQueue.length) {\n      const node = nodeQueue.shift()!;\n      if (\n        ts.isIdentifier(node) &&\n        node.text === name &&\n        // Identifiers that are aliased in an import aren't\n        // problematic since they're used under a different name.\n        (!ts.isImportSpecifier(node.parent) || node.parent.propertyName !== node)\n      ) {\n        return false;\n      }\n      nodeQueue.push(...node.getChildren());\n    }\n    return true;\n  }\n\n  private _recordUsedIdentifier(sourceFile: ts.SourceFile, identifierName: string) {\n    this.usedIdentifierNames.set(\n      sourceFile,\n      (this.usedIdentifierNames.get(sourceFile) || []).concat(identifierName),\n    );\n  }\n\n  /**\n   * Determines the full end of a given node. By default the end position of a node is\n   * before all trailing comments. This could mean that generated imports shift comments.\n   */\n  private _getEndPositionOfNode(node: ts.Node) {\n    const nodeEndPos = node.getEnd();\n    const commentRanges = ts.getTrailingCommentRanges(node.getSourceFile().text, nodeEndPos);\n    if (!commentRanges || !commentRanges.length) {\n      return nodeEndPos;\n    }\n    return commentRanges[commentRanges.length - 1]!.end;\n  }\n\n  /** Gets the text that should be added to the file for a newly-created import declaration. */\n  private _getNewImportText(\n    importStartIndex: number,\n    newImport: ts.ImportDeclaration,\n    sourceFile: ts.SourceFile,\n  ): string {\n    const text = this.printer.printNode(ts.EmitHint.Unspecified, newImport, sourceFile);\n\n    // If the import is generated at the start of the source file, we want to add\n    // a new-line after the import. Otherwise if the import is generated after an\n    // existing import, we need to prepend a new-line so that the import is not on\n    // the same line as the existing import anchor\n    return importStartIndex === 0 ? `${text}\\n` : `\\n${text}`;\n  }\n\n  /**\n   * Gets the different parts necessary to construct an import specifier.\n   * @param sourceFile File in which the import is being inserted.\n   * @param symbolName Name of the symbol.\n   * @param alias Alias that the symbol may be available under.\n   * @returns Object containing the different parts. E.g. `{name: 'alias', propertyName: 'name'}`\n   * would correspond to `import {name as alias}` while `{name: 'name', propertyName: undefined}`\n   * corresponds to `import {name}`.\n   */\n  private _getImportParts(\n    sourceFile: ts.SourceFile,\n    symbolName: string,\n    alias: string | null,\n    keepSymbolName: boolean,\n  ) {\n    const symbolIdentifier = ts.factory.createIdentifier(symbolName);\n    const aliasIdentifier = alias ? ts.factory.createIdentifier(alias) : null;\n    const generatedUniqueIdentifier = this._getUniqueIdentifier(sourceFile, alias || symbolName);\n    const needsGeneratedUniqueName = generatedUniqueIdentifier.text !== (alias || symbolName);\n    let propertyName: ts.Identifier | undefined;\n    let name: ts.Identifier;\n\n    if (needsGeneratedUniqueName && !keepSymbolName) {\n      propertyName = symbolIdentifier;\n      name = generatedUniqueIdentifier;\n    } else if (aliasIdentifier) {\n      propertyName = symbolIdentifier;\n      name = aliasIdentifier;\n    } else {\n      name = symbolIdentifier;\n    }\n\n    return {propertyName, name};\n  }\n\n  /** Gets the quote style that is used for a file's imports. */\n  private _getQuoteStyle(sourceFile: ts.SourceFile): QuoteStyle {\n    if (!this.quoteStyles.hasOwnProperty(sourceFile.fileName)) {\n      let quoteStyle: QuoteStyle | undefined;\n\n      // Walk through the top-level imports and try to infer the quotes.\n      for (const statement of sourceFile.statements) {\n        if (\n          ts.isImportDeclaration(statement) &&\n          ts.isStringLiteralLike(statement.moduleSpecifier)\n        ) {\n          // Use `getText` instead of the actual text since it includes the quotes.\n          quoteStyle = statement.moduleSpecifier.getText().trim().startsWith('\"')\n            ? QuoteStyle.Double\n            : QuoteStyle.Single;\n          break;\n        }\n      }\n\n      // Otherwise fall back to single quotes.\n      this.quoteStyles[sourceFile.fileName] = quoteStyle ?? QuoteStyle.Single;\n    }\n\n    return this.quoteStyles[sourceFile.fileName];\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {Tree} from '@angular-devkit/schematics';\nimport {dirname, relative, resolve} from 'path';\nimport ts from 'typescript';\n\nimport {parseTsconfigFile} from './parse_tsconfig';\n\ntype FakeReadFileFn = (fileName: string) => string | undefined;\n\n/**\n * Creates a TypeScript program instance for a TypeScript project within\n * the virtual file system tree.\n * @param tree Virtual file system tree that contains the source files.\n * @param tsconfigPath Virtual file system path that resolves to the TypeScript project.\n * @param basePath Base path for the virtual file system tree.\n * @param fakeFileRead Optional file reader function. Can be used to overwrite files in\n *   the TypeScript program, or to add in-memory files (e.g. to add global types).\n * @param additionalFiles Additional file paths that should be added to the program.\n */\nexport function createMigrationProgram(\n  tree: Tree,\n  tsconfigPath: string,\n  basePath: string,\n  fakeFileRead?: FakeReadFileFn,\n  additionalFiles?: string[],\n) {\n  const {rootNames, options, host} = createProgramOptions(\n    tree,\n    tsconfigPath,\n    basePath,\n    fakeFileRead,\n    additionalFiles,\n  );\n  return ts.createProgram(rootNames, options, host);\n}\n\n/**\n * Creates the options necessary to instantiate a TypeScript program.\n * @param tree Virtual file system tree that contains the source files.\n * @param tsconfigPath Virtual file system path that resolves to the TypeScript project.\n * @param basePath Base path for the virtual file system tree.\n * @param fakeFileRead Optional file reader function. Can be used to overwrite files in\n *   the TypeScript program, or to add in-memory files (e.g. to add global types).\n * @param additionalFiles Additional file paths that should be added to the program.\n * @param optionOverrides Overrides of the parsed compiler options.\n */\nexport function createProgramOptions(\n  tree: Tree,\n  tsconfigPath: string,\n  basePath: string,\n  fakeFileRead?: FakeReadFileFn,\n  additionalFiles?: string[],\n  optionOverrides?: ts.CompilerOptions,\n) {\n  // Resolve the tsconfig path to an absolute path. This is needed as TypeScript otherwise\n  // is not able to resolve root directories in the given tsconfig. More details can be found\n  // in the following issue: https://github.com/microsoft/TypeScript/issues/37731.\n  tsconfigPath = resolve(basePath, tsconfigPath);\n  const parsed = parseTsconfigFile(tsconfigPath, dirname(tsconfigPath));\n  const options = optionOverrides ? {...parsed.options, ...optionOverrides} : parsed.options;\n  const host = createMigrationCompilerHost(tree, options, basePath, fakeFileRead);\n  return {rootNames: parsed.fileNames.concat(additionalFiles || []), options, host};\n}\n\nfunction createMigrationCompilerHost(\n  tree: Tree,\n  options: ts.CompilerOptions,\n  basePath: string,\n  fakeRead?: FakeReadFileFn,\n): ts.CompilerHost {\n  const host = ts.createCompilerHost(options, true);\n  const defaultReadFile = host.readFile;\n\n  // We need to overwrite the host \"readFile\" method, as we want the TypeScript\n  // program to be based on the file contents in the virtual file tree. Otherwise\n  // if we run multiple migrations we might have intersecting changes and\n  // source files.\n  host.readFile = (fileName) => {\n    const treeRelativePath = relative(basePath, fileName);\n    let result: string | undefined = fakeRead?.(treeRelativePath);\n\n    if (typeof result !== 'string') {\n      // If the relative path resolved to somewhere outside of the tree, fall back to\n      // TypeScript's default file reading function since the `tree` will throw an error.\n      result = treeRelativePath.startsWith('..')\n        ? defaultReadFile.call(host, fileName)\n        : tree.read(treeRelativePath)?.toString();\n    }\n\n    // Strip BOM as otherwise TSC methods (Ex: getWidth) will return an offset,\n    // which breaks the CLI UpdateRecorder.\n    // See: https://github.com/angular/angular/pull/30719\n    return typeof result === 'string' ? result.replace(/^\\uFEFF/, '') : undefined;\n  };\n\n  return host;\n}\n\n/**\n * Checks whether a file can be migrate by our automated migrations.\n * @param basePath Absolute path to the project.\n * @param sourceFile File being checked.\n * @param program Program that includes the source file.\n */\nexport function canMigrateFile(\n  basePath: string,\n  sourceFile: ts.SourceFile,\n  program: ts.Program,\n): boolean {\n  // We shouldn't migrate .d.ts files, files from an external library or type checking files.\n  if (\n    sourceFile.fileName.endsWith('.ngtypecheck.ts') ||\n    sourceFile.isDeclarationFile ||\n    program.isSourceFileFromExternalLibrary(sourceFile)\n  ) {\n    return false;\n  }\n\n  // Our migrations are set up to create a `Program` from the project's tsconfig and to migrate all\n  // the files within the program. This can include files that are outside of the Angular CLI\n  // project. We can't migrate files outside of the project, because our file system interactions\n  // go through the CLI's `Tree` which assumes that all files are within the project. See:\n  // https://github.com/angular/angular-cli/blob/0b0961c9c233a825b6e4bb59ab7f0790f9b14676/packages/angular_devkit/schematics/src/tree/host-tree.ts#L131\n  return !relative(basePath, sourceFile.fileName).startsWith('..');\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as path from 'path';\nimport ts from 'typescript';\n\nexport function parseTsconfigFile(tsconfigPath: string, basePath: string): ts.ParsedCommandLine {\n  const {config} = ts.readConfigFile(tsconfigPath, ts.sys.readFile);\n  const parseConfigHost = {\n    useCaseSensitiveFileNames: ts.sys.useCaseSensitiveFileNames,\n    fileExists: ts.sys.fileExists,\n    readDirectory: ts.sys.readDirectory,\n    readFile: ts.sys.readFile,\n  };\n\n  // Throw if incorrect arguments are passed to this function. Passing relative base paths\n  // results in root directories not being resolved and in later type checking runtime errors.\n  // More details can be found here: https://github.com/microsoft/TypeScript/issues/37731.\n  if (!path.isAbsolute(basePath)) {\n    throw Error('Unexpected relative base path has been specified.');\n  }\n\n  return ts.parseJsonConfigFileContent(config, parseConfigHost, basePath, {});\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\nimport {PendingChange, ChangeTracker} from '../../utils/change_tracker';\nimport {\n  detectClassesUsingDI,\n  getNodeIndentation,\n  getSuperParameters,\n  getConstructorUnusedParameters,\n  hasGenerics,\n  isNullableType,\n  parameterDeclaresProperty,\n} from './analysis';\nimport {getAngularDecorators} from '../../utils/ng_decorators';\n\n/**\n * Placeholder used to represent expressions inside the AST.\n * Includes Unicode characters to reduce the chance of collisions.\n */\nconst PLACEHOLDER = 'ɵɵngGeneratePlaceholderɵɵ';\n\n/** Options that can be used to configure the migration. */\nexport interface MigrationOptions {\n  /** Whether to generate code that keeps injectors backwards compatible. */\n  backwardsCompatibleConstructors: boolean;\n\n  /** Whether to migrate abstract classes. */\n  migrateAbstractClasses: boolean;\n\n  /** Whether to make the return type of `@Optinal()` parameters to be non-nullable. */\n  nonNullableOptional: boolean;\n}\n\n/**\n * Migrates all of the classes in a `SourceFile` away from constructor injection.\n * @param sourceFile File to be migrated.\n * @param options Options that configure the migration.\n */\nexport function migrateFile(sourceFile: ts.SourceFile, options: MigrationOptions): PendingChange[] {\n  // Note: even though externally we have access to the full program with a proper type\n  // checker, we create a new one that is local to the file for a couple of reasons:\n  // 1. Not having to depend on a program makes running the migration internally faster and easier.\n  // 2. All the necessary information for this migration is local so using a file-specific type\n  //    checker should speed up the lookups.\n  const localTypeChecker = getLocalTypeChecker(sourceFile);\n  const printer = ts.createPrinter();\n  const tracker = new ChangeTracker(printer);\n\n  detectClassesUsingDI(sourceFile, localTypeChecker).forEach((result) => {\n    migrateClass(\n      result.node,\n      result.constructor,\n      result.superCall,\n      options,\n      localTypeChecker,\n      printer,\n      tracker,\n    );\n  });\n\n  return tracker.recordChanges().get(sourceFile) || [];\n}\n\n/**\n * Migrates a class away from constructor injection.\n * @param node Class to be migrated.\n * @param constructor Reference to the class' constructor node.\n * @param superCall Reference to the constructor's `super()` call, if any.\n * @param options Options used to configure the migration.\n * @param localTypeChecker Type checker set up for the specific file.\n * @param printer Printer used to output AST nodes as strings.\n * @param tracker Object keeping track of the changes made to the file.\n */\nfunction migrateClass(\n  node: ts.ClassDeclaration,\n  constructor: ts.ConstructorDeclaration,\n  superCall: ts.CallExpression | null,\n  options: MigrationOptions,\n  localTypeChecker: ts.TypeChecker,\n  printer: ts.Printer,\n  tracker: ChangeTracker,\n): void {\n  const isAbstract = !!node.modifiers?.some((m) => m.kind === ts.SyntaxKind.AbstractKeyword);\n\n  // Don't migrate abstract classes by default, because\n  // their parameters aren't guaranteed to be injectable.\n  if (isAbstract && !options.migrateAbstractClasses) {\n    return;\n  }\n\n  const sourceFile = node.getSourceFile();\n  const unusedParameters = getConstructorUnusedParameters(constructor, localTypeChecker);\n  const superParameters = superCall\n    ? getSuperParameters(constructor, superCall, localTypeChecker)\n    : null;\n  const memberIndentation = getNodeIndentation(node.members[0]);\n  const innerReference = superCall || constructor.body?.statements[0] || constructor;\n  const innerIndentation = getNodeIndentation(innerReference);\n  const propsToAdd: string[] = [];\n  const prependToConstructor: string[] = [];\n  const afterSuper: string[] = [];\n  const removedMembers = new Set<ts.ClassElement>();\n\n  for (const param of constructor.parameters) {\n    const usedInSuper = superParameters !== null && superParameters.has(param);\n    const usedInConstructor = !unusedParameters.has(param);\n\n    migrateParameter(\n      param,\n      options,\n      localTypeChecker,\n      printer,\n      tracker,\n      superCall,\n      usedInSuper,\n      usedInConstructor,\n      memberIndentation,\n      innerIndentation,\n      prependToConstructor,\n      propsToAdd,\n      afterSuper,\n    );\n  }\n\n  // Delete all of the constructor overloads since below we're either going to\n  // remove the implementation, or we're going to delete all of the parameters.\n  for (const member of node.members) {\n    if (ts.isConstructorDeclaration(member) && member !== constructor) {\n      removedMembers.add(member);\n      tracker.replaceText(sourceFile, member.getFullStart(), member.getFullWidth(), '');\n    }\n  }\n\n  if (\n    !options.backwardsCompatibleConstructors &&\n    (!constructor.body || constructor.body.statements.length === 0)\n  ) {\n    // Drop the constructor if it was empty.\n    removedMembers.add(constructor);\n    tracker.replaceText(sourceFile, constructor.getFullStart(), constructor.getFullWidth(), '');\n  } else {\n    // If the constructor contains any statements, only remove the parameters.\n    // We always do this no matter what is passed into `backwardsCompatibleConstructors`.\n    stripConstructorParameters(constructor, tracker);\n\n    if (prependToConstructor.length > 0) {\n      tracker.insertText(\n        sourceFile,\n        innerReference.getFullStart(),\n        `\\n${prependToConstructor.join('\\n')}\\n`,\n      );\n    }\n  }\n\n  if (afterSuper.length > 0 && superCall !== null) {\n    tracker.insertText(sourceFile, superCall.getEnd() + 1, `\\n${afterSuper.join('\\n')}\\n`);\n  }\n\n  // Need to resolve this once all constructor signatures have been removed.\n  const memberReference = node.members.find((m) => !removedMembers.has(m)) || node.members[0];\n\n  // If `backwardsCompatibleConstructors` is enabled, we maintain\n  // backwards compatibility by adding a catch-all signature.\n  if (options.backwardsCompatibleConstructors) {\n    const extraSignature =\n      `\\n${memberIndentation}/** Inserted by Angular inject() migration for backwards compatibility */\\n` +\n      `${memberIndentation}constructor(...args: unknown[]);`;\n\n    // The new signature always has to be right before the constructor implementation.\n    if (memberReference === constructor) {\n      propsToAdd.push(extraSignature);\n    } else {\n      tracker.insertText(sourceFile, constructor.getFullStart(), '\\n' + extraSignature);\n    }\n  }\n\n  if (propsToAdd.length > 0) {\n    if (removedMembers.size === node.members.length) {\n      tracker.insertText(sourceFile, constructor.getEnd() + 1, `${propsToAdd.join('\\n')}\\n`);\n    } else {\n      // Insert the new properties after the first member that hasn't been deleted.\n      tracker.insertText(\n        sourceFile,\n        memberReference.getFullStart(),\n        `\\n${propsToAdd.join('\\n')}\\n`,\n      );\n    }\n  }\n}\n\n/**\n * Migrates a single parameter to `inject()` DI.\n * @param node Parameter to be migrated.\n * @param options Options used to configure the migration.\n * @param localTypeChecker Type checker set up for the specific file.\n * @param printer Printer used to output AST nodes as strings.\n * @param tracker Object keeping track of the changes made to the file.\n * @param superCall Call to `super()` from the class' constructor.\n * @param usedInSuper Whether the parameter is referenced inside of `super`.\n * @param usedInConstructor Whether the parameter is referenced inside the body of the constructor.\n * @param memberIndentation Indentation string to use when inserting new class members.\n * @param innerIndentation Indentation string to use when inserting new constructor statements.\n * @param prependToConstructor Statements to be prepended to the constructor.\n * @param propsToAdd Properties to be added to the class.\n * @param afterSuper Statements to be added after the `super` call.\n */\nfunction migrateParameter(\n  node: ts.ParameterDeclaration,\n  options: MigrationOptions,\n  localTypeChecker: ts.TypeChecker,\n  printer: ts.Printer,\n  tracker: ChangeTracker,\n  superCall: ts.CallExpression | null,\n  usedInSuper: boolean,\n  usedInConstructor: boolean,\n  memberIndentation: string,\n  innerIndentation: string,\n  prependToConstructor: string[],\n  propsToAdd: string[],\n  afterSuper: string[],\n): void {\n  if (!ts.isIdentifier(node.name)) {\n    return;\n  }\n\n  const name = node.name.text;\n  const replacementCall = createInjectReplacementCall(\n    node,\n    options,\n    localTypeChecker,\n    printer,\n    tracker,\n  );\n  const declaresProp = parameterDeclaresProperty(node);\n\n  // If the parameter declares a property, we need to declare it (e.g. `private foo: Foo`).\n  if (declaresProp) {\n    const prop = ts.factory.createPropertyDeclaration(\n      node.modifiers?.filter((modifier) => {\n        // Strip out the DI decorators, as well as `public` which is redundant.\n        return !ts.isDecorator(modifier) && modifier.kind !== ts.SyntaxKind.PublicKeyword;\n      }),\n      name,\n      undefined,\n      // We can't initialize the property if it's referenced within a `super` call.\n      // See the logic further below for the initialization.\n      usedInSuper ? node.type : undefined,\n      usedInSuper ? undefined : ts.factory.createIdentifier(PLACEHOLDER),\n    );\n\n    propsToAdd.push(\n      memberIndentation +\n        replaceNodePlaceholder(node.getSourceFile(), prop, replacementCall, printer),\n    );\n  }\n\n  // If the parameter is referenced within the constructor, we need to declare it as a variable.\n  if (usedInConstructor) {\n    if (usedInSuper) {\n      // Usages of `this` aren't allowed before `super` calls so we need to\n      // create a variable which calls `inject()` directly instead...\n      prependToConstructor.push(`${innerIndentation}const ${name} = ${replacementCall};`);\n\n      // ...then we can initialize the property after the `super` call.\n      if (declaresProp) {\n        afterSuper.push(`${innerIndentation}this.${name} = ${name};`);\n      }\n    } else if (declaresProp) {\n      // If the parameter declares a property (`private foo: foo`) and is used inside the class\n      // at the same time, we need to ensure that it's initialized to the value from the variable\n      // and that we only reference `this` after the `super` call.\n      const initializer = `${innerIndentation}const ${name} = this.${name};`;\n\n      if (superCall === null) {\n        prependToConstructor.push(initializer);\n      } else {\n        afterSuper.push(initializer);\n      }\n    } else {\n      // If the parameter is only referenced in the constructor, we\n      // don't need to declare any new properties.\n      prependToConstructor.push(`${innerIndentation}const ${name} = ${replacementCall};`);\n    }\n  }\n}\n\n/**\n * Creates a replacement `inject` call from a function parameter.\n * @param param Parameter for which to generate the `inject` call.\n * @param options Options used to configure the migration.\n * @param localTypeChecker Type checker set up for the specific file.\n * @param printer Printer used to output AST nodes as strings.\n * @param tracker Object keeping track of the changes made to the file.\n */\nfunction createInjectReplacementCall(\n  param: ts.ParameterDeclaration,\n  options: MigrationOptions,\n  localTypeChecker: ts.TypeChecker,\n  printer: ts.Printer,\n  tracker: ChangeTracker,\n): string {\n  const moduleName = '@angular/core';\n  const sourceFile = param.getSourceFile();\n  const decorators = getAngularDecorators(localTypeChecker, ts.getDecorators(param) || []);\n  const literalProps: ts.ObjectLiteralElementLike[] = [];\n  let injectedType = param.type?.getText() || '';\n  let typeArguments = param.type && hasGenerics(param.type) ? [param.type] : undefined;\n  let hasOptionalDecorator = false;\n\n  for (const decorator of decorators) {\n    if (decorator.moduleName !== moduleName) {\n      continue;\n    }\n\n    const firstArg = decorator.node.expression.arguments[0] as ts.Expression | undefined;\n\n    switch (decorator.name) {\n      case 'Inject':\n        if (firstArg) {\n          injectedType = firstArg.getText();\n\n          // `inject` no longer officially supports string injection so we need\n          // to cast to any. We maintain the type by passing it as a generic.\n          if (ts.isStringLiteralLike(firstArg)) {\n            typeArguments = [\n              param.type || ts.factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword),\n            ];\n            injectedType += ' as any';\n          }\n        }\n        break;\n\n      case 'Attribute':\n        if (firstArg) {\n          const constructorRef = tracker.addImport(sourceFile, 'HostAttributeToken', moduleName);\n          const expression = ts.factory.createNewExpression(constructorRef, undefined, [firstArg]);\n          injectedType = printer.printNode(ts.EmitHint.Unspecified, expression, sourceFile);\n          typeArguments = undefined;\n        }\n        break;\n\n      case 'Optional':\n        hasOptionalDecorator = true;\n        literalProps.push(ts.factory.createPropertyAssignment('optional', ts.factory.createTrue()));\n        break;\n\n      case 'SkipSelf':\n        literalProps.push(ts.factory.createPropertyAssignment('skipSelf', ts.factory.createTrue()));\n        break;\n\n      case 'Self':\n        literalProps.push(ts.factory.createPropertyAssignment('self', ts.factory.createTrue()));\n        break;\n\n      case 'Host':\n        literalProps.push(ts.factory.createPropertyAssignment('host', ts.factory.createTrue()));\n        break;\n    }\n  }\n\n  // The injected type might be a `TypeNode` which we can't easily convert into an `Expression`.\n  // Since the value gets passed through directly anyway, we generate the call using a placeholder\n  // which we then replace with the raw text of the `TypeNode`.\n  const injectRef = tracker.addImport(param.getSourceFile(), 'inject', moduleName);\n  const args: ts.Expression[] = [ts.factory.createIdentifier(PLACEHOLDER)];\n\n  if (literalProps.length > 0) {\n    args.push(ts.factory.createObjectLiteralExpression(literalProps));\n  }\n\n  let expression: ts.Expression = ts.factory.createCallExpression(injectRef, typeArguments, args);\n\n  if (hasOptionalDecorator && options.nonNullableOptional) {\n    const hasNullableType =\n      param.questionToken != null || (param.type != null && isNullableType(param.type));\n\n    // Only wrap the expression if the type wasn't already nullable.\n    // If it was, the app was likely accounting for it already.\n    if (!hasNullableType) {\n      expression = ts.factory.createNonNullExpression(expression);\n    }\n  }\n\n  return replaceNodePlaceholder(param.getSourceFile(), expression, injectedType, printer);\n}\n\n/**\n * Removes the parameters from a constructor. This is a bit more complex than just replacing an AST\n * node, because `NodeArray.pos` includes any leading whitespace, but `NodeArray.end` does **not**\n * include trailing whitespace. Since we want to produce somewhat formatted code, we need to find\n * the end of the arguments ourselves. We do it by finding the next parenthesis after the last\n * parameter.\n * @param node Constructor from which to remove the parameters.\n * @param tracker Object keeping track of the changes made to the file.\n */\nfunction stripConstructorParameters(node: ts.ConstructorDeclaration, tracker: ChangeTracker): void {\n  if (node.parameters.length === 0) {\n    return;\n  }\n\n  const constructorText = node.getText();\n  const lastParamText = node.parameters[node.parameters.length - 1].getText();\n  const lastParamStart = constructorText.indexOf(lastParamText);\n  const whitespacePattern = /\\s/;\n  let trailingCharacters = 0;\n\n  if (lastParamStart > -1) {\n    let lastParamEnd = lastParamStart + lastParamText.length;\n    let closeParenIndex = -1;\n\n    for (let i = lastParamEnd; i < constructorText.length; i++) {\n      const char = constructorText[i];\n\n      if (char === ')') {\n        closeParenIndex = i;\n        break;\n      } else if (!whitespacePattern.test(char)) {\n        // The end of the last parameter won't include\n        // any trailing commas which we need to account for.\n        lastParamEnd = i + 1;\n      }\n    }\n\n    if (closeParenIndex > -1) {\n      trailingCharacters = closeParenIndex - lastParamEnd;\n    }\n  }\n\n  tracker.replaceText(\n    node.getSourceFile(),\n    node.parameters.pos,\n    node.parameters.end - node.parameters.pos + trailingCharacters,\n    '',\n  );\n}\n\n/**\n * Creates a type checker scoped to a specific file.\n * @param sourceFile File for which to create the type checker.\n */\nfunction getLocalTypeChecker(sourceFile: ts.SourceFile) {\n  const options: ts.CompilerOptions = {noEmit: true, skipLibCheck: true};\n  const host = ts.createCompilerHost(options);\n  host.getSourceFile = (fileName) => (fileName === sourceFile.fileName ? sourceFile : undefined);\n  const program = ts.createProgram({\n    rootNames: [sourceFile.fileName],\n    options,\n    host,\n  });\n\n  return program.getTypeChecker();\n}\n\n/**\n * Prints out an AST node and replaces the placeholder inside of it.\n * @param sourceFile File in which the node will be inserted.\n * @param node Node to be printed out.\n * @param replacement Replacement for the placeholder.\n * @param printer Printer used to output AST nodes as strings.\n */\nfunction replaceNodePlaceholder(\n  sourceFile: ts.SourceFile,\n  node: ts.Node,\n  replacement: string,\n  printer: ts.Printer,\n): string {\n  const result = printer.printNode(ts.EmitHint.Unspecified, node, sourceFile);\n  return result.replace(PLACEHOLDER, replacement);\n}\n", "/*!\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\nimport {getAngularDecorators} from '../../utils/ng_decorators';\n\n/** Names of decorators that enable DI on a class declaration. */\nconst DECORATORS_SUPPORTING_DI = new Set([\n  'Component',\n  'Directive',\n  'Pipe',\n  'NgModule',\n  'Injectable',\n]);\n\n/**\n * Detects the classes within a file that are likely using DI.\n * @param sourceFile File in which to search for classes.\n * @param localTypeChecker Type checker scoped to the specific file.\n */\nexport function detectClassesUsingDI(sourceFile: ts.SourceFile, localTypeChecker: ts.TypeChecker) {\n  const results: {\n    node: ts.ClassDeclaration;\n    constructor: ts.ConstructorDeclaration;\n    superCall: ts.CallExpression | null;\n  }[] = [];\n\n  sourceFile.forEachChild(function walk(node) {\n    if (ts.isClassDeclaration(node)) {\n      const decorators = getAngularDecorators(localTypeChecker, ts.getDecorators(node) || []);\n      const supportsDI = decorators.some((dec) => DECORATORS_SUPPORTING_DI.has(dec.name));\n      const constructorNode = node.members.find(\n        (member) =>\n          ts.isConstructorDeclaration(member) &&\n          member.body != null &&\n          member.parameters.length > 0,\n      ) as ts.ConstructorDeclaration | undefined;\n\n      if (supportsDI && constructorNode) {\n        results.push({\n          node,\n          constructor: constructorNode,\n          superCall: node.heritageClauses ? findSuperCall(constructorNode) : null,\n        });\n      }\n    }\n\n    node.forEachChild(walk);\n  });\n\n  return results;\n}\n\n/**\n * Returns the parameters of a function that aren't used within its body.\n * @param declaration Function in which to search for unused parameters.\n * @param localTypeChecker Type checker scoped to the file in which the function was declared.\n */\nexport function getConstructorUnusedParameters(\n  declaration: ts.ConstructorDeclaration,\n  localTypeChecker: ts.TypeChecker,\n): Set<ts.ParameterDeclaration> {\n  const accessedTopLevelParameters = new Set<ts.ParameterDeclaration>();\n  const topLevelParameters = new Set<ts.ParameterDeclaration>();\n  const topLevelParameterNames = new Set<string>();\n  const unusedParams = new Set<ts.ParameterDeclaration>();\n\n  // Prepare the parameters for quicker checks further down.\n  for (const param of declaration.parameters) {\n    if (ts.isIdentifier(param.name)) {\n      topLevelParameters.add(param);\n      topLevelParameterNames.add(param.name.text);\n    }\n  }\n\n  if (!declaration.body) {\n    return topLevelParameters;\n  }\n\n  declaration.body.forEachChild(function walk(node) {\n    if (!ts.isIdentifier(node) || !topLevelParameterNames.has(node.text)) {\n      node.forEachChild(walk);\n      return;\n    }\n\n    // Don't consider `this.<name>` accesses as being references to\n    // parameters since they'll be moved to property declarations.\n    if (\n      ts.isPropertyAccessExpression(node.parent) &&\n      node.parent.expression.kind === ts.SyntaxKind.ThisKeyword &&\n      node.parent.name === node\n    ) {\n      return;\n    }\n\n    localTypeChecker.getSymbolAtLocation(node)?.declarations?.forEach((decl) => {\n      if (ts.isParameter(decl) && topLevelParameters.has(decl)) {\n        accessedTopLevelParameters.add(decl);\n      }\n    });\n  });\n\n  for (const param of topLevelParameters) {\n    if (!accessedTopLevelParameters.has(param)) {\n      unusedParams.add(param);\n    }\n  }\n\n  return unusedParams;\n}\n\n/**\n * Determines which parameters of a function declaration are used within its `super` call.\n * @param declaration Function whose parameters to search for.\n * @param superCall `super()` call within the function.\n * @param localTypeChecker Type checker scoped to the file in which the function is declared.\n */\nexport function getSuperParameters(\n  declaration: ts.FunctionLikeDeclaration,\n  superCall: ts.CallExpression,\n  localTypeChecker: ts.TypeChecker,\n): Set<ts.ParameterDeclaration> {\n  const usedParams = new Set<ts.ParameterDeclaration>();\n  const topLevelParameters = new Set<ts.ParameterDeclaration>();\n  const topLevelParameterNames = new Set<string>();\n\n  // Prepare the parameters for quicker checks further down.\n  for (const param of declaration.parameters) {\n    if (ts.isIdentifier(param.name)) {\n      topLevelParameters.add(param);\n      topLevelParameterNames.add(param.name.text);\n    }\n  }\n\n  superCall.forEachChild(function walk(node) {\n    if (ts.isIdentifier(node) && topLevelParameterNames.has(node.text)) {\n      localTypeChecker.getSymbolAtLocation(node)?.declarations?.forEach((decl) => {\n        if (ts.isParameter(decl) && topLevelParameters.has(decl)) {\n          usedParams.add(decl);\n        }\n      });\n    } else {\n      node.forEachChild(walk);\n    }\n  });\n\n  return usedParams;\n}\n\n/**\n * Gets the indentation text of a node. Can be used to\n * output text with the same level of indentation.\n * @param node Node for which to get the indentation level.\n */\nexport function getNodeIndentation(node: ts.Node): string {\n  const fullText = node.getFullText();\n  const end = fullText.indexOf(node.getText());\n  let result = '';\n\n  for (let i = end - 1; i > -1; i--) {\n    // Note: LF line endings are `\\n` while CRLF are `\\r\\n`. This logic should cover both, because\n    // we start from the beginning of the node and go backwards so will always hit `\\n` first.\n    if (fullText[i] !== '\\n') {\n      result = fullText[i] + result;\n    } else {\n      break;\n    }\n  }\n\n  return result;\n}\n\n/** Checks whether a parameter node declares a property on its class. */\nexport function parameterDeclaresProperty(node: ts.ParameterDeclaration): boolean {\n  return !!node.modifiers?.some(\n    ({kind}) =>\n      kind === ts.SyntaxKind.PublicKeyword ||\n      kind === ts.SyntaxKind.PrivateKeyword ||\n      kind === ts.SyntaxKind.ProtectedKeyword ||\n      kind === ts.SyntaxKind.ReadonlyKeyword,\n  );\n}\n\n/** Checks whether a type node is nullable. */\nexport function isNullableType(node: ts.TypeNode): boolean {\n  // Apparently `foo: null` is `Parameter<TypeNode<NullKeyword>>`,\n  // while `foo: undefined` is `Parameter<UndefinedKeyword>`...\n  if (node.kind === ts.SyntaxKind.UndefinedKeyword || node.kind === ts.SyntaxKind.VoidKeyword) {\n    return true;\n  }\n\n  if (ts.isLiteralTypeNode(node)) {\n    return node.literal.kind === ts.SyntaxKind.NullKeyword;\n  }\n\n  if (ts.isUnionTypeNode(node)) {\n    return node.types.some(isNullableType);\n  }\n\n  return false;\n}\n\n/** Checks whether a type node has generic arguments. */\nexport function hasGenerics(node: ts.TypeNode): boolean {\n  if (ts.isTypeReferenceNode(node)) {\n    return node.typeArguments != null && node.typeArguments.length > 0;\n  }\n\n  if (ts.isUnionTypeNode(node)) {\n    return node.types.some(hasGenerics);\n  }\n\n  return false;\n}\n\n/** Finds a `super` call inside of a specific node. */\nfunction findSuperCall(root: ts.Node): ts.CallExpression | null {\n  let result: ts.CallExpression | null = null;\n\n  root.forEachChild(function find(node) {\n    if (ts.isCallExpression(node) && node.expression.kind === ts.SyntaxKind.SuperKeyword) {\n      result = node;\n    } else if (result === null) {\n      node.forEachChild(find);\n    }\n  });\n\n  return result;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\n\nimport {getImportOfIdentifier, Import} from './imports';\n\nexport function getCallDecoratorImport(\n  typeChecker: ts.TypeChecker,\n  decorator: ts.Decorator,\n): Import | null {\n  // Note that this does not cover the edge case where decorators are called from\n  // a namespace import: e.g. \"@core.Component()\". This is not handled by Ngtsc either.\n  if (\n    !ts.isCallExpression(decorator.expression) ||\n    !ts.isIdentifier(decorator.expression.expression)\n  ) {\n    return null;\n  }\n\n  const identifier = decorator.expression.expression;\n  return getImportOfIdentifier(typeChecker, identifier);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\n\nexport type Import = {\n  name: string;\n  importModule: string;\n  node: ts.ImportDeclaration;\n};\n\n/** Gets import information about the specified identifier by using the Type checker. */\nexport function getImportOfIdentifier(\n  typeChecker: ts.TypeChecker,\n  node: ts.Identifier,\n): Import | null {\n  const symbol = typeChecker.getSymbolAtLocation(node);\n\n  if (!symbol || symbol.declarations === undefined || !symbol.declarations.length) {\n    return null;\n  }\n\n  const decl = symbol.declarations[0];\n\n  if (!ts.isImportSpecifier(decl)) {\n    return null;\n  }\n\n  const importDecl = decl.parent.parent.parent;\n\n  if (!ts.isImportDeclaration(importDecl) || !ts.isStringLiteral(importDecl.moduleSpecifier)) {\n    return null;\n  }\n\n  return {\n    // Handles aliased imports: e.g. \"import {Component as myComp} from ...\";\n    name: decl.propertyName ? decl.propertyName.text : decl.name.text,\n    importModule: importDecl.moduleSpecifier.text,\n    node: importDecl,\n  };\n}\n\n/**\n * Gets a top-level import specifier with a specific name that is imported from a particular module.\n * E.g. given a file that looks like:\n *\n * ```\n * import { Component, Directive } from '@angular/core';\n * import { Foo } from './foo';\n * ```\n *\n * Calling `getImportSpecifier(sourceFile, '@angular/core', 'Directive')` will yield the node\n * referring to `Directive` in the top import.\n *\n * @param sourceFile File in which to look for imports.\n * @param moduleName Name of the import's module.\n * @param specifierName Original name of the specifier to look for. Aliases will be resolved to\n *    their original name.\n */\nexport function getImportSpecifier(\n  sourceFile: ts.SourceFile,\n  moduleName: string | RegExp,\n  specifierName: string,\n): ts.ImportSpecifier | null {\n  return getImportSpecifiers(sourceFile, moduleName, [specifierName])[0] ?? null;\n}\n\nexport function getImportSpecifiers(\n  sourceFile: ts.SourceFile,\n  moduleName: string | RegExp,\n  specifierNames: string[],\n): ts.ImportSpecifier[] {\n  const matches: ts.ImportSpecifier[] = [];\n  for (const node of sourceFile.statements) {\n    if (ts.isImportDeclaration(node) && ts.isStringLiteral(node.moduleSpecifier)) {\n      const isMatch =\n        typeof moduleName === 'string'\n          ? node.moduleSpecifier.text === moduleName\n          : moduleName.test(node.moduleSpecifier.text);\n      const namedBindings = node.importClause?.namedBindings;\n      if (isMatch && namedBindings && ts.isNamedImports(namedBindings)) {\n        for (const specifierName of specifierNames) {\n          const match = findImportSpecifier(namedBindings.elements, specifierName);\n          if (match) {\n            matches.push(match);\n          }\n        }\n      }\n    }\n  }\n  return matches;\n}\n\nexport function getNamedImports(\n  sourceFile: ts.SourceFile,\n  moduleName: string | RegExp,\n): ts.NamedImports | null {\n  for (const node of sourceFile.statements) {\n    if (ts.isImportDeclaration(node) && ts.isStringLiteral(node.moduleSpecifier)) {\n      const isMatch =\n        typeof moduleName === 'string'\n          ? node.moduleSpecifier.text === moduleName\n          : moduleName.test(node.moduleSpecifier.text);\n      const namedBindings = node.importClause?.namedBindings;\n      if (isMatch && namedBindings && ts.isNamedImports(namedBindings)) {\n        return namedBindings;\n      }\n    }\n  }\n  return null;\n}\n\n/**\n * Replaces an import inside a named imports node with a different one.\n *\n * @param node Node that contains the imports.\n * @param existingImport Import that should be replaced.\n * @param newImportName Import that should be inserted.\n */\nexport function replaceImport(\n  node: ts.NamedImports,\n  existingImport: string,\n  newImportName: string,\n) {\n  const isAlreadyImported = findImportSpecifier(node.elements, newImportName);\n  if (isAlreadyImported) {\n    return node;\n  }\n\n  const existingImportNode = findImportSpecifier(node.elements, existingImport);\n  if (!existingImportNode) {\n    return node;\n  }\n\n  const importPropertyName = existingImportNode.propertyName\n    ? ts.factory.createIdentifier(newImportName)\n    : undefined;\n  const importName = existingImportNode.propertyName\n    ? existingImportNode.name\n    : ts.factory.createIdentifier(newImportName);\n\n  return ts.factory.updateNamedImports(node, [\n    ...node.elements.filter((current) => current !== existingImportNode),\n    // Create a new import while trying to preserve the alias of the old one.\n    ts.factory.createImportSpecifier(false, importPropertyName, importName),\n  ]);\n}\n\n/**\n * Removes a symbol from the named imports and updates a node\n * that represents a given named imports.\n *\n * @param node Node that contains the imports.\n * @param symbol Symbol that should be removed.\n * @returns An updated node (ts.NamedImports).\n */\nexport function removeSymbolFromNamedImports(node: ts.NamedImports, symbol: ts.ImportSpecifier) {\n  return ts.factory.updateNamedImports(node, [\n    ...node.elements.filter((current) => current !== symbol),\n  ]);\n}\n\n/** Finds an import specifier with a particular name. */\nexport function findImportSpecifier(\n  nodes: ts.NodeArray<ts.ImportSpecifier>,\n  specifierName: string,\n): ts.ImportSpecifier | undefined {\n  return nodes.find((element) => {\n    const {name, propertyName} = element;\n    return propertyName ? propertyName.text === specifierName : name.text === specifierName;\n  });\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\nimport {getCallDecoratorImport} from './typescript/decorators';\n\nexport type CallExpressionDecorator = ts.Decorator & {\n  expression: ts.CallExpression;\n};\n\nexport interface NgDecorator {\n  name: string;\n  moduleName: string;\n  node: CallExpressionDecorator;\n  importNode: ts.ImportDeclaration;\n}\n\n/**\n * Gets all decorators which are imported from an Angular package (e.g. \"@angular/core\")\n * from a list of decorators.\n */\nexport function getAngularDecorators(\n  typeChecker: ts.TypeChecker,\n  decorators: ReadonlyArray<ts.Decorator>,\n): NgDecorator[] {\n  return decorators\n    .map((node) => ({node, importData: getCallDecoratorImport(typeChecker, node)}))\n    .filter(({importData}) => importData && importData.importModule.startsWith('@angular/'))\n    .map(({node, importData}) => ({\n      node: node as CallExpressionDecorator,\n      name: importData!.name,\n      moduleName: importData!.importModule,\n      importNode: importData!.node,\n    }));\n}\n"],
  "mappings": "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",
  "names": ["import_path", "import_typescript", "ts", "ts", "path", "import_path", "import_typescript", "import_typescript", "ts", "ts", "import_typescript", "import_typescript", "import_typescript", "import_typescript", "ts", "ts", "ts", "ts", "expression"]
}

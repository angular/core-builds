'use strict';
/**
 * @license Angular v21.0.0-next.9+sha-b41a070
 * (c) 2010-2025 Google LLC. https://angular.io/
 * License: MIT
 */
'use strict';

var ts = require('typescript');
var o = require('@angular/compiler');
require('os');
var fs$1 = require('fs');
var module$1 = require('module');
var p = require('path');
var url = require('url');
var core = require('@angular-devkit/core');

var _documentCurrentScript = typeof document !== 'undefined' ? document.currentScript : null;
function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var o__namespace = /*#__PURE__*/_interopNamespaceDefault(o);
var p__namespace = /*#__PURE__*/_interopNamespaceDefault(p);
var url__namespace = /*#__PURE__*/_interopNamespaceDefault(url);

/**
 * @publicApi
 */
exports.ErrorCode = void 0;
(function (ErrorCode) {
    ErrorCode[ErrorCode["DECORATOR_ARG_NOT_LITERAL"] = 1001] = "DECORATOR_ARG_NOT_LITERAL";
    ErrorCode[ErrorCode["DECORATOR_ARITY_WRONG"] = 1002] = "DECORATOR_ARITY_WRONG";
    ErrorCode[ErrorCode["DECORATOR_NOT_CALLED"] = 1003] = "DECORATOR_NOT_CALLED";
    ErrorCode[ErrorCode["DECORATOR_UNEXPECTED"] = 1005] = "DECORATOR_UNEXPECTED";
    /**
     * This error code indicates that there are incompatible decorators on a type or a class field.
     */
    ErrorCode[ErrorCode["DECORATOR_COLLISION"] = 1006] = "DECORATOR_COLLISION";
    ErrorCode[ErrorCode["VALUE_HAS_WRONG_TYPE"] = 1010] = "VALUE_HAS_WRONG_TYPE";
    ErrorCode[ErrorCode["VALUE_NOT_LITERAL"] = 1011] = "VALUE_NOT_LITERAL";
    ErrorCode[ErrorCode["DUPLICATE_DECORATED_PROPERTIES"] = 1012] = "DUPLICATE_DECORATED_PROPERTIES";
    /**
     * Raised when an initializer API is annotated with an unexpected decorator.
     *
     * e.g. `@Input` is also applied on the class member using `input`.
     */
    ErrorCode[ErrorCode["INITIALIZER_API_WITH_DISALLOWED_DECORATOR"] = 1050] = "INITIALIZER_API_WITH_DISALLOWED_DECORATOR";
    /**
     * Raised when an initializer API feature (like signal inputs) are also
     * declared in the class decorator metadata.
     *
     * e.g. a signal input is also declared in the `@Directive` `inputs` array.
     */
    ErrorCode[ErrorCode["INITIALIZER_API_DECORATOR_METADATA_COLLISION"] = 1051] = "INITIALIZER_API_DECORATOR_METADATA_COLLISION";
    /**
     * Raised whenever an initializer API does not support the `.required`
     * function, but is still detected unexpectedly.
     */
    ErrorCode[ErrorCode["INITIALIZER_API_NO_REQUIRED_FUNCTION"] = 1052] = "INITIALIZER_API_NO_REQUIRED_FUNCTION";
    /**
     * Raised whenever an initializer API is used on a class member
     * and the given access modifiers (e.g. `private`) are not allowed.
     */
    ErrorCode[ErrorCode["INITIALIZER_API_DISALLOWED_MEMBER_VISIBILITY"] = 1053] = "INITIALIZER_API_DISALLOWED_MEMBER_VISIBILITY";
    /**
     * An Angular feature, like inputs, outputs or queries is incorrectly
     * declared on a static member.
     */
    ErrorCode[ErrorCode["INCORRECTLY_DECLARED_ON_STATIC_MEMBER"] = 1100] = "INCORRECTLY_DECLARED_ON_STATIC_MEMBER";
    ErrorCode[ErrorCode["COMPONENT_MISSING_TEMPLATE"] = 2001] = "COMPONENT_MISSING_TEMPLATE";
    ErrorCode[ErrorCode["PIPE_MISSING_NAME"] = 2002] = "PIPE_MISSING_NAME";
    ErrorCode[ErrorCode["PARAM_MISSING_TOKEN"] = 2003] = "PARAM_MISSING_TOKEN";
    ErrorCode[ErrorCode["DIRECTIVE_MISSING_SELECTOR"] = 2004] = "DIRECTIVE_MISSING_SELECTOR";
    /** Raised when an undecorated class is passed in as a provider to a module or a directive. */
    ErrorCode[ErrorCode["UNDECORATED_PROVIDER"] = 2005] = "UNDECORATED_PROVIDER";
    /**
     * Raised when a Directive inherits its constructor from a base class without an Angular
     * decorator.
     */
    ErrorCode[ErrorCode["DIRECTIVE_INHERITS_UNDECORATED_CTOR"] = 2006] = "DIRECTIVE_INHERITS_UNDECORATED_CTOR";
    /**
     * Raised when an undecorated class that is using Angular features
     * has been discovered.
     */
    ErrorCode[ErrorCode["UNDECORATED_CLASS_USING_ANGULAR_FEATURES"] = 2007] = "UNDECORATED_CLASS_USING_ANGULAR_FEATURES";
    /**
     * Raised when an component cannot resolve an external resource, such as a template or a style
     * sheet.
     */
    ErrorCode[ErrorCode["COMPONENT_RESOURCE_NOT_FOUND"] = 2008] = "COMPONENT_RESOURCE_NOT_FOUND";
    /**
     * Raised when a component uses `ShadowDom` view encapsulation, but its selector
     * does not match the shadow DOM tag name requirements.
     */
    ErrorCode[ErrorCode["COMPONENT_INVALID_SHADOW_DOM_SELECTOR"] = 2009] = "COMPONENT_INVALID_SHADOW_DOM_SELECTOR";
    /**
     * Raised when a component has `imports` but is not marked as `standalone: true`.
     */
    ErrorCode[ErrorCode["COMPONENT_NOT_STANDALONE"] = 2010] = "COMPONENT_NOT_STANDALONE";
    /**
     * Raised when a type in the `imports` of a component is a directive or pipe, but is not
     * standalone.
     */
    ErrorCode[ErrorCode["COMPONENT_IMPORT_NOT_STANDALONE"] = 2011] = "COMPONENT_IMPORT_NOT_STANDALONE";
    /**
     * Raised when a type in the `imports` of a component is not a directive, pipe, or NgModule.
     */
    ErrorCode[ErrorCode["COMPONENT_UNKNOWN_IMPORT"] = 2012] = "COMPONENT_UNKNOWN_IMPORT";
    /**
     * Raised when the compiler wasn't able to resolve the metadata of a host directive.
     */
    ErrorCode[ErrorCode["HOST_DIRECTIVE_INVALID"] = 2013] = "HOST_DIRECTIVE_INVALID";
    /**
     * Raised when a host directive isn't standalone.
     */
    ErrorCode[ErrorCode["HOST_DIRECTIVE_NOT_STANDALONE"] = 2014] = "HOST_DIRECTIVE_NOT_STANDALONE";
    /**
     * Raised when a host directive is a component.
     */
    ErrorCode[ErrorCode["HOST_DIRECTIVE_COMPONENT"] = 2015] = "HOST_DIRECTIVE_COMPONENT";
    /**
     * Raised when a type with Angular decorator inherits its constructor from a base class
     * which has a constructor that is incompatible with Angular DI.
     */
    ErrorCode[ErrorCode["INJECTABLE_INHERITS_INVALID_CONSTRUCTOR"] = 2016] = "INJECTABLE_INHERITS_INVALID_CONSTRUCTOR";
    /** Raised when a host tries to alias a host directive binding that does not exist. */
    ErrorCode[ErrorCode["HOST_DIRECTIVE_UNDEFINED_BINDING"] = 2017] = "HOST_DIRECTIVE_UNDEFINED_BINDING";
    /**
     * Raised when a host tries to alias a host directive
     * binding to a pre-existing binding's public name.
     */
    ErrorCode[ErrorCode["HOST_DIRECTIVE_CONFLICTING_ALIAS"] = 2018] = "HOST_DIRECTIVE_CONFLICTING_ALIAS";
    /**
     * Raised when a host directive definition doesn't expose a
     * required binding from the host directive.
     */
    ErrorCode[ErrorCode["HOST_DIRECTIVE_MISSING_REQUIRED_BINDING"] = 2019] = "HOST_DIRECTIVE_MISSING_REQUIRED_BINDING";
    /**
     * Raised when a component specifies both a `transform` function on an input
     * and has a corresponding `ngAcceptInputType_` member for the same input.
     */
    ErrorCode[ErrorCode["CONFLICTING_INPUT_TRANSFORM"] = 2020] = "CONFLICTING_INPUT_TRANSFORM";
    /** Raised when a component has both `styleUrls` and `styleUrl`. */
    ErrorCode[ErrorCode["COMPONENT_INVALID_STYLE_URLS"] = 2021] = "COMPONENT_INVALID_STYLE_URLS";
    /**
     * Raised when a type in the `deferredImports` of a component is not a component, directive or
     * pipe.
     */
    ErrorCode[ErrorCode["COMPONENT_UNKNOWN_DEFERRED_IMPORT"] = 2022] = "COMPONENT_UNKNOWN_DEFERRED_IMPORT";
    /**
     * Raised when a `standalone: false` component is declared but `strictStandalone` is set.
     */
    ErrorCode[ErrorCode["NON_STANDALONE_NOT_ALLOWED"] = 2023] = "NON_STANDALONE_NOT_ALLOWED";
    /**
     * Raised when a named template dependency isn't defined in the component's source file.
     */
    ErrorCode[ErrorCode["MISSING_NAMED_TEMPLATE_DEPENDENCY"] = 2024] = "MISSING_NAMED_TEMPLATE_DEPENDENCY";
    /**
     * Raised if an incorrect type is used for a named template dependency (e.g. directive
     * class used as a component).
     */
    ErrorCode[ErrorCode["INCORRECT_NAMED_TEMPLATE_DEPENDENCY_TYPE"] = 2025] = "INCORRECT_NAMED_TEMPLATE_DEPENDENCY_TYPE";
    /**
     * Raised for `@Component` fields that aren't supported in a selectorless context.
     */
    ErrorCode[ErrorCode["UNSUPPORTED_SELECTORLESS_COMPONENT_FIELD"] = 2026] = "UNSUPPORTED_SELECTORLESS_COMPONENT_FIELD";
    /**
     * A component is using both the `animations` property and `animate.enter` or `animate.leave`
     * in the template.
     */
    ErrorCode[ErrorCode["COMPONENT_ANIMATIONS_CONFLICT"] = 2027] = "COMPONENT_ANIMATIONS_CONFLICT";
    ErrorCode[ErrorCode["SYMBOL_NOT_EXPORTED"] = 3001] = "SYMBOL_NOT_EXPORTED";
    /**
     * Raised when a relationship between directives and/or pipes would cause a cyclic import to be
     * created that cannot be handled, such as in partial compilation mode.
     */
    ErrorCode[ErrorCode["IMPORT_CYCLE_DETECTED"] = 3003] = "IMPORT_CYCLE_DETECTED";
    /**
     * Raised when the compiler is unable to generate an import statement for a reference.
     */
    ErrorCode[ErrorCode["IMPORT_GENERATION_FAILURE"] = 3004] = "IMPORT_GENERATION_FAILURE";
    ErrorCode[ErrorCode["CONFIG_FLAT_MODULE_NO_INDEX"] = 4001] = "CONFIG_FLAT_MODULE_NO_INDEX";
    ErrorCode[ErrorCode["CONFIG_STRICT_TEMPLATES_IMPLIES_FULL_TEMPLATE_TYPECHECK"] = 4002] = "CONFIG_STRICT_TEMPLATES_IMPLIES_FULL_TEMPLATE_TYPECHECK";
    ErrorCode[ErrorCode["CONFIG_EXTENDED_DIAGNOSTICS_IMPLIES_STRICT_TEMPLATES"] = 4003] = "CONFIG_EXTENDED_DIAGNOSTICS_IMPLIES_STRICT_TEMPLATES";
    ErrorCode[ErrorCode["CONFIG_EXTENDED_DIAGNOSTICS_UNKNOWN_CATEGORY_LABEL"] = 4004] = "CONFIG_EXTENDED_DIAGNOSTICS_UNKNOWN_CATEGORY_LABEL";
    ErrorCode[ErrorCode["CONFIG_EXTENDED_DIAGNOSTICS_UNKNOWN_CHECK"] = 4005] = "CONFIG_EXTENDED_DIAGNOSTICS_UNKNOWN_CHECK";
    ErrorCode[ErrorCode["CONFIG_EMIT_DECLARATION_ONLY_UNSUPPORTED"] = 4006] = "CONFIG_EMIT_DECLARATION_ONLY_UNSUPPORTED";
    /**
     * Raised when a host expression has a parse error, such as a host listener or host binding
     * expression containing a pipe.
     */
    ErrorCode[ErrorCode["HOST_BINDING_PARSE_ERROR"] = 5001] = "HOST_BINDING_PARSE_ERROR";
    /**
     * Raised when the compiler cannot parse a component's template.
     */
    ErrorCode[ErrorCode["TEMPLATE_PARSE_ERROR"] = 5002] = "TEMPLATE_PARSE_ERROR";
    /**
     * Raised when an NgModule contains an invalid reference in `declarations`.
     */
    ErrorCode[ErrorCode["NGMODULE_INVALID_DECLARATION"] = 6001] = "NGMODULE_INVALID_DECLARATION";
    /**
     * Raised when an NgModule contains an invalid type in `imports`.
     */
    ErrorCode[ErrorCode["NGMODULE_INVALID_IMPORT"] = 6002] = "NGMODULE_INVALID_IMPORT";
    /**
     * Raised when an NgModule contains an invalid type in `exports`.
     */
    ErrorCode[ErrorCode["NGMODULE_INVALID_EXPORT"] = 6003] = "NGMODULE_INVALID_EXPORT";
    /**
     * Raised when an NgModule contains a type in `exports` which is neither in `declarations` nor
     * otherwise imported.
     */
    ErrorCode[ErrorCode["NGMODULE_INVALID_REEXPORT"] = 6004] = "NGMODULE_INVALID_REEXPORT";
    /**
     * Raised when a `ModuleWithProviders` with a missing
     * generic type argument is passed into an `NgModule`.
     */
    ErrorCode[ErrorCode["NGMODULE_MODULE_WITH_PROVIDERS_MISSING_GENERIC"] = 6005] = "NGMODULE_MODULE_WITH_PROVIDERS_MISSING_GENERIC";
    /**
     * Raised when an NgModule exports multiple directives/pipes of the same name and the compiler
     * attempts to generate private re-exports within the NgModule file.
     */
    ErrorCode[ErrorCode["NGMODULE_REEXPORT_NAME_COLLISION"] = 6006] = "NGMODULE_REEXPORT_NAME_COLLISION";
    /**
     * Raised when a directive/pipe is part of the declarations of two or more NgModules.
     */
    ErrorCode[ErrorCode["NGMODULE_DECLARATION_NOT_UNIQUE"] = 6007] = "NGMODULE_DECLARATION_NOT_UNIQUE";
    /**
     * Raised when a standalone directive/pipe is part of the declarations of an NgModule.
     */
    ErrorCode[ErrorCode["NGMODULE_DECLARATION_IS_STANDALONE"] = 6008] = "NGMODULE_DECLARATION_IS_STANDALONE";
    /**
     * Raised when a standalone component is part of the bootstrap list of an NgModule.
     */
    ErrorCode[ErrorCode["NGMODULE_BOOTSTRAP_IS_STANDALONE"] = 6009] = "NGMODULE_BOOTSTRAP_IS_STANDALONE";
    /**
     * Indicates that an NgModule is declared with `id: module.id`. This is an anti-pattern that is
     * disabled explicitly in the compiler, that was originally based on a misunderstanding of
     * `NgModule.id`.
     */
    ErrorCode[ErrorCode["WARN_NGMODULE_ID_UNNECESSARY"] = 6100] = "WARN_NGMODULE_ID_UNNECESSARY";
    /**
     * 6999 was previously assigned to NGMODULE_VE_DEPENDENCY_ON_IVY_LIB
     * To prevent any confusion, let's not reassign it.
     */
    /**
     * An element name failed validation against the DOM schema.
     */
    ErrorCode[ErrorCode["SCHEMA_INVALID_ELEMENT"] = 8001] = "SCHEMA_INVALID_ELEMENT";
    /**
     * An element's attribute name failed validation against the DOM schema.
     */
    ErrorCode[ErrorCode["SCHEMA_INVALID_ATTRIBUTE"] = 8002] = "SCHEMA_INVALID_ATTRIBUTE";
    /**
     * No matching directive was found for a `#ref="target"` expression.
     */
    ErrorCode[ErrorCode["MISSING_REFERENCE_TARGET"] = 8003] = "MISSING_REFERENCE_TARGET";
    /**
     * No matching pipe was found for a
     */
    ErrorCode[ErrorCode["MISSING_PIPE"] = 8004] = "MISSING_PIPE";
    /**
     * The left-hand side of an assignment expression was a template variable. Effectively, the
     * template looked like:
     *
     * ```html
     * <ng-template let-something>
     *   <button (click)="something = ...">...</button>
     * </ng-template>
     * ```
     *
     * Template variables are read-only.
     */
    ErrorCode[ErrorCode["WRITE_TO_READ_ONLY_VARIABLE"] = 8005] = "WRITE_TO_READ_ONLY_VARIABLE";
    /**
     * A template variable was declared twice. For example:
     *
     * ```html
     * <div *ngFor="let i of items; let i = index">
     * </div>
     * ```
     */
    ErrorCode[ErrorCode["DUPLICATE_VARIABLE_DECLARATION"] = 8006] = "DUPLICATE_VARIABLE_DECLARATION";
    /**
     * A template has a two way binding (two bindings created by a single syntactical element)
     * in which the input and output are going to different places.
     */
    ErrorCode[ErrorCode["SPLIT_TWO_WAY_BINDING"] = 8007] = "SPLIT_TWO_WAY_BINDING";
    /**
     * A directive usage isn't binding to one or more required inputs.
     */
    ErrorCode[ErrorCode["MISSING_REQUIRED_INPUTS"] = 8008] = "MISSING_REQUIRED_INPUTS";
    /**
     * The tracking expression of a `for` loop block is accessing a variable that is unavailable,
     * for example:
     *
     * ```angular-html
     * <ng-template let-ref>
     *   @for (item of items; track ref) {}
     * </ng-template>
     * ```
     */
    ErrorCode[ErrorCode["ILLEGAL_FOR_LOOP_TRACK_ACCESS"] = 8009] = "ILLEGAL_FOR_LOOP_TRACK_ACCESS";
    /**
     * The trigger of a `defer` block cannot access its trigger element,
     * either because it doesn't exist or it's in a different view.
     *
     * ```angular-html
     * @defer (on interaction(trigger)) {...}
     *
     * <ng-template>
     *   <button #trigger></button>
     * </ng-template>
     * ```
     */
    ErrorCode[ErrorCode["INACCESSIBLE_DEFERRED_TRIGGER_ELEMENT"] = 8010] = "INACCESSIBLE_DEFERRED_TRIGGER_ELEMENT";
    /**
     * A control flow node is projected at the root of a component and is preventing its direct
     * descendants from being projected, because it has more than one root node.
     *
     * ```angular-html
     * <comp>
     *  @if (expr) {
     *    <div projectsIntoSlot></div>
     *    Text preventing the div from being projected
     *  }
     * </comp>
     * ```
     */
    ErrorCode[ErrorCode["CONTROL_FLOW_PREVENTING_CONTENT_PROJECTION"] = 8011] = "CONTROL_FLOW_PREVENTING_CONTENT_PROJECTION";
    /**
     * A pipe imported via `@Component.deferredImports` is
     * used outside of a `@defer` block in a template.
     */
    ErrorCode[ErrorCode["DEFERRED_PIPE_USED_EAGERLY"] = 8012] = "DEFERRED_PIPE_USED_EAGERLY";
    /**
     * A directive/component imported via `@Component.deferredImports` is
     * used outside of a `@defer` block in a template.
     */
    ErrorCode[ErrorCode["DEFERRED_DIRECTIVE_USED_EAGERLY"] = 8013] = "DEFERRED_DIRECTIVE_USED_EAGERLY";
    /**
     * A directive/component/pipe imported via `@Component.deferredImports` is
     * also included into the `@Component.imports` list.
     */
    ErrorCode[ErrorCode["DEFERRED_DEPENDENCY_IMPORTED_EAGERLY"] = 8014] = "DEFERRED_DEPENDENCY_IMPORTED_EAGERLY";
    /** An expression is trying to write to an `@let` declaration. */
    ErrorCode[ErrorCode["ILLEGAL_LET_WRITE"] = 8015] = "ILLEGAL_LET_WRITE";
    /** An expression is trying to read an `@let` before it has been defined. */
    ErrorCode[ErrorCode["LET_USED_BEFORE_DEFINITION"] = 8016] = "LET_USED_BEFORE_DEFINITION";
    /** A `@let` declaration conflicts with another symbol in the same scope. */
    ErrorCode[ErrorCode["CONFLICTING_LET_DECLARATION"] = 8017] = "CONFLICTING_LET_DECLARATION";
    /**
     * A binding inside selectorless directive syntax did
     * not match any inputs/outputs of the directive.
     */
    ErrorCode[ErrorCode["UNCLAIMED_DIRECTIVE_BINDING"] = 8018] = "UNCLAIMED_DIRECTIVE_BINDING";
    /**
     * An `@defer` block with an implicit trigger does not have a placeholder, for example:
     *
     * ```
     * @defer(on viewport) {
     *   Hello
     * }
     * ```
     */
    ErrorCode[ErrorCode["DEFER_IMPLICIT_TRIGGER_MISSING_PLACEHOLDER"] = 8019] = "DEFER_IMPLICIT_TRIGGER_MISSING_PLACEHOLDER";
    /**
     * The `@placeholder` for an implicit `@defer` trigger is not set up correctly, for example:
     *
     * ```
     * @defer(on viewport) {
     *   Hello
     * } @placeholder {
     *   <!-- Multiple root nodes. -->
     *   <button></button>
     *   <div></div>
     * }
     * ```
     */
    ErrorCode[ErrorCode["DEFER_IMPLICIT_TRIGGER_INVALID_PLACEHOLDER"] = 8020] = "DEFER_IMPLICIT_TRIGGER_INVALID_PLACEHOLDER";
    /**
     * Raised when an `@defer` block defines unreachable or redundant triggers.
     * Examples: multiple main triggers, 'on immediate' together with other mains or any prefetch,
     * prefetch timer delay that is not earlier than the main timer, or an identical prefetch
     */
    ErrorCode[ErrorCode["DEFER_TRIGGER_MISCONFIGURATION"] = 8021] = "DEFER_TRIGGER_MISCONFIGURATION";
    /**
     * A two way binding in a template has an incorrect syntax,
     * parentheses outside brackets. For example:
     *
     * ```html
     * <div ([foo])="bar" />
     * ```
     */
    ErrorCode[ErrorCode["INVALID_BANANA_IN_BOX"] = 8101] = "INVALID_BANANA_IN_BOX";
    /**
     * The left side of a nullish coalescing operation is not nullable.
     *
     * ```html
     * {{ foo ?? bar }}
     * ```
     * When the type of foo doesn't include `null` or `undefined`.
     */
    ErrorCode[ErrorCode["NULLISH_COALESCING_NOT_NULLABLE"] = 8102] = "NULLISH_COALESCING_NOT_NULLABLE";
    /**
     * A known control flow directive (e.g. `*ngIf`) is used in a template,
     * but the `CommonModule` is not imported.
     */
    ErrorCode[ErrorCode["MISSING_CONTROL_FLOW_DIRECTIVE"] = 8103] = "MISSING_CONTROL_FLOW_DIRECTIVE";
    /**
     * A text attribute is not interpreted as a binding but likely intended to be.
     *
     * For example:
     * ```html
     * <div
     *   attr.x="value"
     *   class.blue="true"
     *   style.margin-right.px="5">
     * </div>
     * ```
     *
     * All of the above attributes will just be static text attributes and will not be interpreted as
     * bindings by the compiler.
     */
    ErrorCode[ErrorCode["TEXT_ATTRIBUTE_NOT_BINDING"] = 8104] = "TEXT_ATTRIBUTE_NOT_BINDING";
    /**
     * NgForOf is used in a template, but the user forgot to include let
     * in their statement.
     *
     * For example:
     * ```html
     * <ul><li *ngFor="item of items">{{item["name"]}};</li></ul>
     * ```
     */
    ErrorCode[ErrorCode["MISSING_NGFOROF_LET"] = 8105] = "MISSING_NGFOROF_LET";
    /**
     * Indicates that the binding suffix is not supported
     *
     * Style bindings support suffixes like `style.width.px`, `.em`, and `.%`.
     * These suffixes are _not_ supported for attribute bindings.
     *
     * For example `[attr.width.px]="5"` becomes `width.px="5"` when bound.
     * This is almost certainly unintentional and this error is meant to
     * surface this mistake to the developer.
     */
    ErrorCode[ErrorCode["SUFFIX_NOT_SUPPORTED"] = 8106] = "SUFFIX_NOT_SUPPORTED";
    /**
     * The left side of an optional chain operation is not nullable.
     *
     * ```html
     * {{ foo?.bar }}
     * {{ foo?.['bar'] }}
     * {{ foo?.() }}
     * ```
     * When the type of foo doesn't include `null` or `undefined`.
     */
    ErrorCode[ErrorCode["OPTIONAL_CHAIN_NOT_NULLABLE"] = 8107] = "OPTIONAL_CHAIN_NOT_NULLABLE";
    /**
     * `ngSkipHydration` should not be a binding (it should be a static attribute).
     *
     * For example:
     * ```html
     * <my-cmp [ngSkipHydration]="someTruthyVar" />
     * ```
     *
     * `ngSkipHydration` cannot be a binding and can not have values other than "true" or an empty
     * value
     */
    ErrorCode[ErrorCode["SKIP_HYDRATION_NOT_STATIC"] = 8108] = "SKIP_HYDRATION_NOT_STATIC";
    /**
     * Signal functions should be invoked when interpolated in templates.
     *
     * For example:
     * ```html
     * {{ mySignal() }}
     * ```
     */
    ErrorCode[ErrorCode["INTERPOLATED_SIGNAL_NOT_INVOKED"] = 8109] = "INTERPOLATED_SIGNAL_NOT_INVOKED";
    /**
     * Initializer-based APIs can only be invoked from inside of an initializer.
     *
     * ```ts
     * // Allowed
     * myInput = input();
     *
     * // Not allowed
     * function myInput() {
     *   return input();
     * }
     * ```
     */
    ErrorCode[ErrorCode["UNSUPPORTED_INITIALIZER_API_USAGE"] = 8110] = "UNSUPPORTED_INITIALIZER_API_USAGE";
    /**
     * A function in an event binding is not called.
     *
     * For example:
     * ```html
     * <button (click)="myFunc"></button>
     * ```
     *
     * This will not call `myFunc` when the button is clicked. Instead, it should be
     * `<button (click)="myFunc()"></button>`.
     */
    ErrorCode[ErrorCode["UNINVOKED_FUNCTION_IN_EVENT_BINDING"] = 8111] = "UNINVOKED_FUNCTION_IN_EVENT_BINDING";
    /**
     * A `@let` declaration in a template isn't used.
     *
     * For example:
     * ```angular-html
     * @let used = 1; <!-- Not an error -->
     * @let notUsed = 2; <!-- Error -->
     *
     * {{used}}
     * ```
     */
    ErrorCode[ErrorCode["UNUSED_LET_DECLARATION"] = 8112] = "UNUSED_LET_DECLARATION";
    /**
     * A symbol referenced in `@Component.imports` isn't being used within the template.
     */
    ErrorCode[ErrorCode["UNUSED_STANDALONE_IMPORTS"] = 8113] = "UNUSED_STANDALONE_IMPORTS";
    /**
     * An expression mixes nullish coalescing and logical and/or without parentheses.
     */
    ErrorCode[ErrorCode["UNPARENTHESIZED_NULLISH_COALESCING"] = 8114] = "UNPARENTHESIZED_NULLISH_COALESCING";
    /**
     * The function passed to `@for` track is not invoked.
     *
     * For example:
     * ```angular-html
     * @for (item of items; track trackByName) {}
     * ```
     *
     * For the track function to work properly, it must be invoked.
     *
     * For example:
     * ```angular-html
     * @for (item of items; track trackByName(item)) {}
     * ```
     */
    ErrorCode[ErrorCode["UNINVOKED_TRACK_FUNCTION"] = 8115] = "UNINVOKED_TRACK_FUNCTION";
    /**
     * A structural directive is used in a template, but the directive is not imported.
     */
    ErrorCode[ErrorCode["MISSING_STRUCTURAL_DIRECTIVE"] = 8116] = "MISSING_STRUCTURAL_DIRECTIVE";
    /**
     * A function in a text interpolation is not invoked.
     *
     * For example:
     * ```html
     * <p> {{ firstName }} </p>
     * ```
     *
     * The `firstName` function is not invoked. Instead, it should be:
     * ```html
     * <p> {{ firstName() }} </p>
     * ```
     */
    ErrorCode[ErrorCode["UNINVOKED_FUNCTION_IN_TEXT_INTERPOLATION"] = 8117] = "UNINVOKED_FUNCTION_IN_TEXT_INTERPOLATION";
    /**
     * A required initializer is being invoked in a forbidden context such as a property initializer
     * or a constructor.
     *
     * For example:
     * ```ts
     * class MyComponent {
     *  myInput = input.required();
     *  somValue = this.myInput(); // Error
     *
     *  constructor() {
     *    this.myInput(); // Error
     *  }
     */
    ErrorCode[ErrorCode["FORBIDDEN_REQUIRED_INITIALIZER_INVOCATION"] = 8118] = "FORBIDDEN_REQUIRED_INITIALIZER_INVOCATION";
    /**
     * The template type-checking engine would need to generate an inline type check block for a
     * component, but the current type-checking environment doesn't support it.
     */
    ErrorCode[ErrorCode["INLINE_TCB_REQUIRED"] = 8900] = "INLINE_TCB_REQUIRED";
    /**
     * The template type-checking engine would need to generate an inline type constructor for a
     * directive or component, but the current type-checking environment doesn't support it.
     */
    ErrorCode[ErrorCode["INLINE_TYPE_CTOR_REQUIRED"] = 8901] = "INLINE_TYPE_CTOR_REQUIRED";
    /**
     * An injectable already has a `Éµprov` property.
     */
    ErrorCode[ErrorCode["INJECTABLE_DUPLICATE_PROV"] = 9001] = "INJECTABLE_DUPLICATE_PROV";
    // 10XXX error codes are reserved for diagnostics with categories other than
    // `ts.DiagnosticCategory.Error`. These diagnostics are generated by the compiler when configured
    // to do so by a tool such as the Language Service, or by the Language Service itself.
    /**
     * Suggest users to enable `strictTemplates` to make use of full capabilities
     * provided by Angular language service.
     */
    ErrorCode[ErrorCode["SUGGEST_STRICT_TEMPLATES"] = 10001] = "SUGGEST_STRICT_TEMPLATES";
    /**
     * Indicates that a particular structural directive provides advanced type narrowing
     * functionality, but the current template type-checking configuration does not allow its usage in
     * type inference.
     */
    ErrorCode[ErrorCode["SUGGEST_SUBOPTIMAL_TYPE_INFERENCE"] = 10002] = "SUGGEST_SUBOPTIMAL_TYPE_INFERENCE";
    /**
     * In local compilation mode a const is required to be resolved statically but cannot be so since
     * it is imported from a file outside of the compilation unit. This usually happens with const
     * being used as Angular decorators parameters such as `@Component.template`,
     * `@HostListener.eventName`, etc.
     */
    ErrorCode[ErrorCode["LOCAL_COMPILATION_UNRESOLVED_CONST"] = 11001] = "LOCAL_COMPILATION_UNRESOLVED_CONST";
    /**
     * In local compilation mode a certain expression or syntax is not supported. This is usually
     * because the expression/syntax is not very common and so we did not add support for it yet. This
     * can be changed in the future and support for more expressions could be added if need be.
     * Meanwhile, this error is thrown to indicate a current unavailability.
     */
    ErrorCode[ErrorCode["LOCAL_COMPILATION_UNSUPPORTED_EXPRESSION"] = 11003] = "LOCAL_COMPILATION_UNSUPPORTED_EXPRESSION";
})(exports.ErrorCode || (exports.ErrorCode = {}));

/**
 * Contains a set of error messages that have detailed guides at angular.io.
 * Full list of available error guides can be found at https://angular.dev/errors
 */
const COMPILER_ERRORS_WITH_GUIDES = new Set([
    exports.ErrorCode.DECORATOR_ARG_NOT_LITERAL,
    exports.ErrorCode.IMPORT_CYCLE_DETECTED,
    exports.ErrorCode.PARAM_MISSING_TOKEN,
    exports.ErrorCode.SCHEMA_INVALID_ELEMENT,
    exports.ErrorCode.SCHEMA_INVALID_ATTRIBUTE,
    exports.ErrorCode.MISSING_REFERENCE_TARGET,
    exports.ErrorCode.COMPONENT_INVALID_SHADOW_DOM_SELECTOR,
    exports.ErrorCode.WARN_NGMODULE_ID_UNNECESSARY,
]);

function ngErrorCode(code) {
    return parseInt('-99' + code);
}

class FatalDiagnosticError extends Error {
    code;
    node;
    diagnosticMessage;
    relatedInformation;
    constructor(code, node, diagnosticMessage, relatedInformation) {
        super(`FatalDiagnosticError: Code: ${code}, Message: ${ts.flattenDiagnosticMessageText(diagnosticMessage, '\n')}`);
        this.code = code;
        this.node = node;
        this.diagnosticMessage = diagnosticMessage;
        this.relatedInformation = relatedInformation;
        // Extending `Error` ends up breaking some internal tests. This appears to be a known issue
        // when extending errors in TS and the workaround is to explicitly set the prototype.
        // https://stackoverflow.com/questions/41102060/typescript-extending-error-class
        Object.setPrototypeOf(this, new.target.prototype);
    }
    /**
     * @internal
     */
    _isFatalDiagnosticError = true;
    toDiagnostic() {
        return makeDiagnostic(this.code, this.node, this.diagnosticMessage, this.relatedInformation);
    }
}
function makeDiagnostic(code, node, messageText, relatedInformation, category = ts.DiagnosticCategory.Error) {
    node = ts.getOriginalNode(node);
    return {
        category,
        code: ngErrorCode(code),
        file: ts.getOriginalNode(node).getSourceFile(),
        start: node.getStart(undefined, false),
        length: node.getWidth(),
        messageText,
        relatedInformation,
    };
}
function makeDiagnosticChain(messageText, next) {
    return {
        category: ts.DiagnosticCategory.Message,
        code: 0,
        messageText,
        next,
    };
}
function makeRelatedInformation(node, messageText) {
    node = ts.getOriginalNode(node);
    return {
        category: ts.DiagnosticCategory.Message,
        code: 0,
        file: node.getSourceFile(),
        start: node.getStart(),
        length: node.getWidth(),
        messageText,
    };
}
function addDiagnosticChain(messageText, add) {
    if (typeof messageText === 'string') {
        return makeDiagnosticChain(messageText, add);
    }
    if (messageText.next === undefined) {
        messageText.next = add;
    }
    else {
        messageText.next.push(...add);
    }
    return messageText;
}
function isFatalDiagnosticError(err) {
    return err._isFatalDiagnosticError === true;
}

/**
 * Base URL for the error details page.
 *
 * Keep the files below in full sync:
 *  - packages/compiler-cli/src/ngtsc/diagnostics/src/error_details_base_url.ts
 *  - packages/core/src/error_details_base_url.ts
 */
const ERROR_DETAILS_PAGE_BASE_URL = (() => {
    const versionSubDomain = o.VERSION.major !== '0' ? `v${o.VERSION.major}.` : '';
    return `https://${versionSubDomain}angular.dev/errors`;
})();

/**
 * Enum holding the name of each extended template diagnostic. The name is used as a user-meaningful
 * value for configuring the diagnostic in the project's options.
 *
 * See the corresponding `ErrorCode` for documentation about each specific error.
 * packages/compiler-cli/src/ngtsc/diagnostics/src/error_code.ts
 *
 * @publicApi
 */
var ExtendedTemplateDiagnosticName;
(function (ExtendedTemplateDiagnosticName) {
    ExtendedTemplateDiagnosticName["INVALID_BANANA_IN_BOX"] = "invalidBananaInBox";
    ExtendedTemplateDiagnosticName["NULLISH_COALESCING_NOT_NULLABLE"] = "nullishCoalescingNotNullable";
    ExtendedTemplateDiagnosticName["OPTIONAL_CHAIN_NOT_NULLABLE"] = "optionalChainNotNullable";
    ExtendedTemplateDiagnosticName["MISSING_CONTROL_FLOW_DIRECTIVE"] = "missingControlFlowDirective";
    ExtendedTemplateDiagnosticName["MISSING_STRUCTURAL_DIRECTIVE"] = "missingStructuralDirective";
    ExtendedTemplateDiagnosticName["TEXT_ATTRIBUTE_NOT_BINDING"] = "textAttributeNotBinding";
    ExtendedTemplateDiagnosticName["UNINVOKED_FUNCTION_IN_EVENT_BINDING"] = "uninvokedFunctionInEventBinding";
    ExtendedTemplateDiagnosticName["MISSING_NGFOROF_LET"] = "missingNgForOfLet";
    ExtendedTemplateDiagnosticName["SUFFIX_NOT_SUPPORTED"] = "suffixNotSupported";
    ExtendedTemplateDiagnosticName["SKIP_HYDRATION_NOT_STATIC"] = "skipHydrationNotStatic";
    ExtendedTemplateDiagnosticName["INTERPOLATED_SIGNAL_NOT_INVOKED"] = "interpolatedSignalNotInvoked";
    ExtendedTemplateDiagnosticName["CONTROL_FLOW_PREVENTING_CONTENT_PROJECTION"] = "controlFlowPreventingContentProjection";
    ExtendedTemplateDiagnosticName["UNUSED_LET_DECLARATION"] = "unusedLetDeclaration";
    ExtendedTemplateDiagnosticName["UNINVOKED_TRACK_FUNCTION"] = "uninvokedTrackFunction";
    ExtendedTemplateDiagnosticName["UNUSED_STANDALONE_IMPORTS"] = "unusedStandaloneImports";
    ExtendedTemplateDiagnosticName["UNPARENTHESIZED_NULLISH_COALESCING"] = "unparenthesizedNullishCoalescing";
    ExtendedTemplateDiagnosticName["UNINVOKED_FUNCTION_IN_TEXT_INTERPOLATION"] = "uninvokedFunctionInTextInterpolation";
    ExtendedTemplateDiagnosticName["DEFER_TRIGGER_MISCONFIGURATION"] = "deferTriggerMisconfiguration";
})(ExtendedTemplateDiagnosticName || (ExtendedTemplateDiagnosticName = {}));

/**
 * The default `FileSystem` that will always fail.
 *
 * This is a way of ensuring that the developer consciously chooses and
 * configures the `FileSystem` before using it; particularly important when
 * considering static functions like `absoluteFrom()` which rely on
 * the `FileSystem` under the hood.
 */
class InvalidFileSystem {
    exists(path) {
        throw makeError();
    }
    readFile(path) {
        throw makeError();
    }
    readFileBuffer(path) {
        throw makeError();
    }
    writeFile(path, data, exclusive) {
        throw makeError();
    }
    removeFile(path) {
        throw makeError();
    }
    symlink(target, path) {
        throw makeError();
    }
    readdir(path) {
        throw makeError();
    }
    lstat(path) {
        throw makeError();
    }
    stat(path) {
        throw makeError();
    }
    pwd() {
        throw makeError();
    }
    chdir(path) {
        throw makeError();
    }
    extname(path) {
        throw makeError();
    }
    copyFile(from, to) {
        throw makeError();
    }
    moveFile(from, to) {
        throw makeError();
    }
    ensureDir(path) {
        throw makeError();
    }
    removeDeep(path) {
        throw makeError();
    }
    isCaseSensitive() {
        throw makeError();
    }
    resolve(...paths) {
        throw makeError();
    }
    dirname(file) {
        throw makeError();
    }
    join(basePath, ...paths) {
        throw makeError();
    }
    isRoot(path) {
        throw makeError();
    }
    isRooted(path) {
        throw makeError();
    }
    relative(from, to) {
        throw makeError();
    }
    basename(filePath, extension) {
        throw makeError();
    }
    realpath(filePath) {
        throw makeError();
    }
    getDefaultLibLocation() {
        throw makeError();
    }
    normalize(path) {
        throw makeError();
    }
}
function makeError() {
    return new Error('FileSystem has not been configured. Please call `setFileSystem()` before calling this method.');
}

const TS_DTS_JS_EXTENSION = /(?:\.d)?\.ts$|\.js$/;
/**
 * Remove a .ts, .d.ts, or .js extension from a file name.
 */
function stripExtension(path) {
    return path.replace(TS_DTS_JS_EXTENSION, '');
}
function getSourceFileOrError(program, fileName) {
    const sf = program.getSourceFile(fileName);
    if (sf === undefined) {
        throw new Error(`Program does not contain "${fileName}" - available files are ${program
            .getSourceFiles()
            .map((sf) => sf.fileName)
            .join(', ')}`);
    }
    return sf;
}

let fs = new InvalidFileSystem();
function getFileSystem() {
    return fs;
}
function setFileSystem(fileSystem) {
    fs = fileSystem;
}
/**
 * Convert the path `path` to an `AbsoluteFsPath`, throwing an error if it's not an absolute path.
 */
function absoluteFrom(path) {
    if (!fs.isRooted(path)) {
        throw new Error(`Internal Error: absoluteFrom(${path}): path is not absolute`);
    }
    return fs.resolve(path);
}
const ABSOLUTE_PATH = Symbol('AbsolutePath');
/**
 * Extract an `AbsoluteFsPath` from a `ts.SourceFile`-like object.
 */
function absoluteFromSourceFile(sf) {
    const sfWithPatch = sf;
    if (sfWithPatch[ABSOLUTE_PATH] === undefined) {
        sfWithPatch[ABSOLUTE_PATH] = fs.resolve(sfWithPatch.fileName);
    }
    // Non-null assertion needed since TS doesn't narrow the type of fields that use a symbol as a key
    // apparently.
    return sfWithPatch[ABSOLUTE_PATH];
}
/**
 * Static access to `dirname`.
 */
function dirname(file) {
    return fs.dirname(file);
}
/**
 * Static access to `join`.
 */
function join(basePath, ...paths) {
    return fs.join(basePath, ...paths);
}
/**
 * Static access to `resolve`s.
 */
function resolve(basePath, ...paths) {
    return fs.resolve(basePath, ...paths);
}
/**
 * Static access to `isRooted`.
 */
function isRooted(path) {
    return fs.isRooted(path);
}
/**
 * Static access to `relative`.
 */
function relative(from, to) {
    return fs.relative(from, to);
}
/**
 * Returns true if the given path is locally relative.
 *
 * This is used to work out if the given path is relative (i.e. not absolute) but also is not
 * escaping the current directory.
 */
function isLocalRelativePath(relativePath) {
    return !isRooted(relativePath) && !relativePath.startsWith('..');
}
/**
 * Converts a path to a form suitable for use as a relative module import specifier.
 *
 * In other words it adds the `./` to the path if it is locally relative.
 */
function toRelativeImport(relativePath) {
    return isLocalRelativePath(relativePath) ? `./${relativePath}` : relativePath;
}

const LogicalProjectPath = {
    /**
     * Get the relative path between two `LogicalProjectPath`s.
     *
     * This will return a `PathSegment` which would be a valid module specifier to use in `from` when
     * importing from `to`.
     */
    relativePathBetween: function (from, to) {
        const relativePath = relative(dirname(resolve(from)), resolve(to));
        return toRelativeImport(relativePath);
    },
};
/**
 * A utility class which can translate absolute paths to source files into logical paths in
 * TypeScript's logical file system, based on the root directories of the project.
 */
class LogicalFileSystem {
    compilerHost;
    /**
     * The root directories of the project, sorted with the longest path first.
     */
    rootDirs;
    /**
     * The same root directories as `rootDirs` but with each one converted to its
     * canonical form for matching in case-insensitive file-systems.
     */
    canonicalRootDirs;
    /**
     * A cache of file paths to project paths, because computation of these paths is slightly
     * expensive.
     */
    cache = new Map();
    constructor(rootDirs, compilerHost) {
        this.compilerHost = compilerHost;
        // Make a copy and sort it by length in reverse order (longest first). This speeds up lookups,
        // since there's no need to keep going through the array once a match is found.
        this.rootDirs = rootDirs.concat([]).sort((a, b) => b.length - a.length);
        this.canonicalRootDirs = this.rootDirs.map((dir) => this.compilerHost.getCanonicalFileName(dir));
    }
    /**
     * Get the logical path in the project of a `ts.SourceFile`.
     *
     * This method is provided as a convenient alternative to calling
     * `logicalPathOfFile(absoluteFromSourceFile(sf))`.
     */
    logicalPathOfSf(sf) {
        return this.logicalPathOfFile(absoluteFromSourceFile(sf));
    }
    /**
     * Get the logical path in the project of a source file.
     *
     * @returns A `LogicalProjectPath` to the source file, or `null` if the source file is not in any
     * of the TS project's root directories.
     */
    logicalPathOfFile(physicalFile) {
        if (!this.cache.has(physicalFile)) {
            const canonicalFilePath = this.compilerHost.getCanonicalFileName(physicalFile);
            let logicalFile = null;
            for (let i = 0; i < this.rootDirs.length; i++) {
                const rootDir = this.rootDirs[i];
                const canonicalRootDir = this.canonicalRootDirs[i];
                if (isWithinBasePath(canonicalRootDir, canonicalFilePath)) {
                    // Note that we match against canonical paths but then create the logical path from
                    // original paths.
                    logicalFile = this.createLogicalProjectPath(physicalFile, rootDir);
                    // The logical project does not include any special "node_modules" nested directories.
                    if (logicalFile.indexOf('/node_modules/') !== -1) {
                        logicalFile = null;
                    }
                    else {
                        break;
                    }
                }
            }
            this.cache.set(physicalFile, logicalFile);
        }
        return this.cache.get(physicalFile);
    }
    createLogicalProjectPath(file, rootDir) {
        const logicalPath = stripExtension(file.slice(rootDir.length));
        return (logicalPath.startsWith('/') ? logicalPath : '/' + logicalPath);
    }
}
/**
 * Is the `path` a descendant of the `base`?
 * E.g. `foo/bar/zee` is within `foo/bar` but not within `foo/car`.
 */
function isWithinBasePath(base, path) {
    return isLocalRelativePath(relative(base, path));
}

/// <reference types="node" />
/**
 * A wrapper around the Node.js file-system that supports path manipulation.
 */
class NodeJSPathManipulation {
    pwd() {
        return this.normalize(process.cwd());
    }
    chdir(dir) {
        process.chdir(dir);
    }
    resolve(...paths) {
        return this.normalize(p__namespace.resolve(...paths));
    }
    dirname(file) {
        return this.normalize(p__namespace.dirname(file));
    }
    join(basePath, ...paths) {
        return this.normalize(p__namespace.join(basePath, ...paths));
    }
    isRoot(path) {
        return this.dirname(path) === this.normalize(path);
    }
    isRooted(path) {
        return p__namespace.isAbsolute(path);
    }
    relative(from, to) {
        return this.normalize(p__namespace.relative(from, to));
    }
    basename(filePath, extension) {
        return p__namespace.basename(filePath, extension);
    }
    extname(path) {
        return p__namespace.extname(path);
    }
    normalize(path) {
        // Convert backslashes to forward slashes
        return path.replace(/\\/g, '/');
    }
}
// G3-ESM-MARKER: G3 uses CommonJS, but externally everything in ESM.
// CommonJS/ESM interop for determining the current file name and containing dir.
const isCommonJS = typeof __filename !== 'undefined';
const currentFileUrl = isCommonJS ? null : (typeof document === 'undefined' ? require('u' + 'rl').pathToFileURL(__filename).href : (_documentCurrentScript && _documentCurrentScript.tagName.toUpperCase() === 'SCRIPT' && _documentCurrentScript.src || new URL('project_tsconfig_paths-PsYr_U7n.cjs', document.baseURI).href));
// Note, when this code loads in the browser, `url` may be an empty `{}` due to the Closure shims.
const currentFileName = isCommonJS
    ? __filename
    : (url__namespace.fileURLToPath?.(currentFileUrl) ?? null);
/**
 * A wrapper around the Node.js file-system that supports readonly operations and path manipulation.
 */
class NodeJSReadonlyFileSystem extends NodeJSPathManipulation {
    _caseSensitive = undefined;
    isCaseSensitive() {
        if (this._caseSensitive === undefined) {
            // Note the use of the real file-system is intentional:
            // `this.exists()` relies upon `isCaseSensitive()` so that would cause an infinite recursion.
            this._caseSensitive =
                currentFileName !== null
                    ? !fs$1.existsSync(this.normalize(toggleCase(currentFileName)))
                    : true;
        }
        return this._caseSensitive;
    }
    exists(path) {
        return fs$1.existsSync(path);
    }
    readFile(path) {
        return fs$1.readFileSync(path, 'utf8');
    }
    readFileBuffer(path) {
        // TODO: go/ts59upgrade - Remove the suppression after TS 5.9.2 upgrade
        //   TS2322: Type 'Buffer' is not assignable to type 'Uint8Array<ArrayBufferLike>'.
        // @ts-ignore
        return fs$1.readFileSync(path);
    }
    readdir(path) {
        return fs$1.readdirSync(path);
    }
    lstat(path) {
        return fs$1.lstatSync(path);
    }
    stat(path) {
        return fs$1.statSync(path);
    }
    realpath(path) {
        return this.resolve(fs$1.realpathSync(path));
    }
    getDefaultLibLocation() {
        // G3-ESM-MARKER: G3 uses CommonJS, but externally everything in ESM.
        const requireFn = isCommonJS ? require : module$1.createRequire(currentFileUrl);
        return this.resolve(requireFn.resolve('typescript'), '..');
    }
}
/**
 * A wrapper around the Node.js file-system (i.e. the `fs` package).
 */
class NodeJSFileSystem extends NodeJSReadonlyFileSystem {
    writeFile(path, data, exclusive = false) {
        fs$1.writeFileSync(path, data, exclusive ? { flag: 'wx' } : undefined);
    }
    removeFile(path) {
        fs$1.unlinkSync(path);
    }
    symlink(target, path) {
        fs$1.symlinkSync(target, path);
    }
    copyFile(from, to) {
        fs$1.copyFileSync(from, to);
    }
    moveFile(from, to) {
        fs$1.renameSync(from, to);
    }
    ensureDir(path) {
        fs$1.mkdirSync(path, { recursive: true });
    }
    removeDeep(path) {
        fs$1.rmdirSync(path, { recursive: true });
    }
}
/**
 * Toggle the case of each character in a string.
 */
function toggleCase(str) {
    return str.replace(/\w/g, (ch) => ch.toUpperCase() === ch ? ch.toLowerCase() : ch.toUpperCase());
}

const TS = /\.tsx?$/i;
const D_TS = /\.d\.ts$/i;
function isSymbolWithValueDeclaration(symbol) {
    // If there is a value declaration set, then the `declarations` property is never undefined. We
    // still check for the property to exist as this matches with the type that `symbol` is narrowed
    // to.
    return (symbol != null && symbol.valueDeclaration !== undefined && symbol.declarations !== undefined);
}
function isDtsPath(filePath) {
    return D_TS.test(filePath);
}
function isNonDeclarationTsPath(filePath) {
    return TS.test(filePath) && !D_TS.test(filePath);
}
function isFromDtsFile(node) {
    let sf = node.getSourceFile();
    if (sf === undefined) {
        sf = ts.getOriginalNode(node).getSourceFile();
    }
    return sf !== undefined && sf.isDeclarationFile;
}
function nodeNameForError(node) {
    if (node.name !== undefined && ts.isIdentifier(node.name)) {
        return node.name.text;
    }
    else {
        const kind = ts.SyntaxKind[node.kind];
        const { line, character } = ts.getLineAndCharacterOfPosition(node.getSourceFile(), node.getStart());
        return `${kind}@${line}:${character}`;
    }
}
function getSourceFile(node) {
    // In certain transformation contexts, `ts.Node.getSourceFile()` can actually return `undefined`,
    // despite the type signature not allowing it. In that event, get the `ts.SourceFile` via the
    // original node instead (which works).
    const directSf = node.getSourceFile();
    return directSf !== undefined ? directSf : ts.getOriginalNode(node).getSourceFile();
}
function getSourceFileOrNull(program, fileName) {
    return program.getSourceFile(fileName) || null;
}
function getTokenAtPosition(sf, pos) {
    // getTokenAtPosition is part of TypeScript's private API.
    return ts.getTokenAtPosition(sf, pos);
}
function identifierOfNode(decl) {
    if (decl.name !== undefined && ts.isIdentifier(decl.name)) {
        return decl.name;
    }
    else {
        return null;
    }
}
function isDeclaration(node) {
    return isValueDeclaration(node) || isTypeDeclaration(node);
}
function isValueDeclaration(node) {
    return (ts.isClassDeclaration(node) || ts.isFunctionDeclaration(node) || ts.isVariableDeclaration(node));
}
function isTypeDeclaration(node) {
    return (ts.isEnumDeclaration(node) || ts.isTypeAliasDeclaration(node) || ts.isInterfaceDeclaration(node));
}
function isNamedDeclaration(node) {
    const namedNode = node;
    return namedNode.name !== undefined && ts.isIdentifier(namedNode.name);
}
function getRootDirs(host, options) {
    const rootDirs = [];
    const cwd = host.getCurrentDirectory();
    const fs = getFileSystem();
    if (options.rootDirs !== undefined) {
        rootDirs.push(...options.rootDirs);
    }
    else if (options.rootDir !== undefined) {
        rootDirs.push(options.rootDir);
    }
    else {
        rootDirs.push(cwd);
    }
    // In Windows the above might not always return posix separated paths
    // See:
    // https://github.com/Microsoft/TypeScript/blob/3f7357d37f66c842d70d835bc925ec2a873ecfec/src/compiler/sys.ts#L650
    // Also compiler options might be set via an API which doesn't normalize paths
    return rootDirs.map((rootDir) => fs.resolve(cwd, host.getCanonicalFileName(rootDir)));
}
function nodeDebugInfo(node) {
    const sf = getSourceFile(node);
    const { line, character } = ts.getLineAndCharacterOfPosition(sf, node.pos);
    return `[${sf.fileName}: ${ts.SyntaxKind[node.kind]} @ ${line}:${character}]`;
}
/**
 * Resolve the specified `moduleName` using the given `compilerOptions` and `compilerHost`.
 *
 * This helper will attempt to use the `CompilerHost.resolveModuleNames()` method if available.
 * Otherwise it will fallback on the `ts.ResolveModuleName()` function.
 */
function resolveModuleName(moduleName, containingFile, compilerOptions, compilerHost, moduleResolutionCache) {
    if (compilerHost.resolveModuleNames) {
        return compilerHost.resolveModuleNames([moduleName], containingFile, undefined, // reusedNames
        undefined, // redirectedReference
        compilerOptions)[0];
    }
    else {
        return ts.resolveModuleName(moduleName, containingFile, compilerOptions, compilerHost, moduleResolutionCache !== null ? moduleResolutionCache : undefined).resolvedModule;
    }
}
/** Returns true if the node is an assignment expression. */
function isAssignment(node) {
    return ts.isBinaryExpression(node) && node.operatorToken.kind === ts.SyntaxKind.EqualsToken;
}
/**
 * Obtains the non-redirected source file for `sf`.
 */
function toUnredirectedSourceFile(sf) {
    const redirectInfo = sf.redirectInfo;
    if (redirectInfo === undefined) {
        return sf;
    }
    return redirectInfo.unredirected;
}

/**
 * Find the name, if any, by which a node is exported from a given file.
 */
function findExportedNameOfNode(target, file, reflector) {
    const exports = reflector.getExportsOfModule(file);
    if (exports === null) {
        return null;
    }
    const declaredName = isNamedDeclaration(target) ? target.name.text : null;
    // Look for the export which declares the node.
    let foundExportName = null;
    for (const [exportName, declaration] of exports) {
        if (declaration.node !== target) {
            continue;
        }
        if (exportName === declaredName) {
            // A non-alias export exists which is always preferred, so use that one.
            return exportName;
        }
        foundExportName = exportName;
    }
    return foundExportName;
}

/**
 * Flags which alter the imports generated by the `ReferenceEmitter`.
 */
var ImportFlags;
(function (ImportFlags) {
    ImportFlags[ImportFlags["None"] = 0] = "None";
    /**
     * Force the generation of a new import when generating a reference, even if an identifier already
     * exists in the target file which could be used instead.
     *
     * This is sometimes required if there's a risk TypeScript might remove imports during emit.
     */
    ImportFlags[ImportFlags["ForceNewImport"] = 1] = "ForceNewImport";
    /**
     * Don't make use of any aliasing information when emitting a reference.
     *
     * This is sometimes required if emitting into a context where generated references will be fed
     * into TypeScript and type-checked (such as in template type-checking).
     */
    ImportFlags[ImportFlags["NoAliasing"] = 2] = "NoAliasing";
    /**
     * Indicates that an import to a type-only declaration is allowed.
     *
     * For references that occur in type-positions, the referred declaration may be a type-only
     * declaration that is not retained during emit. Including this flag allows to emit references to
     * type-only declarations as used in e.g. template type-checking.
     */
    ImportFlags[ImportFlags["AllowTypeImports"] = 4] = "AllowTypeImports";
    /**
     * Indicates that importing from a declaration file using a relative import path is allowed.
     *
     * The generated imports should normally use module specifiers that are valid for use in
     * production code, where arbitrary relative imports into e.g. node_modules are not allowed. For
     * template type-checking code it is however acceptable to use relative imports, as such files are
     * never emitted to JS code.
     *
     * Non-declaration files have to be contained within a configured `rootDir` so using relative
     * paths may not be possible for those, hence this flag only applies when importing from a
     * declaration file.
     */
    ImportFlags[ImportFlags["AllowRelativeDtsImports"] = 8] = "AllowRelativeDtsImports";
    /**
     * Indicates that references coming from ambient imports are allowed.
     */
    ImportFlags[ImportFlags["AllowAmbientReferences"] = 16] = "AllowAmbientReferences";
})(ImportFlags || (ImportFlags = {}));
exports.ReferenceEmitKind = void 0;
(function (ReferenceEmitKind) {
    ReferenceEmitKind[ReferenceEmitKind["Success"] = 0] = "Success";
    ReferenceEmitKind[ReferenceEmitKind["Failed"] = 1] = "Failed";
})(exports.ReferenceEmitKind || (exports.ReferenceEmitKind = {}));
/**
 * Verifies that a reference was emitted successfully, or raises a `FatalDiagnosticError` otherwise.
 * @param result The emit result that should have been successful.
 * @param origin The node that is used to report the failure diagnostic.
 * @param typeKind The kind of the symbol that the reference represents, e.g. 'component' or
 *     'class'.
 */
function assertSuccessfulReferenceEmit(result, origin, typeKind) {
    if (result.kind === exports.ReferenceEmitKind.Success) {
        return;
    }
    const message = makeDiagnosticChain(`Unable to import ${typeKind} ${nodeNameForError(result.ref.node)}.`, [makeDiagnosticChain(result.reason)]);
    throw new FatalDiagnosticError(exports.ErrorCode.IMPORT_GENERATION_FAILURE, origin, message, [
        makeRelatedInformation(result.ref.node, `The ${typeKind} is declared here.`),
    ]);
}
/**
 * Generates `Expression`s which refer to `Reference`s in a given context.
 *
 * A `ReferenceEmitter` uses one or more `ReferenceEmitStrategy` implementations to produce an
 * `Expression` which refers to a `Reference` in the context of a particular file.
 */
class ReferenceEmitter {
    strategies;
    constructor(strategies) {
        this.strategies = strategies;
    }
    emit(ref, context, importFlags = ImportFlags.None) {
        for (const strategy of this.strategies) {
            const emitted = strategy.emit(ref, context, importFlags);
            if (emitted !== null) {
                return emitted;
            }
        }
        return {
            kind: exports.ReferenceEmitKind.Failed,
            ref,
            context,
            reason: `Unable to write a reference to ${nodeNameForError(ref.node)}.`,
        };
    }
}
/**
 * A `ReferenceEmitStrategy` which will refer to declarations by any local `ts.Identifier`s, if
 * such identifiers are available.
 */
class LocalIdentifierStrategy {
    emit(ref, context, importFlags) {
        const refSf = getSourceFile(ref.node);
        // If the emitter has specified ForceNewImport, then LocalIdentifierStrategy should not use a
        // local identifier at all, *except* in the source file where the node is actually declared.
        if (importFlags & ImportFlags.ForceNewImport && refSf !== context) {
            return null;
        }
        // If referenced node is not an actual TS declaration (e.g. `class Foo` or `function foo() {}`,
        // etc) and it is in the current file then just use it directly.
        // This is important because the reference could be a property access (e.g. `exports.foo`). In
        // such a case, the reference's `identities` property would be `[foo]`, which would result in an
        // invalid emission of a free-standing `foo` identifier, rather than `exports.foo`.
        if (!isDeclaration(ref.node) && refSf === context) {
            return {
                kind: exports.ReferenceEmitKind.Success,
                expression: new o.WrappedNodeExpr(ref.node),
                importedFile: null,
            };
        }
        // If the reference is to an ambient type, it can be referenced directly.
        if (ref.isAmbient && importFlags & ImportFlags.AllowAmbientReferences) {
            const identifier = identifierOfNode(ref.node);
            if (identifier !== null) {
                return {
                    kind: exports.ReferenceEmitKind.Success,
                    expression: new o.WrappedNodeExpr(identifier),
                    importedFile: null,
                };
            }
            else {
                return null;
            }
        }
        // A Reference can have multiple identities in different files, so it may already have an
        // Identifier in the requested context file.
        const identifier = ref.getIdentityIn(context);
        if (identifier !== null) {
            return {
                kind: exports.ReferenceEmitKind.Success,
                expression: new o.WrappedNodeExpr(identifier),
                importedFile: null,
            };
        }
        else {
            return null;
        }
    }
}
/**
 * A `ReferenceEmitStrategy` which will refer to declarations that come from `node_modules` using
 * an absolute import.
 *
 * Part of this strategy involves looking at the target entry point and identifying the exported
 * name of the targeted declaration, as it might be different from the declared name (e.g. a
 * directive might be declared as FooDirImpl, but exported as FooDir). If no export can be found
 * which maps back to the original directive, an error is thrown.
 */
class AbsoluteModuleStrategy {
    program;
    checker;
    moduleResolver;
    reflectionHost;
    /**
     * A cache of the exports of specific modules, because resolving a module to its exports is a
     * costly operation.
     */
    moduleExportsCache = new Map();
    constructor(program, checker, moduleResolver, reflectionHost) {
        this.program = program;
        this.checker = checker;
        this.moduleResolver = moduleResolver;
        this.reflectionHost = reflectionHost;
    }
    emit(ref, context, importFlags) {
        if (ref.bestGuessOwningModule === null) {
            // There is no module name available for this Reference, meaning it was arrived at via a
            // relative path.
            return null;
        }
        else if (!isDeclaration(ref.node)) {
            // It's not possible to import something which isn't a declaration.
            throw new Error(`Debug assert: unable to import a Reference to non-declaration of type ${ts.SyntaxKind[ref.node.kind]}.`);
        }
        else if ((importFlags & ImportFlags.AllowTypeImports) === 0 && isTypeDeclaration(ref.node)) {
            throw new Error(`Importing a type-only declaration of type ${ts.SyntaxKind[ref.node.kind]} in a value position is not allowed.`);
        }
        // Try to find the exported name of the declaration, if one is available.
        const { specifier, resolutionContext } = ref.bestGuessOwningModule;
        const exports$1 = this.getExportsOfModule(specifier, resolutionContext);
        if (exports$1.module === null) {
            return {
                kind: exports.ReferenceEmitKind.Failed,
                ref,
                context,
                reason: `The module '${specifier}' could not be found.`,
            };
        }
        else if (exports$1.exportMap === null || !exports$1.exportMap.has(ref.node)) {
            return {
                kind: exports.ReferenceEmitKind.Failed,
                ref,
                context,
                reason: `The symbol is not exported from ${exports$1.module.fileName} (module '${specifier}').`,
            };
        }
        const symbolName = exports$1.exportMap.get(ref.node);
        return {
            kind: exports.ReferenceEmitKind.Success,
            expression: new o.ExternalExpr(new o.ExternalReference(specifier, symbolName)),
            importedFile: exports$1.module,
        };
    }
    getExportsOfModule(moduleName, fromFile) {
        if (!this.moduleExportsCache.has(moduleName)) {
            this.moduleExportsCache.set(moduleName, this.enumerateExportsOfModule(moduleName, fromFile));
        }
        return this.moduleExportsCache.get(moduleName);
    }
    enumerateExportsOfModule(specifier, fromFile) {
        // First, resolve the module specifier to its entry point, and get the ts.Symbol for it.
        const entryPointFile = this.moduleResolver.resolveModule(specifier, fromFile);
        if (entryPointFile === null) {
            return { module: null, exportMap: null };
        }
        const exports = this.reflectionHost.getExportsOfModule(entryPointFile);
        if (exports === null) {
            return { module: entryPointFile, exportMap: null };
        }
        const exportMap = new Map();
        for (const [name, declaration] of exports) {
            if (exportMap.has(declaration.node)) {
                // An export for this declaration has already been registered. We prefer an export that
                // has the same name as the declared name, i.e. is not an aliased export. This is relevant
                // for partial compilations where emitted references should import symbols using a stable
                // name. This is particularly relevant for declarations inside VE-generated libraries, as
                // such libraries contain private, unstable reexports of symbols.
                const existingExport = exportMap.get(declaration.node);
                if (isNamedDeclaration(declaration.node) && declaration.node.name.text === existingExport) {
                    continue;
                }
            }
            exportMap.set(declaration.node, name);
        }
        return { module: entryPointFile, exportMap };
    }
}
/**
 * A `ReferenceEmitStrategy` which will refer to declarations via relative paths, provided they're
 * both in the logical project "space" of paths.
 *
 * This is trickier than it sounds, as the two files may be in different root directories in the
 * project. Simply calculating a file system relative path between the two is not sufficient.
 * Instead, `LogicalProjectPath`s are used.
 */
class LogicalProjectStrategy {
    reflector;
    logicalFs;
    relativePathStrategy;
    constructor(reflector, logicalFs) {
        this.reflector = reflector;
        this.logicalFs = logicalFs;
        this.relativePathStrategy = new RelativePathStrategy(this.reflector);
    }
    emit(ref, context, importFlags) {
        const destSf = getSourceFile(ref.node);
        // Compute the relative path from the importing file to the file being imported. This is done
        // as a logical path computation, because the two files might be in different rootDirs.
        const destPath = this.logicalFs.logicalPathOfSf(destSf);
        if (destPath === null) {
            // The imported file is not within the logical project filesystem. An import into a
            // declaration file is exempt from `TS6059: File is not under 'rootDir'` so we choose to allow
            // using a filesystem relative path as fallback, if allowed per the provided import flags.
            if (destSf.isDeclarationFile && importFlags & ImportFlags.AllowRelativeDtsImports) {
                return this.relativePathStrategy.emit(ref, context);
            }
            // Note: this error is analogous to `TS6059: File is not under 'rootDir'` that TypeScript
            // reports.
            return {
                kind: exports.ReferenceEmitKind.Failed,
                ref,
                context,
                reason: `The file ${destSf.fileName} is outside of the configured 'rootDir'.`,
            };
        }
        const originPath = this.logicalFs.logicalPathOfSf(context);
        if (originPath === null) {
            throw new Error(`Debug assert: attempt to import from ${context.fileName} but it's outside the program?`);
        }
        // There's no way to emit a relative reference from a file to itself.
        if (destPath === originPath) {
            return null;
        }
        const name = findExportedNameOfNode(ref.node, destSf, this.reflector);
        if (name === null) {
            // The target declaration isn't exported from the file it's declared in. This is an issue!
            return {
                kind: exports.ReferenceEmitKind.Failed,
                ref,
                context,
                reason: `The symbol is not exported from ${destSf.fileName}.`,
            };
        }
        // With both files expressed as LogicalProjectPaths, getting the module specifier as a relative
        // path is now straightforward.
        const moduleName = LogicalProjectPath.relativePathBetween(originPath, destPath);
        return {
            kind: exports.ReferenceEmitKind.Success,
            expression: new o.ExternalExpr({ moduleName, name }),
            importedFile: destSf,
        };
    }
}
/**
 * A `ReferenceEmitStrategy` which constructs relatives paths between `ts.SourceFile`s.
 *
 * This strategy can be used if there is no `rootDir`/`rootDirs` structure for the project which
 * necessitates the stronger logic of `LogicalProjectStrategy`.
 */
class RelativePathStrategy {
    reflector;
    constructor(reflector) {
        this.reflector = reflector;
    }
    emit(ref, context) {
        const destSf = getSourceFile(ref.node);
        const relativePath = relative(dirname(absoluteFromSourceFile(context)), absoluteFromSourceFile(destSf));
        const moduleName = toRelativeImport(stripExtension(relativePath));
        const name = findExportedNameOfNode(ref.node, destSf, this.reflector);
        if (name === null) {
            return {
                kind: exports.ReferenceEmitKind.Failed,
                ref,
                context,
                reason: `The symbol is not exported from ${destSf.fileName}.`,
            };
        }
        return {
            kind: exports.ReferenceEmitKind.Success,
            expression: new o.ExternalExpr({ moduleName, name }),
            importedFile: destSf,
        };
    }
}
/**
 * A `ReferenceEmitStrategy` which uses a `UnifiedModulesHost` to generate absolute import
 * references.
 */
class UnifiedModulesStrategy {
    reflector;
    unifiedModulesHost;
    constructor(reflector, unifiedModulesHost) {
        this.reflector = reflector;
        this.unifiedModulesHost = unifiedModulesHost;
    }
    emit(ref, context) {
        const destSf = getSourceFile(ref.node);
        const name = findExportedNameOfNode(ref.node, destSf, this.reflector);
        if (name === null) {
            return null;
        }
        const moduleName = this.unifiedModulesHost.fileNameToModuleName(destSf.fileName, context.fileName);
        return {
            kind: exports.ReferenceEmitKind.Success,
            expression: new o.ExternalExpr({ moduleName, name }),
            importedFile: destSf,
        };
    }
}

// Escape anything that isn't alphanumeric, '/' or '_'.
const CHARS_TO_ESCAPE = /[^a-zA-Z0-9/_]/g;
/**
 * An `AliasingHost` which generates and consumes alias re-exports when module names for each file
 * are determined by a `UnifiedModulesHost`.
 *
 * When using a `UnifiedModulesHost`, aliasing prevents issues with transitive dependencies. See the
 * README.md for more details.
 */
class UnifiedModulesAliasingHost {
    unifiedModulesHost;
    constructor(unifiedModulesHost) {
        this.unifiedModulesHost = unifiedModulesHost;
    }
    /**
     * With a `UnifiedModulesHost`, aliases are chosen automatically without the need to look through
     * the exports present in a .d.ts file, so we can avoid cluttering the .d.ts files.
     */
    aliasExportsInDts = false;
    maybeAliasSymbolAs(ref, context, ngModuleName, isReExport) {
        if (!isReExport) {
            // Aliasing is used with a UnifiedModulesHost to prevent transitive dependencies. Thus,
            // aliases
            // only need to be created for directives/pipes which are not direct declarations of an
            // NgModule which exports them.
            return null;
        }
        return this.aliasName(ref.node, context);
    }
    /**
     * Generates an `Expression` to import `decl` from `via`, assuming an export was added when `via`
     * was compiled per `maybeAliasSymbolAs` above.
     */
    getAliasIn(decl, via, isReExport) {
        if (!isReExport) {
            // Directly exported directives/pipes don't require an alias, per the logic in
            // `maybeAliasSymbolAs`.
            return null;
        }
        // viaModule is the module it'll actually be imported from.
        const moduleName = this.unifiedModulesHost.fileNameToModuleName(via.fileName, via.fileName);
        return new o.ExternalExpr({ moduleName, name: this.aliasName(decl, via) });
    }
    /**
     * Generates an alias name based on the full module name of the file which declares the aliased
     * directive/pipe.
     */
    aliasName(decl, context) {
        // The declared module is used to get the name of the alias.
        const declModule = this.unifiedModulesHost.fileNameToModuleName(decl.getSourceFile().fileName, context.fileName);
        const replaced = declModule.replace(CHARS_TO_ESCAPE, '_').replace(/\//g, '$');
        return 'Éµng$' + replaced + '$$' + decl.name.text;
    }
}
/**
 * An `AliasingHost` which exports directives from any file containing an NgModule in which they're
 * declared/exported, under a private symbol name.
 *
 * These exports support cases where an NgModule is imported deeply from an absolute module path
 * (that is, it's not part of an Angular Package Format entrypoint), and the compiler needs to
 * import any matched directives/pipes from the same path (to the NgModule file). See README.md for
 * more details.
 */
class PrivateExportAliasingHost {
    host;
    constructor(host) {
        this.host = host;
    }
    /**
     * Under private export aliasing, the `AbsoluteModuleStrategy` used for emitting references will
     * will select aliased exports that it finds in the .d.ts file for an NgModule's file. Thus,
     * emitting these exports in .d.ts is a requirement for the `PrivateExportAliasingHost` to
     * function correctly.
     */
    aliasExportsInDts = true;
    maybeAliasSymbolAs(ref, context, ngModuleName) {
        if (ref.hasOwningModuleGuess) {
            // Skip nodes that already have an associated absolute module specifier, since they can be
            // safely imported from that specifier.
            return null;
        }
        // Look for a user-provided export of `decl` in `context`. If one exists, then an alias export
        // is not needed.
        // TODO(alxhub): maybe add a host method to check for the existence of an export without going
        // through the entire list of exports.
        const exports = this.host.getExportsOfModule(context);
        if (exports === null) {
            // Something went wrong, and no exports were available at all. Bail rather than risk creating
            // re-exports when they're not needed.
            throw new Error(`Could not determine the exports of: ${context.fileName}`);
        }
        let found = false;
        exports.forEach((value) => {
            if (value.node === ref.node) {
                found = true;
            }
        });
        if (found) {
            // The module exports the declared class directly, no alias is necessary.
            return null;
        }
        return `ÉµngExportÉµ${ngModuleName}Éµ${ref.node.name.text}`;
    }
    /**
     * A `PrivateExportAliasingHost` only generates re-exports and does not direct the compiler to
     * directly consume the aliases it creates.
     *
     * Instead, they're consumed indirectly: `AbsoluteModuleStrategy` `ReferenceEmitterStrategy` will
     * select these alias exports automatically when looking for an export of the directive/pipe from
     * the same path as the NgModule was imported.
     *
     * Thus, `getAliasIn` always returns `null`.
     */
    getAliasIn() {
        return null;
    }
}
/**
 * A `ReferenceEmitStrategy` which will consume the alias attached to a particular `Reference` to a
 * directive or pipe, if it exists.
 */
class AliasStrategy {
    emit(ref, context, importMode) {
        if (importMode & ImportFlags.NoAliasing || ref.alias === null) {
            return null;
        }
        return {
            kind: exports.ReferenceEmitKind.Success,
            expression: ref.alias,
            importedFile: 'unknown',
        };
    }
}

function relativePathBetween(from, to) {
    const relativePath = stripExtension(relative(dirname(resolve(from)), resolve(to)));
    return relativePath !== '' ? toRelativeImport(relativePath) : null;
}
function normalizeSeparators(path) {
    // TODO: normalize path only for OS that need it.
    return path.replace(/\\/g, '/');
}
/**
 * Attempts to generate a project-relative path for a file.
 * @param fileName Absolute path to the file.
 * @param rootDirs Root directories of the project.
 * @param compilerHost Host used to resolve file names.
 * @returns
 */
function getProjectRelativePath(fileName, rootDirs, compilerHost) {
    // Note: we need to pass both the file name and the root directories through getCanonicalFileName,
    // because the root directories might've been passed through it already while the source files
    // definitely have not. This can break the relative return value, because in some platforms
    // getCanonicalFileName lowercases the path.
    const filePath = compilerHost.getCanonicalFileName(fileName);
    for (const rootDir of rootDirs) {
        const rel = relative(compilerHost.getCanonicalFileName(rootDir), filePath);
        if (!rel.startsWith('..')) {
            return rel;
        }
    }
    return null;
}

/**
 * `ImportRewriter` that does no rewriting.
 */
class NoopImportRewriter {
    rewriteSymbol(symbol, specifier) {
        return symbol;
    }
    rewriteSpecifier(specifier, inContextOfFile) {
        return specifier;
    }
    rewriteNamespaceImportIdentifier(specifier) {
        return specifier;
    }
}
/**
 * A mapping of supported symbols that can be imported from within @angular/core, and the names by
 * which they're exported from r3_symbols.
 */
const CORE_SUPPORTED_SYMBOLS = new Map([
    ['ÉµÉµdefineInjectable', 'ÉµÉµdefineInjectable'],
    ['ÉµÉµdefineInjector', 'ÉµÉµdefineInjector'],
    ['ÉµÉµdefineNgModule', 'ÉµÉµdefineNgModule'],
    ['ÉµÉµsetNgModuleScope', 'ÉµÉµsetNgModuleScope'],
    ['ÉµÉµinject', 'ÉµÉµinject'],
    ['ÉµÉµFactoryDeclaration', 'ÉµÉµFactoryDeclaration'],
    ['ÉµsetClassMetadata', 'setClassMetadata'],
    ['ÉµsetClassMetadataAsync', 'setClassMetadataAsync'],
    ['ÉµÉµInjectableDeclaration', 'ÉµÉµInjectableDeclaration'],
    ['ÉµÉµInjectorDeclaration', 'ÉµÉµInjectorDeclaration'],
    ['ÉµÉµNgModuleDeclaration', 'ÉµÉµNgModuleDeclaration'],
    ['ÉµNgModuleFactory', 'NgModuleFactory'],
    ['ÉµnoSideEffects', 'ÉµnoSideEffects'],
]);
const CORE_MODULE$1 = '@angular/core';
/**
 * `ImportRewriter` that rewrites imports from '@angular/core' to be imported from the r3_symbols.ts
 * file instead.
 */
class R3SymbolsImportRewriter {
    r3SymbolsPath;
    constructor(r3SymbolsPath) {
        this.r3SymbolsPath = r3SymbolsPath;
    }
    rewriteSymbol(symbol, specifier) {
        if (specifier !== CORE_MODULE$1) {
            // This import isn't from core, so ignore it.
            return symbol;
        }
        return validateAndRewriteCoreSymbol(symbol);
    }
    rewriteSpecifier(specifier, inContextOfFile) {
        if (specifier !== CORE_MODULE$1) {
            // This module isn't core, so ignore it.
            return specifier;
        }
        const relativePathToR3Symbols = relativePathBetween(inContextOfFile, this.r3SymbolsPath);
        if (relativePathToR3Symbols === null) {
            throw new Error(`Failed to rewrite import inside ${CORE_MODULE$1}: ${inContextOfFile} -> ${this.r3SymbolsPath}`);
        }
        return relativePathToR3Symbols;
    }
    rewriteNamespaceImportIdentifier(specifier) {
        return specifier;
    }
}
function validateAndRewriteCoreSymbol(name) {
    if (!CORE_SUPPORTED_SYMBOLS.has(name)) {
        throw new Error(`Importing unexpected symbol ${name} while compiling ${CORE_MODULE$1}`);
    }
    return CORE_SUPPORTED_SYMBOLS.get(name);
}

const patchedReferencedAliasesSymbol = Symbol('patchedReferencedAliases');
/**
 * Patches the alias declaration reference resolution for a given transformation context
 * so that TypeScript knows about the specified alias declarations being referenced.
 *
 * This exists because TypeScript performs analysis of import usage before transformers
 * run and doesn't refresh its state after transformations. This means that imports
 * for symbols used as constructor types are elided due to their original type-only usage.
 *
 * In reality though, since we downlevel decorators and constructor parameters, we want
 * these symbols to be retained in the JavaScript output as they will be used as values
 * at runtime. We can instruct TypeScript to preserve imports for such identifiers by
 * creating a mutable clone of a given import specifier/clause or namespace, but that
 * has the downside of preserving the full import in the JS output. See:
 * https://github.com/microsoft/TypeScript/blob/3eaa7c65f6f076a08a5f7f1946fd0df7c7430259/src/compiler/transformers/ts.ts#L242-L250.
 *
 * This is a trick the CLI used in the past  for constructor parameter downleveling in JIT:
 * https://github.com/angular/angular-cli/blob/b3f84cc5184337666ce61c07b7b9df418030106f/packages/ngtools/webpack/src/transformers/ctor-parameters.ts#L323-L325
 * The trick is not ideal though as it preserves the full import (as outlined before), and it
 * results in a slow-down due to the type checker being involved multiple times. The CLI worked
 * around this import preserving issue by having another complex post-process step that detects and
 * elides unused imports. Note that these unused imports could cause unused chunks being generated
 * by webpack if the application or library is not marked as side-effect free.
 *
 * This is not ideal though, as we basically re-implement the complex import usage resolution
 * from TypeScript. We can do better by letting TypeScript do the import eliding, but providing
 * information about the alias declarations (e.g. import specifiers) that should not be elided
 * because they are actually referenced (as they will now appear in static properties).
 *
 * More information about these limitations with transformers can be found in:
 *   1. https://github.com/Microsoft/TypeScript/issues/17552.
 *   2. https://github.com/microsoft/TypeScript/issues/17516.
 *   3. https://github.com/angular/tsickle/issues/635.
 *
 * The patch we apply to tell TypeScript about actual referenced aliases (i.e. imported symbols),
 * matches conceptually with the logic that runs internally in TypeScript when the
 * `emitDecoratorMetadata` flag is enabled. TypeScript basically surfaces the same problem and
 * solves it conceptually the same way, but obviously doesn't need to access an internal API.
 *
 * The set that is returned by this function is meant to be filled with import declaration nodes
 * that have been referenced in a value-position by the transform, such the installed patch can
 * ensure that those import declarations are not elided.
 *
 * If `null` is returned then the transform operates in an isolated context, i.e. using the
 * `ts.transform` API. In such scenario there is no information whether an alias declaration
 * is referenced, so all alias declarations are naturally preserved and explicitly registering
 * an alias declaration as used isn't necessary.
 *
 * See below. Note that this uses sourcegraph as the TypeScript checker file doesn't display on
 * Github.
 * https://sourcegraph.com/github.com/microsoft/TypeScript@3eaa7c65f6f076a08a5f7f1946fd0df7c7430259/-/blob/src/compiler/checker.ts#L31219-31257
 */
function loadIsReferencedAliasDeclarationPatch(context) {
    // If the `getEmitResolver` method is not available, TS most likely changed the
    // internal structure of the transformation context. We will abort gracefully.
    if (!isTransformationContextWithEmitResolver(context)) {
        throwIncompatibleTransformationContextError();
    }
    const emitResolver = context.getEmitResolver();
    if (emitResolver === undefined) {
        // In isolated `ts.transform` operations no emit resolver is present, return null as `isReferencedAliasDeclaration`
        // will never be invoked.
        return null;
    }
    // The emit resolver may have been patched already, in which case we return the set of referenced
    // aliases that was created when the patch was first applied.
    // See https://github.com/angular/angular/issues/40276.
    const existingReferencedAliases = emitResolver[patchedReferencedAliasesSymbol];
    if (existingReferencedAliases !== undefined) {
        return existingReferencedAliases;
    }
    const originalIsReferencedAliasDeclaration = emitResolver.isReferencedAliasDeclaration;
    // If the emit resolver does not have a function called `isReferencedAliasDeclaration`, then
    // we abort gracefully as most likely TS changed the internal structure of the emit resolver.
    if (originalIsReferencedAliasDeclaration === undefined) {
        throwIncompatibleTransformationContextError();
    }
    const referencedAliases = new Set();
    emitResolver.isReferencedAliasDeclaration = function (node, ...args) {
        if (isAliasImportDeclaration(node) && referencedAliases.has(node)) {
            return true;
        }
        return originalIsReferencedAliasDeclaration.call(emitResolver, node, ...args);
    };
    return (emitResolver[patchedReferencedAliasesSymbol] = referencedAliases);
}
/**
 * Gets whether a given node corresponds to an import alias declaration. Alias
 * declarations can be import specifiers, namespace imports or import clauses
 * as these do not declare an actual symbol but just point to a target declaration.
 */
function isAliasImportDeclaration(node) {
    return ts.isImportSpecifier(node) || ts.isNamespaceImport(node) || ts.isImportClause(node);
}
/** Whether the transformation context exposes its emit resolver. */
function isTransformationContextWithEmitResolver(context) {
    return context.getEmitResolver !== undefined;
}
/**
 * Throws an error about an incompatible TypeScript version for which the alias
 * declaration reference resolution could not be monkey-patched. The error will
 * also propose potential solutions that can be applied by developers.
 */
function throwIncompatibleTransformationContextError() {
    throw Error('Angular compiler is incompatible with this version of the TypeScript compiler.\n\n' +
        'If you recently updated TypeScript and this issue surfaces now, consider downgrading.\n\n' +
        'Please report an issue on the Angular repositories when this issue ' +
        'surfaces and you are using a supposedly compatible TypeScript version.');
}

const DefaultImportDeclaration = Symbol('DefaultImportDeclaration');
/**
 * Attaches a default import declaration to `expr` to indicate the dependency of `expr` on the
 * default import.
 */
function attachDefaultImportDeclaration(expr, importDecl) {
    expr[DefaultImportDeclaration] = importDecl;
}
/**
 * Obtains the default import declaration that `expr` depends on, or `null` if there is no such
 * dependency.
 */
function getDefaultImportDeclaration(expr) {
    return expr[DefaultImportDeclaration] ?? null;
}
/**
 * TypeScript has trouble with generating default imports inside of transformers for some module
 * formats. The issue is that for the statement:
 *
 * import X from 'some/module';
 * console.log(X);
 *
 * TypeScript will not use the "X" name in generated code. For normal user code, this is fine
 * because references to X will also be renamed. However, if both the import and any references are
 * added in a transformer, TypeScript does not associate the two, and will leave the "X" references
 * dangling while renaming the import variable. The generated code looks something like:
 *
 * const module_1 = require('some/module');
 * console.log(X); // now X is a dangling reference.
 *
 * Therefore, we cannot synthetically add default imports, and must reuse the imports that users
 * include. Doing this poses a challenge for imports that are only consumed in the type position in
 * the user's code. If Angular reuses the imported symbol in a value position (for example, we
 * see a constructor parameter of type Foo and try to write "inject(Foo)") we will also end up with
 * a dangling reference, as TS will elide the import because it was only used in the type position
 * originally.
 *
 * To avoid this, the compiler must patch the emit resolver, and should only do this for imports
 * which are actually consumed. The `DefaultImportTracker` keeps track of these imports as they're
 * encountered and emitted, and implements a transform which can correctly flag the imports as
 * required.
 *
 * This problem does not exist for non-default imports as the compiler can easily insert
 * "import * as X" style imports for those, and the "X" identifier survives transformation.
 */
class DefaultImportTracker {
    /**
     * A `Map` which tracks the `Set` of `ts.ImportClause`s for default imports that were used in
     * a given file name.
     */
    sourceFileToUsedImports = new Map();
    recordUsedImport(importDecl) {
        if (importDecl.importClause) {
            const sf = getSourceFile(importDecl);
            // Add the default import declaration to the set of used import declarations for the file.
            if (!this.sourceFileToUsedImports.has(sf.fileName)) {
                this.sourceFileToUsedImports.set(sf.fileName, new Set());
            }
            this.sourceFileToUsedImports.get(sf.fileName).add(importDecl.importClause);
        }
    }
    /**
     * Get a `ts.TransformerFactory` which will preserve default imports that were previously marked
     * as used.
     *
     * This transformer must run after any other transformers which call `recordUsedImport`.
     */
    importPreservingTransformer() {
        return (context) => {
            let clausesToPreserve = null;
            return (sourceFile) => {
                const clausesForFile = this.sourceFileToUsedImports.get(sourceFile.fileName);
                if (clausesForFile !== undefined) {
                    for (const clause of clausesForFile) {
                        // Initialize the patch lazily so that apps that
                        // don't use default imports aren't patched.
                        if (clausesToPreserve === null) {
                            clausesToPreserve = loadIsReferencedAliasDeclarationPatch(context);
                        }
                        clausesToPreserve?.add(clause);
                    }
                }
                return sourceFile;
            };
        };
    }
}

function isDecoratorIdentifier(exp) {
    return (ts.isIdentifier(exp) ||
        (ts.isPropertyAccessExpression(exp) &&
            ts.isIdentifier(exp.expression) &&
            ts.isIdentifier(exp.name)));
}
/**
 * An enumeration of possible kinds of class members.
 */
var ClassMemberKind;
(function (ClassMemberKind) {
    ClassMemberKind[ClassMemberKind["Constructor"] = 0] = "Constructor";
    ClassMemberKind[ClassMemberKind["Getter"] = 1] = "Getter";
    ClassMemberKind[ClassMemberKind["Setter"] = 2] = "Setter";
    ClassMemberKind[ClassMemberKind["Property"] = 3] = "Property";
    ClassMemberKind[ClassMemberKind["Method"] = 4] = "Method";
})(ClassMemberKind || (ClassMemberKind = {}));
/** Possible access levels of a class member. */
var ClassMemberAccessLevel;
(function (ClassMemberAccessLevel) {
    ClassMemberAccessLevel[ClassMemberAccessLevel["PublicWritable"] = 0] = "PublicWritable";
    ClassMemberAccessLevel[ClassMemberAccessLevel["PublicReadonly"] = 1] = "PublicReadonly";
    ClassMemberAccessLevel[ClassMemberAccessLevel["Protected"] = 2] = "Protected";
    ClassMemberAccessLevel[ClassMemberAccessLevel["Private"] = 3] = "Private";
    ClassMemberAccessLevel[ClassMemberAccessLevel["EcmaScriptPrivate"] = 4] = "EcmaScriptPrivate";
})(ClassMemberAccessLevel || (ClassMemberAccessLevel = {}));
/** Indicates that a declaration is referenced through an ambient type. */
const AmbientImport = {};

/**
 * Potentially convert a `ts.TypeNode` to a `TypeValueReference`, which indicates how to use the
 * type given in the `ts.TypeNode` in a value position.
 *
 * This can return `null` if the `typeNode` is `null`, if it does not refer to a symbol with a value
 * declaration, or if it is not possible to statically understand.
 */
function typeToValue(typeNode, checker, isLocalCompilation) {
    // It's not possible to get a value expression if the parameter doesn't even have a type.
    if (typeNode === null) {
        return missingType();
    }
    if (!ts.isTypeReferenceNode(typeNode)) {
        return unsupportedType(typeNode);
    }
    const symbols = resolveTypeSymbols(typeNode, checker);
    if (symbols === null) {
        return unknownReference(typeNode);
    }
    const { local, decl } = symbols;
    // It's only valid to convert a type reference to a value reference if the type actually
    // has a value declaration associated with it. Note that const enums are an exception,
    // because while they do have a value declaration, they don't exist at runtime.
    if (decl.valueDeclaration === undefined || decl.flags & ts.SymbolFlags.ConstEnum) {
        let typeOnlyDecl = null;
        if (decl.declarations !== undefined && decl.declarations.length > 0) {
            typeOnlyDecl = decl.declarations[0];
        }
        // In local compilation mode a declaration is considered invalid only if it is a type related
        // declaration.
        if (!isLocalCompilation ||
            (typeOnlyDecl &&
                [
                    ts.SyntaxKind.TypeParameter,
                    ts.SyntaxKind.TypeAliasDeclaration,
                    ts.SyntaxKind.InterfaceDeclaration,
                ].includes(typeOnlyDecl.kind))) {
            return noValueDeclaration(typeNode, typeOnlyDecl);
        }
    }
    // The type points to a valid value declaration. Rewrite the TypeReference into an
    // Expression which references the value pointed to by the TypeReference, if possible.
    // Look at the local `ts.Symbol`'s declarations and see if it comes from an import
    // statement. If so, extract the module specifier and the name of the imported type.
    const firstDecl = local.declarations && local.declarations[0];
    if (firstDecl !== undefined) {
        if (ts.isImportClause(firstDecl) && firstDecl.name !== undefined) {
            // This is a default import.
            //   import Foo from 'foo';
            if (firstDecl.isTypeOnly) {
                // Type-only imports cannot be represented as value.
                return typeOnlyImport(typeNode, firstDecl);
            }
            if (!ts.isImportDeclaration(firstDecl.parent)) {
                return unsupportedType(typeNode);
            }
            return {
                kind: 0 /* TypeValueReferenceKind.LOCAL */,
                expression: firstDecl.name,
                defaultImportStatement: firstDecl.parent,
            };
        }
        else if (ts.isImportSpecifier(firstDecl)) {
            // The symbol was imported by name
            //   import {Foo} from 'foo';
            // or
            //   import {Foo as Bar} from 'foo';
            if (firstDecl.isTypeOnly) {
                // The import specifier can't be type-only (e.g. `import {type Foo} from '...')`.
                return typeOnlyImport(typeNode, firstDecl);
            }
            if (firstDecl.parent.parent.isTypeOnly) {
                // The import specifier can't be inside a type-only import clause
                // (e.g. `import type {Foo} from '...')`.
                return typeOnlyImport(typeNode, firstDecl.parent.parent);
            }
            // Determine the name to import (`Foo`) from the import specifier, as the symbol names of
            // the imported type could refer to a local alias (like `Bar` in the example above).
            const importedName = (firstDecl.propertyName || firstDecl.name).text;
            // The first symbol name refers to the local name, which is replaced by `importedName` above.
            // Any remaining symbol names make up the complete path to the value.
            const [_localName, ...nestedPath] = symbols.symbolNames;
            const importDeclaration = firstDecl.parent.parent.parent;
            if (!ts.isImportDeclaration(importDeclaration)) {
                return unsupportedType(typeNode);
            }
            const moduleName = extractModuleName(importDeclaration);
            return {
                kind: 1 /* TypeValueReferenceKind.IMPORTED */,
                valueDeclaration: decl.valueDeclaration ?? null,
                moduleName,
                importedName,
                nestedPath,
            };
        }
        else if (ts.isNamespaceImport(firstDecl)) {
            // The import is a namespace import
            //   import * as Foo from 'foo';
            if (firstDecl.parent.isTypeOnly) {
                // Type-only imports cannot be represented as value.
                return typeOnlyImport(typeNode, firstDecl.parent);
            }
            if (symbols.symbolNames.length === 1) {
                // The type refers to the namespace itself, which cannot be represented as a value.
                return namespaceImport(typeNode, firstDecl.parent);
            }
            // The first symbol name refers to the local name of the namespace, which is is discarded
            // as a new namespace import will be generated. This is followed by the symbol name that needs
            // to be imported and any remaining names that constitute the complete path to the value.
            const [_ns, importedName, ...nestedPath] = symbols.symbolNames;
            const importDeclaration = firstDecl.parent.parent;
            if (!ts.isImportDeclaration(importDeclaration)) {
                return unsupportedType(typeNode);
            }
            const moduleName = extractModuleName(importDeclaration);
            return {
                kind: 1 /* TypeValueReferenceKind.IMPORTED */,
                valueDeclaration: decl.valueDeclaration ?? null,
                moduleName,
                importedName,
                nestedPath,
            };
        }
    }
    // If the type is not imported, the type reference can be converted into an expression as is.
    const expression = typeNodeToValueExpr(typeNode);
    if (expression !== null) {
        return {
            kind: 0 /* TypeValueReferenceKind.LOCAL */,
            expression,
            defaultImportStatement: null,
        };
    }
    else {
        return unsupportedType(typeNode);
    }
}
function unsupportedType(typeNode) {
    return {
        kind: 2 /* TypeValueReferenceKind.UNAVAILABLE */,
        reason: { kind: 5 /* ValueUnavailableKind.UNSUPPORTED */, typeNode },
    };
}
function noValueDeclaration(typeNode, decl) {
    return {
        kind: 2 /* TypeValueReferenceKind.UNAVAILABLE */,
        reason: { kind: 1 /* ValueUnavailableKind.NO_VALUE_DECLARATION */, typeNode, decl },
    };
}
function typeOnlyImport(typeNode, node) {
    return {
        kind: 2 /* TypeValueReferenceKind.UNAVAILABLE */,
        reason: { kind: 2 /* ValueUnavailableKind.TYPE_ONLY_IMPORT */, typeNode, node },
    };
}
function unknownReference(typeNode) {
    return {
        kind: 2 /* TypeValueReferenceKind.UNAVAILABLE */,
        reason: { kind: 3 /* ValueUnavailableKind.UNKNOWN_REFERENCE */, typeNode },
    };
}
function namespaceImport(typeNode, importClause) {
    return {
        kind: 2 /* TypeValueReferenceKind.UNAVAILABLE */,
        reason: { kind: 4 /* ValueUnavailableKind.NAMESPACE */, typeNode, importClause },
    };
}
function missingType() {
    return {
        kind: 2 /* TypeValueReferenceKind.UNAVAILABLE */,
        reason: { kind: 0 /* ValueUnavailableKind.MISSING_TYPE */ },
    };
}
/**
 * Attempt to extract a `ts.Expression` that's equivalent to a `ts.TypeNode`, as the two have
 * different AST shapes but can reference the same symbols.
 *
 * This will return `null` if an equivalent expression cannot be constructed.
 */
function typeNodeToValueExpr(node) {
    if (ts.isTypeReferenceNode(node)) {
        return entityNameToValue(node.typeName);
    }
    else {
        return null;
    }
}
/**
 * Resolve a `TypeReference` node to the `ts.Symbol`s for both its declaration and its local source.
 *
 * In the event that the `TypeReference` refers to a locally declared symbol, these will be the
 * same. If the `TypeReference` refers to an imported symbol, then `decl` will be the fully resolved
 * `ts.Symbol` of the referenced symbol. `local` will be the `ts.Symbol` of the `ts.Identifier`
 * which points to the import statement by which the symbol was imported.
 *
 * All symbol names that make up the type reference are returned left-to-right into the
 * `symbolNames` array, which is guaranteed to include at least one entry.
 */
function resolveTypeSymbols(typeRef, checker) {
    const typeName = typeRef.typeName;
    // typeRefSymbol is the ts.Symbol of the entire type reference.
    const typeRefSymbol = checker.getSymbolAtLocation(typeName);
    if (typeRefSymbol === undefined) {
        return null;
    }
    // `local` is the `ts.Symbol` for the local `ts.Identifier` for the type.
    // If the type is actually locally declared or is imported by name, for example:
    //   import {Foo} from './foo';
    // then it'll be the same as `typeRefSymbol`.
    //
    // If the type is imported via a namespace import, for example:
    //   import * as foo from './foo';
    // and then referenced as:
    //   constructor(f: foo.Foo)
    // then `local` will be the `ts.Symbol` of `foo`, whereas `typeRefSymbol` will be the `ts.Symbol`
    // of `foo.Foo`. This allows tracking of the import behind whatever type reference exists.
    let local = typeRefSymbol;
    // Destructure a name like `foo.X.Y.Z` as follows:
    // - in `leftMost`, the `ts.Identifier` of the left-most name (`foo`) in the qualified name.
    //   This identifier is used to resolve the `ts.Symbol` for `local`.
    // - in `symbolNames`, all names involved in the qualified path, or a single symbol name if the
    //   type is not qualified.
    let leftMost = typeName;
    const symbolNames = [];
    while (ts.isQualifiedName(leftMost)) {
        symbolNames.unshift(leftMost.right.text);
        leftMost = leftMost.left;
    }
    symbolNames.unshift(leftMost.text);
    if (leftMost !== typeName) {
        const localTmp = checker.getSymbolAtLocation(leftMost);
        if (localTmp !== undefined) {
            local = localTmp;
        }
    }
    // De-alias the top-level type reference symbol to get the symbol of the actual declaration.
    let decl = typeRefSymbol;
    if (typeRefSymbol.flags & ts.SymbolFlags.Alias) {
        decl = checker.getAliasedSymbol(typeRefSymbol);
    }
    return { local, decl, symbolNames };
}
function entityNameToValue(node) {
    if (ts.isQualifiedName(node)) {
        const left = entityNameToValue(node.left);
        return left !== null ? ts.factory.createPropertyAccessExpression(left, node.right) : null;
    }
    else if (ts.isIdentifier(node)) {
        const clone = ts.setOriginalNode(ts.factory.createIdentifier(node.text), node);
        clone.parent = node.parent;
        return clone;
    }
    else {
        return null;
    }
}
function extractModuleName(node) {
    if (!ts.isStringLiteral(node.moduleSpecifier)) {
        throw new Error('not a module specifier');
    }
    return node.moduleSpecifier.text;
}

function isNamedClassDeclaration(node) {
    return ts.isClassDeclaration(node) && isIdentifier(node.name);
}
function isIdentifier(node) {
    return node !== undefined && ts.isIdentifier(node);
}
/**
 * Converts the given class member access level to a string.
 * Useful fo error messages.
 */
function classMemberAccessLevelToString(level) {
    switch (level) {
        case ClassMemberAccessLevel.EcmaScriptPrivate:
            return 'ES private';
        case ClassMemberAccessLevel.Private:
            return 'private';
        case ClassMemberAccessLevel.Protected:
            return 'protected';
        case ClassMemberAccessLevel.PublicReadonly:
            return 'public readonly';
        case ClassMemberAccessLevel.PublicWritable:
        default:
            return 'public';
    }
}

/**
 * reflector.ts implements static reflection of declarations using the TypeScript `ts.TypeChecker`.
 */
class TypeScriptReflectionHost {
    checker;
    isLocalCompilation;
    skipPrivateValueDeclarationTypes;
    /**
     * @param skipPrivateValueDeclarationTypes Avoids using a value declaration that is considered private (using a Éµ-prefix),
     * instead using the first available declaration. This is needed for the {@link FormControl} API of
     * which the type declaration documents the type and the value declaration corresponds with an implementation detail.
     */
    constructor(checker, isLocalCompilation = false, skipPrivateValueDeclarationTypes = false) {
        this.checker = checker;
        this.isLocalCompilation = isLocalCompilation;
        this.skipPrivateValueDeclarationTypes = skipPrivateValueDeclarationTypes;
    }
    getDecoratorsOfDeclaration(declaration) {
        const decorators = ts.canHaveDecorators(declaration)
            ? ts.getDecorators(declaration)
            : undefined;
        return decorators !== undefined && decorators.length
            ? decorators
                .map((decorator) => this._reflectDecorator(decorator))
                .filter((dec) => dec !== null)
            : null;
    }
    getMembersOfClass(clazz) {
        const tsClazz = castDeclarationToClassOrDie(clazz);
        return tsClazz.members
            .map((member) => {
            const result = reflectClassMember(member);
            if (result === null) {
                return null;
            }
            return {
                ...result,
                decorators: this.getDecoratorsOfDeclaration(member),
            };
        })
            .filter((member) => member !== null);
    }
    getConstructorParameters(clazz) {
        const tsClazz = castDeclarationToClassOrDie(clazz);
        const isDeclaration = tsClazz.getSourceFile().isDeclarationFile;
        // For non-declaration files, we want to find the constructor with a `body`. The constructors
        // without a `body` are overloads whereas we want the implementation since it's the one that'll
        // be executed and which can have decorators. For declaration files, we take the first one that
        // we get.
        const ctor = tsClazz.members.find((member) => ts.isConstructorDeclaration(member) && (isDeclaration || member.body !== undefined));
        if (ctor === undefined) {
            return null;
        }
        return ctor.parameters.map((node) => {
            // The name of the parameter is easy.
            const name = parameterName(node.name);
            const decorators = this.getDecoratorsOfDeclaration(node);
            // It may or may not be possible to write an expression that refers to the value side of the
            // type named for the parameter.
            let originalTypeNode = node.type || null;
            let typeNode = originalTypeNode;
            // Check if we are dealing with a simple nullable union type e.g. `foo: Foo|null`
            // and extract the type. More complex union types e.g. `foo: Foo|Bar` are not supported.
            // We also don't need to support `foo: Foo|undefined` because Angular's DI injects `null` for
            // optional tokes that don't have providers.
            if (typeNode && ts.isUnionTypeNode(typeNode)) {
                let childTypeNodes = typeNode.types.filter((childTypeNode) => !(ts.isLiteralTypeNode(childTypeNode) &&
                    childTypeNode.literal.kind === ts.SyntaxKind.NullKeyword));
                if (childTypeNodes.length === 1) {
                    typeNode = childTypeNodes[0];
                }
            }
            const typeValueReference = typeToValue(typeNode, this.checker, this.isLocalCompilation);
            return {
                name,
                nameNode: node.name,
                typeValueReference,
                typeNode: originalTypeNode,
                decorators,
            };
        });
    }
    getImportOfIdentifier(id) {
        const directImport = this.getDirectImportOfIdentifier(id);
        if (directImport !== null) {
            return directImport;
        }
        else if (ts.isQualifiedName(id.parent) && id.parent.right === id) {
            return this.getImportOfNamespacedIdentifier(id, getQualifiedNameRoot(id.parent));
        }
        else if (ts.isPropertyAccessExpression(id.parent) && id.parent.name === id) {
            return this.getImportOfNamespacedIdentifier(id, getFarLeftIdentifier(id.parent));
        }
        else {
            return null;
        }
    }
    getExportsOfModule(node) {
        // In TypeScript code, modules are only ts.SourceFiles. Throw if the node isn't a module.
        if (!ts.isSourceFile(node)) {
            throw new Error(`getExportsOfModule() called on non-SourceFile in TS code`);
        }
        // Reflect the module to a Symbol, and use getExportsOfModule() to get a list of exported
        // Symbols.
        const symbol = this.checker.getSymbolAtLocation(node);
        if (symbol === undefined) {
            return null;
        }
        const map = new Map();
        this.checker.getExportsOfModule(symbol).forEach((exportSymbol) => {
            // Map each exported Symbol to a Declaration and add it to the map.
            const decl = this.getDeclarationOfSymbol(exportSymbol, null);
            if (decl !== null) {
                map.set(exportSymbol.name, decl);
            }
        });
        return map;
    }
    isClass(node) {
        // For our purposes, classes are "named" ts.ClassDeclarations;
        // (`node.name` can be undefined in unnamed default exports: `default export class { ... }`).
        return isNamedClassDeclaration(node);
    }
    hasBaseClass(clazz) {
        return this.getBaseClassExpression(clazz) !== null;
    }
    getBaseClassExpression(clazz) {
        if (!(ts.isClassDeclaration(clazz) || ts.isClassExpression(clazz)) ||
            clazz.heritageClauses === undefined) {
            return null;
        }
        const extendsClause = clazz.heritageClauses.find((clause) => clause.token === ts.SyntaxKind.ExtendsKeyword);
        if (extendsClause === undefined) {
            return null;
        }
        const extendsType = extendsClause.types[0];
        if (extendsType === undefined) {
            return null;
        }
        return extendsType.expression;
    }
    getDeclarationOfIdentifier(id) {
        // Resolve the identifier to a Symbol, and return the declaration of that.
        let symbol = this.checker.getSymbolAtLocation(id);
        if (symbol === undefined) {
            return null;
        }
        return this.getDeclarationOfSymbol(symbol, id);
    }
    getDefinitionOfFunction(node) {
        if (!ts.isFunctionDeclaration(node) &&
            !ts.isMethodDeclaration(node) &&
            !ts.isFunctionExpression(node) &&
            !ts.isArrowFunction(node)) {
            return null;
        }
        let body = null;
        if (node.body !== undefined) {
            // The body might be an expression if the node is an arrow function.
            body = ts.isBlock(node.body)
                ? Array.from(node.body.statements)
                : [ts.factory.createReturnStatement(node.body)];
        }
        const type = this.checker.getTypeAtLocation(node);
        const signatures = this.checker.getSignaturesOfType(type, ts.SignatureKind.Call);
        return {
            node,
            body,
            signatureCount: signatures.length,
            typeParameters: node.typeParameters === undefined ? null : Array.from(node.typeParameters),
            parameters: node.parameters.map((param) => {
                const name = parameterName(param.name);
                const initializer = param.initializer || null;
                return { name, node: param, initializer, type: param.type || null };
            }),
        };
    }
    getGenericArityOfClass(clazz) {
        if (!ts.isClassDeclaration(clazz)) {
            return null;
        }
        return clazz.typeParameters !== undefined ? clazz.typeParameters.length : 0;
    }
    getVariableValue(declaration) {
        return declaration.initializer || null;
    }
    isStaticallyExported(decl) {
        // First check if there's an `export` modifier directly on the declaration.
        let topLevel = decl;
        if (ts.isVariableDeclaration(decl) && ts.isVariableDeclarationList(decl.parent)) {
            topLevel = decl.parent.parent;
        }
        const modifiers = ts.canHaveModifiers(topLevel) ? ts.getModifiers(topLevel) : undefined;
        if (modifiers !== undefined &&
            modifiers.some((modifier) => modifier.kind === ts.SyntaxKind.ExportKeyword)) {
            // The node is part of a declaration that's directly exported.
            return true;
        }
        // If `topLevel` is not directly exported via a modifier, then it might be indirectly exported,
        // e.g.:
        //
        // class Foo {}
        // export {Foo};
        //
        // The only way to check this is to look at the module level for exports of the class. As a
        // performance optimization, this check is only performed if the class is actually declared at
        // the top level of the file and thus eligible for exporting in the first place.
        if (topLevel.parent === undefined || !ts.isSourceFile(topLevel.parent)) {
            return false;
        }
        const localExports = this.getLocalExportedDeclarationsOfSourceFile(decl.getSourceFile());
        return localExports.has(decl);
    }
    getDirectImportOfIdentifier(id) {
        const symbol = this.checker.getSymbolAtLocation(id);
        if (symbol === undefined ||
            symbol.declarations === undefined ||
            symbol.declarations.length !== 1) {
            return null;
        }
        const decl = symbol.declarations[0];
        const importDecl = getContainingImportDeclaration(decl);
        // Ignore declarations that are defined locally (not imported).
        if (importDecl === null) {
            return null;
        }
        // The module specifier is guaranteed to be a string literal, so this should always pass.
        if (!ts.isStringLiteral(importDecl.moduleSpecifier)) {
            // Not allowed to happen in TypeScript ASTs.
            return null;
        }
        return {
            from: importDecl.moduleSpecifier.text,
            name: getExportedName(decl, id),
            node: importDecl,
        };
    }
    /**
     * Try to get the import info for this identifier as though it is a namespaced import.
     *
     * For example, if the identifier is the `Directive` part of a qualified type chain like:
     *
     * ```ts
     * core.Directive
     * ```
     *
     * then it might be that `core` is a namespace import such as:
     *
     * ```ts
     * import * as core from 'tslib';
     * ```
     *
     * @param id the TypeScript identifier to find the import info for.
     * @returns The import info if this is a namespaced import or `null`.
     */
    getImportOfNamespacedIdentifier(id, namespaceIdentifier) {
        if (namespaceIdentifier === null) {
            return null;
        }
        const namespaceSymbol = this.checker.getSymbolAtLocation(namespaceIdentifier);
        if (!namespaceSymbol || namespaceSymbol.declarations === undefined) {
            return null;
        }
        const declaration = namespaceSymbol.declarations.length === 1 ? namespaceSymbol.declarations[0] : null;
        if (!declaration) {
            return null;
        }
        const namespaceDeclaration = ts.isNamespaceImport(declaration) ? declaration : null;
        if (!namespaceDeclaration) {
            return null;
        }
        const importDeclaration = namespaceDeclaration.parent.parent;
        if (!ts.isImportDeclaration(importDeclaration) ||
            !ts.isStringLiteral(importDeclaration.moduleSpecifier)) {
            // Should not happen as this would be invalid TypesScript
            return null;
        }
        return {
            from: importDeclaration.moduleSpecifier.text,
            name: id.text,
            node: importDeclaration,
        };
    }
    /**
     * Resolve a `ts.Symbol` to its declaration, keeping track of the `viaModule` along the way.
     */
    getDeclarationOfSymbol(symbol, originalId) {
        // If the symbol points to a ShorthandPropertyAssignment, resolve it.
        let valueDeclaration = undefined;
        if (symbol.valueDeclaration !== undefined) {
            valueDeclaration = symbol.valueDeclaration;
        }
        else if (symbol.declarations !== undefined && symbol.declarations.length > 0) {
            valueDeclaration = symbol.declarations[0];
        }
        if (valueDeclaration !== undefined && ts.isShorthandPropertyAssignment(valueDeclaration)) {
            const shorthandSymbol = this.checker.getShorthandAssignmentValueSymbol(valueDeclaration);
            if (shorthandSymbol === undefined) {
                return null;
            }
            return this.getDeclarationOfSymbol(shorthandSymbol, originalId);
        }
        else if (valueDeclaration !== undefined && ts.isExportSpecifier(valueDeclaration)) {
            const targetSymbol = this.checker.getExportSpecifierLocalTargetSymbol(valueDeclaration);
            if (targetSymbol === undefined) {
                return null;
            }
            return this.getDeclarationOfSymbol(targetSymbol, originalId);
        }
        const importInfo = originalId && this.getImportOfIdentifier(originalId);
        // Now, resolve the Symbol to its declaration by following any and all aliases.
        while (symbol.flags & ts.SymbolFlags.Alias) {
            symbol = this.checker.getAliasedSymbol(symbol);
        }
        // Look at the resolved Symbol's declarations and pick one of them to return.
        // Value declarations are given precedence over type declarations if not specified otherwise
        if (symbol.valueDeclaration !== undefined &&
            (!this.skipPrivateValueDeclarationTypes || !isPrivateSymbol(this.checker, symbol))) {
            return {
                node: symbol.valueDeclaration,
                viaModule: this._viaModule(symbol.valueDeclaration, originalId, importInfo),
            };
        }
        else if (symbol.declarations !== undefined && symbol.declarations.length > 0) {
            return {
                node: symbol.declarations[0],
                viaModule: this._viaModule(symbol.declarations[0], originalId, importInfo),
            };
        }
        else {
            return null;
        }
    }
    _reflectDecorator(node) {
        // Attempt to resolve the decorator expression into a reference to a concrete Identifier. The
        // expression may contain a call to a function which returns the decorator function, in which
        // case we want to return the arguments.
        let decoratorExpr = node.expression;
        let args = null;
        // Check for call expressions.
        if (ts.isCallExpression(decoratorExpr)) {
            args = Array.from(decoratorExpr.arguments);
            decoratorExpr = decoratorExpr.expression;
        }
        // The final resolved decorator should be a `ts.Identifier` - if it's not, then something is
        // wrong and the decorator can't be resolved statically.
        if (!isDecoratorIdentifier(decoratorExpr)) {
            return null;
        }
        const decoratorIdentifier = ts.isIdentifier(decoratorExpr) ? decoratorExpr : decoratorExpr.name;
        const importDecl = this.getImportOfIdentifier(decoratorIdentifier);
        return {
            name: decoratorIdentifier.text,
            identifier: decoratorExpr,
            import: importDecl,
            node,
            args,
        };
    }
    /**
     * Get the set of declarations declared in `file` which are exported.
     */
    getLocalExportedDeclarationsOfSourceFile(file) {
        const cacheSf = file;
        if (cacheSf[LocalExportedDeclarations] !== undefined) {
            // TS does not currently narrow symbol-keyed fields, hence the non-null assert is needed.
            return cacheSf[LocalExportedDeclarations];
        }
        const exportSet = new Set();
        cacheSf[LocalExportedDeclarations] = exportSet;
        const sfSymbol = this.checker.getSymbolAtLocation(cacheSf);
        if (sfSymbol === undefined || sfSymbol.exports === undefined) {
            return exportSet;
        }
        // Scan the exported symbol of the `ts.SourceFile` for the original `symbol` of the class
        // declaration.
        //
        // Note: when checking multiple classes declared in the same file, this repeats some operations.
        // In theory, this could be expensive if run in the context of a massive input file. If
        // performance does become an issue here, it should be possible to create a `Set<>`
        // Unfortunately, `ts.Iterator` doesn't implement the iterator protocol, so iteration here is
        // done manually.
        const iter = sfSymbol.exports.values();
        let item = iter.next();
        while (item.done !== true) {
            let exportedSymbol = item.value;
            // If this exported symbol comes from an `export {Foo}` statement, then the symbol is actually
            // for the export declaration, not the original declaration. Such a symbol will be an alias,
            // so unwrap aliasing if necessary.
            if (exportedSymbol.flags & ts.SymbolFlags.Alias) {
                exportedSymbol = this.checker.getAliasedSymbol(exportedSymbol);
            }
            if (exportedSymbol.valueDeclaration !== undefined &&
                exportedSymbol.valueDeclaration.getSourceFile() === file) {
                exportSet.add(exportedSymbol.valueDeclaration);
            }
            item = iter.next();
        }
        return exportSet;
    }
    _viaModule(declaration, originalId, importInfo) {
        if (importInfo === null &&
            originalId !== null &&
            declaration.getSourceFile() !== originalId.getSourceFile()) {
            return AmbientImport;
        }
        return importInfo !== null && importInfo.from !== null && !importInfo.from.startsWith('.')
            ? importInfo.from
            : null;
    }
}
class TypeEntityToDeclarationError extends Error {
    constructor(message) {
        super(message);
        // Extending `Error` ends up breaking some internal tests. This appears to be a known issue
        // when extending errors in TS and the workaround is to explicitly set the prototype.
        // https://stackoverflow.com/questions/41102060/typescript-extending-error-class
        Object.setPrototypeOf(this, new.target.prototype);
    }
}
/**
 * @throws {TypeEntityToDeclarationError} if the type cannot be converted
 *   to a declaration.
 */
function reflectTypeEntityToDeclaration(type, checker) {
    let realSymbol = checker.getSymbolAtLocation(type);
    if (realSymbol === undefined) {
        throw new TypeEntityToDeclarationError(`Cannot resolve type entity ${type.getText()} to symbol`);
    }
    while (realSymbol.flags & ts.SymbolFlags.Alias) {
        realSymbol = checker.getAliasedSymbol(realSymbol);
    }
    let node = null;
    if (realSymbol.valueDeclaration !== undefined) {
        node = realSymbol.valueDeclaration;
    }
    else if (realSymbol.declarations !== undefined && realSymbol.declarations.length === 1) {
        node = realSymbol.declarations[0];
    }
    else {
        throw new TypeEntityToDeclarationError(`Cannot resolve type entity symbol to declaration`);
    }
    if (ts.isQualifiedName(type)) {
        if (!ts.isIdentifier(type.left)) {
            throw new TypeEntityToDeclarationError(`Cannot handle qualified name with non-identifier lhs`);
        }
        const symbol = checker.getSymbolAtLocation(type.left);
        if (symbol === undefined ||
            symbol.declarations === undefined ||
            symbol.declarations.length !== 1) {
            throw new TypeEntityToDeclarationError(`Cannot resolve qualified type entity lhs to symbol`);
        }
        const decl = symbol.declarations[0];
        if (ts.isNamespaceImport(decl)) {
            const clause = decl.parent;
            const importDecl = clause.parent;
            if (!ts.isStringLiteral(importDecl.moduleSpecifier)) {
                throw new TypeEntityToDeclarationError(`Module specifier is not a string`);
            }
            return { node, from: importDecl.moduleSpecifier.text };
        }
        else if (ts.isModuleDeclaration(decl)) {
            return { node, from: null };
        }
        else {
            throw new TypeEntityToDeclarationError(`Unknown import type?`);
        }
    }
    else {
        return { node, from: null };
    }
}
function filterToMembersWithDecorator(members, name, module) {
    return members
        .filter((member) => !member.isStatic)
        .map((member) => {
        if (member.decorators === null) {
            return null;
        }
        const decorators = member.decorators.filter((dec) => {
            if (dec.import !== null) {
                return dec.import.name === name && (module === undefined || dec.import.from === module);
            }
            else {
                return dec.name === name && module === undefined;
            }
        });
        if (decorators.length === 0) {
            return null;
        }
        return { member, decorators };
    })
        .filter((value) => value !== null);
}
function extractModifiersOfMember(node) {
    const modifiers = ts.getModifiers(node);
    let isStatic = false;
    let isReadonly = false;
    let accessLevel = ClassMemberAccessLevel.PublicWritable;
    if (modifiers !== undefined) {
        for (const modifier of modifiers) {
            switch (modifier.kind) {
                case ts.SyntaxKind.StaticKeyword:
                    isStatic = true;
                    break;
                case ts.SyntaxKind.PrivateKeyword:
                    accessLevel = ClassMemberAccessLevel.Private;
                    break;
                case ts.SyntaxKind.ProtectedKeyword:
                    accessLevel = ClassMemberAccessLevel.Protected;
                    break;
                case ts.SyntaxKind.ReadonlyKeyword:
                    isReadonly = true;
                    break;
            }
        }
    }
    if (isReadonly && accessLevel === ClassMemberAccessLevel.PublicWritable) {
        accessLevel = ClassMemberAccessLevel.PublicReadonly;
    }
    if (node.name !== undefined && ts.isPrivateIdentifier(node.name)) {
        accessLevel = ClassMemberAccessLevel.EcmaScriptPrivate;
    }
    return { accessLevel, isStatic };
}
/**
 * Reflects a class element and returns static information about the
 * class member.
 *
 * Note: Decorator information is not included in this helper as it relies
 * on type checking to resolve originating import.
 */
function reflectClassMember(node) {
    let kind = null;
    let value = null;
    let name = null;
    let nameNode = null;
    if (ts.isPropertyDeclaration(node)) {
        kind = ClassMemberKind.Property;
        value = node.initializer || null;
    }
    else if (ts.isGetAccessorDeclaration(node)) {
        kind = ClassMemberKind.Getter;
    }
    else if (ts.isSetAccessorDeclaration(node)) {
        kind = ClassMemberKind.Setter;
    }
    else if (ts.isMethodDeclaration(node)) {
        kind = ClassMemberKind.Method;
    }
    else if (ts.isConstructorDeclaration(node)) {
        kind = ClassMemberKind.Constructor;
    }
    else {
        return null;
    }
    if (ts.isConstructorDeclaration(node)) {
        name = 'constructor';
    }
    else if (ts.isIdentifier(node.name)) {
        name = node.name.text;
        nameNode = node.name;
    }
    else if (ts.isStringLiteral(node.name)) {
        name = node.name.text;
        nameNode = node.name;
    }
    else if (ts.isPrivateIdentifier(node.name)) {
        name = node.name.text;
        nameNode = node.name;
    }
    else {
        return null;
    }
    const { accessLevel, isStatic } = extractModifiersOfMember(node);
    return {
        node,
        implementation: node,
        kind,
        type: node.type || null,
        accessLevel,
        name,
        nameNode,
        value,
        isStatic,
    };
}
function reflectObjectLiteral(node) {
    const map = new Map();
    node.properties.forEach((prop) => {
        if (ts.isPropertyAssignment(prop)) {
            const name = propertyNameToString(prop.name);
            if (name === null) {
                return;
            }
            map.set(name, prop.initializer);
        }
        else if (ts.isShorthandPropertyAssignment(prop)) {
            map.set(prop.name.text, prop.name);
        }
        else {
            return;
        }
    });
    return map;
}
function castDeclarationToClassOrDie(declaration) {
    if (!ts.isClassDeclaration(declaration)) {
        throw new Error(`Reflecting on a ${ts.SyntaxKind[declaration.kind]} instead of a ClassDeclaration.`);
    }
    return declaration;
}
function parameterName(name) {
    if (ts.isIdentifier(name)) {
        return name.text;
    }
    else {
        return null;
    }
}
function propertyNameToString(node) {
    if (ts.isIdentifier(node) || ts.isStringLiteral(node) || ts.isNumericLiteral(node)) {
        return node.text;
    }
    else {
        return null;
    }
}
/** Determines whether a given symbol represents a private API (symbols with names that start with `Éµ`) */
function isPrivateSymbol(typeChecker, symbol) {
    if (symbol.valueDeclaration !== undefined) {
        const symbolType = typeChecker.getTypeOfSymbolAtLocation(symbol, symbol.valueDeclaration);
        return symbolType?.symbol?.name.startsWith('Éµ') === true;
    }
    return false;
}
/**
 * Compute the left most identifier in a qualified type chain. E.g. the `a` of `a.b.c.SomeType`.
 * @param qualifiedName The starting property access expression from which we want to compute
 * the left most identifier.
 * @returns the left most identifier in the chain or `null` if it is not an identifier.
 */
function getQualifiedNameRoot(qualifiedName) {
    while (ts.isQualifiedName(qualifiedName.left)) {
        qualifiedName = qualifiedName.left;
    }
    return ts.isIdentifier(qualifiedName.left) ? qualifiedName.left : null;
}
/**
 * Compute the left most identifier in a property access chain. E.g. the `a` of `a.b.c.d`.
 * @param propertyAccess The starting property access expression from which we want to compute
 * the left most identifier.
 * @returns the left most identifier in the chain or `null` if it is not an identifier.
 */
function getFarLeftIdentifier(propertyAccess) {
    while (ts.isPropertyAccessExpression(propertyAccess.expression)) {
        propertyAccess = propertyAccess.expression;
    }
    return ts.isIdentifier(propertyAccess.expression) ? propertyAccess.expression : null;
}
/**
 * Gets the closest ancestor `ImportDeclaration` to a node.
 */
function getContainingImportDeclaration(node) {
    let parent = node.parent;
    while (parent && !ts.isSourceFile(parent)) {
        if (ts.isImportDeclaration(parent)) {
            return parent;
        }
        parent = parent.parent;
    }
    return null;
}
/**
 * Compute the name by which the `decl` was exported, not imported.
 * If no such declaration can be found (e.g. it is a namespace import)
 * then fallback to the `originalId`.
 */
function getExportedName(decl, originalId) {
    return ts.isImportSpecifier(decl)
        ? (decl.propertyName !== undefined ? decl.propertyName : decl.name).text
        : originalId.text;
}
const LocalExportedDeclarations = Symbol('LocalExportedDeclarations');

const AssumeEager = 'AssumeEager';
/**
 * Allows to register a symbol as deferrable and keep track of its usage.
 *
 * This information is later used to determine whether it's safe to drop
 * a regular import of this symbol (actually the entire import declaration)
 * in favor of using a dynamic import for cases when defer blocks are used.
 */
class DeferredSymbolTracker {
    typeChecker;
    onlyExplicitDeferDependencyImports;
    imports = new Map();
    /**
     * Map of a component class -> all import declarations that bring symbols
     * used within `@Component.deferredImports` field.
     */
    explicitlyDeferredImports = new Map();
    constructor(typeChecker, onlyExplicitDeferDependencyImports) {
        this.typeChecker = typeChecker;
        this.onlyExplicitDeferDependencyImports = onlyExplicitDeferDependencyImports;
    }
    /**
     * Given an import declaration node, extract the names of all imported symbols
     * and return them as a map where each symbol is a key and `AssumeEager` is a value.
     *
     * The logic recognizes the following import shapes:
     *
     * Case 1: `import {a, b as B} from 'a'`
     * Case 2: `import X from 'a'`
     * Case 3: `import * as x from 'a'`
     */
    extractImportedSymbols(importDecl) {
        const symbolMap = new Map();
        // Unsupported case: `import 'a'`
        if (importDecl.importClause === undefined) {
            throw new Error(`Provided import declaration doesn't have any symbols.`);
        }
        // If the entire import is a type-only import, none of the symbols can be eager.
        if (importDecl.importClause.isTypeOnly) {
            return symbolMap;
        }
        if (importDecl.importClause.namedBindings !== undefined) {
            const bindings = importDecl.importClause.namedBindings;
            if (ts.isNamedImports(bindings)) {
                // Case 1: `import {a, b as B} from 'a'`
                for (const element of bindings.elements) {
                    if (!element.isTypeOnly) {
                        symbolMap.set(element.name.text, AssumeEager);
                    }
                }
            }
            else {
                // Case 2: `import X from 'a'`
                symbolMap.set(bindings.name.text, AssumeEager);
            }
        }
        else if (importDecl.importClause.name !== undefined) {
            // Case 2: `import * as x from 'a'`
            symbolMap.set(importDecl.importClause.name.text, AssumeEager);
        }
        else {
            throw new Error('Unrecognized import structure.');
        }
        return symbolMap;
    }
    /**
     * Retrieves a list of import declarations that contain symbols used within
     * `@Component.deferredImports` of a specific component class, but those imports
     * can not be removed, since there are other symbols imported alongside deferred
     * components.
     */
    getNonRemovableDeferredImports(sourceFile, classDecl) {
        const affectedImports = [];
        const importDecls = this.explicitlyDeferredImports.get(classDecl) ?? [];
        for (const importDecl of importDecls) {
            if (importDecl.getSourceFile() === sourceFile && !this.canDefer(importDecl)) {
                affectedImports.push(importDecl);
            }
        }
        return affectedImports;
    }
    /**
     * Marks a given identifier and an associated import declaration as a candidate
     * for defer loading.
     */
    markAsDeferrableCandidate(identifier, importDecl, componentClassDecl, isExplicitlyDeferred) {
        if (this.onlyExplicitDeferDependencyImports && !isExplicitlyDeferred) {
            // Ignore deferrable candidates when only explicit deferred imports mode is enabled.
            // In that mode only dependencies from the `@Component.deferredImports` field are
            // defer-loadable.
            return;
        }
        if (isExplicitlyDeferred) {
            if (this.explicitlyDeferredImports.has(componentClassDecl)) {
                this.explicitlyDeferredImports.get(componentClassDecl).push(importDecl);
            }
            else {
                this.explicitlyDeferredImports.set(componentClassDecl, [importDecl]);
            }
        }
        let symbolMap = this.imports.get(importDecl);
        // Do we come across this import for the first time?
        if (!symbolMap) {
            symbolMap = this.extractImportedSymbols(importDecl);
            this.imports.set(importDecl, symbolMap);
        }
        if (!symbolMap.has(identifier.text)) {
            throw new Error(`The '${identifier.text}' identifier doesn't belong ` +
                `to the provided import declaration.`);
        }
        if (symbolMap.get(identifier.text) === AssumeEager) {
            // We process this symbol for the first time, populate references.
            symbolMap.set(identifier.text, this.lookupIdentifiersInSourceFile(identifier.text, importDecl));
        }
        const identifiers = symbolMap.get(identifier.text);
        // Drop the current identifier, since we are trying to make it deferrable
        // (it's used as a dependency in one of the defer blocks).
        identifiers.delete(identifier);
    }
    /**
     * Whether all symbols from a given import declaration have no references
     * in a source file, thus it's safe to use dynamic imports.
     */
    canDefer(importDecl) {
        if (!this.imports.has(importDecl)) {
            return false;
        }
        const symbolsMap = this.imports.get(importDecl);
        for (const refs of symbolsMap.values()) {
            if (refs === AssumeEager || refs.size > 0) {
                // There may be still eager references to this symbol.
                return false;
            }
        }
        return true;
    }
    /**
     * Returns a set of import declarations that is safe to remove
     * from the current source file and generate dynamic imports instead.
     */
    getDeferrableImportDecls() {
        const deferrableDecls = new Set();
        for (const [importDecl] of this.imports) {
            if (this.canDefer(importDecl)) {
                deferrableDecls.add(importDecl);
            }
        }
        return deferrableDecls;
    }
    lookupIdentifiersInSourceFile(name, importDecl) {
        const results = new Set();
        const visit = (node) => {
            // Don't record references from the declaration itself or inside
            // type nodes which will be stripped from the JS output.
            if (node === importDecl || ts.isTypeNode(node)) {
                return;
            }
            if (ts.isIdentifier(node) && node.text === name) {
                // Is `node` actually a reference to this symbol?
                const sym = this.typeChecker.getSymbolAtLocation(node);
                if (sym === undefined) {
                    return;
                }
                if (sym.declarations === undefined || sym.declarations.length === 0) {
                    return;
                }
                const importClause = sym.declarations[0];
                // Is declaration from this import statement?
                const decl = getContainingImportDeclaration(importClause);
                if (decl !== importDecl) {
                    return;
                }
                // `node` *is* a reference to the same import.
                results.add(node);
            }
            ts.forEachChild(node, visit);
        };
        visit(importDecl.getSourceFile());
        return results;
    }
}

/*!
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.dev/license
 */
/**
 * Tracks which symbols are imported in specific files and under what names. Allows for efficient
 * querying for references to those symbols without having to consult the type checker early in the
 * process.
 *
 * Note that the tracker doesn't account for variable shadowing so a final verification with the
 * type checker may be necessary, depending on the context. Also does not track dynamic imports.
 */
class ImportedSymbolsTracker {
    fileToNamedImports = new WeakMap();
    fileToNamespaceImports = new WeakMap();
    /**
     * Checks if an identifier is a potential reference to a specific named import within the same
     * file.
     * @param node Identifier to be checked.
     * @param exportedName Name of the exported symbol that is being searched for.
     * @param moduleName Module from which the symbol should be imported.
     */
    isPotentialReferenceToNamedImport(node, exportedName, moduleName) {
        const sourceFile = node.getSourceFile();
        this.scanImports(sourceFile);
        const fileImports = this.fileToNamedImports.get(sourceFile);
        const moduleImports = fileImports.get(moduleName);
        const symbolImports = moduleImports?.get(exportedName);
        return symbolImports !== undefined && symbolImports.has(node.text);
    }
    /**
     * Checks if an identifier is a potential reference to a specific namespace import within the same
     * file.
     * @param node Identifier to be checked.
     * @param moduleName Module from which the namespace is imported.
     */
    isPotentialReferenceToNamespaceImport(node, moduleName) {
        const sourceFile = node.getSourceFile();
        this.scanImports(sourceFile);
        const namespaces = this.fileToNamespaceImports.get(sourceFile);
        return namespaces.get(moduleName)?.has(node.text) ?? false;
    }
    /**
     * Checks if a file has a named imported of a certain symbol.
     * @param sourceFile File to be checked.
     * @param exportedName Name of the exported symbol that is being checked.
     * @param moduleName Module that exports the symbol.
     */
    hasNamedImport(sourceFile, exportedName, moduleName) {
        this.scanImports(sourceFile);
        const fileImports = this.fileToNamedImports.get(sourceFile);
        const moduleImports = fileImports.get(moduleName);
        return moduleImports !== undefined && moduleImports.has(exportedName);
    }
    /**
     * Checks if a file has namespace imports of a certain symbol.
     * @param sourceFile File to be checked.
     * @param moduleName Module whose namespace import is being searched for.
     */
    hasNamespaceImport(sourceFile, moduleName) {
        this.scanImports(sourceFile);
        const namespaces = this.fileToNamespaceImports.get(sourceFile);
        return namespaces.has(moduleName);
    }
    /** Scans a `SourceFile` for import statements and caches them for later use. */
    scanImports(sourceFile) {
        if (this.fileToNamedImports.has(sourceFile) && this.fileToNamespaceImports.has(sourceFile)) {
            return;
        }
        const namedImports = new Map();
        const namespaceImports = new Map();
        this.fileToNamedImports.set(sourceFile, namedImports);
        this.fileToNamespaceImports.set(sourceFile, namespaceImports);
        // Only check top-level imports.
        for (const stmt of sourceFile.statements) {
            if (!ts.isImportDeclaration(stmt) ||
                !ts.isStringLiteralLike(stmt.moduleSpecifier) ||
                stmt.importClause?.namedBindings === undefined) {
                continue;
            }
            const moduleName = stmt.moduleSpecifier.text;
            if (ts.isNamespaceImport(stmt.importClause.namedBindings)) {
                // import * as foo from 'module'
                if (!namespaceImports.has(moduleName)) {
                    namespaceImports.set(moduleName, new Set());
                }
                namespaceImports.get(moduleName).add(stmt.importClause.namedBindings.name.text);
            }
            else {
                // import {foo, bar as alias} from 'module'
                for (const element of stmt.importClause.namedBindings.elements) {
                    const localName = element.name.text;
                    const exportedName = element.propertyName === undefined ? localName : element.propertyName.text;
                    if (!namedImports.has(moduleName)) {
                        namedImports.set(moduleName, new Map());
                    }
                    const localNames = namedImports.get(moduleName);
                    if (!localNames.has(exportedName)) {
                        localNames.set(exportedName, new Set());
                    }
                    localNames.get(exportedName)?.add(localName);
                }
            }
        }
    }
}

/**
 * A tool to track extra imports to be added to the generated files in the local compilation mode.
 *
 * This is needed for g3 bundling mechanism which requires dev files (= locally compiled) to have
 * imports resemble those generated for prod files (= full compilation mode). In full compilation
 * mode Angular compiler generates extra imports for statically analyzed component dependencies. We
 * need similar imports in local compilation as well.
 *
 * The tool offers API for adding local imports (to be added to a specific file) and global imports
 * (to be added to all the files in the local compilation). For more details on how these extra
 * imports are determined see this design doc:
 * https://docs.google.com/document/d/1dOWoSDvOY9ozlMmyCnxoFLEzGgHmTFVRAOVdVU-bxlI/edit?tab=t.0#heading=h.5n3k516r57g5
 *
 * An instance of this class will be passed to each annotation handler so that they can register the
 * extra imports that they see fit. Later on, the instance is passed to the Ivy transformer ({@link
 * ivyTransformFactory}) and it is used to add the extra imports registered by the handlers to the
 * import manager ({@link ImportManager}) in order to have these imports generated.
 *
 * The extra imports are all side effect imports, and so they are identified by a single string
 * containing the module name.
 *
 */
class LocalCompilationExtraImportsTracker {
    typeChecker;
    localImportsMap = new Map();
    globalImportsSet = new Set();
    /** Names of the files marked for extra import generation. */
    markedFilesSet = new Set();
    constructor(typeChecker) {
        this.typeChecker = typeChecker;
    }
    /**
     * Marks the source file for extra imports generation.
     *
     * The extra imports are generated only for the files marked through this method. In other words,
     * the method {@link getImportsForFile} returns empty if the file is not marked. This allows the
     * consumers of this tool to avoid generating extra imports for unrelated files (e.g., non-Angular
     * files)
     */
    markFileForExtraImportGeneration(sf) {
        this.markedFilesSet.add(sf.fileName);
    }
    /**
     * Adds an extra import to be added to the generated file of a specific source file.
     */
    addImportForFile(sf, moduleName) {
        if (!this.localImportsMap.has(sf.fileName)) {
            this.localImportsMap.set(sf.fileName, new Set());
        }
        this.localImportsMap.get(sf.fileName).add(moduleName);
    }
    /**
     * If the given node is an imported identifier, this method adds the module from which it is
     * imported as an extra import to the generated file of each source file in the compilation unit,
     * otherwise the method is noop.
     *
     * Adding an extra import to all files is not optimal though. There are rooms to optimize and a
     * add the import to a subset of files (e.g., exclude all the non Angular files as they don't need
     * any extra import). However for this first version of this feature we go by this mechanism for
     * simplicity. There will be on-going work to further optimize this method to add the extra import
     * to smallest possible candidate files instead of all files.
     */
    addGlobalImportFromIdentifier(node) {
        let identifier = null;
        if (ts.isIdentifier(node)) {
            identifier = node;
        }
        else if (ts.isPropertyAccessExpression(node) && ts.isIdentifier(node.expression)) {
            identifier = node.expression;
        }
        if (identifier === null) {
            return;
        }
        const sym = this.typeChecker.getSymbolAtLocation(identifier);
        if (!sym?.declarations?.length) {
            return;
        }
        const importClause = sym.declarations[0];
        const decl = getContainingImportDeclaration(importClause);
        if (decl !== null) {
            this.globalImportsSet.add(removeQuotations(decl.moduleSpecifier.getText()));
        }
    }
    /**
     * Returns the list of all module names that the given file should include as its extra imports.
     */
    getImportsForFile(sf) {
        if (!this.markedFilesSet.has(sf.fileName)) {
            return [];
        }
        return [...this.globalImportsSet, ...(this.localImportsMap.get(sf.fileName) ?? [])];
    }
}
function removeQuotations(s) {
    return s.substring(1, s.length - 1).trim();
}

/**
 * A `ts.Node` plus the context in which it was discovered.
 *
 * A `Reference` is a pointer to a `ts.Node` that was extracted from the program somehow. It
 * contains not only the node itself, but the information regarding how the node was located. In
 * particular, it might track different identifiers by which the node is exposed, as well as
 * potentially a module specifier which might expose the node.
 *
 * The Angular compiler uses `Reference`s instead of `ts.Node`s when tracking classes or generating
 * imports.
 */
class Reference {
    node;
    /**
     * The compiler's best guess at an absolute module specifier which owns this `Reference`.
     *
     * This is usually determined by tracking the import statements which led the compiler to a given
     * node. If any of these imports are absolute, it's an indication that the node being imported
     * might come from that module.
     *
     * It is not _guaranteed_ that the node in question is exported from its `bestGuessOwningModule` -
     * that is mostly a convention that applies in certain package formats.
     *
     * If `bestGuessOwningModule` is `null`, then it's likely the node came from the current program.
     */
    bestGuessOwningModule;
    identifiers = [];
    /**
     * Indicates that the Reference was created synthetically, not as a result of natural value
     * resolution.
     *
     * This is used to avoid misinterpreting the Reference in certain contexts.
     */
    synthetic = false;
    _alias = null;
    isAmbient;
    constructor(node, bestGuessOwningModule = null) {
        this.node = node;
        if (bestGuessOwningModule === AmbientImport) {
            this.isAmbient = true;
            this.bestGuessOwningModule = null;
        }
        else {
            this.isAmbient = false;
            this.bestGuessOwningModule = bestGuessOwningModule;
        }
        const id = identifierOfNode(node);
        if (id !== null) {
            this.identifiers.push(id);
        }
    }
    /**
     * The best guess at which module specifier owns this particular reference, or `null` if there
     * isn't one.
     */
    get ownedByModuleGuess() {
        if (this.bestGuessOwningModule !== null) {
            return this.bestGuessOwningModule.specifier;
        }
        else {
            return null;
        }
    }
    /**
     * Whether this reference has a potential owning module or not.
     *
     * See `bestGuessOwningModule`.
     */
    get hasOwningModuleGuess() {
        return this.bestGuessOwningModule !== null;
    }
    /**
     * A name for the node, if one is available.
     *
     * This is only suited for debugging. Any actual references to this node should be made with
     * `ts.Identifier`s (see `getIdentityIn`).
     */
    get debugName() {
        const id = identifierOfNode(this.node);
        return id !== null ? id.text : null;
    }
    get alias() {
        return this._alias;
    }
    /**
     * Record a `ts.Identifier` by which it's valid to refer to this node, within the context of this
     * `Reference`.
     */
    addIdentifier(identifier) {
        this.identifiers.push(identifier);
    }
    /**
     * Get a `ts.Identifier` within this `Reference` that can be used to refer within the context of a
     * given `ts.SourceFile`, if any.
     */
    getIdentityIn(context) {
        return this.identifiers.find((id) => id.getSourceFile() === context) || null;
    }
    /**
     * Get a `ts.Identifier` for this `Reference` that exists within the given expression.
     *
     * This is very useful for producing `ts.Diagnostic`s that reference `Reference`s that were
     * extracted from some larger expression, as it can be used to pinpoint the `ts.Identifier` within
     * the expression from which the `Reference` originated.
     */
    getIdentityInExpression(expr) {
        const sf = expr.getSourceFile();
        return (this.identifiers.find((id) => {
            if (id.getSourceFile() !== sf) {
                return false;
            }
            // This identifier is a match if its position lies within the given expression.
            return id.pos >= expr.pos && id.end <= expr.end;
        }) || null);
    }
    /**
     * Given the 'container' expression from which this `Reference` was extracted, produce a
     * `ts.Expression` to use in a diagnostic which best indicates the position within the container
     * expression that generated the `Reference`.
     *
     * For example, given a `Reference` to the class 'Bar' and the containing expression:
     * `[Foo, Bar, Baz]`, this function would attempt to return the `ts.Identifier` for `Bar` within
     * the array. This could be used to produce a nice diagnostic context:
     *
     * ```text
     * [Foo, Bar, Baz]
     *       ~~~
     * ```
     *
     * If no specific node can be found, then the `fallback` expression is used, which defaults to the
     * entire containing expression.
     */
    getOriginForDiagnostics(container, fallback = container) {
        const id = this.getIdentityInExpression(container);
        return id !== null ? id : fallback;
    }
    cloneWithAlias(alias) {
        const ref = new Reference(this.node, this.isAmbient ? AmbientImport : this.bestGuessOwningModule);
        ref.identifiers = [...this.identifiers];
        ref._alias = alias;
        return ref;
    }
    cloneWithNoIdentifiers() {
        const ref = new Reference(this.node, this.isAmbient ? AmbientImport : this.bestGuessOwningModule);
        ref._alias = this._alias;
        ref.identifiers = [];
        return ref;
    }
}

/**
 * Used by `RouterEntryPointManager` and `NgModuleRouteAnalyzer` (which is in turn is used by
 * `NgModuleDecoratorHandler`) for resolving the module source-files references in lazy-loaded
 * routes (relative to the source-file containing the `NgModule` that provides the route
 * definitions).
 */
class ModuleResolver {
    program;
    compilerOptions;
    host;
    moduleResolutionCache;
    constructor(program, compilerOptions, host, moduleResolutionCache) {
        this.program = program;
        this.compilerOptions = compilerOptions;
        this.host = host;
        this.moduleResolutionCache = moduleResolutionCache;
    }
    resolveModule(moduleName, containingFile) {
        const resolved = resolveModuleName(moduleName, containingFile, this.compilerOptions, this.host, this.moduleResolutionCache);
        if (resolved === undefined) {
            return null;
        }
        return getSourceFileOrNull(this.program, absoluteFrom(resolved.resolvedFileName));
    }
}

/** Module name of the framework core. */
const CORE_MODULE = '@angular/core';
function valueReferenceToExpression(valueRef) {
    if (valueRef.kind === 2 /* TypeValueReferenceKind.UNAVAILABLE */) {
        return null;
    }
    else if (valueRef.kind === 0 /* TypeValueReferenceKind.LOCAL */) {
        const expr = new o.WrappedNodeExpr(valueRef.expression);
        if (valueRef.defaultImportStatement !== null) {
            attachDefaultImportDeclaration(expr, valueRef.defaultImportStatement);
        }
        return expr;
    }
    else {
        let importExpr = new o.ExternalExpr({
            moduleName: valueRef.moduleName,
            name: valueRef.importedName,
        });
        if (valueRef.nestedPath !== null) {
            for (const property of valueRef.nestedPath) {
                importExpr = new o.ReadPropExpr(importExpr, property);
            }
        }
        return importExpr;
    }
}
function toR3Reference(origin, ref, context, refEmitter) {
    const emittedValueRef = refEmitter.emit(ref, context);
    assertSuccessfulReferenceEmit(emittedValueRef, origin, 'class');
    const emittedTypeRef = refEmitter.emit(ref, context, ImportFlags.ForceNewImport | ImportFlags.AllowTypeImports);
    assertSuccessfulReferenceEmit(emittedTypeRef, origin, 'class');
    return {
        value: emittedValueRef.expression,
        type: emittedTypeRef.expression,
    };
}
function isAngularCore(decorator) {
    return decorator.import !== null && decorator.import.from === CORE_MODULE;
}
/**
 * This function is used for verifying that a given reference is declared
 * inside `@angular/core` and corresponds to the given symbol name.
 *
 * In some cases, due to the compiler face duplicating many symbols as
 * an independent bridge between core and the compiler, the dts bundler may
 * decide to alias declarations in the `.d.ts`, to avoid conflicts.
 *
 * e.g.
 *
 * ```
 * declare enum ViewEncapsulation {} // from the facade
 * declare enum ViewEncapsulation$1 {} // the real one exported to users.
 * ```
 *
 * This function accounts for such potential re-namings.
 */
function isAngularCoreReferenceWithPotentialAliasing(reference, symbolName, isCore) {
    return ((reference.ownedByModuleGuess === CORE_MODULE || isCore) &&
        reference.debugName?.replace(/\$\d+$/, '') === symbolName);
}
function findAngularDecorator(decorators, name, isCore) {
    return decorators.find((decorator) => isAngularDecorator$2(decorator, name, isCore));
}
function isAngularDecorator$2(decorator, name, isCore) {
    if (isCore) {
        return decorator.name === name;
    }
    else if (isAngularCore(decorator)) {
        return decorator.import.name === name;
    }
    return false;
}
function getAngularDecorators(decorators, names, isCore) {
    return decorators.filter((decorator) => {
        const name = isCore ? decorator.name : decorator.import?.name;
        if (name === undefined || !names.includes(name)) {
            return false;
        }
        return isCore || isAngularCore(decorator);
    });
}
/**
 * Unwrap a `ts.Expression`, removing outer type-casts or parentheses until the expression is in its
 * lowest level form.
 *
 * For example, the expression "(foo as Type)" unwraps to "foo".
 */
function unwrapExpression(node) {
    while (ts.isAsExpression(node) || ts.isParenthesizedExpression(node)) {
        node = node.expression;
    }
    return node;
}
function expandForwardRef(arg) {
    arg = unwrapExpression(arg);
    if (!ts.isArrowFunction(arg) && !ts.isFunctionExpression(arg)) {
        return null;
    }
    const body = arg.body;
    // Either the body is a ts.Expression directly, or a block with a single return statement.
    if (ts.isBlock(body)) {
        // Block body - look for a single return statement.
        if (body.statements.length !== 1) {
            return null;
        }
        const stmt = body.statements[0];
        if (!ts.isReturnStatement(stmt) || stmt.expression === undefined) {
            return null;
        }
        return stmt.expression;
    }
    else {
        // Shorthand body - return as an expression.
        return body;
    }
}
/**
 * If the given `node` is a forwardRef() expression then resolve its inner value, otherwise return
 * `null`.
 *
 * @param node the forwardRef() expression to resolve
 * @param reflector a ReflectionHost
 * @returns the resolved expression, if the original expression was a forwardRef(), or `null`
 *     otherwise.
 */
function tryUnwrapForwardRef(node, reflector) {
    node = unwrapExpression(node);
    if (!ts.isCallExpression(node) || node.arguments.length !== 1) {
        return null;
    }
    const fn = ts.isPropertyAccessExpression(node.expression)
        ? node.expression.name
        : node.expression;
    if (!ts.isIdentifier(fn)) {
        return null;
    }
    const expr = expandForwardRef(node.arguments[0]);
    if (expr === null) {
        return null;
    }
    const imp = reflector.getImportOfIdentifier(fn);
    if (imp === null || imp.from !== '@angular/core' || imp.name !== 'forwardRef') {
        return null;
    }
    return expr;
}
/**
 * A foreign function resolver for `staticallyResolve` which unwraps forwardRef() expressions.
 *
 * @param ref a Reference to the declaration of the function being called (which might be
 * forwardRef)
 * @param args the arguments to the invocation of the forwardRef expression
 * @returns an unwrapped argument if `ref` pointed to forwardRef, or null otherwise
 */
function createForwardRefResolver(isCore) {
    return (fn, callExpr, resolve, unresolvable) => {
        if (!isAngularCoreReferenceWithPotentialAliasing(fn, 'forwardRef', isCore) ||
            callExpr.arguments.length !== 1) {
            return unresolvable;
        }
        const expanded = expandForwardRef(callExpr.arguments[0]);
        if (expanded !== null) {
            return resolve(expanded);
        }
        else {
            return unresolvable;
        }
    };
}
/**
 * Combines an array of resolver functions into a one.
 * @param resolvers Resolvers to be combined.
 */
function combineResolvers(resolvers) {
    return (fn, callExpr, resolve, unresolvable) => {
        for (const resolver of resolvers) {
            const resolved = resolver(fn, callExpr, resolve, unresolvable);
            if (resolved !== unresolvable) {
                return resolved;
            }
        }
        return unresolvable;
    };
}
function isExpressionForwardReference(expr, context, contextSource) {
    if (isWrappedTsNodeExpr(expr)) {
        const node = ts.getOriginalNode(expr.node);
        return node.getSourceFile() === contextSource && context.pos < node.pos;
    }
    else {
        return false;
    }
}
function isWrappedTsNodeExpr(expr) {
    return expr instanceof o.WrappedNodeExpr;
}
function readBaseClass$1(node, reflector, evaluator) {
    const baseExpression = reflector.getBaseClassExpression(node);
    if (baseExpression !== null) {
        const baseClass = evaluator.evaluate(baseExpression);
        if (baseClass instanceof Reference && reflector.isClass(baseClass.node)) {
            return baseClass;
        }
        else {
            return 'dynamic';
        }
    }
    return null;
}
const parensWrapperTransformerFactory = (context) => {
    const visitor = (node) => {
        const visited = ts.visitEachChild(node, visitor, context);
        if (ts.isArrowFunction(visited) || ts.isFunctionExpression(visited)) {
            return ts.factory.createParenthesizedExpression(visited);
        }
        return visited;
    };
    return (node) => ts.visitEachChild(node, visitor, context);
};
/**
 * Wraps all functions in a given expression in parentheses. This is needed to avoid problems
 * where Tsickle annotations added between analyse and transform phases in Angular may trigger
 * automatic semicolon insertion, e.g. if a function is the expression in a `return` statement.
 * More
 * info can be found in Tsickle source code here:
 * https://github.com/angular/tsickle/blob/d7974262571c8a17d684e5ba07680e1b1993afdd/src/jsdoc_transformer.ts#L1021
 *
 * @param expression Expression where functions should be wrapped in parentheses
 */
function wrapFunctionExpressionsInParens(expression) {
    return ts.transform(expression, [parensWrapperTransformerFactory]).transformed[0];
}
/**
 * Resolves the given `rawProviders` into `ClassDeclarations` and returns
 * a set containing those that are known to require a factory definition.
 * @param rawProviders Expression that declared the providers array in the source.
 */
function resolveProvidersRequiringFactory(rawProviders, reflector, evaluator) {
    const providers = new Set();
    const resolvedProviders = evaluator.evaluate(rawProviders);
    if (!Array.isArray(resolvedProviders)) {
        return providers;
    }
    resolvedProviders.forEach(function processProviders(provider) {
        let tokenClass = null;
        if (Array.isArray(provider)) {
            // If we ran into an array, recurse into it until we've resolve all the classes.
            provider.forEach(processProviders);
        }
        else if (provider instanceof Reference) {
            tokenClass = provider;
        }
        else if (provider instanceof Map && provider.has('useClass') && !provider.has('deps')) {
            const useExisting = provider.get('useClass');
            if (useExisting instanceof Reference) {
                tokenClass = useExisting;
            }
        }
        // TODO(alxhub): there was a bug where `getConstructorParameters` would return `null` for a
        // class in a .d.ts file, always, even if the class had a constructor. This was fixed for
        // `getConstructorParameters`, but that fix causes more classes to be recognized here as needing
        // provider checks, which is a breaking change in g3. Avoid this breakage for now by skipping
        // classes from .d.ts files here directly, until g3 can be cleaned up.
        if (tokenClass !== null &&
            !tokenClass.node.getSourceFile().isDeclarationFile &&
            reflector.isClass(tokenClass.node)) {
            const constructorParameters = reflector.getConstructorParameters(tokenClass.node);
            // Note that we only want to capture providers with a non-trivial constructor,
            // because they're the ones that might be using DI and need to be decorated.
            if (constructorParameters !== null && constructorParameters.length > 0) {
                providers.add(tokenClass);
            }
        }
    });
    return providers;
}
/**
 * Create an R3Reference for a class.
 *
 * The `value` is the exported declaration of the class from its source file.
 * The `type` is an expression that would be used in the typings (.d.ts) files.
 */
function wrapTypeReference(reflector, clazz) {
    const value = new o.WrappedNodeExpr(clazz.name);
    const type = value;
    return { value, type };
}
/** Creates a ParseSourceSpan for a TypeScript node. */
function createSourceSpan(node) {
    const sf = node.getSourceFile();
    const [startOffset, endOffset] = [node.getStart(), node.getEnd()];
    const { line: startLine, character: startCol } = sf.getLineAndCharacterOfPosition(startOffset);
    const { line: endLine, character: endCol } = sf.getLineAndCharacterOfPosition(endOffset);
    const parseSf = new o.ParseSourceFile(sf.getFullText(), sf.fileName);
    // +1 because values are zero-indexed.
    return new o.ParseSourceSpan(new o.ParseLocation(parseSf, startOffset, startLine + 1, startCol + 1), new o.ParseLocation(parseSf, endOffset, endLine + 1, endCol + 1));
}
/**
 * Collate the factory and definition compiled results into an array of CompileResult objects.
 */
function compileResults(fac, def, metadataStmt, propName, additionalFields, deferrableImports, debugInfo = null, hmrInitializer = null) {
    const statements = def.statements;
    if (metadataStmt !== null) {
        statements.push(metadataStmt);
    }
    if (debugInfo !== null) {
        statements.push(debugInfo);
    }
    if (hmrInitializer !== null) {
        statements.push(hmrInitializer);
    }
    const results = [
        fac,
        {
            name: propName,
            initializer: def.expression,
            statements: def.statements,
            type: def.type,
            deferrableImports,
        },
    ];
    if (additionalFields !== null) {
        results.push(...additionalFields);
    }
    return results;
}
function toFactoryMetadata(meta, target) {
    return {
        name: meta.name,
        type: meta.type,
        typeArgumentCount: meta.typeArgumentCount,
        deps: meta.deps,
        target,
    };
}
function resolveImportedFile(moduleResolver, importedFile, expr, origin) {
    // If `importedFile` is not 'unknown' then it accurately reflects the source file that is
    // being imported.
    if (importedFile !== 'unknown') {
        return importedFile;
    }
    // Otherwise `expr` has to be inspected to determine the file that is being imported. If `expr`
    // is not an `ExternalExpr` then it does not correspond with an import, so return null in that
    // case.
    if (!(expr instanceof o.ExternalExpr)) {
        return null;
    }
    // Figure out what file is being imported.
    return moduleResolver.resolveModule(expr.value.moduleName, origin.fileName);
}
/**
 * Determines the most appropriate expression for diagnostic reporting purposes. If `expr` is
 * contained within `container` then `expr` is used as origin node, otherwise `container` itself is
 * used.
 */
function getOriginNodeForDiagnostics(expr, container) {
    const nodeSf = expr.getSourceFile();
    const exprSf = container.getSourceFile();
    if (nodeSf === exprSf && expr.pos >= container.pos && expr.end <= container.end) {
        // `expr` occurs within the same source file as `container` and is contained within it, so
        // `expr` is appropriate to use as origin node for diagnostics.
        return expr;
    }
    else {
        return container;
    }
}
function isAbstractClassDeclaration(clazz) {
    return ts.canHaveModifiers(clazz) && clazz.modifiers !== undefined
        ? clazz.modifiers.some((mod) => mod.kind === ts.SyntaxKind.AbstractKeyword)
        : false;
}

function getConstructorDependencies(clazz, reflector, isCore) {
    const deps = [];
    const errors = [];
    let ctorParams = reflector.getConstructorParameters(clazz);
    if (ctorParams === null) {
        if (reflector.hasBaseClass(clazz)) {
            return null;
        }
        else {
            ctorParams = [];
        }
    }
    ctorParams.forEach((param, idx) => {
        let token = valueReferenceToExpression(param.typeValueReference);
        let attributeNameType = null;
        let optional = false, self = false, skipSelf = false, host = false;
        (param.decorators || [])
            .filter((dec) => isCore || isAngularCore(dec))
            .forEach((dec) => {
            const name = isCore || dec.import === null ? dec.name : dec.import.name;
            if (name === 'Inject') {
                if (dec.args === null || dec.args.length !== 1) {
                    throw new FatalDiagnosticError(exports.ErrorCode.DECORATOR_ARITY_WRONG, dec.node, `Unexpected number of arguments to @Inject().`);
                }
                token = new o.WrappedNodeExpr(dec.args[0]);
            }
            else if (name === 'Optional') {
                optional = true;
            }
            else if (name === 'SkipSelf') {
                skipSelf = true;
            }
            else if (name === 'Self') {
                self = true;
            }
            else if (name === 'Host') {
                host = true;
            }
            else if (name === 'Attribute') {
                if (dec.args === null || dec.args.length !== 1) {
                    throw new FatalDiagnosticError(exports.ErrorCode.DECORATOR_ARITY_WRONG, dec.node, `Unexpected number of arguments to @Attribute().`);
                }
                const attributeName = dec.args[0];
                token = new o.WrappedNodeExpr(attributeName);
                if (ts.isStringLiteralLike(attributeName)) {
                    attributeNameType = new o.LiteralExpr(attributeName.text);
                }
                else {
                    attributeNameType = new o.WrappedNodeExpr(ts.factory.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword));
                }
            }
            else {
                throw new FatalDiagnosticError(exports.ErrorCode.DECORATOR_UNEXPECTED, dec.node, `Unexpected decorator ${name} on parameter.`);
            }
        });
        if (token === null) {
            if (param.typeValueReference.kind !== 2 /* TypeValueReferenceKind.UNAVAILABLE */) {
                throw new Error('Illegal state: expected value reference to be unavailable if no token is present');
            }
            errors.push({
                index: idx,
                param,
                reason: param.typeValueReference.reason,
            });
        }
        else {
            deps.push({ token, attributeNameType, optional, self, skipSelf, host });
        }
    });
    if (errors.length === 0) {
        return { deps };
    }
    else {
        return { deps: null, errors };
    }
}
/**
 * Convert `ConstructorDeps` into the `R3DependencyMetadata` array for those deps if they're valid,
 * or into an `'invalid'` signal if they're not.
 *
 * This is a companion function to `validateConstructorDependencies` which accepts invalid deps.
 */
function unwrapConstructorDependencies(deps) {
    if (deps === null) {
        return null;
    }
    else if (deps.deps !== null) {
        // These constructor dependencies are valid.
        return deps.deps;
    }
    else {
        // These deps are invalid.
        return 'invalid';
    }
}
function getValidConstructorDependencies(clazz, reflector, isCore) {
    return validateConstructorDependencies(clazz, getConstructorDependencies(clazz, reflector, isCore));
}
/**
 * Validate that `ConstructorDeps` does not have any invalid dependencies and convert them into the
 * `R3DependencyMetadata` array if so, or raise a diagnostic if some deps are invalid.
 *
 * This is a companion function to `unwrapConstructorDependencies` which does not accept invalid
 * deps.
 */
function validateConstructorDependencies(clazz, deps) {
    if (deps === null) {
        return null;
    }
    else if (deps.deps !== null) {
        return deps.deps;
    }
    else {
        // There is at least one error.
        const error = deps.errors[0];
        throw createUnsuitableInjectionTokenError(clazz, error);
    }
}
/**
 * Creates a fatal error with diagnostic for an invalid injection token.
 * @param clazz The class for which the injection token was unavailable.
 * @param error The reason why no valid injection token is available.
 */
function createUnsuitableInjectionTokenError(clazz, error) {
    const { param, index, reason } = error;
    let chainMessage = undefined;
    let hints = undefined;
    switch (reason.kind) {
        case 5 /* ValueUnavailableKind.UNSUPPORTED */:
            chainMessage = 'Consider using the @Inject decorator to specify an injection token.';
            hints = [
                makeRelatedInformation(reason.typeNode, 'This type is not supported as injection token.'),
            ];
            break;
        case 1 /* ValueUnavailableKind.NO_VALUE_DECLARATION */:
            chainMessage = 'Consider using the @Inject decorator to specify an injection token.';
            hints = [
                makeRelatedInformation(reason.typeNode, 'This type does not have a value, so it cannot be used as injection token.'),
            ];
            if (reason.decl !== null) {
                hints.push(makeRelatedInformation(reason.decl, 'The type is declared here.'));
            }
            break;
        case 2 /* ValueUnavailableKind.TYPE_ONLY_IMPORT */:
            chainMessage =
                'Consider changing the type-only import to a regular import, or use the @Inject decorator to specify an injection token.';
            hints = [
                makeRelatedInformation(reason.typeNode, 'This type is imported using a type-only import, which prevents it from being usable as an injection token.'),
                makeRelatedInformation(reason.node, 'The type-only import occurs here.'),
            ];
            break;
        case 4 /* ValueUnavailableKind.NAMESPACE */:
            chainMessage = 'Consider using the @Inject decorator to specify an injection token.';
            hints = [
                makeRelatedInformation(reason.typeNode, 'This type corresponds with a namespace, which cannot be used as injection token.'),
                makeRelatedInformation(reason.importClause, 'The namespace import occurs here.'),
            ];
            break;
        case 3 /* ValueUnavailableKind.UNKNOWN_REFERENCE */:
            chainMessage = 'The type should reference a known declaration.';
            hints = [makeRelatedInformation(reason.typeNode, 'This type could not be resolved.')];
            break;
        case 0 /* ValueUnavailableKind.MISSING_TYPE */:
            chainMessage =
                'Consider adding a type to the parameter or use the @Inject decorator to specify an injection token.';
            break;
    }
    const chain = {
        messageText: `No suitable injection token for parameter '${param.name || index}' of class '${clazz.name.text}'.`,
        category: ts.DiagnosticCategory.Error,
        code: 0,
        next: [
            {
                messageText: chainMessage,
                category: ts.DiagnosticCategory.Message,
                code: 0,
            },
        ],
    };
    return new FatalDiagnosticError(exports.ErrorCode.PARAM_MISSING_TOKEN, param.nameNode, chain, hints);
}

/**
 * Disambiguates different kinds of compiler metadata objects.
 */
var MetaKind;
(function (MetaKind) {
    MetaKind[MetaKind["Directive"] = 0] = "Directive";
    MetaKind[MetaKind["Pipe"] = 1] = "Pipe";
    MetaKind[MetaKind["NgModule"] = 2] = "NgModule";
})(MetaKind || (MetaKind = {}));
/**
 * Possible ways that a directive can be matched.
 */
var MatchSource;
(function (MatchSource) {
    /** The directive was matched by its selector. */
    MatchSource[MatchSource["Selector"] = 0] = "Selector";
    /** The directive was applied as a host directive. */
    MatchSource[MatchSource["HostDirective"] = 1] = "HostDirective";
})(MatchSource || (MatchSource = {}));

/**
 * A mapping of component property and template binding property names, for example containing the
 * inputs of a particular directive or component.
 *
 * A single component property has exactly one input/output annotation (and therefore one binding
 * property name) associated with it, but the same binding property name may be shared across many
 * component property names.
 *
 * Allows bidirectional querying of the mapping - looking up all inputs/outputs with a given
 * property name, or mapping from a specific class property to its binding property name.
 */
class ClassPropertyMapping {
    /**
     * Mapping from class property names to the single `InputOrOutput` for that class property.
     */
    forwardMap;
    /**
     * Mapping from property names to one or more `InputOrOutput`s which share that name.
     */
    reverseMap;
    constructor(forwardMap) {
        this.forwardMap = forwardMap;
        this.reverseMap = reverseMapFromForwardMap(forwardMap);
    }
    /**
     * Construct a `ClassPropertyMapping` with no entries.
     */
    static empty() {
        return new ClassPropertyMapping(new Map());
    }
    /**
     * Construct a `ClassPropertyMapping` from a primitive JS object which maps class property names
     * to either binding property names or an array that contains both names, which is used in on-disk
     * metadata formats (e.g. in .d.ts files).
     */
    static fromMappedObject(obj) {
        const forwardMap = new Map();
        for (const classPropertyName of Object.keys(obj)) {
            const value = obj[classPropertyName];
            let inputOrOutput;
            if (typeof value === 'string') {
                inputOrOutput = {
                    classPropertyName,
                    bindingPropertyName: value,
                    // Inputs/outputs not captured via an explicit `InputOrOutput` mapping
                    // value are always considered non-signal. This is the string shorthand.
                    isSignal: false,
                };
            }
            else {
                inputOrOutput = value;
            }
            forwardMap.set(classPropertyName, inputOrOutput);
        }
        return new ClassPropertyMapping(forwardMap);
    }
    /**
     * Merge two mappings into one, with class properties from `b` taking precedence over class
     * properties from `a`.
     */
    static merge(a, b) {
        const forwardMap = new Map(a.forwardMap.entries());
        for (const [classPropertyName, inputOrOutput] of b.forwardMap) {
            forwardMap.set(classPropertyName, inputOrOutput);
        }
        return new ClassPropertyMapping(forwardMap);
    }
    /**
     * All class property names mapped in this mapping.
     */
    get classPropertyNames() {
        return Array.from(this.forwardMap.keys());
    }
    /**
     * All binding property names mapped in this mapping.
     */
    get propertyNames() {
        return Array.from(this.reverseMap.keys());
    }
    /**
     * Check whether a mapping for the given property name exists.
     */
    hasBindingPropertyName(propertyName) {
        return this.reverseMap.has(propertyName);
    }
    /**
     * Lookup all `InputOrOutput`s that use this `propertyName`.
     */
    getByBindingPropertyName(propertyName) {
        return this.reverseMap.has(propertyName) ? this.reverseMap.get(propertyName) : null;
    }
    /**
     * Lookup the `InputOrOutput` associated with a `classPropertyName`.
     */
    getByClassPropertyName(classPropertyName) {
        return this.forwardMap.has(classPropertyName) ? this.forwardMap.get(classPropertyName) : null;
    }
    /**
     * Convert this mapping to a primitive JS object which maps each class property directly to the
     * binding property name associated with it.
     */
    toDirectMappedObject() {
        const obj = {};
        for (const [classPropertyName, inputOrOutput] of this.forwardMap) {
            obj[classPropertyName] = inputOrOutput.bindingPropertyName;
        }
        return obj;
    }
    /**
     * Convert this mapping to a primitive JS object which maps each class property either to itself
     * (for cases where the binding property name is the same) or to an array which contains both
     * names if they differ.
     *
     * This object format is used when mappings are serialized (for example into .d.ts files).
     * @param transform Function used to transform the values of the generated map.
     */
    toJointMappedObject(transform) {
        const obj = {};
        for (const [classPropertyName, inputOrOutput] of this.forwardMap) {
            obj[classPropertyName] = transform(inputOrOutput);
        }
        return obj;
    }
    /**
     * Implement the iterator protocol and return entry objects which contain the class and binding
     * property names (and are useful for destructuring).
     */
    *[Symbol.iterator]() {
        for (const inputOrOutput of this.forwardMap.values()) {
            yield inputOrOutput;
        }
    }
}
function reverseMapFromForwardMap(forwardMap) {
    const reverseMap = new Map();
    for (const [_, inputOrOutput] of forwardMap) {
        if (!reverseMap.has(inputOrOutput.bindingPropertyName)) {
            reverseMap.set(inputOrOutput.bindingPropertyName, []);
        }
        reverseMap.get(inputOrOutput.bindingPropertyName).push(inputOrOutput);
    }
    return reverseMap;
}

function extractReferencesFromType(checker, def, bestGuessOwningModule) {
    if (!ts.isTupleTypeNode(def)) {
        return { result: [], isIncomplete: false };
    }
    const result = [];
    let isIncomplete = false;
    for (const element of def.elements) {
        if (!ts.isTypeQueryNode(element)) {
            throw new Error(`Expected TypeQueryNode: ${nodeDebugInfo(element)}`);
        }
        const ref = extraReferenceFromTypeQuery(checker, element, def, bestGuessOwningModule);
        // Note: Sometimes a reference inside the type tuple/array
        // may not be resolvable/existent. We proceed with incomplete data.
        if (ref === null) {
            isIncomplete = true;
        }
        else {
            result.push(ref);
        }
    }
    return { result, isIncomplete };
}
function extraReferenceFromTypeQuery(checker, typeNode, origin, bestGuessOwningModule) {
    const type = typeNode.exprName;
    let node;
    let from;
    // Gracefully handle when the type entity could not be converted or
    // resolved to its declaration node.
    try {
        const result = reflectTypeEntityToDeclaration(type, checker);
        node = result.node;
        from = result.from;
    }
    catch (e) {
        if (e instanceof TypeEntityToDeclarationError) {
            return null;
        }
        throw e;
    }
    if (!isNamedClassDeclaration(node)) {
        throw new Error(`Expected named ClassDeclaration: ${nodeDebugInfo(node)}`);
    }
    if (from !== null && !from.startsWith('.')) {
        // The symbol was imported using an absolute module specifier so return a reference that
        // uses that absolute module specifier as its best guess owning module.
        return new Reference(node, {
            specifier: from,
            resolutionContext: origin.getSourceFile().fileName,
        });
    }
    // For local symbols or symbols that were imported using a relative module import it is
    // assumed that the symbol is exported from the provided best guess owning module.
    return new Reference(node, bestGuessOwningModule);
}
function readBooleanType(type) {
    if (!ts.isLiteralTypeNode(type)) {
        return null;
    }
    switch (type.literal.kind) {
        case ts.SyntaxKind.TrueKeyword:
            return true;
        case ts.SyntaxKind.FalseKeyword:
            return false;
        default:
            return null;
    }
}
function readStringType(type) {
    if (!ts.isLiteralTypeNode(type) || !ts.isStringLiteral(type.literal)) {
        return null;
    }
    return type.literal.text;
}
function readMapType(type, valueTransform) {
    if (!ts.isTypeLiteralNode(type)) {
        return {};
    }
    const obj = {};
    type.members.forEach((member) => {
        if (!ts.isPropertySignature(member) ||
            member.type === undefined ||
            member.name === undefined ||
            (!ts.isStringLiteral(member.name) && !ts.isIdentifier(member.name))) {
            return;
        }
        const value = valueTransform(member.type);
        if (value !== null) {
            obj[member.name.text] = value;
        }
    });
    return obj;
}
function readStringArrayType(type) {
    if (!ts.isTupleTypeNode(type)) {
        return [];
    }
    const res = [];
    type.elements.forEach((el) => {
        if (!ts.isLiteralTypeNode(el) || !ts.isStringLiteral(el.literal)) {
            return;
        }
        res.push(el.literal.text);
    });
    return res;
}
/**
 * Inspects the class' members and extracts the metadata that is used when type-checking templates
 * that use the directive. This metadata does not contain information from a base class, if any,
 * making this metadata invariant to changes of inherited classes.
 */
function extractDirectiveTypeCheckMeta(node, inputs, reflector) {
    const members = reflector.getMembersOfClass(node);
    const staticMembers = members.filter((member) => member.isStatic);
    const ngTemplateGuards = staticMembers
        .map(extractTemplateGuard)
        .filter((guard) => guard !== null);
    const hasNgTemplateContextGuard = staticMembers.some((member) => member.kind === ClassMemberKind.Method && member.name === 'ngTemplateContextGuard');
    const coercedInputFields = new Set(staticMembers.map(extractCoercedInput).filter((inputName) => {
        // If the input refers to a signal input, we will not respect coercion members.
        // A transform function should be used instead.
        if (inputName === null || inputs.getByClassPropertyName(inputName)?.isSignal) {
            return false;
        }
        return true;
    }));
    const restrictedInputFields = new Set();
    const stringLiteralInputFields = new Set();
    const undeclaredInputFields = new Set();
    for (const { classPropertyName, transform } of inputs) {
        const field = members.find((member) => member.name === classPropertyName);
        if (field === undefined || field.node === null) {
            undeclaredInputFields.add(classPropertyName);
            continue;
        }
        if (isRestricted(field.node)) {
            restrictedInputFields.add(classPropertyName);
        }
        if (field.nameNode !== null && ts.isStringLiteral(field.nameNode)) {
            stringLiteralInputFields.add(classPropertyName);
        }
        if (transform !== null) {
            coercedInputFields.add(classPropertyName);
        }
    }
    const arity = reflector.getGenericArityOfClass(node);
    return {
        hasNgTemplateContextGuard,
        ngTemplateGuards,
        coercedInputFields,
        restrictedInputFields,
        stringLiteralInputFields,
        undeclaredInputFields,
        isGeneric: arity !== null && arity > 0,
    };
}
function isRestricted(node) {
    const modifiers = ts.canHaveModifiers(node) ? ts.getModifiers(node) : undefined;
    return (modifiers !== undefined &&
        modifiers.some(({ kind }) => {
            return (kind === ts.SyntaxKind.PrivateKeyword ||
                kind === ts.SyntaxKind.ProtectedKeyword ||
                kind === ts.SyntaxKind.ReadonlyKeyword);
        }));
}
function extractTemplateGuard(member) {
    if (!member.name.startsWith('ngTemplateGuard_')) {
        return null;
    }
    const inputName = afterUnderscore(member.name);
    if (member.kind === ClassMemberKind.Property) {
        let type = null;
        if (member.type !== null &&
            ts.isLiteralTypeNode(member.type) &&
            ts.isStringLiteral(member.type.literal)) {
            type = member.type.literal.text;
        }
        // Only property members with string literal type 'binding' are considered as template guard.
        if (type !== 'binding') {
            return null;
        }
        return { inputName, type };
    }
    else if (member.kind === ClassMemberKind.Method) {
        return { inputName, type: 'invocation' };
    }
    else {
        return null;
    }
}
function extractCoercedInput(member) {
    if (member.kind !== ClassMemberKind.Property || !member.name.startsWith('ngAcceptInputType_')) {
        return null;
    }
    return afterUnderscore(member.name);
}
/**
 * A `MetadataReader` that reads from an ordered set of child readers until it obtains the requested
 * metadata.
 *
 * This is used to combine `MetadataReader`s that read from different sources (e.g. from a registry
 * and from .d.ts files).
 */
class CompoundMetadataReader {
    readers;
    constructor(readers) {
        this.readers = readers;
    }
    getDirectiveMetadata(node) {
        for (const reader of this.readers) {
            const meta = reader.getDirectiveMetadata(node);
            if (meta !== null) {
                return meta;
            }
        }
        return null;
    }
    getNgModuleMetadata(node) {
        for (const reader of this.readers) {
            const meta = reader.getNgModuleMetadata(node);
            if (meta !== null) {
                return meta;
            }
        }
        return null;
    }
    getPipeMetadata(node) {
        for (const reader of this.readers) {
            const meta = reader.getPipeMetadata(node);
            if (meta !== null) {
                return meta;
            }
        }
        return null;
    }
}
function afterUnderscore(str) {
    const pos = str.indexOf('_');
    if (pos === -1) {
        throw new Error(`Expected '${str}' to contain '_'`);
    }
    return str.slice(pos + 1);
}
/** Returns whether a class declaration has the necessary class fields to make it injectable. */
function hasInjectableFields(clazz, host) {
    const members = host.getMembersOfClass(clazz);
    return members.some(({ isStatic, name }) => isStatic && (name === 'Éµprov' || name === 'Éµfac'));
}
function isHostDirectiveMetaForGlobalMode(hostDirectiveMeta) {
    return hostDirectiveMeta.directive instanceof Reference;
}

/**
 * A `MetadataReader` that can read metadata from `.d.ts` files, which have static Ivy properties
 * from an upstream compilation already.
 */
class DtsMetadataReader {
    checker;
    reflector;
    constructor(checker, reflector) {
        this.checker = checker;
        this.reflector = reflector;
    }
    /**
     * Read the metadata from a class that has already been compiled somehow (either it's in a .d.ts
     * file, or in a .ts file with a handwritten definition).
     *
     * @param ref `Reference` to the class of interest, with the context of how it was obtained.
     */
    getNgModuleMetadata(ref) {
        const clazz = ref.node;
        // This operation is explicitly not memoized, as it depends on `ref.ownedByModuleGuess`.
        // TODO(alxhub): investigate caching of .d.ts module metadata.
        const ngModuleDef = this.reflector
            .getMembersOfClass(clazz)
            .find((member) => member.name === 'Éµmod' && member.isStatic);
        if (ngModuleDef === undefined) {
            return null;
        }
        else if (
        // Validate that the shape of the ngModuleDef type is correct.
        ngModuleDef.type === null ||
            !ts.isTypeReferenceNode(ngModuleDef.type) ||
            ngModuleDef.type.typeArguments === undefined ||
            ngModuleDef.type.typeArguments.length !== 4) {
            return null;
        }
        // Read the ModuleData out of the type arguments.
        const [_, declarationMetadata, importMetadata, exportMetadata] = ngModuleDef.type.typeArguments;
        const declarations = extractReferencesFromType(this.checker, declarationMetadata, ref.bestGuessOwningModule);
        const exports = extractReferencesFromType(this.checker, exportMetadata, ref.bestGuessOwningModule);
        const imports = extractReferencesFromType(this.checker, importMetadata, ref.bestGuessOwningModule);
        // The module is considered poisoned if it's exports couldn't be
        // resolved completely. This would make the module not necessarily
        // usable for scope computation relying on this module; so we propagate
        // this "incompleteness" information to the caller.
        const isPoisoned = exports.isIncomplete;
        return {
            kind: MetaKind.NgModule,
            ref,
            declarations: declarations.result,
            isPoisoned,
            exports: exports.result,
            imports: imports.result,
            schemas: [],
            rawDeclarations: null,
            rawImports: null,
            rawExports: null,
            decorator: null,
            // NgModules declared outside the current compilation are assumed to contain providers, as it
            // would be a non-breaking change for a library to introduce providers at any point.
            mayDeclareProviders: true,
        };
    }
    /**
     * Read directive (or component) metadata from a referenced class in a .d.ts file.
     */
    getDirectiveMetadata(ref) {
        const clazz = ref.node;
        const def = this.reflector
            .getMembersOfClass(clazz)
            .find((field) => field.isStatic && (field.name === 'Éµcmp' || field.name === 'Éµdir'));
        if (def === undefined) {
            // No definition could be found.
            return null;
        }
        else if (def.type === null ||
            !ts.isTypeReferenceNode(def.type) ||
            def.type.typeArguments === undefined ||
            def.type.typeArguments.length < 2) {
            // The type metadata was the wrong shape.
            return null;
        }
        const isComponent = def.name === 'Éµcmp';
        const ctorParams = this.reflector.getConstructorParameters(clazz);
        // A directive is considered to be structural if:
        // 1) it's a directive, not a component, and
        // 2) it injects `TemplateRef`
        const isStructural = !isComponent &&
            ctorParams !== null &&
            ctorParams.some((param) => {
                return (param.typeValueReference.kind === 1 /* TypeValueReferenceKind.IMPORTED */ &&
                    param.typeValueReference.moduleName === '@angular/core' &&
                    param.typeValueReference.importedName === 'TemplateRef');
            });
        const ngContentSelectors = def.type.typeArguments.length > 6 ? readStringArrayType(def.type.typeArguments[6]) : null;
        // Note: the default value is still `false` here, because only legacy .d.ts files written before
        // we had so many arguments use this default.
        const isStandalone = def.type.typeArguments.length > 7 && (readBooleanType(def.type.typeArguments[7]) ?? false);
        const inputs = ClassPropertyMapping.fromMappedObject(readInputsType(def.type.typeArguments[3]));
        const outputs = ClassPropertyMapping.fromMappedObject(readMapType(def.type.typeArguments[4], readStringType));
        const hostDirectives = def.type.typeArguments.length > 8
            ? readHostDirectivesType(this.checker, def.type.typeArguments[8], ref.bestGuessOwningModule)
            : null;
        const isSignal = def.type.typeArguments.length > 9 && (readBooleanType(def.type.typeArguments[9]) ?? false);
        // At this point in time, the `.d.ts` may not be fully extractable when
        // trying to resolve host directive types to their declarations.
        // If this cannot be done completely, the metadata is incomplete and "poisoned".
        const isPoisoned = hostDirectives !== null && hostDirectives?.isIncomplete;
        return {
            kind: MetaKind.Directive,
            matchSource: MatchSource.Selector,
            ref,
            name: clazz.name.text,
            isComponent,
            selector: readStringType(def.type.typeArguments[1]),
            exportAs: readStringArrayType(def.type.typeArguments[2]),
            inputs,
            outputs,
            hostDirectives: hostDirectives?.result ?? null,
            queries: readStringArrayType(def.type.typeArguments[5]),
            ...extractDirectiveTypeCheckMeta(clazz, inputs, this.reflector),
            baseClass: readBaseClass(clazz, this.checker, this.reflector),
            isPoisoned,
            isStructural,
            animationTriggerNames: null,
            ngContentSelectors,
            isStandalone,
            isSignal,
            // We do not transfer information about inputs from class metadata
            // via `.d.ts` declarations. This is fine because this metadata is
            // currently only used for classes defined in source files. E.g. in migrations.
            inputFieldNamesFromMetadataArray: null,
            // Imports are tracked in metadata only for template type-checking purposes,
            // so standalone components from .d.ts files don't have any.
            imports: null,
            rawImports: null,
            deferredImports: null,
            // The same goes for schemas.
            schemas: null,
            decorator: null,
            // Assume that standalone components from .d.ts files may export providers.
            assumedToExportProviders: isComponent && isStandalone,
            // `preserveWhitespaces` isn't encoded in the .d.ts and is only
            // used to increase the accuracy of a diagnostic.
            preserveWhitespaces: false,
            isExplicitlyDeferred: false,
            // We don't need to know if imported components from .d.ts
            // files are selectorless for type-checking purposes.
            selectorlessEnabled: false,
            localReferencedSymbols: null,
        };
    }
    /**
     * Read pipe metadata from a referenced class in a .d.ts file.
     */
    getPipeMetadata(ref) {
        const def = this.reflector
            .getMembersOfClass(ref.node)
            .find((field) => field.isStatic && field.name === 'Éµpipe');
        if (def === undefined) {
            // No definition could be found.
            return null;
        }
        else if (def.type === null ||
            !ts.isTypeReferenceNode(def.type) ||
            def.type.typeArguments === undefined ||
            def.type.typeArguments.length < 2) {
            // The type metadata was the wrong shape.
            return null;
        }
        const type = def.type.typeArguments[1];
        if (!ts.isLiteralTypeNode(type) ||
            (!ts.isStringLiteral(type.literal) && type.literal.kind !== ts.SyntaxKind.NullKeyword)) {
            // The type metadata was the wrong type.
            return null;
        }
        const name = ts.isStringLiteral(type.literal) ? type.literal.text : null;
        const isStandalone = def.type.typeArguments.length > 2 && (readBooleanType(def.type.typeArguments[2]) ?? false);
        return {
            kind: MetaKind.Pipe,
            ref,
            name,
            nameExpr: null,
            isStandalone,
            isPure: null, // The DTS has no idea about that
            decorator: null,
            isExplicitlyDeferred: false,
        };
    }
}
function readInputsType(type) {
    const inputsMap = {};
    if (ts.isTypeLiteralNode(type)) {
        for (const member of type.members) {
            if (!ts.isPropertySignature(member) ||
                member.type === undefined ||
                member.name === undefined ||
                (!ts.isStringLiteral(member.name) && !ts.isIdentifier(member.name))) {
                continue;
            }
            const stringValue = readStringType(member.type);
            const classPropertyName = member.name.text;
            // Before v16 the inputs map has the type of `{[field: string]: string}`.
            // After v16 it has the type of `{[field: string]: {alias: string, required: boolean}}`.
            if (stringValue != null) {
                inputsMap[classPropertyName] = {
                    bindingPropertyName: stringValue,
                    classPropertyName,
                    required: false,
                    // Signal inputs were not supported pre v16- so those inputs are never signal based.
                    isSignal: false,
                    // Input transform are only tracked for locally-compiled directives. Directives coming
                    // from the .d.ts already have them included through `ngAcceptInputType` class members,
                    // or via the `InputSignal` type of the member.
                    transform: null,
                };
            }
            else {
                const config = readMapType(member.type, (innerValue) => {
                    return readStringType(innerValue) ?? readBooleanType(innerValue);
                });
                inputsMap[classPropertyName] = {
                    classPropertyName,
                    bindingPropertyName: config.alias,
                    required: config.required,
                    isSignal: !!config.isSignal,
                    // Input transform are only tracked for locally-compiled directives. Directives coming
                    // from the .d.ts already have them included through `ngAcceptInputType` class members,
                    // or via the `InputSignal` type of the member.
                    transform: null,
                };
            }
        }
    }
    return inputsMap;
}
function readBaseClass(clazz, checker, reflector) {
    if (!isNamedClassDeclaration(clazz)) {
        // Technically this is an error in a .d.ts file, but for the purposes of finding the base class
        // it's ignored.
        return reflector.hasBaseClass(clazz) ? 'dynamic' : null;
    }
    if (clazz.heritageClauses !== undefined) {
        for (const clause of clazz.heritageClauses) {
            if (clause.token === ts.SyntaxKind.ExtendsKeyword) {
                const baseExpr = clause.types[0].expression;
                let symbol = checker.getSymbolAtLocation(baseExpr);
                if (symbol === undefined) {
                    return 'dynamic';
                }
                else if (symbol.flags & ts.SymbolFlags.Alias) {
                    symbol = checker.getAliasedSymbol(symbol);
                }
                if (symbol.valueDeclaration !== undefined &&
                    isNamedClassDeclaration(symbol.valueDeclaration)) {
                    return new Reference(symbol.valueDeclaration);
                }
                else {
                    return 'dynamic';
                }
            }
        }
    }
    return null;
}
function readHostDirectivesType(checker, type, bestGuessOwningModule) {
    if (!ts.isTupleTypeNode(type) || type.elements.length === 0) {
        return null;
    }
    const result = [];
    let isIncomplete = false;
    for (const hostDirectiveType of type.elements) {
        const { directive, inputs, outputs } = readMapType(hostDirectiveType, (type) => type);
        if (directive) {
            if (!ts.isTypeQueryNode(directive)) {
                throw new Error(`Expected TypeQueryNode: ${nodeDebugInfo(directive)}`);
            }
            const ref = extraReferenceFromTypeQuery(checker, directive, type, bestGuessOwningModule);
            if (ref === null) {
                isIncomplete = true;
                continue;
            }
            result.push({
                directive: ref,
                isForwardReference: false,
                inputs: readMapType(inputs, readStringType),
                outputs: readMapType(outputs, readStringType),
            });
        }
    }
    return result.length > 0 ? { result, isIncomplete } : null;
}

/**
 * Given a reference to a directive, return a flattened version of its `DirectiveMeta` metadata
 * which includes metadata from its entire inheritance chain.
 *
 * The returned `DirectiveMeta` will either have `baseClass: null` if the inheritance chain could be
 * fully resolved, or `baseClass: 'dynamic'` if the inheritance chain could not be completely
 * followed.
 */
function flattenInheritedDirectiveMetadata(reader, dir) {
    const topMeta = reader.getDirectiveMetadata(dir);
    if (topMeta === null) {
        return null;
    }
    if (topMeta.baseClass === null) {
        return topMeta;
    }
    const coercedInputFields = new Set();
    const undeclaredInputFields = new Set();
    const restrictedInputFields = new Set();
    const stringLiteralInputFields = new Set();
    let hostDirectives = null;
    let isDynamic = false;
    let inputs = ClassPropertyMapping.empty();
    let outputs = ClassPropertyMapping.empty();
    let isStructural = false;
    const addMetadata = (meta) => {
        if (meta.baseClass === 'dynamic') {
            isDynamic = true;
        }
        else if (meta.baseClass !== null) {
            const baseMeta = reader.getDirectiveMetadata(meta.baseClass);
            if (baseMeta !== null) {
                addMetadata(baseMeta);
            }
            else {
                // Missing metadata for the base class means it's effectively dynamic.
                isDynamic = true;
            }
        }
        isStructural = isStructural || meta.isStructural;
        inputs = ClassPropertyMapping.merge(inputs, meta.inputs);
        outputs = ClassPropertyMapping.merge(outputs, meta.outputs);
        for (const coercedInputField of meta.coercedInputFields) {
            coercedInputFields.add(coercedInputField);
        }
        for (const undeclaredInputField of meta.undeclaredInputFields) {
            undeclaredInputFields.add(undeclaredInputField);
        }
        for (const restrictedInputField of meta.restrictedInputFields) {
            restrictedInputFields.add(restrictedInputField);
        }
        for (const field of meta.stringLiteralInputFields) {
            stringLiteralInputFields.add(field);
        }
        if (meta.hostDirectives !== null && meta.hostDirectives.length > 0) {
            hostDirectives ??= [];
            hostDirectives.push(...meta.hostDirectives);
        }
    };
    addMetadata(topMeta);
    return {
        ...topMeta,
        inputs,
        outputs,
        coercedInputFields,
        undeclaredInputFields,
        restrictedInputFields,
        stringLiteralInputFields,
        baseClass: isDynamic ? 'dynamic' : null,
        isStructural,
        hostDirectives,
    };
}

/**
 * A registry of directive, pipe, and module metadata for types defined in the current compilation
 * unit, which supports both reading and registering.
 */
class LocalMetadataRegistry {
    directives = new Map();
    ngModules = new Map();
    pipes = new Map();
    getDirectiveMetadata(ref) {
        return this.directives.has(ref.node) ? this.directives.get(ref.node) : null;
    }
    getNgModuleMetadata(ref) {
        return this.ngModules.has(ref.node) ? this.ngModules.get(ref.node) : null;
    }
    getPipeMetadata(ref) {
        return this.pipes.has(ref.node) ? this.pipes.get(ref.node) : null;
    }
    registerDirectiveMetadata(meta) {
        this.directives.set(meta.ref.node, meta);
    }
    registerNgModuleMetadata(meta) {
        this.ngModules.set(meta.ref.node, meta);
    }
    registerPipeMetadata(meta) {
        this.pipes.set(meta.ref.node, meta);
    }
    getKnown(kind) {
        switch (kind) {
            case MetaKind.Directive:
                return Array.from(this.directives.values()).map((v) => v.ref.node);
            case MetaKind.Pipe:
                return Array.from(this.pipes.values()).map((v) => v.ref.node);
            case MetaKind.NgModule:
                return Array.from(this.ngModules.values()).map((v) => v.ref.node);
        }
    }
}
/**
 * A `MetadataRegistry` which registers metadata with multiple delegate `MetadataRegistry`
 * instances.
 */
class CompoundMetadataRegistry {
    registries;
    constructor(registries) {
        this.registries = registries;
    }
    registerDirectiveMetadata(meta) {
        for (const registry of this.registries) {
            registry.registerDirectiveMetadata(meta);
        }
    }
    registerNgModuleMetadata(meta) {
        for (const registry of this.registries) {
            registry.registerNgModuleMetadata(meta);
        }
    }
    registerPipeMetadata(meta) {
        for (const registry of this.registries) {
            registry.registerPipeMetadata(meta);
        }
    }
}

/**
 * Tracks the mapping between external resources and the directives(s) which use them.
 *
 * This information is produced during analysis of the program and is used mainly to support
 * external tooling, for which such a mapping is challenging to determine without compiler
 * assistance.
 */
class ResourceRegistry {
    externalTemplateToComponentsMap = new Map();
    componentToTemplateMap = new Map();
    componentToStylesMap = new Map();
    externalStyleToComponentsMap = new Map();
    directiveToHostBindingsMap = new Map();
    getComponentsWithTemplate(template) {
        if (!this.externalTemplateToComponentsMap.has(template)) {
            return new Set();
        }
        return this.externalTemplateToComponentsMap.get(template);
    }
    registerResources(resources, directive) {
        if (resources.template !== null) {
            this.registerTemplate(resources.template, directive);
        }
        if (resources.styles !== null) {
            for (const style of resources.styles) {
                this.registerStyle(style, directive);
            }
        }
        if (resources.hostBindings !== null) {
            this.directiveToHostBindingsMap.set(directive, resources.hostBindings);
        }
    }
    registerTemplate(templateResource, component) {
        const { path } = templateResource;
        if (path !== null) {
            if (!this.externalTemplateToComponentsMap.has(path)) {
                this.externalTemplateToComponentsMap.set(path, new Set());
            }
            this.externalTemplateToComponentsMap.get(path).add(component);
        }
        this.componentToTemplateMap.set(component, templateResource);
    }
    getTemplate(component) {
        if (!this.componentToTemplateMap.has(component)) {
            return null;
        }
        return this.componentToTemplateMap.get(component);
    }
    registerStyle(styleResource, component) {
        const { path } = styleResource;
        if (!this.componentToStylesMap.has(component)) {
            this.componentToStylesMap.set(component, new Set());
        }
        if (path !== null) {
            if (!this.externalStyleToComponentsMap.has(path)) {
                this.externalStyleToComponentsMap.set(path, new Set());
            }
            this.externalStyleToComponentsMap.get(path).add(component);
        }
        this.componentToStylesMap.get(component).add(styleResource);
    }
    getStyles(component) {
        if (!this.componentToStylesMap.has(component)) {
            return new Set();
        }
        return this.componentToStylesMap.get(component);
    }
    getComponentsWithStyle(styleUrl) {
        if (!this.externalStyleToComponentsMap.has(styleUrl)) {
            return new Set();
        }
        return this.externalStyleToComponentsMap.get(styleUrl);
    }
    getHostBindings(directive) {
        return this.directiveToHostBindingsMap.get(directive) ?? null;
    }
}

/**
 * Determines whether types may or may not export providers to NgModules, by transitively walking
 * the NgModule & standalone import graph.
 */
class ExportedProviderStatusResolver {
    metaReader;
    /**
     * `ClassDeclaration`s that we are in the process of determining the provider status for.
     *
     * This is used to detect cycles in the import graph and avoid getting stuck in them.
     */
    calculating = new Set();
    constructor(metaReader) {
        this.metaReader = metaReader;
    }
    /**
     * Determines whether `ref` may or may not export providers to NgModules which import it.
     *
     * NgModules export providers if any are declared, and standalone components export providers from
     * their `imports` array (if any).
     *
     * If `true`, then `ref` should be assumed to export providers. In practice, this could mean
     * either that `ref` is a local type that we _know_ exports providers, or it's imported from a
     * .d.ts library and is declared in a way where the compiler cannot prove that it doesn't.
     *
     * If `false`, then `ref` is guaranteed not to export providers.
     *
     * @param `ref` the class for which the provider status should be determined
     * @param `dependencyCallback` a callback that, if provided, will be called for every type
     *     which is used in the determination of provider status for `ref`
     * @returns `true` if `ref` should be assumed to export providers, or `false` if the compiler can
     *     prove that it does not
     */
    mayExportProviders(ref, dependencyCallback) {
        if (this.calculating.has(ref.node)) {
            // For cycles, we treat the cyclic edge as not having providers.
            return false;
        }
        this.calculating.add(ref.node);
        if (dependencyCallback !== undefined) {
            dependencyCallback(ref);
        }
        try {
            const dirMeta = this.metaReader.getDirectiveMetadata(ref);
            if (dirMeta !== null) {
                if (!dirMeta.isComponent || !dirMeta.isStandalone) {
                    return false;
                }
                if (dirMeta.assumedToExportProviders) {
                    return true;
                }
                // If one of the imports contains providers, then so does this component.
                return (dirMeta.imports ?? []).some((importRef) => this.mayExportProviders(importRef, dependencyCallback));
            }
            const pipeMeta = this.metaReader.getPipeMetadata(ref);
            if (pipeMeta !== null) {
                return false;
            }
            const ngModuleMeta = this.metaReader.getNgModuleMetadata(ref);
            if (ngModuleMeta !== null) {
                if (ngModuleMeta.mayDeclareProviders) {
                    return true;
                }
                // If one of the NgModule's imports may contain providers, then so does this NgModule.
                return ngModuleMeta.imports.some((importRef) => this.mayExportProviders(importRef, dependencyCallback));
            }
            return false;
        }
        finally {
            this.calculating.delete(ref.node);
        }
    }
}

/*!
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.dev/license
 */
const EMPTY_ARRAY$1 = [];
/** Resolves the host directives of a directive to a flat array of matches. */
class HostDirectivesResolver {
    metaReader;
    cache = new Map();
    constructor(metaReader) {
        this.metaReader = metaReader;
    }
    /** Resolves all of the host directives that apply to a directive. */
    resolve(metadata) {
        if (this.cache.has(metadata.ref.node)) {
            return this.cache.get(metadata.ref.node);
        }
        const results = metadata.hostDirectives && metadata.hostDirectives.length > 0
            ? this.walkHostDirectives(metadata.hostDirectives, [])
            : EMPTY_ARRAY$1;
        this.cache.set(metadata.ref.node, results);
        return results;
    }
    /**
     * Traverses all of the host directive chains and produces a flat array of
     * directive metadata representing the host directives that apply to the host.
     */
    walkHostDirectives(directives, results) {
        for (const current of directives) {
            if (!isHostDirectiveMetaForGlobalMode(current)) {
                throw new Error('Impossible state: resolving code path in local compilation mode');
            }
            const hostMeta = flattenInheritedDirectiveMetadata(this.metaReader, current.directive);
            // This case has been checked for already and produces a diagnostic
            if (hostMeta === null) {
                continue;
            }
            if (hostMeta.hostDirectives) {
                this.walkHostDirectives(hostMeta.hostDirectives, results);
            }
            results.push({
                ...hostMeta,
                matchSource: MatchSource.HostDirective,
                inputs: ClassPropertyMapping.fromMappedObject(this.filterMappings(hostMeta.inputs, current.inputs, resolveInput)),
                outputs: ClassPropertyMapping.fromMappedObject(this.filterMappings(hostMeta.outputs, current.outputs, resolveOutput)),
            });
        }
        return results;
    }
    /**
     * Filters the class property mappings so that only the allowed ones are present.
     * @param source Property mappings that should be filtered.
     * @param allowedProperties Property mappings that are allowed in the final results.
     * @param valueResolver Function used to resolve the value that is assigned to the final mapping.
     */
    filterMappings(source, allowedProperties, valueResolver) {
        const result = {};
        if (allowedProperties !== null) {
            for (const publicName in allowedProperties) {
                if (allowedProperties.hasOwnProperty(publicName)) {
                    const bindings = source.getByBindingPropertyName(publicName);
                    if (bindings !== null) {
                        for (const binding of bindings) {
                            result[binding.classPropertyName] = valueResolver(allowedProperties[publicName], binding);
                        }
                    }
                }
            }
        }
        return result;
    }
}
function resolveInput(bindingName, binding) {
    return {
        bindingPropertyName: bindingName,
        classPropertyName: binding.classPropertyName,
        required: binding.required,
        transform: binding.transform,
        isSignal: binding.isSignal,
    };
}
function resolveOutput(bindingName) {
    return bindingName;
}

/**
 * Represents a value which cannot be determined statically.
 */
class DynamicValue {
    node;
    reason;
    code;
    constructor(node, reason, code) {
        this.node = node;
        this.reason = reason;
        this.code = code;
    }
    static fromDynamicInput(node, input) {
        return new DynamicValue(node, input, 0 /* DynamicValueReason.DYNAMIC_INPUT */);
    }
    static fromDynamicString(node) {
        return new DynamicValue(node, undefined, 1 /* DynamicValueReason.DYNAMIC_STRING */);
    }
    static fromExternalReference(node, ref) {
        return new DynamicValue(node, ref, 2 /* DynamicValueReason.EXTERNAL_REFERENCE */);
    }
    static fromUnsupportedSyntax(node) {
        return new DynamicValue(node, undefined, 3 /* DynamicValueReason.UNSUPPORTED_SYNTAX */);
    }
    static fromUnknownIdentifier(node) {
        return new DynamicValue(node, undefined, 4 /* DynamicValueReason.UNKNOWN_IDENTIFIER */);
    }
    static fromInvalidExpressionType(node, value) {
        return new DynamicValue(node, value, 5 /* DynamicValueReason.INVALID_EXPRESSION_TYPE */);
    }
    static fromComplexFunctionCall(node, fn) {
        return new DynamicValue(node, fn, 6 /* DynamicValueReason.COMPLEX_FUNCTION_CALL */);
    }
    static fromDynamicType(node) {
        return new DynamicValue(node, undefined, 7 /* DynamicValueReason.DYNAMIC_TYPE */);
    }
    static fromSyntheticInput(node, value) {
        return new DynamicValue(node, value, 8 /* DynamicValueReason.SYNTHETIC_INPUT */);
    }
    static fromUnknown(node) {
        return new DynamicValue(node, undefined, 9 /* DynamicValueReason.UNKNOWN */);
    }
    isFromDynamicInput() {
        return this.code === 0 /* DynamicValueReason.DYNAMIC_INPUT */;
    }
    isFromDynamicString() {
        return this.code === 1 /* DynamicValueReason.DYNAMIC_STRING */;
    }
    isFromExternalReference() {
        return this.code === 2 /* DynamicValueReason.EXTERNAL_REFERENCE */;
    }
    isFromUnsupportedSyntax() {
        return this.code === 3 /* DynamicValueReason.UNSUPPORTED_SYNTAX */;
    }
    isFromUnknownIdentifier() {
        return this.code === 4 /* DynamicValueReason.UNKNOWN_IDENTIFIER */;
    }
    isFromInvalidExpressionType() {
        return this.code === 5 /* DynamicValueReason.INVALID_EXPRESSION_TYPE */;
    }
    isFromComplexFunctionCall() {
        return this.code === 6 /* DynamicValueReason.COMPLEX_FUNCTION_CALL */;
    }
    isFromDynamicType() {
        return this.code === 7 /* DynamicValueReason.DYNAMIC_TYPE */;
    }
    isFromUnknown() {
        return this.code === 9 /* DynamicValueReason.UNKNOWN */;
    }
    accept(visitor) {
        switch (this.code) {
            case 0 /* DynamicValueReason.DYNAMIC_INPUT */:
                return visitor.visitDynamicInput(this);
            case 1 /* DynamicValueReason.DYNAMIC_STRING */:
                return visitor.visitDynamicString(this);
            case 2 /* DynamicValueReason.EXTERNAL_REFERENCE */:
                return visitor.visitExternalReference(this);
            case 3 /* DynamicValueReason.UNSUPPORTED_SYNTAX */:
                return visitor.visitUnsupportedSyntax(this);
            case 4 /* DynamicValueReason.UNKNOWN_IDENTIFIER */:
                return visitor.visitUnknownIdentifier(this);
            case 5 /* DynamicValueReason.INVALID_EXPRESSION_TYPE */:
                return visitor.visitInvalidExpressionType(this);
            case 6 /* DynamicValueReason.COMPLEX_FUNCTION_CALL */:
                return visitor.visitComplexFunctionCall(this);
            case 7 /* DynamicValueReason.DYNAMIC_TYPE */:
                return visitor.visitDynamicType(this);
            case 8 /* DynamicValueReason.SYNTHETIC_INPUT */:
                return visitor.visitSyntheticInput(this);
            case 9 /* DynamicValueReason.UNKNOWN */:
                return visitor.visitUnknown(this);
        }
    }
}

/**
 * A collection of publicly exported declarations from a module. Each declaration is evaluated
 * lazily upon request.
 */
class ResolvedModule {
    exports;
    evaluate;
    constructor(exports, evaluate) {
        this.exports = exports;
        this.evaluate = evaluate;
    }
    getExport(name) {
        if (!this.exports.has(name)) {
            return undefined;
        }
        return this.evaluate(this.exports.get(name));
    }
    getExports() {
        const map = new Map();
        this.exports.forEach((decl, name) => {
            map.set(name, this.evaluate(decl));
        });
        return map;
    }
}
/**
 * A value member of an enumeration.
 *
 * Contains a `Reference` to the enumeration itself, and the name of the referenced member.
 */
class EnumValue {
    enumRef;
    name;
    resolved;
    constructor(enumRef, name, resolved) {
        this.enumRef = enumRef;
        this.name = name;
        this.resolved = resolved;
    }
}
/**
 * An implementation of a known function that can be statically evaluated.
 * It could be a built-in function or method (such as `Array.prototype.slice`) or a TypeScript
 * helper (such as `__spread`).
 */
class KnownFn {
}

/**
 * Derives a type representation from a resolved value to be reported in a diagnostic.
 *
 * @param value The resolved value for which a type representation should be derived.
 * @param maxDepth The maximum nesting depth of objects and arrays, defaults to 1 level.
 */
function describeResolvedType(value, maxDepth = 1) {
    if (value === null) {
        return 'null';
    }
    else if (value === undefined) {
        return 'undefined';
    }
    else if (typeof value === 'number' || typeof value === 'boolean' || typeof value === 'string') {
        return typeof value;
    }
    else if (value instanceof Map) {
        if (maxDepth === 0) {
            return 'object';
        }
        const entries = Array.from(value.entries()).map(([key, v]) => {
            return `${quoteKey(key)}: ${describeResolvedType(v, maxDepth - 1)}`;
        });
        return entries.length > 0 ? `{ ${entries.join('; ')} }` : '{}';
    }
    else if (value instanceof ResolvedModule) {
        return '(module)';
    }
    else if (value instanceof EnumValue) {
        return value.enumRef.debugName ?? '(anonymous)';
    }
    else if (value instanceof Reference) {
        return value.debugName ?? '(anonymous)';
    }
    else if (Array.isArray(value)) {
        if (maxDepth === 0) {
            return 'Array';
        }
        return `[${value.map((v) => describeResolvedType(v, maxDepth - 1)).join(', ')}]`;
    }
    else if (value instanceof DynamicValue) {
        return '(not statically analyzable)';
    }
    else if (value instanceof KnownFn) {
        return 'Function';
    }
    else {
        return 'unknown';
    }
}
function quoteKey(key) {
    if (/^[a-z0-9_]+$/i.test(key)) {
        return key;
    }
    else {
        return `'${key.replace(/'/g, "\\'")}'`;
    }
}
/**
 * Creates an array of related information diagnostics for a `DynamicValue` that describe the trace
 * of why an expression was evaluated as dynamic.
 *
 * @param node The node for which a `ts.Diagnostic` is to be created with the trace.
 * @param value The dynamic value for which a trace should be created.
 */
function traceDynamicValue(node, value) {
    return value.accept(new TraceDynamicValueVisitor(node));
}
class TraceDynamicValueVisitor {
    node;
    currentContainerNode = null;
    constructor(node) {
        this.node = node;
    }
    visitDynamicInput(value) {
        const trace = value.reason.accept(this);
        if (this.shouldTrace(value.node)) {
            const info = makeRelatedInformation(value.node, 'Unable to evaluate this expression statically.');
            trace.unshift(info);
        }
        return trace;
    }
    visitSyntheticInput(value) {
        return [makeRelatedInformation(value.node, 'Unable to evaluate this expression further.')];
    }
    visitDynamicString(value) {
        return [
            makeRelatedInformation(value.node, 'A string value could not be determined statically.'),
        ];
    }
    visitExternalReference(value) {
        const name = value.reason.debugName;
        const description = name !== null ? `'${name}'` : 'an anonymous declaration';
        return [
            makeRelatedInformation(value.node, `A value for ${description} cannot be determined statically, as it is an external declaration.`),
        ];
    }
    visitComplexFunctionCall(value) {
        return [
            makeRelatedInformation(value.node, 'Unable to evaluate function call of complex function. A function must have exactly one return statement.'),
            makeRelatedInformation(value.reason.node, 'Function is declared here.'),
        ];
    }
    visitInvalidExpressionType(value) {
        return [makeRelatedInformation(value.node, 'Unable to evaluate an invalid expression.')];
    }
    visitUnknown(value) {
        return [makeRelatedInformation(value.node, 'Unable to evaluate statically.')];
    }
    visitUnknownIdentifier(value) {
        return [makeRelatedInformation(value.node, 'Unknown reference.')];
    }
    visitDynamicType(value) {
        return [makeRelatedInformation(value.node, 'Dynamic type.')];
    }
    visitUnsupportedSyntax(value) {
        return [makeRelatedInformation(value.node, 'This syntax is not supported.')];
    }
    /**
     * Determines whether the dynamic value reported for the node should be traced, i.e. if it is not
     * part of the container for which the most recent trace was created.
     */
    shouldTrace(node) {
        if (node === this.node) {
            // Do not include a dynamic value for the origin node, as the main diagnostic is already
            // reported on that node.
            return false;
        }
        const container = getContainerNode(node);
        if (container === this.currentContainerNode) {
            // The node is part of the same container as the previous trace entry, so this dynamic value
            // should not become part of the trace.
            return false;
        }
        this.currentContainerNode = container;
        return true;
    }
}
/**
 * Determines the closest parent node that is to be considered as container, which is used to reduce
 * the granularity of tracing the dynamic values to a single entry per container. Currently, full
 * statements and destructuring patterns are considered as container.
 */
function getContainerNode(node) {
    let currentNode = node;
    while (currentNode !== undefined) {
        switch (currentNode.kind) {
            case ts.SyntaxKind.ExpressionStatement:
            case ts.SyntaxKind.VariableStatement:
            case ts.SyntaxKind.ReturnStatement:
            case ts.SyntaxKind.IfStatement:
            case ts.SyntaxKind.SwitchStatement:
            case ts.SyntaxKind.DoStatement:
            case ts.SyntaxKind.WhileStatement:
            case ts.SyntaxKind.ForStatement:
            case ts.SyntaxKind.ForInStatement:
            case ts.SyntaxKind.ForOfStatement:
            case ts.SyntaxKind.ContinueStatement:
            case ts.SyntaxKind.BreakStatement:
            case ts.SyntaxKind.ThrowStatement:
            case ts.SyntaxKind.ObjectBindingPattern:
            case ts.SyntaxKind.ArrayBindingPattern:
                return currentNode;
        }
        currentNode = currentNode.parent;
    }
    return node.getSourceFile();
}

class ArraySliceBuiltinFn extends KnownFn {
    lhs;
    constructor(lhs) {
        super();
        this.lhs = lhs;
    }
    evaluate(node, args) {
        if (args.length === 0) {
            return this.lhs;
        }
        else {
            return DynamicValue.fromUnknown(node);
        }
    }
}
class ArrayConcatBuiltinFn extends KnownFn {
    lhs;
    constructor(lhs) {
        super();
        this.lhs = lhs;
    }
    evaluate(node, args) {
        const result = [...this.lhs];
        for (const arg of args) {
            if (arg instanceof DynamicValue) {
                result.push(DynamicValue.fromDynamicInput(node, arg));
            }
            else if (Array.isArray(arg)) {
                result.push(...arg);
            }
            else {
                result.push(arg);
            }
        }
        return result;
    }
}
class StringConcatBuiltinFn extends KnownFn {
    lhs;
    constructor(lhs) {
        super();
        this.lhs = lhs;
    }
    evaluate(node, args) {
        let result = this.lhs;
        for (const arg of args) {
            const resolved = arg instanceof EnumValue ? arg.resolved : arg;
            if (typeof resolved === 'string' ||
                typeof resolved === 'number' ||
                typeof resolved === 'boolean' ||
                resolved == null) {
                // Cast to `any`, because `concat` will convert
                // anything to a string, but TS only allows strings.
                result = result.concat(resolved);
            }
            else {
                return DynamicValue.fromUnknown(node);
            }
        }
        return result;
    }
}

/**
 * A value produced which originated in a `ForeignFunctionResolver` and doesn't come from the
 * template itself.
 *
 * Synthetic values cannot be further evaluated, and attempts to do so produce `DynamicValue`s
 * instead.
 */
class SyntheticValue {
    value;
    constructor(value) {
        this.value = value;
    }
}

function literalBinaryOp(op) {
    return { op, literal: true };
}
function referenceBinaryOp(op) {
    return { op, literal: false };
}
class StaticInterpreter {
    host;
    checker;
    dependencyTracker;
    BINARY_OPERATORS = new Map([
        [ts.SyntaxKind.PlusToken, literalBinaryOp((a, b) => a + b)],
        [ts.SyntaxKind.MinusToken, literalBinaryOp((a, b) => a - b)],
        [ts.SyntaxKind.AsteriskToken, literalBinaryOp((a, b) => a * b)],
        [ts.SyntaxKind.SlashToken, literalBinaryOp((a, b) => a / b)],
        [ts.SyntaxKind.PercentToken, literalBinaryOp((a, b) => a % b)],
        [ts.SyntaxKind.AmpersandToken, literalBinaryOp((a, b) => a & b)],
        [ts.SyntaxKind.BarToken, literalBinaryOp((a, b) => a | b)],
        [ts.SyntaxKind.CaretToken, literalBinaryOp((a, b) => a ^ b)],
        [ts.SyntaxKind.LessThanToken, literalBinaryOp((a, b) => a < b)],
        [ts.SyntaxKind.LessThanEqualsToken, literalBinaryOp((a, b) => a <= b)],
        [ts.SyntaxKind.GreaterThanToken, literalBinaryOp((a, b) => a > b)],
        [ts.SyntaxKind.GreaterThanEqualsToken, literalBinaryOp((a, b) => a >= b)],
        [ts.SyntaxKind.EqualsEqualsToken, literalBinaryOp((a, b) => a == b)],
        [ts.SyntaxKind.EqualsEqualsEqualsToken, literalBinaryOp((a, b) => a === b)],
        [ts.SyntaxKind.ExclamationEqualsToken, literalBinaryOp((a, b) => a != b)],
        [ts.SyntaxKind.ExclamationEqualsEqualsToken, literalBinaryOp((a, b) => a !== b)],
        [ts.SyntaxKind.LessThanLessThanToken, literalBinaryOp((a, b) => a << b)],
        [ts.SyntaxKind.GreaterThanGreaterThanToken, literalBinaryOp((a, b) => a >> b)],
        [ts.SyntaxKind.GreaterThanGreaterThanGreaterThanToken, literalBinaryOp((a, b) => a >>> b)],
        [ts.SyntaxKind.AsteriskAsteriskToken, literalBinaryOp((a, b) => Math.pow(a, b))],
        [ts.SyntaxKind.AmpersandAmpersandToken, referenceBinaryOp((a, b) => a && b)],
        [ts.SyntaxKind.BarBarToken, referenceBinaryOp((a, b) => a || b)],
    ]);
    UNARY_OPERATORS = new Map([
        [ts.SyntaxKind.TildeToken, (a) => ~a],
        [ts.SyntaxKind.MinusToken, (a) => -a],
        [ts.SyntaxKind.PlusToken, (a) => +a],
        [ts.SyntaxKind.ExclamationToken, (a) => !a],
    ]);
    constructor(host, checker, dependencyTracker) {
        this.host = host;
        this.checker = checker;
        this.dependencyTracker = dependencyTracker;
    }
    visit(node, context) {
        return this.visitExpression(node, context);
    }
    visitExpression(node, context) {
        let result;
        if (node.kind === ts.SyntaxKind.TrueKeyword) {
            return true;
        }
        else if (node.kind === ts.SyntaxKind.FalseKeyword) {
            return false;
        }
        else if (node.kind === ts.SyntaxKind.NullKeyword) {
            return null;
        }
        else if (ts.isStringLiteral(node)) {
            return node.text;
        }
        else if (ts.isNoSubstitutionTemplateLiteral(node)) {
            return node.text;
        }
        else if (ts.isTemplateExpression(node)) {
            result = this.visitTemplateExpression(node, context);
        }
        else if (ts.isNumericLiteral(node)) {
            return parseFloat(node.text);
        }
        else if (ts.isObjectLiteralExpression(node)) {
            result = this.visitObjectLiteralExpression(node, context);
        }
        else if (ts.isIdentifier(node)) {
            result = this.visitIdentifier(node, context);
        }
        else if (ts.isPropertyAccessExpression(node)) {
            result = this.visitPropertyAccessExpression(node, context);
        }
        else if (ts.isCallExpression(node)) {
            result = this.visitCallExpression(node, context);
        }
        else if (ts.isConditionalExpression(node)) {
            result = this.visitConditionalExpression(node, context);
        }
        else if (ts.isPrefixUnaryExpression(node)) {
            result = this.visitPrefixUnaryExpression(node, context);
        }
        else if (ts.isBinaryExpression(node)) {
            result = this.visitBinaryExpression(node, context);
        }
        else if (ts.isArrayLiteralExpression(node)) {
            result = this.visitArrayLiteralExpression(node, context);
        }
        else if (ts.isParenthesizedExpression(node)) {
            result = this.visitParenthesizedExpression(node, context);
        }
        else if (ts.isElementAccessExpression(node)) {
            result = this.visitElementAccessExpression(node, context);
        }
        else if (ts.isAsExpression(node)) {
            result = this.visitExpression(node.expression, context);
        }
        else if (ts.isNonNullExpression(node)) {
            result = this.visitExpression(node.expression, context);
        }
        else if (this.host.isClass(node)) {
            result = this.visitDeclaration(node, context);
        }
        else {
            return DynamicValue.fromUnsupportedSyntax(node);
        }
        if (result instanceof DynamicValue && result.node !== node) {
            return DynamicValue.fromDynamicInput(node, result);
        }
        return result;
    }
    visitArrayLiteralExpression(node, context) {
        const array = [];
        for (let i = 0; i < node.elements.length; i++) {
            const element = node.elements[i];
            if (ts.isSpreadElement(element)) {
                array.push(...this.visitSpreadElement(element, context));
            }
            else {
                array.push(this.visitExpression(element, context));
            }
        }
        return array;
    }
    visitObjectLiteralExpression(node, context) {
        const map = new Map();
        for (let i = 0; i < node.properties.length; i++) {
            const property = node.properties[i];
            if (ts.isPropertyAssignment(property)) {
                const name = this.stringNameFromPropertyName(property.name, context);
                // Check whether the name can be determined statically.
                if (name === undefined) {
                    return DynamicValue.fromDynamicInput(node, DynamicValue.fromDynamicString(property.name));
                }
                map.set(name, this.visitExpression(property.initializer, context));
            }
            else if (ts.isShorthandPropertyAssignment(property)) {
                const symbol = this.checker.getShorthandAssignmentValueSymbol(property);
                if (symbol === undefined || symbol.valueDeclaration === undefined) {
                    map.set(property.name.text, DynamicValue.fromUnknown(property));
                }
                else {
                    map.set(property.name.text, this.visitDeclaration(symbol.valueDeclaration, context));
                }
            }
            else if (ts.isSpreadAssignment(property)) {
                const spread = this.visitExpression(property.expression, context);
                if (spread instanceof DynamicValue) {
                    return DynamicValue.fromDynamicInput(node, spread);
                }
                else if (spread instanceof Map) {
                    spread.forEach((value, key) => map.set(key, value));
                }
                else if (spread instanceof ResolvedModule) {
                    spread.getExports().forEach((value, key) => map.set(key, value));
                }
                else {
                    return DynamicValue.fromDynamicInput(node, DynamicValue.fromInvalidExpressionType(property, spread));
                }
            }
            else {
                return DynamicValue.fromUnknown(node);
            }
        }
        return map;
    }
    visitTemplateExpression(node, context) {
        const pieces = [node.head.text];
        for (let i = 0; i < node.templateSpans.length; i++) {
            const span = node.templateSpans[i];
            const value = literal(this.visit(span.expression, context), () => DynamicValue.fromDynamicString(span.expression));
            if (value instanceof DynamicValue) {
                return DynamicValue.fromDynamicInput(node, value);
            }
            pieces.push(`${value}`, span.literal.text);
        }
        return pieces.join('');
    }
    visitIdentifier(node, context) {
        const decl = this.host.getDeclarationOfIdentifier(node);
        if (decl === null) {
            if (ts.identifierToKeywordKind(node) === ts.SyntaxKind.UndefinedKeyword) {
                return undefined;
            }
            else {
                // Check if the symbol here is imported.
                if (this.dependencyTracker !== null && this.host.getImportOfIdentifier(node) !== null) {
                    // It was, but no declaration for the node could be found. This means that the dependency
                    // graph for the current file cannot be properly updated to account for this (broken)
                    // import. Instead, the originating file is reported as failing dependency analysis,
                    // ensuring that future compilations will always attempt to re-resolve the previously
                    // broken identifier.
                    this.dependencyTracker.recordDependencyAnalysisFailure(context.originatingFile);
                }
                return DynamicValue.fromUnknownIdentifier(node);
            }
        }
        const declContext = { ...context, ...joinModuleContext(context, node, decl) };
        const result = this.visitDeclaration(decl.node, declContext);
        if (result instanceof Reference) {
            // Only record identifiers to non-synthetic references. Synthetic references may not have the
            // same value at runtime as they do at compile time, so it's not legal to refer to them by the
            // identifier here.
            if (!result.synthetic) {
                result.addIdentifier(node);
            }
        }
        else if (result instanceof DynamicValue) {
            return DynamicValue.fromDynamicInput(node, result);
        }
        return result;
    }
    visitDeclaration(node, context) {
        if (this.dependencyTracker !== null) {
            this.dependencyTracker.addDependency(context.originatingFile, node.getSourceFile());
        }
        if (this.host.isClass(node)) {
            return this.getReference(node, context);
        }
        else if (ts.isVariableDeclaration(node)) {
            return this.visitVariableDeclaration(node, context);
        }
        else if (ts.isParameter(node) && context.scope.has(node)) {
            return context.scope.get(node);
        }
        else if (ts.isExportAssignment(node)) {
            return this.visitExpression(node.expression, context);
        }
        else if (ts.isEnumDeclaration(node)) {
            return this.visitEnumDeclaration(node, context);
        }
        else if (ts.isSourceFile(node)) {
            return this.visitSourceFile(node, context);
        }
        else if (ts.isBindingElement(node)) {
            return this.visitBindingElement(node, context);
        }
        else {
            return this.getReference(node, context);
        }
    }
    visitVariableDeclaration(node, context) {
        const value = this.host.getVariableValue(node);
        if (value !== null) {
            return this.visitExpression(value, context);
        }
        else if (isVariableDeclarationDeclared(node)) {
            // If the declaration has a literal type that can be statically reduced to a value, resolve to
            // that value. If not, the historical behavior for variable declarations is to return a
            // `Reference` to the variable, as the consumer could use it in a context where knowing its
            // static value is not necessary.
            //
            // Arguably, since the value cannot be statically determined, we should return a
            // `DynamicValue`. This returns a `Reference` because it's the same behavior as before
            // `visitType` was introduced.
            //
            // TODO(zarend): investigate switching to a `DynamicValue` and verify this won't break any
            // use cases, especially in ngcc
            if (node.type !== undefined) {
                const evaluatedType = this.visitType(node.type, context);
                if (!(evaluatedType instanceof DynamicValue)) {
                    return evaluatedType;
                }
            }
            return this.getReference(node, context);
        }
        else {
            return undefined;
        }
    }
    visitEnumDeclaration(node, context) {
        const enumRef = this.getReference(node, context);
        const map = new Map();
        node.members.forEach((member, index) => {
            const name = this.stringNameFromPropertyName(member.name, context);
            if (name !== undefined) {
                const resolved = member.initializer ? this.visit(member.initializer, context) : index;
                map.set(name, new EnumValue(enumRef, name, resolved));
            }
        });
        return map;
    }
    visitElementAccessExpression(node, context) {
        const lhs = this.visitExpression(node.expression, context);
        if (lhs instanceof DynamicValue) {
            return DynamicValue.fromDynamicInput(node, lhs);
        }
        const rhs = this.visitExpression(node.argumentExpression, context);
        if (rhs instanceof DynamicValue) {
            return DynamicValue.fromDynamicInput(node, rhs);
        }
        if (typeof rhs !== 'string' && typeof rhs !== 'number') {
            return DynamicValue.fromInvalidExpressionType(node, rhs);
        }
        return this.accessHelper(node, lhs, rhs, context);
    }
    visitPropertyAccessExpression(node, context) {
        const lhs = this.visitExpression(node.expression, context);
        const rhs = node.name.text;
        // TODO: handle reference to class declaration.
        if (lhs instanceof DynamicValue) {
            return DynamicValue.fromDynamicInput(node, lhs);
        }
        return this.accessHelper(node, lhs, rhs, context);
    }
    visitSourceFile(node, context) {
        const declarations = this.host.getExportsOfModule(node);
        if (declarations === null) {
            return DynamicValue.fromUnknown(node);
        }
        return new ResolvedModule(declarations, (decl) => {
            const declContext = {
                ...context,
                ...joinModuleContext(context, node, decl),
            };
            // Visit both concrete and inline declarations.
            return this.visitDeclaration(decl.node, declContext);
        });
    }
    accessHelper(node, lhs, rhs, context) {
        const strIndex = `${rhs}`;
        if (lhs instanceof Map) {
            if (lhs.has(strIndex)) {
                return lhs.get(strIndex);
            }
            else {
                return undefined;
            }
        }
        else if (lhs instanceof ResolvedModule) {
            return lhs.getExport(strIndex);
        }
        else if (Array.isArray(lhs)) {
            if (rhs === 'length') {
                return lhs.length;
            }
            else if (rhs === 'slice') {
                return new ArraySliceBuiltinFn(lhs);
            }
            else if (rhs === 'concat') {
                return new ArrayConcatBuiltinFn(lhs);
            }
            if (typeof rhs !== 'number' || !Number.isInteger(rhs)) {
                return DynamicValue.fromInvalidExpressionType(node, rhs);
            }
            return lhs[rhs];
        }
        else if (typeof lhs === 'string' && rhs === 'concat') {
            return new StringConcatBuiltinFn(lhs);
        }
        else if (lhs instanceof Reference) {
            const ref = lhs.node;
            if (this.host.isClass(ref)) {
                const module = owningModule(context, lhs.bestGuessOwningModule);
                let value = undefined;
                const member = this.host
                    .getMembersOfClass(ref)
                    .find((member) => member.isStatic && member.name === strIndex);
                if (member !== undefined) {
                    if (member.value !== null) {
                        value = this.visitExpression(member.value, context);
                    }
                    else if (member.implementation !== null) {
                        value = new Reference(member.implementation, module);
                    }
                    else if (member.node) {
                        value = new Reference(member.node, module);
                    }
                }
                return value;
            }
            else if (isDeclaration(ref)) {
                return DynamicValue.fromDynamicInput(node, DynamicValue.fromExternalReference(ref, lhs));
            }
        }
        else if (lhs instanceof DynamicValue) {
            return DynamicValue.fromDynamicInput(node, lhs);
        }
        else if (lhs instanceof SyntheticValue) {
            return DynamicValue.fromSyntheticInput(node, lhs);
        }
        return DynamicValue.fromUnknown(node);
    }
    visitCallExpression(node, context) {
        const lhs = this.visitExpression(node.expression, context);
        if (lhs instanceof DynamicValue) {
            return DynamicValue.fromDynamicInput(node, lhs);
        }
        // If the call refers to a builtin function, attempt to evaluate the function.
        if (lhs instanceof KnownFn) {
            return lhs.evaluate(node, this.evaluateFunctionArguments(node, context));
        }
        if (!(lhs instanceof Reference)) {
            return DynamicValue.fromInvalidExpressionType(node.expression, lhs);
        }
        const fn = this.host.getDefinitionOfFunction(lhs.node);
        if (fn === null) {
            return DynamicValue.fromInvalidExpressionType(node.expression, lhs);
        }
        if (!isFunctionOrMethodReference(lhs)) {
            return DynamicValue.fromInvalidExpressionType(node.expression, lhs);
        }
        const resolveFfrExpr = (expr) => {
            let contextExtension = {};
            // TODO(alxhub): the condition `fn.body === null` here is vestigial - we probably _do_ want to
            // change the context like this even for non-null function bodies. But, this is being
            // redesigned as a refactoring with no behavior changes so that should be done as a follow-up.
            if (fn.body === null &&
                expr.getSourceFile() !== node.expression.getSourceFile() &&
                lhs.bestGuessOwningModule !== null) {
                contextExtension = {
                    absoluteModuleName: lhs.bestGuessOwningModule.specifier,
                    resolutionContext: lhs.bestGuessOwningModule.resolutionContext,
                };
            }
            return this.visitFfrExpression(expr, { ...context, ...contextExtension });
        };
        // If the function is foreign (declared through a d.ts file), attempt to resolve it with the
        // foreignFunctionResolver, if one is specified.
        if (fn.body === null && context.foreignFunctionResolver !== undefined) {
            const unresolvable = DynamicValue.fromDynamicInput(node, DynamicValue.fromExternalReference(node.expression, lhs));
            return context.foreignFunctionResolver(lhs, node, resolveFfrExpr, unresolvable);
        }
        const res = this.visitFunctionBody(node, fn, context);
        // If the result of attempting to resolve the function body was a DynamicValue, attempt to use
        // the foreignFunctionResolver if one is present. This could still potentially yield a usable
        // value.
        if (res instanceof DynamicValue && context.foreignFunctionResolver !== undefined) {
            const unresolvable = DynamicValue.fromComplexFunctionCall(node, fn);
            return context.foreignFunctionResolver(lhs, node, resolveFfrExpr, unresolvable);
        }
        return res;
    }
    /**
     * Visit an expression which was extracted from a foreign-function resolver.
     *
     * This will process the result and ensure it's correct for FFR-resolved values, including marking
     * `Reference`s as synthetic.
     */
    visitFfrExpression(expr, context) {
        const res = this.visitExpression(expr, context);
        if (res instanceof Reference) {
            // This Reference was created synthetically, via a foreign function resolver. The real
            // runtime value of the function expression may be different than the foreign function
            // resolved value, so mark the Reference as synthetic to avoid it being misinterpreted.
            res.synthetic = true;
        }
        return res;
    }
    visitFunctionBody(node, fn, context) {
        if (fn.body === null) {
            return DynamicValue.fromUnknown(node);
        }
        else if (fn.body.length !== 1 || !ts.isReturnStatement(fn.body[0])) {
            return DynamicValue.fromComplexFunctionCall(node, fn);
        }
        const ret = fn.body[0];
        const args = this.evaluateFunctionArguments(node, context);
        const newScope = new Map();
        const calleeContext = { ...context, scope: newScope };
        fn.parameters.forEach((param, index) => {
            let arg = args[index];
            if (param.node.dotDotDotToken !== undefined) {
                arg = args.slice(index);
            }
            if (arg === undefined && param.initializer !== null) {
                arg = this.visitExpression(param.initializer, calleeContext);
            }
            newScope.set(param.node, arg);
        });
        return ret.expression !== undefined
            ? this.visitExpression(ret.expression, calleeContext)
            : undefined;
    }
    visitConditionalExpression(node, context) {
        const condition = this.visitExpression(node.condition, context);
        if (condition instanceof DynamicValue) {
            return DynamicValue.fromDynamicInput(node, condition);
        }
        if (condition) {
            return this.visitExpression(node.whenTrue, context);
        }
        else {
            return this.visitExpression(node.whenFalse, context);
        }
    }
    visitPrefixUnaryExpression(node, context) {
        const operatorKind = node.operator;
        if (!this.UNARY_OPERATORS.has(operatorKind)) {
            return DynamicValue.fromUnsupportedSyntax(node);
        }
        const op = this.UNARY_OPERATORS.get(operatorKind);
        const value = this.visitExpression(node.operand, context);
        if (value instanceof DynamicValue) {
            return DynamicValue.fromDynamicInput(node, value);
        }
        else {
            return op(value);
        }
    }
    visitBinaryExpression(node, context) {
        const tokenKind = node.operatorToken.kind;
        if (!this.BINARY_OPERATORS.has(tokenKind)) {
            return DynamicValue.fromUnsupportedSyntax(node);
        }
        const opRecord = this.BINARY_OPERATORS.get(tokenKind);
        let lhs, rhs;
        if (opRecord.literal) {
            lhs = literal(this.visitExpression(node.left, context), (value) => DynamicValue.fromInvalidExpressionType(node.left, value));
            rhs = literal(this.visitExpression(node.right, context), (value) => DynamicValue.fromInvalidExpressionType(node.right, value));
        }
        else {
            lhs = this.visitExpression(node.left, context);
            rhs = this.visitExpression(node.right, context);
        }
        if (lhs instanceof DynamicValue) {
            return DynamicValue.fromDynamicInput(node, lhs);
        }
        else if (rhs instanceof DynamicValue) {
            return DynamicValue.fromDynamicInput(node, rhs);
        }
        else {
            return opRecord.op(lhs, rhs);
        }
    }
    visitParenthesizedExpression(node, context) {
        return this.visitExpression(node.expression, context);
    }
    evaluateFunctionArguments(node, context) {
        const args = [];
        for (const arg of node.arguments) {
            if (ts.isSpreadElement(arg)) {
                args.push(...this.visitSpreadElement(arg, context));
            }
            else {
                args.push(this.visitExpression(arg, context));
            }
        }
        return args;
    }
    visitSpreadElement(node, context) {
        const spread = this.visitExpression(node.expression, context);
        if (spread instanceof DynamicValue) {
            return [DynamicValue.fromDynamicInput(node, spread)];
        }
        else if (!Array.isArray(spread)) {
            return [DynamicValue.fromInvalidExpressionType(node, spread)];
        }
        else {
            return spread;
        }
    }
    visitBindingElement(node, context) {
        const path = [];
        let closestDeclaration = node;
        while (ts.isBindingElement(closestDeclaration) ||
            ts.isArrayBindingPattern(closestDeclaration) ||
            ts.isObjectBindingPattern(closestDeclaration)) {
            if (ts.isBindingElement(closestDeclaration)) {
                path.unshift(closestDeclaration);
            }
            closestDeclaration = closestDeclaration.parent;
        }
        if (!ts.isVariableDeclaration(closestDeclaration) ||
            closestDeclaration.initializer === undefined) {
            return DynamicValue.fromUnknown(node);
        }
        let value = this.visit(closestDeclaration.initializer, context);
        for (const element of path) {
            let key;
            if (ts.isArrayBindingPattern(element.parent)) {
                key = element.parent.elements.indexOf(element);
            }
            else {
                const name = element.propertyName || element.name;
                if (ts.isIdentifier(name)) {
                    key = name.text;
                }
                else {
                    return DynamicValue.fromUnknown(element);
                }
            }
            value = this.accessHelper(element, value, key, context);
            if (value instanceof DynamicValue) {
                return value;
            }
        }
        return value;
    }
    stringNameFromPropertyName(node, context) {
        if (ts.isIdentifier(node) || ts.isStringLiteral(node) || ts.isNumericLiteral(node)) {
            return node.text;
        }
        else if (ts.isComputedPropertyName(node)) {
            const literal = this.visitExpression(node.expression, context);
            return typeof literal === 'string' ? literal : undefined;
        }
        else {
            return undefined;
        }
    }
    getReference(node, context) {
        return new Reference(node, owningModule(context));
    }
    visitType(node, context) {
        if (ts.isLiteralTypeNode(node)) {
            return this.visitExpression(node.literal, context);
        }
        else if (ts.isTupleTypeNode(node)) {
            return this.visitTupleType(node, context);
        }
        else if (ts.isNamedTupleMember(node)) {
            return this.visitType(node.type, context);
        }
        else if (ts.isTypeOperatorNode(node) && node.operator === ts.SyntaxKind.ReadonlyKeyword) {
            return this.visitType(node.type, context);
        }
        else if (ts.isTypeQueryNode(node)) {
            return this.visitTypeQuery(node, context);
        }
        return DynamicValue.fromDynamicType(node);
    }
    visitTupleType(node, context) {
        const res = [];
        for (const elem of node.elements) {
            res.push(this.visitType(elem, context));
        }
        return res;
    }
    visitTypeQuery(node, context) {
        if (!ts.isIdentifier(node.exprName)) {
            return DynamicValue.fromUnknown(node);
        }
        const decl = this.host.getDeclarationOfIdentifier(node.exprName);
        if (decl === null) {
            return DynamicValue.fromUnknownIdentifier(node.exprName);
        }
        const declContext = { ...context, ...joinModuleContext(context, node, decl) };
        return this.visitDeclaration(decl.node, declContext);
    }
}
function isFunctionOrMethodReference(ref) {
    return (ts.isFunctionDeclaration(ref.node) ||
        ts.isMethodDeclaration(ref.node) ||
        ts.isFunctionExpression(ref.node));
}
function literal(value, reject) {
    if (value instanceof EnumValue) {
        value = value.resolved;
    }
    if (value instanceof DynamicValue ||
        value === null ||
        value === undefined ||
        typeof value === 'string' ||
        typeof value === 'number' ||
        typeof value === 'boolean') {
        return value;
    }
    return reject(value);
}
function isVariableDeclarationDeclared(node) {
    if (node.parent === undefined || !ts.isVariableDeclarationList(node.parent)) {
        return false;
    }
    const declList = node.parent;
    if (declList.parent === undefined || !ts.isVariableStatement(declList.parent)) {
        return false;
    }
    const varStmt = declList.parent;
    const modifiers = ts.getModifiers(varStmt);
    return (modifiers !== undefined && modifiers.some((mod) => mod.kind === ts.SyntaxKind.DeclareKeyword));
}
const EMPTY = {};
function joinModuleContext(existing, node, decl) {
    if (typeof decl.viaModule === 'string' && decl.viaModule !== existing.absoluteModuleName) {
        return {
            absoluteModuleName: decl.viaModule,
            resolutionContext: node.getSourceFile().fileName,
        };
    }
    else {
        return EMPTY;
    }
}
function owningModule(context, override = null) {
    let specifier = context.absoluteModuleName;
    if (override !== null) {
        specifier = override.specifier;
    }
    if (specifier !== null) {
        return {
            specifier,
            resolutionContext: context.resolutionContext,
        };
    }
    else {
        return null;
    }
}

class PartialEvaluator {
    host;
    checker;
    dependencyTracker;
    constructor(host, checker, dependencyTracker) {
        this.host = host;
        this.checker = checker;
        this.dependencyTracker = dependencyTracker;
    }
    evaluate(expr, foreignFunctionResolver) {
        const interpreter = new StaticInterpreter(this.host, this.checker, this.dependencyTracker);
        const sourceFile = expr.getSourceFile();
        return interpreter.visit(expr, {
            originatingFile: sourceFile,
            absoluteModuleName: null,
            resolutionContext: sourceFile.fileName,
            scope: new Map(),
            foreignFunctionResolver,
        });
    }
}

/**
 * Specifies the compilation mode that is used for the compilation.
 */
exports.CompilationMode = void 0;
(function (CompilationMode) {
    /**
     * Generates fully AOT compiled code using Ivy instructions.
     */
    CompilationMode[CompilationMode["FULL"] = 0] = "FULL";
    /**
     * Generates code using a stable, but intermediate format suitable to be published to NPM.
     */
    CompilationMode[CompilationMode["PARTIAL"] = 1] = "PARTIAL";
    /**
     * Generates code based on each individual source file without using its
     * dependencies (suitable for local dev edit/refresh workflow).
     */
    CompilationMode[CompilationMode["LOCAL"] = 2] = "LOCAL";
})(exports.CompilationMode || (exports.CompilationMode = {}));
var HandlerPrecedence;
(function (HandlerPrecedence) {
    /**
     * Handler with PRIMARY precedence cannot overlap - there can only be one on a given class.
     *
     * If more than one PRIMARY handler matches a class, an error is produced.
     */
    HandlerPrecedence[HandlerPrecedence["PRIMARY"] = 0] = "PRIMARY";
    /**
     * Handlers with SHARED precedence can match any class, possibly in addition to a single PRIMARY
     * handler.
     *
     * It is not an error for a class to have any number of SHARED handlers.
     */
    HandlerPrecedence[HandlerPrecedence["SHARED"] = 1] = "SHARED";
    /**
     * Handlers with WEAK precedence that match a class are ignored if any handlers with stronger
     * precedence match a class.
     */
    HandlerPrecedence[HandlerPrecedence["WEAK"] = 2] = "WEAK";
})(HandlerPrecedence || (HandlerPrecedence = {}));

function aliasTransformFactory(exportStatements) {
    return () => {
        return (file) => {
            if (ts.isBundle(file) || !exportStatements.has(file.fileName)) {
                return file;
            }
            const statements = [...file.statements];
            exportStatements.get(file.fileName).forEach(([moduleName, symbolName], aliasName) => {
                const stmt = ts.factory.createExportDeclaration(
                /* modifiers */ undefined, 
                /* isTypeOnly */ false, 
                /* exportClause */ ts.factory.createNamedExports([
                    ts.factory.createExportSpecifier(false, symbolName, aliasName),
                ]), 
                /* moduleSpecifier */ ts.factory.createStringLiteral(moduleName));
                statements.push(stmt);
            });
            return ts.factory.updateSourceFile(file, statements);
        };
    };
}

/**
 * A phase of compilation for which time is tracked in a distinct bucket.
 */
exports.PerfPhase = void 0;
(function (PerfPhase) {
    /**
     * The "default" phase which tracks time not spent in any other phase.
     */
    PerfPhase[PerfPhase["Unaccounted"] = 0] = "Unaccounted";
    /**
     * Time spent setting up the compiler, before a TypeScript program is created.
     *
     * This includes operations like configuring the `ts.CompilerHost` and any wrappers.
     */
    PerfPhase[PerfPhase["Setup"] = 1] = "Setup";
    /**
     * Time spent in `ts.createProgram`, including reading and parsing `ts.SourceFile`s in the
     * `ts.CompilerHost`.
     *
     * This might be an incremental program creation operation.
     */
    PerfPhase[PerfPhase["TypeScriptProgramCreate"] = 2] = "TypeScriptProgramCreate";
    /**
     * Time spent reconciling the contents of an old `ts.Program` with the new incremental one.
     *
     * Only present in incremental compilations.
     */
    PerfPhase[PerfPhase["Reconciliation"] = 3] = "Reconciliation";
    /**
     * Time spent updating an `NgCompiler` instance with a resource-only change.
     *
     * Only present in incremental compilations where the change was resource-only.
     */
    PerfPhase[PerfPhase["ResourceUpdate"] = 4] = "ResourceUpdate";
    /**
     * Time spent calculating the plain TypeScript diagnostics (structural and semantic).
     */
    PerfPhase[PerfPhase["TypeScriptDiagnostics"] = 5] = "TypeScriptDiagnostics";
    /**
     * Time spent in Angular analysis of individual classes in the program.
     */
    PerfPhase[PerfPhase["Analysis"] = 6] = "Analysis";
    /**
     * Time spent in Angular global analysis (synthesis of analysis information into a complete
     * understanding of the program).
     */
    PerfPhase[PerfPhase["Resolve"] = 7] = "Resolve";
    /**
     * Time spent building the import graph of the program in order to perform cycle detection.
     */
    PerfPhase[PerfPhase["CycleDetection"] = 8] = "CycleDetection";
    /**
     * Time spent generating the text of Type Check Blocks in order to perform template type checking.
     */
    PerfPhase[PerfPhase["TcbGeneration"] = 9] = "TcbGeneration";
    /**
     * Time spent updating the `ts.Program` with new Type Check Block code.
     */
    PerfPhase[PerfPhase["TcbUpdateProgram"] = 10] = "TcbUpdateProgram";
    /**
     * Time spent by TypeScript performing its emit operations, including downleveling and writing
     * output files.
     */
    PerfPhase[PerfPhase["TypeScriptEmit"] = 11] = "TypeScriptEmit";
    /**
     * Time spent by Angular performing code transformations of ASTs as they're about to be emitted.
     *
     * This includes the actual code generation step for templates, and occurs during the emit phase
     * (but is tracked separately from `TypeScriptEmit` time).
     */
    PerfPhase[PerfPhase["Compile"] = 12] = "Compile";
    /**
     * Time spent performing a `TemplateTypeChecker` autocompletion operation.
     */
    PerfPhase[PerfPhase["TtcAutocompletion"] = 13] = "TtcAutocompletion";
    /**
     * Time spent computing template type-checking diagnostics.
     */
    PerfPhase[PerfPhase["TtcDiagnostics"] = 14] = "TtcDiagnostics";
    /**
     * Time spent computing template type-checking suggestion diagnostics.
     */
    PerfPhase[PerfPhase["TtcSuggestionDiagnostics"] = 15] = "TtcSuggestionDiagnostics";
    /**
     * Time spent getting a `Symbol` from the `TemplateTypeChecker`.
     */
    PerfPhase[PerfPhase["TtcSymbol"] = 16] = "TtcSymbol";
    /**
     * Time spent by the Angular Language Service calculating a "get references" or a renaming
     * operation.
     */
    PerfPhase[PerfPhase["LsReferencesAndRenames"] = 17] = "LsReferencesAndRenames";
    /**
     * Time spent by the Angular Language Service calculating a "quick info" operation.
     */
    PerfPhase[PerfPhase["LsQuickInfo"] = 18] = "LsQuickInfo";
    /**
     * Time spent by the Angular Language Service calculating a "get type definition" or "get
     * definition" operation.
     */
    PerfPhase[PerfPhase["LsDefinition"] = 19] = "LsDefinition";
    /**
     * Time spent by the Angular Language Service calculating a "get completions" (AKA autocomplete)
     * operation.
     */
    PerfPhase[PerfPhase["LsCompletions"] = 20] = "LsCompletions";
    /**
     * Time spent by the Angular Language Service calculating a "view template typecheck block"
     * operation.
     */
    PerfPhase[PerfPhase["LsTcb"] = 21] = "LsTcb";
    /**
     * Time spent by the Angular Language Service calculating diagnostics.
     */
    PerfPhase[PerfPhase["LsDiagnostics"] = 22] = "LsDiagnostics";
    /**
     * Time spent by the Angular Language Service calculating suggestion diagnostics.
     */
    PerfPhase[PerfPhase["LsSuggestionDiagnostics"] = 23] = "LsSuggestionDiagnostics";
    /**
     * Time spent by the Angular Language Service calculating a "get component locations for template"
     * operation.
     */
    PerfPhase[PerfPhase["LsComponentLocations"] = 24] = "LsComponentLocations";
    /**
     * Time spent by the Angular Language Service calculating signature help.
     */
    PerfPhase[PerfPhase["LsSignatureHelp"] = 25] = "LsSignatureHelp";
    /**
     * Time spent by the Angular Language Service calculating outlining spans.
     */
    PerfPhase[PerfPhase["OutliningSpans"] = 26] = "OutliningSpans";
    /**
     * Time spent by the Angular Language Service calculating code fixes.
     */
    PerfPhase[PerfPhase["LsCodeFixes"] = 27] = "LsCodeFixes";
    /**
     * Time spent by the Angular Language Service to fix all detected same type errors.
     */
    PerfPhase[PerfPhase["LsCodeFixesAll"] = 28] = "LsCodeFixesAll";
    /**
     * Time spent computing possible Angular refactorings.
     */
    PerfPhase[PerfPhase["LSComputeApplicableRefactorings"] = 29] = "LSComputeApplicableRefactorings";
    /**
     * Time spent computing changes for applying a given refactoring.
     */
    PerfPhase[PerfPhase["LSApplyRefactoring"] = 30] = "LSApplyRefactoring";
    /**
     * Time spent by the Angular Language Service calculating semantic classifications.
     */
    PerfPhase[PerfPhase["LSSemanticClassification"] = 31] = "LSSemanticClassification";
    /**
     * Tracks the number of `PerfPhase`s, and must appear at the end of the list.
     */
    PerfPhase[PerfPhase["LAST"] = 32] = "LAST";
})(exports.PerfPhase || (exports.PerfPhase = {}));
/**
 * Represents some occurrence during compilation, and is tracked with a counter.
 */
exports.PerfEvent = void 0;
(function (PerfEvent) {
    /**
     * Counts the number of `.d.ts` files in the program.
     */
    PerfEvent[PerfEvent["InputDtsFile"] = 0] = "InputDtsFile";
    /**
     * Counts the number of non-`.d.ts` files in the program.
     */
    PerfEvent[PerfEvent["InputTsFile"] = 1] = "InputTsFile";
    /**
     * An `@Component` class was analyzed.
     */
    PerfEvent[PerfEvent["AnalyzeComponent"] = 2] = "AnalyzeComponent";
    /**
     * An `@Directive` class was analyzed.
     */
    PerfEvent[PerfEvent["AnalyzeDirective"] = 3] = "AnalyzeDirective";
    /**
     * An `@Injectable` class was analyzed.
     */
    PerfEvent[PerfEvent["AnalyzeInjectable"] = 4] = "AnalyzeInjectable";
    /**
     * An `@NgModule` class was analyzed.
     */
    PerfEvent[PerfEvent["AnalyzeNgModule"] = 5] = "AnalyzeNgModule";
    /**
     * An `@Pipe` class was analyzed.
     */
    PerfEvent[PerfEvent["AnalyzePipe"] = 6] = "AnalyzePipe";
    /**
     * A trait was analyzed.
     *
     * In theory, this should be the sum of the `Analyze` counters for each decorator type.
     */
    PerfEvent[PerfEvent["TraitAnalyze"] = 7] = "TraitAnalyze";
    /**
     * A trait had a prior analysis available from an incremental program, and did not need to be
     * re-analyzed.
     */
    PerfEvent[PerfEvent["TraitReuseAnalysis"] = 8] = "TraitReuseAnalysis";
    /**
     * A `ts.SourceFile` directly changed between the prior program and a new incremental compilation.
     */
    PerfEvent[PerfEvent["SourceFilePhysicalChange"] = 9] = "SourceFilePhysicalChange";
    /**
     * A `ts.SourceFile` did not physically changed, but according to the file dependency graph, has
     * logically changed between the prior program and a new incremental compilation.
     */
    PerfEvent[PerfEvent["SourceFileLogicalChange"] = 10] = "SourceFileLogicalChange";
    /**
     * A `ts.SourceFile` has not logically changed and all of its analysis results were thus available
     * for reuse.
     */
    PerfEvent[PerfEvent["SourceFileReuseAnalysis"] = 11] = "SourceFileReuseAnalysis";
    /**
     * A Type Check Block (TCB) was generated.
     */
    PerfEvent[PerfEvent["GenerateTcb"] = 12] = "GenerateTcb";
    /**
     * A Type Check Block (TCB) could not be generated because inlining was disabled, and the block
     * would've required inlining.
     */
    PerfEvent[PerfEvent["SkipGenerateTcbNoInline"] = 13] = "SkipGenerateTcbNoInline";
    /**
     * A `.ngtypecheck.ts` file could be reused from the previous program and did not need to be
     * regenerated.
     */
    PerfEvent[PerfEvent["ReuseTypeCheckFile"] = 14] = "ReuseTypeCheckFile";
    /**
     * The template type-checking program required changes and had to be updated in an incremental
     * step.
     */
    PerfEvent[PerfEvent["UpdateTypeCheckProgram"] = 15] = "UpdateTypeCheckProgram";
    /**
     * The compiler was able to prove that a `ts.SourceFile` did not need to be re-emitted.
     */
    PerfEvent[PerfEvent["EmitSkipSourceFile"] = 16] = "EmitSkipSourceFile";
    /**
     * A `ts.SourceFile` was emitted.
     */
    PerfEvent[PerfEvent["EmitSourceFile"] = 17] = "EmitSourceFile";
    /**
     * Tracks the number of `PrefEvent`s, and must appear at the end of the list.
     */
    PerfEvent[PerfEvent["LAST"] = 18] = "LAST";
})(exports.PerfEvent || (exports.PerfEvent = {}));
/**
 * Represents a checkpoint during compilation at which the memory usage of the compiler should be
 * recorded.
 */
exports.PerfCheckpoint = void 0;
(function (PerfCheckpoint) {
    /**
     * The point at which the `PerfRecorder` was created, and ideally tracks memory used before any
     * compilation structures are created.
     */
    PerfCheckpoint[PerfCheckpoint["Initial"] = 0] = "Initial";
    /**
     * The point just after the `ts.Program` has been created.
     */
    PerfCheckpoint[PerfCheckpoint["TypeScriptProgramCreate"] = 1] = "TypeScriptProgramCreate";
    /**
     * The point just before Angular analysis starts.
     *
     * In the main usage pattern for the compiler, TypeScript diagnostics have been calculated at this
     * point, so the `ts.TypeChecker` has fully ingested the current program, all `ts.Type` structures
     * and `ts.Symbol`s have been created.
     */
    PerfCheckpoint[PerfCheckpoint["PreAnalysis"] = 2] = "PreAnalysis";
    /**
     * The point just after Angular analysis completes.
     */
    PerfCheckpoint[PerfCheckpoint["Analysis"] = 3] = "Analysis";
    /**
     * The point just after Angular resolution is complete.
     */
    PerfCheckpoint[PerfCheckpoint["Resolve"] = 4] = "Resolve";
    /**
     * The point just after Type Check Blocks (TCBs) have been generated.
     */
    PerfCheckpoint[PerfCheckpoint["TtcGeneration"] = 5] = "TtcGeneration";
    /**
     * The point just after the template type-checking program has been updated with any new TCBs.
     */
    PerfCheckpoint[PerfCheckpoint["TtcUpdateProgram"] = 6] = "TtcUpdateProgram";
    /**
     * The point just before emit begins.
     *
     * In the main usage pattern for the compiler, all template type-checking diagnostics have been
     * requested at this point.
     */
    PerfCheckpoint[PerfCheckpoint["PreEmit"] = 7] = "PreEmit";
    /**
     * The point just after the program has been fully emitted.
     */
    PerfCheckpoint[PerfCheckpoint["Emit"] = 8] = "Emit";
    /**
     * Tracks the number of `PerfCheckpoint`s, and must appear at the end of the list.
     */
    PerfCheckpoint[PerfCheckpoint["LAST"] = 9] = "LAST";
})(exports.PerfCheckpoint || (exports.PerfCheckpoint = {}));

/// <reference types="node" />
function mark() {
    return process.hrtime();
}
function timeSinceInMicros(mark) {
    const delta = process.hrtime(mark);
    return delta[0] * 1000000 + Math.floor(delta[1] / 1000);
}

/// <reference types="node" />
/**
 * A `PerfRecorder` that actively tracks performance statistics.
 */
class ActivePerfRecorder {
    zeroTime;
    counters;
    phaseTime;
    bytes;
    currentPhase = exports.PerfPhase.Unaccounted;
    currentPhaseEntered;
    /**
     * Creates an `ActivePerfRecorder` with its zero point set to the current time.
     */
    static zeroedToNow() {
        return new ActivePerfRecorder(mark());
    }
    constructor(zeroTime) {
        this.zeroTime = zeroTime;
        this.currentPhaseEntered = this.zeroTime;
        this.counters = Array(exports.PerfEvent.LAST).fill(0);
        this.phaseTime = Array(exports.PerfPhase.LAST).fill(0);
        this.bytes = Array(exports.PerfCheckpoint.LAST).fill(0);
        // Take an initial memory snapshot before any other compilation work begins.
        this.memory(exports.PerfCheckpoint.Initial);
    }
    reset() {
        this.counters = Array(exports.PerfEvent.LAST).fill(0);
        this.phaseTime = Array(exports.PerfPhase.LAST).fill(0);
        this.bytes = Array(exports.PerfCheckpoint.LAST).fill(0);
        this.zeroTime = mark();
        this.currentPhase = exports.PerfPhase.Unaccounted;
        this.currentPhaseEntered = this.zeroTime;
    }
    memory(after) {
        this.bytes[after] = process.memoryUsage().heapUsed;
    }
    phase(phase) {
        const previous = this.currentPhase;
        this.phaseTime[this.currentPhase] += timeSinceInMicros(this.currentPhaseEntered);
        this.currentPhase = phase;
        this.currentPhaseEntered = mark();
        return previous;
    }
    inPhase(phase, fn) {
        const previousPhase = this.phase(phase);
        try {
            return fn();
        }
        finally {
            this.phase(previousPhase);
        }
    }
    eventCount(counter, incrementBy = 1) {
        this.counters[counter] += incrementBy;
    }
    /**
     * Return the current performance metrics as a serializable object.
     */
    finalize() {
        // Track the last segment of time spent in `this.currentPhase` in the time array.
        this.phase(exports.PerfPhase.Unaccounted);
        const results = {
            events: {},
            phases: {},
            memory: {},
        };
        for (let i = 0; i < this.phaseTime.length; i++) {
            if (this.phaseTime[i] > 0) {
                results.phases[exports.PerfPhase[i]] = this.phaseTime[i];
            }
        }
        for (let i = 0; i < this.phaseTime.length; i++) {
            if (this.counters[i] > 0) {
                results.events[exports.PerfEvent[i]] = this.counters[i];
            }
        }
        for (let i = 0; i < this.bytes.length; i++) {
            if (this.bytes[i] > 0) {
                results.memory[exports.PerfCheckpoint[i]] = this.bytes[i];
            }
        }
        return results;
    }
}
/**
 * A `PerfRecorder` that delegates to a target `PerfRecorder` which can be updated later.
 *
 * `DelegatingPerfRecorder` is useful when a compiler class that needs a `PerfRecorder` can outlive
 * the current compilation. This is true for most compiler classes as resource-only changes reuse
 * the same `NgCompiler` for a new compilation.
 */
class DelegatingPerfRecorder {
    target;
    constructor(target) {
        this.target = target;
    }
    eventCount(counter, incrementBy) {
        this.target.eventCount(counter, incrementBy);
    }
    phase(phase) {
        return this.target.phase(phase);
    }
    inPhase(phase, fn) {
        // Note: this doesn't delegate to `this.target.inPhase` but instead is implemented manually here
        // to avoid adding an additional frame of noise to the stack when debugging.
        const previousPhase = this.target.phase(phase);
        try {
            return fn();
        }
        finally {
            this.target.phase(previousPhase);
        }
    }
    memory(after) {
        this.target.memory(after);
    }
    reset() {
        this.target.reset();
    }
}

var TraitState;
(function (TraitState) {
    /**
     * Pending traits are freshly created and have never been analyzed.
     */
    TraitState[TraitState["Pending"] = 0] = "Pending";
    /**
     * Analyzed traits have successfully been analyzed, but are pending resolution.
     */
    TraitState[TraitState["Analyzed"] = 1] = "Analyzed";
    /**
     * Resolved traits have successfully been analyzed and resolved and are ready for compilation.
     */
    TraitState[TraitState["Resolved"] = 2] = "Resolved";
    /**
     * Skipped traits are no longer considered for compilation.
     */
    TraitState[TraitState["Skipped"] = 3] = "Skipped";
})(TraitState || (TraitState = {}));
/**
 * The value side of `Trait` exposes a helper to create a `Trait` in a pending state (by delegating
 * to `TraitImpl`).
 */
const Trait = {
    pending: (handler, detected) => TraitImpl.pending(handler, detected),
};
/**
 * An implementation of the `Trait` type which transitions safely between the various
 * `TraitState`s.
 */
class TraitImpl {
    state = TraitState.Pending;
    handler;
    detected;
    analysis = null;
    symbol = null;
    resolution = null;
    analysisDiagnostics = null;
    resolveDiagnostics = null;
    typeCheckDiagnostics = null;
    constructor(handler, detected) {
        this.handler = handler;
        this.detected = detected;
    }
    toAnalyzed(analysis, diagnostics, symbol) {
        // Only pending traits can be analyzed.
        this.assertTransitionLegal(TraitState.Pending, TraitState.Analyzed);
        this.analysis = analysis;
        this.analysisDiagnostics = diagnostics;
        this.symbol = symbol;
        this.state = TraitState.Analyzed;
        return this;
    }
    toResolved(resolution, diagnostics) {
        // Only analyzed traits can be resolved.
        this.assertTransitionLegal(TraitState.Analyzed, TraitState.Resolved);
        if (this.analysis === null) {
            throw new Error(`Cannot transition an Analyzed trait with a null analysis to Resolved`);
        }
        this.resolution = resolution;
        this.state = TraitState.Resolved;
        this.resolveDiagnostics = diagnostics;
        this.typeCheckDiagnostics = null;
        return this;
    }
    toSkipped() {
        // Only pending traits can be skipped.
        this.assertTransitionLegal(TraitState.Pending, TraitState.Skipped);
        this.state = TraitState.Skipped;
        return this;
    }
    /**
     * Verifies that the trait is currently in one of the `allowedState`s.
     *
     * If correctly used, the `Trait` type and transition methods prevent illegal transitions from
     * occurring. However, if a reference to the `TraitImpl` instance typed with the previous
     * interface is retained after calling one of its transition methods, it will allow for illegal
     * transitions to take place. Hence, this assertion provides a little extra runtime protection.
     */
    assertTransitionLegal(allowedState, transitionTo) {
        if (!(this.state === allowedState)) {
            throw new Error(`Assertion failure: cannot transition from ${TraitState[this.state]} to ${TraitState[transitionTo]}.`);
        }
    }
    /**
     * Construct a new `TraitImpl` in the pending state.
     */
    static pending(handler, detected) {
        return new TraitImpl(handler, detected);
    }
}

/**
 * The heart of Angular compilation.
 *
 * The `TraitCompiler` is responsible for processing all classes in the program. Any time a
 * `DecoratorHandler` matches a class, a "trait" is created to represent that Angular aspect of the
 * class (such as the class having a component definition).
 *
 * The `TraitCompiler` transitions each trait through the various phases of compilation, culminating
 * in the production of `CompileResult`s instructing the compiler to apply various mutations to the
 * class (like adding fields or type declarations).
 */
class TraitCompiler {
    handlers;
    reflector;
    perf;
    incrementalBuild;
    compileNonExportedClasses;
    compilationMode;
    dtsTransforms;
    semanticDepGraphUpdater;
    sourceFileTypeIdentifier;
    emitDeclarationOnly;
    /**
     * Maps class declarations to their `ClassRecord`, which tracks the Ivy traits being applied to
     * those classes.
     */
    classes = new Map();
    /**
     * Maps source files to any class declaration(s) within them which have been discovered to contain
     * Ivy traits.
     */
    fileToClasses = new Map();
    /**
     * Tracks which source files have been analyzed but did not contain any traits. This set allows
     * the compiler to skip analyzing these files in an incremental rebuild.
     */
    filesWithoutTraits = new Set();
    reexportMap = new Map();
    handlersByName = new Map();
    constructor(handlers, reflector, perf, incrementalBuild, compileNonExportedClasses, compilationMode, dtsTransforms, semanticDepGraphUpdater, sourceFileTypeIdentifier, emitDeclarationOnly) {
        this.handlers = handlers;
        this.reflector = reflector;
        this.perf = perf;
        this.incrementalBuild = incrementalBuild;
        this.compileNonExportedClasses = compileNonExportedClasses;
        this.compilationMode = compilationMode;
        this.dtsTransforms = dtsTransforms;
        this.semanticDepGraphUpdater = semanticDepGraphUpdater;
        this.sourceFileTypeIdentifier = sourceFileTypeIdentifier;
        this.emitDeclarationOnly = emitDeclarationOnly;
        for (const handler of handlers) {
            this.handlersByName.set(handler.name, handler);
        }
    }
    analyzeSync(sf) {
        this.analyze(sf, false);
    }
    analyzeAsync(sf) {
        return this.analyze(sf, true);
    }
    analyze(sf, preanalyze) {
        // We shouldn't analyze declaration, shim, or resource files.
        if (sf.isDeclarationFile ||
            this.sourceFileTypeIdentifier.isShim(sf) ||
            this.sourceFileTypeIdentifier.isResource(sf)) {
            return undefined;
        }
        // analyze() really wants to return `Promise<void>|void`, but TypeScript cannot narrow a return
        // type of 'void', so `undefined` is used instead.
        const promises = [];
        // Local compilation does not support incremental build.
        const priorWork = this.compilationMode !== exports.CompilationMode.LOCAL
            ? this.incrementalBuild.priorAnalysisFor(sf)
            : null;
        if (priorWork !== null) {
            this.perf.eventCount(exports.PerfEvent.SourceFileReuseAnalysis);
            if (priorWork.length > 0) {
                for (const priorRecord of priorWork) {
                    this.adopt(priorRecord);
                }
                this.perf.eventCount(exports.PerfEvent.TraitReuseAnalysis, priorWork.length);
            }
            else {
                this.filesWithoutTraits.add(sf);
            }
            // Skip the rest of analysis, as this file's prior traits are being reused.
            return;
        }
        const visit = (node) => {
            if (this.reflector.isClass(node)) {
                this.analyzeClass(node, preanalyze ? promises : null);
            }
            ts.forEachChild(node, visit);
        };
        visit(sf);
        if (!this.fileToClasses.has(sf)) {
            // If no traits were detected in the source file we record the source file itself to not have
            // any traits, such that analysis of the source file can be skipped during incremental
            // rebuilds.
            this.filesWithoutTraits.add(sf);
        }
        if (preanalyze && promises.length > 0) {
            return Promise.all(promises).then(() => undefined);
        }
        else {
            return undefined;
        }
    }
    recordFor(clazz) {
        if (this.classes.has(clazz)) {
            return this.classes.get(clazz);
        }
        else {
            return null;
        }
    }
    getAnalyzedRecords() {
        const result = new Map();
        for (const [sf, classes] of this.fileToClasses) {
            const records = [];
            for (const clazz of classes) {
                records.push(this.classes.get(clazz));
            }
            result.set(sf, records);
        }
        for (const sf of this.filesWithoutTraits) {
            result.set(sf, []);
        }
        return result;
    }
    /**
     * Import a `ClassRecord` from a previous compilation (only to be used in global compilation
     * modes)
     *
     * Traits from the `ClassRecord` have accurate metadata, but the `handler` is from the old program
     * and needs to be updated (matching is done by name). A new pending trait is created and then
     * transitioned to analyzed using the previous analysis. If the trait is in the errored state,
     * instead the errors are copied over.
     */
    adopt(priorRecord) {
        const record = {
            hasPrimaryHandler: priorRecord.hasPrimaryHandler,
            hasWeakHandlers: priorRecord.hasWeakHandlers,
            metaDiagnostics: priorRecord.metaDiagnostics,
            node: priorRecord.node,
            traits: [],
        };
        for (const priorTrait of priorRecord.traits) {
            const handler = this.handlersByName.get(priorTrait.handler.name);
            let trait = Trait.pending(handler, priorTrait.detected);
            if (priorTrait.state === TraitState.Analyzed || priorTrait.state === TraitState.Resolved) {
                const symbol = this.makeSymbolForTrait(handler, record.node, priorTrait.analysis);
                trait = trait.toAnalyzed(priorTrait.analysis, priorTrait.analysisDiagnostics, symbol);
                if (trait.analysis !== null && trait.handler.register !== undefined) {
                    trait.handler.register(record.node, trait.analysis);
                }
            }
            else if (priorTrait.state === TraitState.Skipped) {
                trait = trait.toSkipped();
            }
            record.traits.push(trait);
        }
        this.classes.set(record.node, record);
        const sf = record.node.getSourceFile();
        if (!this.fileToClasses.has(sf)) {
            this.fileToClasses.set(sf, new Set());
        }
        this.fileToClasses.get(sf).add(record.node);
    }
    scanClassForTraits(clazz) {
        if (!this.compileNonExportedClasses && !this.reflector.isStaticallyExported(clazz)) {
            return null;
        }
        const decorators = this.reflector.getDecoratorsOfDeclaration(clazz);
        return this.detectTraits(clazz, decorators);
    }
    detectTraits(clazz, decorators) {
        let record = this.recordFor(clazz);
        let foundTraits = [];
        // A set to track the non-Angular decorators in local compilation mode. An error will be issued
        // if non-Angular decorators is found in local compilation mode.
        const nonNgDecoratorsInLocalMode = this.compilationMode === exports.CompilationMode.LOCAL ? new Set(decorators) : null;
        for (const handler of this.handlers) {
            const result = handler.detect(clazz, decorators);
            if (result === undefined) {
                continue;
            }
            if (nonNgDecoratorsInLocalMode !== null && result.decorator !== null) {
                nonNgDecoratorsInLocalMode.delete(result.decorator);
            }
            const isPrimaryHandler = handler.precedence === HandlerPrecedence.PRIMARY;
            const isWeakHandler = handler.precedence === HandlerPrecedence.WEAK;
            const trait = Trait.pending(handler, result);
            foundTraits.push(trait);
            if (record === null) {
                // This is the first handler to match this class. This path is a fast path through which
                // most classes will flow.
                record = {
                    node: clazz,
                    traits: [trait],
                    metaDiagnostics: null,
                    hasPrimaryHandler: isPrimaryHandler,
                    hasWeakHandlers: isWeakHandler,
                };
                this.classes.set(clazz, record);
                const sf = clazz.getSourceFile();
                if (!this.fileToClasses.has(sf)) {
                    this.fileToClasses.set(sf, new Set());
                }
                this.fileToClasses.get(sf).add(clazz);
            }
            else {
                // This is at least the second handler to match this class. This is a slower path that some
                // classes will go through, which validates that the set of decorators applied to the class
                // is valid.
                // Validate according to rules as follows:
                //
                // * WEAK handlers are removed if a non-WEAK handler matches.
                // * Only one PRIMARY handler can match at a time. Any other PRIMARY handler matching a
                //   class with an existing PRIMARY handler is an error.
                if (!isWeakHandler && record.hasWeakHandlers) {
                    // The current handler is not a WEAK handler, but the class has other WEAK handlers.
                    // Remove them.
                    record.traits = record.traits.filter((field) => field.handler.precedence !== HandlerPrecedence.WEAK);
                    record.hasWeakHandlers = false;
                }
                else if (isWeakHandler && !record.hasWeakHandlers) {
                    // The current handler is a WEAK handler, but the class has non-WEAK handlers already.
                    // Drop the current one.
                    continue;
                }
                if (isPrimaryHandler && record.hasPrimaryHandler) {
                    // The class already has a PRIMARY handler, and another one just matched.
                    record.metaDiagnostics = [
                        {
                            category: ts.DiagnosticCategory.Error,
                            code: Number('-99' + exports.ErrorCode.DECORATOR_COLLISION),
                            file: getSourceFile(clazz),
                            start: clazz.getStart(undefined, false),
                            length: clazz.getWidth(),
                            messageText: 'Two incompatible decorators on class',
                        },
                    ];
                    record.traits = foundTraits = [];
                    break;
                }
                // Otherwise, it's safe to accept the multiple decorators here. Update some of the metadata
                // regarding this class.
                record.traits.push(trait);
                record.hasPrimaryHandler = record.hasPrimaryHandler || isPrimaryHandler;
            }
        }
        if (nonNgDecoratorsInLocalMode !== null &&
            nonNgDecoratorsInLocalMode.size > 0 &&
            record !== null &&
            record.metaDiagnostics === null) {
            // Custom decorators found in local compilation mode! In this mode we don't support custom
            // decorators yet. But will eventually do (b/320536434). For now a temporary error is thrown.
            const compilationModeName = this.emitDeclarationOnly
                ? 'experimental declaration-only emission'
                : 'local compilation';
            record.metaDiagnostics = [...nonNgDecoratorsInLocalMode].map((decorator) => ({
                category: ts.DiagnosticCategory.Error,
                code: Number('-99' + exports.ErrorCode.DECORATOR_UNEXPECTED),
                file: getSourceFile(clazz),
                start: decorator.node.getStart(),
                length: decorator.node.getWidth(),
                messageText: `In ${compilationModeName} mode, Angular does not support custom decorators. Ensure all class decorators are from Angular.`,
            }));
            record.traits = foundTraits = [];
        }
        return foundTraits.length > 0 ? foundTraits : null;
    }
    makeSymbolForTrait(handler, decl, analysis) {
        if (analysis === null) {
            return null;
        }
        const symbol = handler.symbol(decl, analysis);
        if (symbol !== null && this.semanticDepGraphUpdater !== null) {
            const isPrimary = handler.precedence === HandlerPrecedence.PRIMARY;
            if (!isPrimary) {
                throw new Error(`AssertionError: ${handler.name} returned a symbol but is not a primary handler.`);
            }
            this.semanticDepGraphUpdater.registerSymbol(symbol);
        }
        return symbol;
    }
    analyzeClass(clazz, preanalyzeQueue) {
        const traits = this.scanClassForTraits(clazz);
        if (traits === null) {
            // There are no Ivy traits on the class, so it can safely be skipped.
            return;
        }
        for (const trait of traits) {
            const analyze = () => this.analyzeTrait(clazz, trait);
            let preanalysis = null;
            if (preanalyzeQueue !== null && trait.handler.preanalyze !== undefined) {
                // Attempt to run preanalysis. This could fail with a `FatalDiagnosticError`; catch it if it
                // does.
                try {
                    preanalysis = trait.handler.preanalyze(clazz, trait.detected.metadata) || null;
                }
                catch (err) {
                    if (err instanceof FatalDiagnosticError) {
                        trait.toAnalyzed(null, [err.toDiagnostic()], null);
                        return;
                    }
                    else {
                        throw err;
                    }
                }
            }
            if (preanalysis !== null) {
                preanalyzeQueue.push(preanalysis.then(analyze));
            }
            else {
                analyze();
            }
        }
    }
    analyzeTrait(clazz, trait) {
        if (trait.state !== TraitState.Pending) {
            throw new Error(`Attempt to analyze trait of ${clazz.name.text} in state ${TraitState[trait.state]} (expected DETECTED)`);
        }
        this.perf.eventCount(exports.PerfEvent.TraitAnalyze);
        // Attempt analysis. This could fail with a `FatalDiagnosticError`; catch it if it does.
        let result;
        try {
            result = trait.handler.analyze(clazz, trait.detected.metadata);
        }
        catch (err) {
            if (err instanceof FatalDiagnosticError) {
                trait.toAnalyzed(null, [err.toDiagnostic()], null);
                return;
            }
            else {
                throw err;
            }
        }
        const symbol = this.makeSymbolForTrait(trait.handler, clazz, result.analysis ?? null);
        if (result.analysis !== undefined && trait.handler.register !== undefined) {
            trait.handler.register(clazz, result.analysis);
        }
        trait = trait.toAnalyzed(result.analysis ?? null, result.diagnostics ?? null, symbol);
    }
    resolve() {
        const classes = this.classes.keys();
        for (const clazz of classes) {
            const record = this.classes.get(clazz);
            for (let trait of record.traits) {
                const handler = trait.handler;
                switch (trait.state) {
                    case TraitState.Skipped:
                        continue;
                    case TraitState.Pending:
                        throw new Error(`Resolving a trait that hasn't been analyzed: ${clazz.name.text} / ${trait.handler.name}`);
                    case TraitState.Resolved:
                        throw new Error(`Resolving an already resolved trait`);
                }
                if (trait.analysis === null) {
                    // No analysis results, cannot further process this trait.
                    continue;
                }
                if (handler.resolve === undefined) {
                    // No resolution of this trait needed - it's considered successful by default.
                    trait = trait.toResolved(null, null);
                    continue;
                }
                let result;
                try {
                    result = handler.resolve(clazz, trait.analysis, trait.symbol);
                }
                catch (err) {
                    if (err instanceof FatalDiagnosticError) {
                        trait = trait.toResolved(null, [err.toDiagnostic()]);
                        continue;
                    }
                    else {
                        throw err;
                    }
                }
                trait = trait.toResolved(result.data ?? null, result.diagnostics ?? null);
                if (result.reexports !== undefined) {
                    const fileName = clazz.getSourceFile().fileName;
                    if (!this.reexportMap.has(fileName)) {
                        this.reexportMap.set(fileName, new Map());
                    }
                    const fileReexports = this.reexportMap.get(fileName);
                    for (const reexport of result.reexports) {
                        fileReexports.set(reexport.asAlias, [reexport.fromModule, reexport.symbolName]);
                    }
                }
            }
        }
    }
    /**
     * Generate type-checking code into the `TypeCheckContext` for any components within the given
     * `ts.SourceFile`.
     */
    typeCheck(sf, ctx) {
        if (!this.fileToClasses.has(sf) || this.compilationMode === exports.CompilationMode.LOCAL) {
            return;
        }
        for (const clazz of this.fileToClasses.get(sf)) {
            const record = this.classes.get(clazz);
            for (const trait of record.traits) {
                if (trait.state !== TraitState.Resolved) {
                    continue;
                }
                else if (trait.handler.typeCheck === undefined) {
                    continue;
                }
                if (trait.resolution !== null) {
                    trait.handler.typeCheck(ctx, clazz, trait.analysis, trait.resolution);
                }
            }
        }
    }
    runAdditionalChecks(sf, check) {
        if (this.compilationMode === exports.CompilationMode.LOCAL) {
            return [];
        }
        const classes = this.fileToClasses.get(sf);
        if (classes === undefined) {
            return [];
        }
        const diagnostics = [];
        for (const clazz of classes) {
            if (!isNamedClassDeclaration(clazz)) {
                continue;
            }
            const record = this.classes.get(clazz);
            for (const trait of record.traits) {
                const result = check(clazz, trait.handler);
                if (result !== null) {
                    diagnostics.push(...result);
                }
            }
        }
        return diagnostics;
    }
    index(ctx) {
        for (const clazz of this.classes.keys()) {
            const record = this.classes.get(clazz);
            for (const trait of record.traits) {
                if (trait.state !== TraitState.Resolved) {
                    // Skip traits that haven't been resolved successfully.
                    continue;
                }
                else if (trait.handler.index === undefined) {
                    // Skip traits that don't affect indexing.
                    continue;
                }
                if (trait.resolution !== null) {
                    trait.handler.index(ctx, clazz, trait.analysis, trait.resolution);
                }
            }
        }
    }
    xi18n(bundle) {
        for (const clazz of this.classes.keys()) {
            const record = this.classes.get(clazz);
            for (const trait of record.traits) {
                if (trait.state !== TraitState.Analyzed && trait.state !== TraitState.Resolved) {
                    // Skip traits that haven't been analyzed successfully.
                    continue;
                }
                else if (trait.handler.xi18n === undefined) {
                    // Skip traits that don't support xi18n.
                    continue;
                }
                if (trait.analysis !== null) {
                    trait.handler.xi18n(bundle, clazz, trait.analysis);
                }
            }
        }
    }
    updateResources(clazz) {
        // Local compilation does not support incremental
        if (this.compilationMode === exports.CompilationMode.LOCAL ||
            !this.reflector.isClass(clazz) ||
            !this.classes.has(clazz)) {
            return;
        }
        const record = this.classes.get(clazz);
        for (const trait of record.traits) {
            if (trait.state !== TraitState.Resolved || trait.handler.updateResources === undefined) {
                continue;
            }
            trait.handler.updateResources(clazz, trait.analysis, trait.resolution);
        }
    }
    compile(clazz, constantPool) {
        const original = ts.getOriginalNode(clazz);
        if (!this.reflector.isClass(clazz) ||
            !this.reflector.isClass(original) ||
            !this.classes.has(original)) {
            return null;
        }
        const record = this.classes.get(original);
        let res = [];
        for (const trait of record.traits) {
            let compileRes;
            if (trait.state !== TraitState.Resolved ||
                containsErrors(trait.analysisDiagnostics) ||
                containsErrors(trait.resolveDiagnostics)) {
                // Cannot compile a trait that is not resolved, or had any errors in its declaration.
                continue;
            }
            if (this.compilationMode === exports.CompilationMode.LOCAL) {
                // `trait.analysis` is non-null asserted here because TypeScript does not recognize that
                // `Readonly<unknown>` is nullable (as `unknown` itself is nullable) due to the way that
                // `Readonly` works.
                compileRes = trait.handler.compileLocal(clazz, trait.analysis, trait.resolution, constantPool);
            }
            else {
                // `trait.resolution` is non-null asserted below because TypeScript does not recognize that
                // `Readonly<unknown>` is nullable (as `unknown` itself is nullable) due to the way that
                // `Readonly` works.
                if (this.compilationMode === exports.CompilationMode.PARTIAL &&
                    trait.handler.compilePartial !== undefined) {
                    compileRes = trait.handler.compilePartial(clazz, trait.analysis, trait.resolution);
                }
                else {
                    compileRes = trait.handler.compileFull(clazz, trait.analysis, trait.resolution, constantPool);
                }
            }
            const compileMatchRes = compileRes;
            if (Array.isArray(compileMatchRes)) {
                for (const result of compileMatchRes) {
                    if (!res.some((r) => r.name === result.name)) {
                        res.push(result);
                    }
                }
            }
            else if (!res.some((result) => result.name === compileMatchRes.name)) {
                res.push(compileMatchRes);
            }
        }
        // Look up the .d.ts transformer for the input file and record that at least one field was
        // generated, which will allow the .d.ts to be transformed later.
        this.dtsTransforms
            .getIvyDeclarationTransform(original.getSourceFile())
            .addFields(original, res);
        // Return the instruction to the transformer so the fields will be added.
        return res.length > 0 ? res : null;
    }
    compileHmrUpdateCallback(clazz) {
        const original = ts.getOriginalNode(clazz);
        if (!this.reflector.isClass(clazz) ||
            !this.reflector.isClass(original) ||
            !this.classes.has(original)) {
            return null;
        }
        const record = this.classes.get(original);
        for (const trait of record.traits) {
            // Cannot compile a trait that is not resolved, or had any errors in its declaration.
            if (trait.state === TraitState.Resolved &&
                trait.handler.compileHmrUpdateDeclaration !== undefined &&
                !containsErrors(trait.analysisDiagnostics) &&
                !containsErrors(trait.resolveDiagnostics)) {
                return trait.handler.compileHmrUpdateDeclaration(clazz, trait.analysis, trait.resolution);
            }
        }
        return null;
    }
    decoratorsFor(node) {
        const original = ts.getOriginalNode(node);
        if (!this.reflector.isClass(original) || !this.classes.has(original)) {
            return [];
        }
        const record = this.classes.get(original);
        const decorators = [];
        for (const trait of record.traits) {
            // In global compilation mode skip the non-resolved traits.
            if (this.compilationMode !== exports.CompilationMode.LOCAL && trait.state !== TraitState.Resolved) {
                continue;
            }
            if (trait.detected.trigger !== null && ts.isDecorator(trait.detected.trigger)) {
                decorators.push(trait.detected.trigger);
            }
        }
        return decorators;
    }
    get diagnostics() {
        const diagnostics = [];
        for (const clazz of this.classes.keys()) {
            const record = this.classes.get(clazz);
            if (record.metaDiagnostics !== null) {
                diagnostics.push(...record.metaDiagnostics);
            }
            for (const trait of record.traits) {
                if ((trait.state === TraitState.Analyzed || trait.state === TraitState.Resolved) &&
                    trait.analysisDiagnostics !== null) {
                    diagnostics.push(...trait.analysisDiagnostics);
                }
                if (trait.state === TraitState.Resolved) {
                    diagnostics.push(...(trait.resolveDiagnostics ?? []));
                }
            }
        }
        return diagnostics;
    }
    get exportStatements() {
        return this.reexportMap;
    }
}
function containsErrors(diagnostics) {
    return (diagnostics !== null &&
        diagnostics.some((diag) => diag.category === ts.DiagnosticCategory.Error));
}

/**
 * The current context of a translator visitor as it traverses the AST tree.
 *
 * It tracks whether we are in the process of outputting a statement or an expression.
 */
let Context$1 = class Context {
    isStatement;
    constructor(isStatement) {
        this.isStatement = isStatement;
    }
    get withExpressionMode() {
        return this.isStatement ? new Context(false) : this;
    }
    get withStatementMode() {
        return !this.isStatement ? new Context(true) : this;
    }
};

/**
 * Generates a helper for `ImportManagerConfig` to generate unique identifiers
 * for a given source file.
 */
function createGenerateUniqueIdentifierHelper() {
    const generatedIdentifiers = new Set();
    const isGeneratedIdentifier = (sf, identifierName) => generatedIdentifiers.has(`${sf.fileName}@@${identifierName}`);
    const markIdentifierAsGenerated = (sf, identifierName) => generatedIdentifiers.add(`${sf.fileName}@@${identifierName}`);
    return (sourceFile, symbolName) => {
        const sf = sourceFile;
        // NOTE: Typically accesses to TS fields are not renamed because the 1P externs
        // produced from TypeScript are ensuring public fields are considered "external".
        // See: https://developers.google.com/closure/compiler/docs/externs-and-exports.
        // This property is internal, so not part of the externsâ so we need be cautious
        if (sf['identifiers'] === undefined) {
            throw new Error('Source file unexpectedly lacks map of parsed `identifiers`.');
        }
        const isUniqueIdentifier = (name) => !sf['identifiers'].has(name) && !isGeneratedIdentifier(sf, name);
        if (isUniqueIdentifier(symbolName)) {
            markIdentifierAsGenerated(sf, symbolName);
            return null;
        }
        let name = null;
        let counter = 1;
        do {
            name = `${symbolName}_${counter++}`;
        } while (!isUniqueIdentifier(name));
        markIdentifierAsGenerated(sf, name);
        return ts.factory.createUniqueName(name, ts.GeneratedIdentifierFlags.Optimistic);
    };
}

/**
 * Creates a TypeScript transform for the given import manager.
 *
 *  - The transform updates existing imports with new symbols to be added.
 *  - The transform adds new necessary imports.
 *  - The transform inserts additional optional statements after imports.
 *  - The transform deletes any nodes that are marked for deletion by the manager.
 */
function createTsTransformForImportManager(manager, extraStatementsForFiles) {
    return (ctx) => {
        const { affectedFiles, newImports, updatedImports, reusedOriginalAliasDeclarations, deletedImports, } = manager.finalize();
        // If we re-used existing source file alias declarations, mark those as referenced so TypeScript
        // doesn't drop these thinking they are unused.
        if (reusedOriginalAliasDeclarations.size > 0) {
            const referencedAliasDeclarations = loadIsReferencedAliasDeclarationPatch(ctx);
            if (referencedAliasDeclarations !== null) {
                reusedOriginalAliasDeclarations.forEach((aliasDecl) => referencedAliasDeclarations.add(aliasDecl));
            }
        }
        // Update the set of affected files to include files that need extra statements to be inserted.
        if (extraStatementsForFiles !== undefined) {
            for (const [fileName, statements] of extraStatementsForFiles.entries()) {
                if (statements.length > 0) {
                    affectedFiles.add(fileName);
                }
            }
        }
        const visitStatement = (node) => {
            if (!ts.isImportDeclaration(node)) {
                return node;
            }
            if (deletedImports.has(node)) {
                return undefined;
            }
            if (node.importClause === undefined || !ts.isImportClause(node.importClause)) {
                return node;
            }
            const clause = node.importClause;
            if (clause.namedBindings === undefined ||
                !ts.isNamedImports(clause.namedBindings) ||
                !updatedImports.has(clause.namedBindings)) {
                return node;
            }
            const newClause = ctx.factory.updateImportClause(clause, clause.isTypeOnly, clause.name, updatedImports.get(clause.namedBindings));
            const newImport = ctx.factory.updateImportDeclaration(node, node.modifiers, newClause, node.moduleSpecifier, node.attributes);
            // This tricks TypeScript into thinking that the `importClause` is still optimizable.
            // By default, TS assumes, no specifiers are elide-able if the clause of the "original
            // node" has changed. google3:
            // typescript/unstable/src/compiler/transformers/ts.ts;l=456;rcl=611254538.
            ts.setOriginalNode(newImport, {
                importClause: newClause,
                kind: newImport.kind,
            });
            return newImport;
        };
        return (sourceFile) => {
            if (!affectedFiles.has(sourceFile.fileName)) {
                return sourceFile;
            }
            sourceFile = ts.visitEachChild(sourceFile, visitStatement, ctx);
            // Filter out the existing imports and the source file body.
            // All new statements will be inserted between them.
            const extraStatements = extraStatementsForFiles?.get(sourceFile.fileName) ?? [];
            const existingImports = [];
            const body = [];
            for (const statement of sourceFile.statements) {
                if (isImportStatement(statement)) {
                    existingImports.push(statement);
                }
                else {
                    body.push(statement);
                }
            }
            return ctx.factory.updateSourceFile(sourceFile, [
                ...existingImports,
                ...(newImports.get(sourceFile.fileName) ?? []),
                ...extraStatements,
                ...body,
            ], sourceFile.isDeclarationFile, sourceFile.referencedFiles, sourceFile.typeReferenceDirectives, sourceFile.hasNoDefaultLib, sourceFile.libReferenceDirectives);
        };
    };
}
/** Whether the given statement is an import statement. */
function isImportStatement(stmt) {
    return (ts.isImportDeclaration(stmt) || ts.isImportEqualsDeclaration(stmt) || ts.isNamespaceImport(stmt));
}

/** Attempts to efficiently re-use previous generated import requests. */
function attemptToReuseGeneratedImports(tracker, request) {
    const requestHash = hashImportRequest(request);
    // In case the given import has been already generated previously, we just return
    // the previous generated identifier in order to avoid duplicate generated imports.
    const existingExactImport = tracker.directReuseCache.get(requestHash);
    if (existingExactImport !== undefined) {
        return existingExactImport;
    }
    const potentialNamespaceImport = tracker.namespaceImportReuseCache.get(request.exportModuleSpecifier);
    if (potentialNamespaceImport === undefined) {
        return null;
    }
    if (request.exportSymbolName === null) {
        return potentialNamespaceImport;
    }
    return [potentialNamespaceImport, ts.factory.createIdentifier(request.exportSymbolName)];
}
/** Captures the given import request and its generated reference node/path for future re-use. */
function captureGeneratedImport(request, tracker, referenceNode) {
    tracker.directReuseCache.set(hashImportRequest(request), referenceNode);
    if (request.exportSymbolName === null && !Array.isArray(referenceNode)) {
        tracker.namespaceImportReuseCache.set(request.exportModuleSpecifier, referenceNode);
    }
}
/** Generates a unique hash for the given import request. */
function hashImportRequest(req) {
    return `${req.requestedFile.fileName}:${req.exportModuleSpecifier}:${req.exportSymbolName}${req.unsafeAliasOverride ? ':' + req.unsafeAliasOverride : ''}`;
}

/** Attempts to re-use original source file imports for the given request. */
function attemptToReuseExistingSourceFileImports(tracker, sourceFile, request) {
    // Walk through all source-file top-level statements and search for import declarations
    // that already match the specified "moduleName" and can be updated to import the
    // given symbol. If no matching import can be found, the last import in the source-file
    // will be used as starting point for a new import that will be generated.
    let candidateImportToBeUpdated = null;
    for (let i = sourceFile.statements.length - 1; i >= 0; i--) {
        const statement = sourceFile.statements[i];
        if (!ts.isImportDeclaration(statement) || !ts.isStringLiteral(statement.moduleSpecifier)) {
            continue;
        }
        // Side-effect imports are ignored, or type-only imports.
        // TODO: Consider re-using type-only imports efficiently.
        if (!statement.importClause || statement.importClause.isTypeOnly) {
            continue;
        }
        const moduleSpecifier = statement.moduleSpecifier.text;
        // If the import does not match the module name, or requested target file, continue.
        // Note: In the future, we may consider performing better analysis here. E.g. resolve paths,
        // or try to detect re-usable symbols via type-checking.
        if (moduleSpecifier !== request.exportModuleSpecifier) {
            continue;
        }
        if (statement.importClause.namedBindings) {
            const namedBindings = statement.importClause.namedBindings;
            // A namespace import can be reused.
            if (ts.isNamespaceImport(namedBindings)) {
                tracker.reusedAliasDeclarations.add(namedBindings);
                if (request.exportSymbolName === null) {
                    return namedBindings.name;
                }
                return [namedBindings.name, ts.factory.createIdentifier(request.exportSymbolName)];
            }
            // Named imports can be re-used if a specific symbol is requested.
            if (ts.isNamedImports(namedBindings) && request.exportSymbolName !== null) {
                const existingElement = namedBindings.elements.find((e) => {
                    // TODO: Consider re-using type-only imports efficiently.
                    let nameMatches;
                    if (request.unsafeAliasOverride) {
                        // If a specific alias is passed, both the original name and alias have to match.
                        nameMatches =
                            e.propertyName?.text === request.exportSymbolName &&
                                e.name.text === request.unsafeAliasOverride;
                    }
                    else {
                        nameMatches = e.propertyName
                            ? e.propertyName.text === request.exportSymbolName
                            : e.name.text === request.exportSymbolName;
                    }
                    return !e.isTypeOnly && nameMatches;
                });
                if (existingElement !== undefined) {
                    tracker.reusedAliasDeclarations.add(existingElement);
                    return existingElement.name;
                }
                // In case the symbol could not be found in an existing import, we
                // keep track of the import declaration as it can be updated to include
                // the specified symbol name without having to create a new import.
                candidateImportToBeUpdated = statement;
            }
        }
    }
    if (candidateImportToBeUpdated === null || request.exportSymbolName === null) {
        return null;
    }
    // We have a candidate import. Update it to import what we need.
    if (!tracker.updatedImports.has(candidateImportToBeUpdated)) {
        tracker.updatedImports.set(candidateImportToBeUpdated, []);
    }
    const symbolsToBeImported = tracker.updatedImports.get(candidateImportToBeUpdated);
    const propertyName = ts.factory.createIdentifier(request.exportSymbolName);
    const fileUniqueAlias = request.unsafeAliasOverride
        ? ts.factory.createIdentifier(request.unsafeAliasOverride)
        : tracker.generateUniqueIdentifier(sourceFile, request.exportSymbolName);
    // Since it can happen that multiple classes need to be imported within the
    // specified source file and we want to add the identifiers to the existing
    // import declaration, we need to keep track of the updated import declarations.
    // We can't directly update the import declaration for each identifier as this
    // would not be reflected in the ASTâ or would throw of update recording offsets.
    symbolsToBeImported.push({
        propertyName,
        fileUniqueAlias,
    });
    return fileUniqueAlias ?? propertyName;
}

/**
 * Preset configuration for forcing namespace imports.
 *
 * This preset is commonly used to avoid test differences to previous
 * versions of the `ImportManager`.
 */
const presetImportManagerForceNamespaceImports = {
    // Forcing namespace imports also means no-reuse.
    // Re-using would otherwise become more complicated and we don't
    // expect re-usable namespace imports.
    disableOriginalSourceFileReuse: true,
    forceGenerateNamespacesForNewImports: true,
};
/**
 * Import manager that can be used to conveniently and efficiently generate
 * imports It efficiently re-uses existing source file imports, or previous
 * generated imports.
 *
 * These capabilities are important for efficient TypeScript transforms that
 * minimize structural changes to the dependency graph of source files, enabling
 * as much incremental re-use as possible.
 *
 * Those imports may be inserted via a TypeScript transform, or via manual string
 * manipulation using e.g. `magic-string`.
 */
class ImportManager {
    /** List of new imports that will be inserted into given source files. */
    newImports = new Map();
    /**
     * Keeps track of imports marked for removal. The root-level key is the file from which the
     * import should be removed, the inner map key is the name of the module from which the symbol
     * is being imported. The value of the inner map is a set of symbol names that should be removed.
     * Note! the inner map tracks the original names of the imported symbols, not their local aliases.
     */
    removedImports = new Map();
    nextUniqueIndex = 0;
    config;
    reuseSourceFileImportsTracker;
    reuseGeneratedImportsTracker = {
        directReuseCache: new Map(),
        namespaceImportReuseCache: new Map(),
    };
    constructor(config = {}) {
        this.config = {
            shouldUseSingleQuotes: config.shouldUseSingleQuotes ?? (() => false),
            rewriter: config.rewriter ?? null,
            disableOriginalSourceFileReuse: config.disableOriginalSourceFileReuse ?? false,
            forceGenerateNamespacesForNewImports: config.forceGenerateNamespacesForNewImports ?? false,
            namespaceImportPrefix: config.namespaceImportPrefix ?? 'i',
            generateUniqueIdentifier: config.generateUniqueIdentifier ?? createGenerateUniqueIdentifierHelper(),
        };
        this.reuseSourceFileImportsTracker = {
            generateUniqueIdentifier: this.config.generateUniqueIdentifier,
            reusedAliasDeclarations: new Set(),
            updatedImports: new Map(),
        };
    }
    /** Adds a side-effect import for the given module. */
    addSideEffectImport(requestedFile, moduleSpecifier) {
        if (this.config.rewriter !== null) {
            moduleSpecifier = this.config.rewriter.rewriteSpecifier(moduleSpecifier, requestedFile.fileName);
        }
        this._getNewImportsTrackerForFile(requestedFile).sideEffectImports.add(moduleSpecifier);
    }
    addImport(request) {
        if (this.config.rewriter !== null) {
            if (request.exportSymbolName !== null) {
                request.exportSymbolName = this.config.rewriter.rewriteSymbol(request.exportSymbolName, request.exportModuleSpecifier);
            }
            request.exportModuleSpecifier = this.config.rewriter.rewriteSpecifier(request.exportModuleSpecifier, request.requestedFile.fileName);
        }
        // Remove the newly-added import from the set of removed imports.
        if (request.exportSymbolName !== null && !request.asTypeReference) {
            this.removedImports
                .get(request.requestedFile)
                ?.get(request.exportModuleSpecifier)
                ?.delete(request.exportSymbolName);
        }
        // Attempt to re-use previous identical import requests.
        const previousGeneratedImportRef = attemptToReuseGeneratedImports(this.reuseGeneratedImportsTracker, request);
        if (previousGeneratedImportRef !== null) {
            return createImportReference(!!request.asTypeReference, previousGeneratedImportRef);
        }
        // Generate a new one, and cache it.
        const resultImportRef = this._generateNewImport(request);
        captureGeneratedImport(request, this.reuseGeneratedImportsTracker, resultImportRef);
        return createImportReference(!!request.asTypeReference, resultImportRef);
    }
    /**
     * Marks all imported symbols with a specific name for removal.
     * Call `addImport` to undo this operation.
     * @param requestedFile File from which to remove the imports.
     * @param exportSymbolName Declared name of the symbol being removed.
     * @param moduleSpecifier Module from which the symbol is being imported.
     */
    removeImport(requestedFile, exportSymbolName, moduleSpecifier) {
        let moduleMap = this.removedImports.get(requestedFile);
        if (!moduleMap) {
            moduleMap = new Map();
            this.removedImports.set(requestedFile, moduleMap);
        }
        let removedSymbols = moduleMap.get(moduleSpecifier);
        if (!removedSymbols) {
            removedSymbols = new Set();
            moduleMap.set(moduleSpecifier, removedSymbols);
        }
        removedSymbols.add(exportSymbolName);
    }
    _generateNewImport(request) {
        const { requestedFile: sourceFile } = request;
        const disableOriginalSourceFileReuse = this.config.disableOriginalSourceFileReuse;
        const forceGenerateNamespacesForNewImports = this.config.forceGenerateNamespacesForNewImports;
        // If desired, attempt to re-use original source file imports as a base, or as much as possible.
        // This may involve updates to existing import named bindings.
        if (!disableOriginalSourceFileReuse) {
            const reuseResult = attemptToReuseExistingSourceFileImports(this.reuseSourceFileImportsTracker, sourceFile, request);
            if (reuseResult !== null) {
                return reuseResult;
            }
        }
        // A new import needs to be generated.
        // No candidate existing import was found.
        const { namedImports, namespaceImports } = this._getNewImportsTrackerForFile(sourceFile);
        // If a namespace import is requested, or the symbol should be forcibly
        // imported through namespace imports:
        if (request.exportSymbolName === null || forceGenerateNamespacesForNewImports) {
            let namespaceImportName = `${this.config.namespaceImportPrefix}${this.nextUniqueIndex++}`;
            if (this.config.rewriter) {
                namespaceImportName = this.config.rewriter.rewriteNamespaceImportIdentifier(namespaceImportName, request.exportModuleSpecifier);
            }
            const namespaceImport = ts.factory.createNamespaceImport(this.config.generateUniqueIdentifier(sourceFile, namespaceImportName) ??
                ts.factory.createIdentifier(namespaceImportName));
            namespaceImports.set(request.exportModuleSpecifier, namespaceImport);
            // Capture the generated namespace import alone, to allow re-use.
            captureGeneratedImport({ ...request, exportSymbolName: null }, this.reuseGeneratedImportsTracker, namespaceImport.name);
            if (request.exportSymbolName !== null) {
                return [namespaceImport.name, ts.factory.createIdentifier(request.exportSymbolName)];
            }
            return namespaceImport.name;
        }
        // Otherwise, an individual named import is requested.
        if (!namedImports.has(request.exportModuleSpecifier)) {
            namedImports.set(request.exportModuleSpecifier, []);
        }
        const exportSymbolName = ts.factory.createIdentifier(request.exportSymbolName);
        const fileUniqueName = request.unsafeAliasOverride
            ? null
            : this.config.generateUniqueIdentifier(sourceFile, request.exportSymbolName);
        let needsAlias;
        let specifierName;
        if (request.unsafeAliasOverride) {
            needsAlias = true;
            specifierName = ts.factory.createIdentifier(request.unsafeAliasOverride);
        }
        else if (fileUniqueName !== null) {
            needsAlias = true;
            specifierName = fileUniqueName;
        }
        else {
            needsAlias = false;
            specifierName = exportSymbolName;
        }
        namedImports
            .get(request.exportModuleSpecifier)
            .push(ts.factory.createImportSpecifier(false, needsAlias ? exportSymbolName : undefined, specifierName));
        return specifierName;
    }
    /**
     * Finalizes the import manager by computing all necessary import changes
     * and returning them.
     *
     * Changes are collected once at the end, after all imports are requested,
     * because this simplifies building up changes to existing imports that need
     * to be updated, and allows more trivial re-use of previous generated imports.
     */
    finalize() {
        const affectedFiles = new Set();
        const updatedImportsResult = new Map();
        const newImportsResult = new Map();
        const deletedImports = new Set();
        const importDeclarationsPerFile = new Map();
        const addNewImport = (fileName, importDecl) => {
            affectedFiles.add(fileName);
            if (newImportsResult.has(fileName)) {
                newImportsResult.get(fileName).push(importDecl);
            }
            else {
                newImportsResult.set(fileName, [importDecl]);
            }
        };
        // Collect original source file imports that need to be updated.
        this.reuseSourceFileImportsTracker.updatedImports.forEach((expressions, importDecl) => {
            const sourceFile = importDecl.getSourceFile();
            const namedBindings = importDecl.importClause.namedBindings;
            const moduleName = importDecl.moduleSpecifier.text;
            const newElements = namedBindings.elements
                .concat(expressions.map(({ propertyName, fileUniqueAlias }) => ts.factory.createImportSpecifier(false, fileUniqueAlias !== null ? propertyName : undefined, fileUniqueAlias ?? propertyName)))
                .filter((specifier) => this._canAddSpecifier(sourceFile, moduleName, specifier));
            affectedFiles.add(sourceFile.fileName);
            if (newElements.length === 0) {
                deletedImports.add(importDecl);
            }
            else {
                updatedImportsResult.set(namedBindings, ts.factory.updateNamedImports(namedBindings, newElements));
            }
        });
        this.removedImports.forEach((removeMap, sourceFile) => {
            if (removeMap.size === 0) {
                return;
            }
            let allImports = importDeclarationsPerFile.get(sourceFile);
            if (!allImports) {
                allImports = sourceFile.statements.filter(ts.isImportDeclaration);
                importDeclarationsPerFile.set(sourceFile, allImports);
            }
            for (const node of allImports) {
                if (!node.importClause?.namedBindings ||
                    !ts.isNamedImports(node.importClause.namedBindings) ||
                    this.reuseSourceFileImportsTracker.updatedImports.has(node) ||
                    deletedImports.has(node)) {
                    continue;
                }
                const namedBindings = node.importClause.namedBindings;
                const moduleName = node.moduleSpecifier.text;
                const newImports = namedBindings.elements.filter((specifier) => this._canAddSpecifier(sourceFile, moduleName, specifier));
                if (newImports.length === 0) {
                    affectedFiles.add(sourceFile.fileName);
                    deletedImports.add(node);
                }
                else if (newImports.length !== namedBindings.elements.length) {
                    affectedFiles.add(sourceFile.fileName);
                    updatedImportsResult.set(namedBindings, ts.factory.updateNamedImports(namedBindings, newImports));
                }
            }
        });
        // Collect all new imports to be added. Named imports, namespace imports or side-effects.
        this.newImports.forEach(({ namedImports, namespaceImports, sideEffectImports }, sourceFile) => {
            const useSingleQuotes = this.config.shouldUseSingleQuotes(sourceFile);
            const fileName = sourceFile.fileName;
            sideEffectImports.forEach((moduleName) => {
                addNewImport(fileName, ts.factory.createImportDeclaration(undefined, undefined, ts.factory.createStringLiteral(moduleName)));
            });
            namespaceImports.forEach((namespaceImport, moduleName) => {
                const newImport = ts.factory.createImportDeclaration(undefined, ts.factory.createImportClause(false, undefined, namespaceImport), ts.factory.createStringLiteral(moduleName, useSingleQuotes));
                // IMPORTANT: Set the original TS node to the `ts.ImportDeclaration`. This allows
                // downstream transforms such as tsickle to properly process references to this import.
                //
                // This operation is load-bearing in g3 as some imported modules contain special metadata
                // generated by clutz, which tsickle uses to transform imports and references to those
                // imports. See: `google3: node_modules/tsickle/src/googmodule.ts;l=637-640;rcl=615418148`
                ts.setOriginalNode(namespaceImport.name, newImport);
                addNewImport(fileName, newImport);
            });
            namedImports.forEach((specifiers, moduleName) => {
                const filteredSpecifiers = specifiers.filter((specifier) => this._canAddSpecifier(sourceFile, moduleName, specifier));
                if (filteredSpecifiers.length > 0) {
                    const newImport = ts.factory.createImportDeclaration(undefined, ts.factory.createImportClause(false, undefined, ts.factory.createNamedImports(filteredSpecifiers)), ts.factory.createStringLiteral(moduleName, useSingleQuotes));
                    addNewImport(fileName, newImport);
                }
            });
        });
        return {
            affectedFiles,
            newImports: newImportsResult,
            updatedImports: updatedImportsResult,
            reusedOriginalAliasDeclarations: this.reuseSourceFileImportsTracker.reusedAliasDeclarations,
            deletedImports,
        };
    }
    /**
     * Gets a TypeScript transform for the import manager.
     *
     * @param extraStatementsMap Additional set of statements to be inserted
     *   for given source files after their imports. E.g. top-level constants.
     */
    toTsTransform(extraStatementsMap) {
        return createTsTransformForImportManager(this, extraStatementsMap);
    }
    /**
     * Transforms a single file as a shorthand, using {@link toTsTransform}.
     *
     * @param extraStatementsMap Additional set of statements to be inserted
     *   for given source files after their imports. E.g. top-level constants.
     */
    transformTsFile(ctx, file, extraStatementsAfterImports) {
        const extraStatementsMap = extraStatementsAfterImports
            ? new Map([[file.fileName, extraStatementsAfterImports]])
            : undefined;
        return this.toTsTransform(extraStatementsMap)(ctx)(file);
    }
    _getNewImportsTrackerForFile(file) {
        if (!this.newImports.has(file)) {
            this.newImports.set(file, {
                namespaceImports: new Map(),
                namedImports: new Map(),
                sideEffectImports: new Set(),
            });
        }
        return this.newImports.get(file);
    }
    _canAddSpecifier(sourceFile, moduleSpecifier, specifier) {
        return !this.removedImports
            .get(sourceFile)
            ?.get(moduleSpecifier)
            ?.has((specifier.propertyName || specifier.name).text);
    }
}
/** Creates an import reference based on the given identifier, or nested access. */
function createImportReference(asTypeReference, ref) {
    if (asTypeReference) {
        return Array.isArray(ref) ? ts.factory.createQualifiedName(ref[0], ref[1]) : ref;
    }
    else {
        return Array.isArray(ref) ? ts.factory.createPropertyAccessExpression(ref[0], ref[1]) : ref;
    }
}

const UNARY_OPERATORS = /* @__PURE__ */ new Map([
    [o__namespace.UnaryOperator.Minus, '-'],
    [o__namespace.UnaryOperator.Plus, '+'],
]);
const BINARY_OPERATORS = /* @__PURE__ */ new Map([
    [o__namespace.BinaryOperator.And, '&&'],
    [o__namespace.BinaryOperator.Bigger, '>'],
    [o__namespace.BinaryOperator.BiggerEquals, '>='],
    [o__namespace.BinaryOperator.BitwiseAnd, '&'],
    [o__namespace.BinaryOperator.BitwiseOr, '|'],
    [o__namespace.BinaryOperator.Divide, '/'],
    [o__namespace.BinaryOperator.Equals, '=='],
    [o__namespace.BinaryOperator.Identical, '==='],
    [o__namespace.BinaryOperator.Lower, '<'],
    [o__namespace.BinaryOperator.LowerEquals, '<='],
    [o__namespace.BinaryOperator.Minus, '-'],
    [o__namespace.BinaryOperator.Modulo, '%'],
    [o__namespace.BinaryOperator.Multiply, '*'],
    [o__namespace.BinaryOperator.NotEquals, '!='],
    [o__namespace.BinaryOperator.NotIdentical, '!=='],
    [o__namespace.BinaryOperator.Or, '||'],
    [o__namespace.BinaryOperator.Plus, '+'],
    [o__namespace.BinaryOperator.NullishCoalesce, '??'],
    [o__namespace.BinaryOperator.Exponentiation, '**'],
    [o__namespace.BinaryOperator.In, 'in'],
    [o__namespace.BinaryOperator.Assign, '='],
    [o__namespace.BinaryOperator.AdditionAssignment, '+='],
    [o__namespace.BinaryOperator.SubtractionAssignment, '-='],
    [o__namespace.BinaryOperator.MultiplicationAssignment, '*='],
    [o__namespace.BinaryOperator.DivisionAssignment, '/='],
    [o__namespace.BinaryOperator.RemainderAssignment, '%='],
    [o__namespace.BinaryOperator.ExponentiationAssignment, '**='],
    [o__namespace.BinaryOperator.AndAssignment, '&&='],
    [o__namespace.BinaryOperator.OrAssignment, '||='],
    [o__namespace.BinaryOperator.NullishCoalesceAssignment, '??='],
]);
class ExpressionTranslatorVisitor {
    factory;
    imports;
    contextFile;
    downlevelTaggedTemplates;
    downlevelVariableDeclarations;
    recordWrappedNode;
    constructor(factory, imports, contextFile, options) {
        this.factory = factory;
        this.imports = imports;
        this.contextFile = contextFile;
        this.downlevelTaggedTemplates = options.downlevelTaggedTemplates === true;
        this.downlevelVariableDeclarations = options.downlevelVariableDeclarations === true;
        this.recordWrappedNode = options.recordWrappedNode || (() => { });
    }
    visitDeclareVarStmt(stmt, context) {
        const varType = this.downlevelVariableDeclarations
            ? 'var'
            : stmt.hasModifier(o__namespace.StmtModifier.Final)
                ? 'const'
                : 'let';
        return this.attachComments(this.factory.createVariableDeclaration(stmt.name, stmt.value?.visitExpression(this, context.withExpressionMode), varType), stmt.leadingComments);
    }
    visitDeclareFunctionStmt(stmt, context) {
        return this.attachComments(this.factory.createFunctionDeclaration(stmt.name, stmt.params.map((param) => param.name), this.factory.createBlock(this.visitStatements(stmt.statements, context.withStatementMode))), stmt.leadingComments);
    }
    visitExpressionStmt(stmt, context) {
        return this.attachComments(this.factory.createExpressionStatement(stmt.expr.visitExpression(this, context.withStatementMode)), stmt.leadingComments);
    }
    visitReturnStmt(stmt, context) {
        return this.attachComments(this.factory.createReturnStatement(stmt.value.visitExpression(this, context.withExpressionMode)), stmt.leadingComments);
    }
    visitIfStmt(stmt, context) {
        return this.attachComments(this.factory.createIfStatement(stmt.condition.visitExpression(this, context), this.factory.createBlock(this.visitStatements(stmt.trueCase, context.withStatementMode)), stmt.falseCase.length > 0
            ? this.factory.createBlock(this.visitStatements(stmt.falseCase, context.withStatementMode))
            : null), stmt.leadingComments);
    }
    visitReadVarExpr(ast, _context) {
        const identifier = this.factory.createIdentifier(ast.name);
        this.setSourceMapRange(identifier, ast.sourceSpan);
        return identifier;
    }
    visitInvokeFunctionExpr(ast, context) {
        return this.setSourceMapRange(this.factory.createCallExpression(ast.fn.visitExpression(this, context), ast.args.map((arg) => arg.visitExpression(this, context)), ast.pure), ast.sourceSpan);
    }
    visitTaggedTemplateLiteralExpr(ast, context) {
        return this.setSourceMapRange(this.createTaggedTemplateExpression(ast.tag.visitExpression(this, context), this.getTemplateLiteralFromAst(ast.template, context)), ast.sourceSpan);
    }
    visitTemplateLiteralExpr(ast, context) {
        return this.setSourceMapRange(this.factory.createTemplateLiteral(this.getTemplateLiteralFromAst(ast, context)), ast.sourceSpan);
    }
    visitInstantiateExpr(ast, context) {
        return this.factory.createNewExpression(ast.classExpr.visitExpression(this, context), ast.args.map((arg) => arg.visitExpression(this, context)));
    }
    visitLiteralExpr(ast, _context) {
        return this.setSourceMapRange(this.factory.createLiteral(ast.value), ast.sourceSpan);
    }
    visitRegularExpressionLiteral(ast, context) {
        return this.setSourceMapRange(this.factory.createRegularExpressionLiteral(ast.body, ast.flags), ast.sourceSpan);
    }
    visitLocalizedString(ast, context) {
        // A `$localize` message consists of `messageParts` and `expressions`, which get interleaved
        // together. The interleaved pieces look like:
        // `[messagePart0, expression0, messagePart1, expression1, messagePart2]`
        //
        // Note that there is always a message part at the start and end, and so therefore
        // `messageParts.length === expressions.length + 1`.
        //
        // Each message part may be prefixed with "metadata", which is wrapped in colons (:) delimiters.
        // The metadata is attached to the first and subsequent message parts by calls to
        // `serializeI18nHead()` and `serializeI18nTemplatePart()` respectively.
        //
        // The first message part (i.e. `ast.messageParts[0]`) is used to initialize `messageParts`
        // array.
        const elements = [createTemplateElement(ast.serializeI18nHead())];
        const expressions = [];
        for (let i = 0; i < ast.expressions.length; i++) {
            const placeholder = this.setSourceMapRange(ast.expressions[i].visitExpression(this, context), ast.getPlaceholderSourceSpan(i));
            expressions.push(placeholder);
            elements.push(createTemplateElement(ast.serializeI18nTemplatePart(i + 1)));
        }
        const localizeTag = this.factory.createIdentifier('$localize');
        return this.setSourceMapRange(this.createTaggedTemplateExpression(localizeTag, { elements, expressions }), ast.sourceSpan);
    }
    createTaggedTemplateExpression(tag, template) {
        return this.downlevelTaggedTemplates
            ? this.createES5TaggedTemplateFunctionCall(tag, template)
            : this.factory.createTaggedTemplate(tag, template);
    }
    /**
     * Translate the tagged template literal into a call that is compatible with ES5, using the
     * imported `__makeTemplateObject` helper for ES5 formatted output.
     */
    createES5TaggedTemplateFunctionCall(tagHandler, { elements, expressions }) {
        // Ensure that the `__makeTemplateObject()` helper has been imported.
        const __makeTemplateObjectHelper = this.imports.addImport({
            exportModuleSpecifier: 'tslib',
            exportSymbolName: '__makeTemplateObject',
            requestedFile: this.contextFile,
        });
        // Collect up the cooked and raw strings into two separate arrays.
        const cooked = [];
        const raw = [];
        for (const element of elements) {
            cooked.push(this.factory.setSourceMapRange(this.factory.createLiteral(element.cooked), element.range));
            raw.push(this.factory.setSourceMapRange(this.factory.createLiteral(element.raw), element.range));
        }
        // Generate the helper call in the form: `__makeTemplateObject([cooked], [raw]);`
        const templateHelperCall = this.factory.createCallExpression(__makeTemplateObjectHelper, [this.factory.createArrayLiteral(cooked), this.factory.createArrayLiteral(raw)], 
        /* pure */ false);
        // Finally create the tagged handler call in the form:
        // `tag(__makeTemplateObject([cooked], [raw]), ...expressions);`
        return this.factory.createCallExpression(tagHandler, [templateHelperCall, ...expressions], 
        /* pure */ false);
    }
    visitExternalExpr(ast, _context) {
        if (ast.value.name === null) {
            if (ast.value.moduleName === null) {
                throw new Error('Invalid import without name nor moduleName');
            }
            return this.imports.addImport({
                exportModuleSpecifier: ast.value.moduleName,
                exportSymbolName: null,
                requestedFile: this.contextFile,
            });
        }
        // If a moduleName is specified, this is a normal import. If there's no module name, it's a
        // reference to a global/ambient symbol.
        if (ast.value.moduleName !== null) {
            // This is a normal import. Find the imported module.
            return this.imports.addImport({
                exportModuleSpecifier: ast.value.moduleName,
                exportSymbolName: ast.value.name,
                requestedFile: this.contextFile,
            });
        }
        else {
            // The symbol is ambient, so just reference it.
            return this.factory.createIdentifier(ast.value.name);
        }
    }
    visitConditionalExpr(ast, context) {
        return this.factory.createConditional(ast.condition.visitExpression(this, context), ast.trueCase.visitExpression(this, context), ast.falseCase.visitExpression(this, context));
    }
    visitDynamicImportExpr(ast, context) {
        const urlExpression = typeof ast.url === 'string'
            ? this.factory.createLiteral(ast.url)
            : ast.url.visitExpression(this, context);
        if (ast.urlComment) {
            this.factory.attachComments(urlExpression, [o__namespace.leadingComment(ast.urlComment, true)]);
        }
        return this.factory.createDynamicImport(urlExpression);
    }
    visitNotExpr(ast, context) {
        return this.factory.createUnaryExpression('!', ast.condition.visitExpression(this, context));
    }
    visitFunctionExpr(ast, context) {
        return this.factory.createFunctionExpression(ast.name ?? null, ast.params.map((param) => param.name), this.factory.createBlock(this.visitStatements(ast.statements, context)));
    }
    visitArrowFunctionExpr(ast, context) {
        return this.factory.createArrowFunctionExpression(ast.params.map((param) => param.name), Array.isArray(ast.body)
            ? this.factory.createBlock(this.visitStatements(ast.body, context))
            : ast.body.visitExpression(this, context));
    }
    visitBinaryOperatorExpr(ast, context) {
        if (!BINARY_OPERATORS.has(ast.operator)) {
            throw new Error(`Unknown binary operator: ${o__namespace.BinaryOperator[ast.operator]}`);
        }
        const operator = BINARY_OPERATORS.get(ast.operator);
        if (ast.isAssignment()) {
            return this.factory.createAssignment(ast.lhs.visitExpression(this, context), operator, ast.rhs.visitExpression(this, context));
        }
        return this.factory.createBinaryExpression(ast.lhs.visitExpression(this, context), operator, ast.rhs.visitExpression(this, context));
    }
    visitReadPropExpr(ast, context) {
        return this.factory.createPropertyAccess(ast.receiver.visitExpression(this, context), ast.name);
    }
    visitReadKeyExpr(ast, context) {
        return this.factory.createElementAccess(ast.receiver.visitExpression(this, context), ast.index.visitExpression(this, context));
    }
    visitLiteralArrayExpr(ast, context) {
        return this.factory.createArrayLiteral(ast.entries.map((expr) => this.setSourceMapRange(expr.visitExpression(this, context), ast.sourceSpan)));
    }
    visitLiteralMapExpr(ast, context) {
        const properties = ast.entries.map((entry) => {
            return {
                propertyName: entry.key,
                quoted: entry.quoted,
                value: entry.value.visitExpression(this, context),
            };
        });
        return this.setSourceMapRange(this.factory.createObjectLiteral(properties), ast.sourceSpan);
    }
    visitCommaExpr(ast, context) {
        throw new Error('Method not implemented.');
    }
    visitTemplateLiteralElementExpr(ast, context) {
        throw new Error('Method not implemented');
    }
    visitWrappedNodeExpr(ast, _context) {
        this.recordWrappedNode(ast);
        return ast.node;
    }
    visitTypeofExpr(ast, context) {
        return this.factory.createTypeOfExpression(ast.expr.visitExpression(this, context));
    }
    visitVoidExpr(ast, context) {
        return this.factory.createVoidExpression(ast.expr.visitExpression(this, context));
    }
    visitUnaryOperatorExpr(ast, context) {
        if (!UNARY_OPERATORS.has(ast.operator)) {
            throw new Error(`Unknown unary operator: ${o__namespace.UnaryOperator[ast.operator]}`);
        }
        return this.factory.createUnaryExpression(UNARY_OPERATORS.get(ast.operator), ast.expr.visitExpression(this, context));
    }
    visitParenthesizedExpr(ast, context) {
        const result = ast.expr.visitExpression(this, context);
        return this.factory.createParenthesizedExpression(result);
    }
    visitStatements(statements, context) {
        return statements
            .map((stmt) => stmt.visitStatement(this, context))
            .filter((stmt) => stmt !== undefined);
    }
    setSourceMapRange(ast, span) {
        return this.factory.setSourceMapRange(ast, createRange(span));
    }
    attachComments(statement, leadingComments) {
        if (leadingComments !== undefined) {
            this.factory.attachComments(statement, leadingComments);
        }
        return statement;
    }
    getTemplateLiteralFromAst(ast, context) {
        return {
            elements: ast.elements.map((e) => createTemplateElement({
                cooked: e.text,
                raw: e.rawText,
                range: e.sourceSpan ?? ast.sourceSpan,
            })),
            expressions: ast.expressions.map((e) => e.visitExpression(this, context)),
        };
    }
}
/**
 * Convert a cooked-raw string object into one that can be used by the AST factories.
 */
function createTemplateElement({ cooked, raw, range, }) {
    return { cooked, raw, range: createRange(range) };
}
/**
 * Convert an OutputAST source-span into a range that can be used by the AST factories.
 */
function createRange(span) {
    if (span === null) {
        return null;
    }
    const { start, end } = span;
    const { url, content } = start.file;
    if (!url) {
        return null;
    }
    return {
        url,
        content,
        start: { offset: start.offset, line: start.line, column: start.col },
        end: { offset: end.offset, line: end.line, column: end.col },
    };
}

const INELIGIBLE = {};
/**
 * Determines whether the provided type can be emitted, which means that it can be safely emitted
 * into a different location.
 *
 * If this function returns true, a `TypeEmitter` should be able to succeed. Vice versa, if this
 * function returns false, then using the `TypeEmitter` should not be attempted as it is known to
 * fail.
 */
function canEmitType(type, canEmit) {
    return canEmitTypeWorker(type);
    function canEmitTypeWorker(type) {
        return visitNode(type) !== INELIGIBLE;
    }
    // To determine whether a type can be emitted, we have to recursively look through all type nodes.
    // If an unsupported type node is found at any position within the type, then the `INELIGIBLE`
    // constant is returned to stop the recursive walk as the type as a whole cannot be emitted in
    // that case. Otherwise, the result of visiting all child nodes determines the result. If no
    // ineligible type reference node is found then the walk returns `undefined`, indicating that
    // no type node was visited that could not be emitted.
    function visitNode(node) {
        // `import('module')` type nodes are not supported, as it may require rewriting the module
        // specifier which is currently not done.
        if (ts.isImportTypeNode(node)) {
            return INELIGIBLE;
        }
        // Emitting a type reference node in a different context requires that an import for the type
        // can be created. If a type reference node cannot be emitted, `INELIGIBLE` is returned to stop
        // the walk.
        if (ts.isTypeReferenceNode(node) && !canEmitTypeReference(node)) {
            return INELIGIBLE;
        }
        else {
            return ts.forEachChild(node, visitNode);
        }
    }
    function canEmitTypeReference(type) {
        if (!canEmit(type)) {
            return false;
        }
        // The type can be emitted if either it does not have any type arguments, or all of them can be
        // emitted.
        return type.typeArguments === undefined || type.typeArguments.every(canEmitTypeWorker);
    }
}
/**
 * Given a `ts.TypeNode`, this class derives an equivalent `ts.TypeNode` that has been emitted into
 * a different context.
 *
 * For example, consider the following code:
 *
 * ```ts
 * import {NgIterable} from '@angular/core';
 *
 * class NgForOf<T, U extends NgIterable<T>> {}
 * ```
 *
 * Here, the generic type parameters `T` and `U` can be emitted into a different context, as the
 * type reference to `NgIterable` originates from an absolute module import so that it can be
 * emitted anywhere, using that same module import. The process of emitting translates the
 * `NgIterable` type reference to a type reference that is valid in the context in which it is
 * emitted, for example:
 *
 * ```ts
 * import * as i0 from '@angular/core';
 * import * as i1 from '@angular/common';
 *
 * const _ctor1: <T, U extends i0.NgIterable<T>>(o: Pick<i1.NgForOf<T, U>, 'ngForOf'>):
 * i1.NgForOf<T, U>;
 * ```
 *
 * Notice how the type reference for `NgIterable` has been translated into a qualified name,
 * referring to the namespace import that was created.
 */
class TypeEmitter {
    translator;
    constructor(translator) {
        this.translator = translator;
    }
    emitType(type) {
        const typeReferenceTransformer = (context) => {
            const visitNode = (node) => {
                if (ts.isImportTypeNode(node)) {
                    throw new Error('Unable to emit import type');
                }
                if (ts.isTypeReferenceNode(node)) {
                    return this.emitTypeReference(node);
                }
                else if (ts.isLiteralExpression(node)) {
                    // TypeScript would typically take the emit text for a literal expression from the source
                    // file itself. As the type node is being emitted into a different file, however,
                    // TypeScript would extract the literal text from the wrong source file. To mitigate this
                    // issue the literal is cloned and explicitly marked as synthesized by setting its text
                    // range to a negative range, forcing TypeScript to determine the node's literal text from
                    // the synthesized node's text instead of the incorrect source file.
                    let clone;
                    if (ts.isStringLiteral(node)) {
                        clone = ts.factory.createStringLiteral(node.text);
                    }
                    else if (ts.isNumericLiteral(node)) {
                        clone = ts.factory.createNumericLiteral(node.text);
                    }
                    else if (ts.isBigIntLiteral(node)) {
                        clone = ts.factory.createBigIntLiteral(node.text);
                    }
                    else if (ts.isNoSubstitutionTemplateLiteral(node)) {
                        clone = ts.factory.createNoSubstitutionTemplateLiteral(node.text, node.rawText);
                    }
                    else if (ts.isRegularExpressionLiteral(node)) {
                        clone = ts.factory.createRegularExpressionLiteral(node.text);
                    }
                    else {
                        throw new Error(`Unsupported literal kind ${ts.SyntaxKind[node.kind]}`);
                    }
                    ts.setTextRange(clone, { pos: -1, end: -1 });
                    return clone;
                }
                else {
                    return ts.visitEachChild(node, visitNode, context);
                }
            };
            return (node) => ts.visitNode(node, visitNode, ts.isTypeNode);
        };
        return ts.transform(type, [typeReferenceTransformer]).transformed[0];
    }
    emitTypeReference(type) {
        // Determine the reference that the type corresponds with.
        const translatedType = this.translator(type);
        if (translatedType === null) {
            throw new Error('Unable to emit an unresolved reference');
        }
        // Emit the type arguments, if any.
        let typeArguments = undefined;
        if (type.typeArguments !== undefined) {
            typeArguments = ts.factory.createNodeArray(type.typeArguments.map((typeArg) => this.emitType(typeArg)));
        }
        return ts.factory.updateTypeReferenceNode(type, translatedType.typeName, typeArguments);
    }
}

/*!
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.dev/license
 */
/**
 * Creates a TypeScript node representing a numeric value.
 */
function tsNumericExpression$1(value) {
    // As of TypeScript 5.3 negative numbers are represented as `prefixUnaryOperator` and passing a
    // negative number (even as a string) into `createNumericLiteral` will result in an error.
    if (value < 0) {
        const operand = ts.factory.createNumericLiteral(Math.abs(value));
        return ts.factory.createPrefixUnaryExpression(ts.SyntaxKind.MinusToken, operand);
    }
    return ts.factory.createNumericLiteral(value);
}

function translateType(type, contextFile, reflector, refEmitter, imports) {
    return type.visitType(new TypeTranslatorVisitor(imports, contextFile, reflector, refEmitter), new Context$1(false));
}
class TypeTranslatorVisitor {
    imports;
    contextFile;
    reflector;
    refEmitter;
    constructor(imports, contextFile, reflector, refEmitter) {
        this.imports = imports;
        this.contextFile = contextFile;
        this.reflector = reflector;
        this.refEmitter = refEmitter;
    }
    visitBuiltinType(type, context) {
        switch (type.name) {
            case o__namespace.BuiltinTypeName.Bool:
                return ts.factory.createKeywordTypeNode(ts.SyntaxKind.BooleanKeyword);
            case o__namespace.BuiltinTypeName.Dynamic:
                return ts.factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword);
            case o__namespace.BuiltinTypeName.Int:
            case o__namespace.BuiltinTypeName.Number:
                return ts.factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword);
            case o__namespace.BuiltinTypeName.String:
                return ts.factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword);
            case o__namespace.BuiltinTypeName.None:
                return ts.factory.createKeywordTypeNode(ts.SyntaxKind.NeverKeyword);
            default:
                throw new Error(`Unsupported builtin type: ${o__namespace.BuiltinTypeName[type.name]}`);
        }
    }
    visitExpressionType(type, context) {
        const typeNode = this.translateExpression(type.value, context);
        if (type.typeParams === null) {
            return typeNode;
        }
        if (!ts.isTypeReferenceNode(typeNode)) {
            throw new Error('An ExpressionType with type arguments must translate into a TypeReferenceNode');
        }
        else if (typeNode.typeArguments !== undefined) {
            throw new Error(`An ExpressionType with type arguments cannot have multiple levels of type arguments`);
        }
        const typeArgs = type.typeParams.map((param) => this.translateType(param, context));
        return ts.factory.createTypeReferenceNode(typeNode.typeName, typeArgs);
    }
    visitArrayType(type, context) {
        return ts.factory.createArrayTypeNode(this.translateType(type.of, context));
    }
    visitMapType(type, context) {
        const parameter = ts.factory.createParameterDeclaration(undefined, undefined, 'key', undefined, ts.factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword));
        const typeArgs = type.valueType !== null
            ? this.translateType(type.valueType, context)
            : ts.factory.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword);
        const indexSignature = ts.factory.createIndexSignature(undefined, [parameter], typeArgs);
        return ts.factory.createTypeLiteralNode([indexSignature]);
    }
    visitTransplantedType(ast, context) {
        const node = ast.type instanceof Reference ? ast.type.node : ast.type;
        if (!ts.isTypeNode(node)) {
            throw new Error(`A TransplantedType must wrap a TypeNode`);
        }
        const viaModule = ast.type instanceof Reference ? ast.type.bestGuessOwningModule : null;
        const emitter = new TypeEmitter((typeRef) => this.translateTypeReference(typeRef, context, viaModule));
        return emitter.emitType(node);
    }
    visitReadVarExpr(ast, context) {
        if (ast.name === null) {
            throw new Error(`ReadVarExpr with no variable name in type`);
        }
        return ts.factory.createTypeQueryNode(ts.factory.createIdentifier(ast.name));
    }
    visitInvokeFunctionExpr(ast, context) {
        throw new Error('Method not implemented.');
    }
    visitTaggedTemplateLiteralExpr(ast, context) {
        throw new Error('Method not implemented.');
    }
    visitTemplateLiteralExpr(ast, context) {
        throw new Error('Method not implemented.');
    }
    visitTemplateLiteralElementExpr(ast, context) {
        throw new Error('Method not implemented.');
    }
    visitInstantiateExpr(ast, context) {
        throw new Error('Method not implemented.');
    }
    visitLiteralExpr(ast, context) {
        if (ast.value === null) {
            return ts.factory.createLiteralTypeNode(ts.factory.createNull());
        }
        else if (ast.value === undefined) {
            return ts.factory.createKeywordTypeNode(ts.SyntaxKind.UndefinedKeyword);
        }
        else if (typeof ast.value === 'boolean') {
            return ts.factory.createLiteralTypeNode(ast.value ? ts.factory.createTrue() : ts.factory.createFalse());
        }
        else if (typeof ast.value === 'number') {
            return ts.factory.createLiteralTypeNode(tsNumericExpression$1(ast.value));
        }
        else {
            return ts.factory.createLiteralTypeNode(ts.factory.createStringLiteral(ast.value));
        }
    }
    visitLocalizedString(ast, context) {
        throw new Error('Method not implemented.');
    }
    visitExternalExpr(ast, context) {
        if (ast.value.moduleName === null || ast.value.name === null) {
            throw new Error(`Import unknown module or symbol`);
        }
        const typeName = this.imports.addImport({
            exportModuleSpecifier: ast.value.moduleName,
            exportSymbolName: ast.value.name,
            requestedFile: this.contextFile,
            asTypeReference: true,
        });
        const typeArguments = ast.typeParams !== null
            ? ast.typeParams.map((type) => this.translateType(type, context))
            : undefined;
        return ts.factory.createTypeReferenceNode(typeName, typeArguments);
    }
    visitConditionalExpr(ast, context) {
        throw new Error('Method not implemented.');
    }
    visitDynamicImportExpr(ast, context) {
        throw new Error('Method not implemented.');
    }
    visitRegularExpressionLiteral(ast, context) {
        throw new Error('Method not implemented.');
    }
    visitNotExpr(ast, context) {
        throw new Error('Method not implemented.');
    }
    visitFunctionExpr(ast, context) {
        throw new Error('Method not implemented.');
    }
    visitArrowFunctionExpr(ast, context) {
        throw new Error('Method not implemented.');
    }
    visitUnaryOperatorExpr(ast, context) {
        throw new Error('Method not implemented.');
    }
    visitBinaryOperatorExpr(ast, context) {
        throw new Error('Method not implemented.');
    }
    visitReadPropExpr(ast, context) {
        throw new Error('Method not implemented.');
    }
    visitReadKeyExpr(ast, context) {
        throw new Error('Method not implemented.');
    }
    visitLiteralArrayExpr(ast, context) {
        const values = ast.entries.map((expr) => this.translateExpression(expr, context));
        return ts.factory.createTupleTypeNode(values);
    }
    visitLiteralMapExpr(ast, context) {
        const entries = ast.entries.map((entry) => {
            const { key, quoted } = entry;
            const type = this.translateExpression(entry.value, context);
            return ts.factory.createPropertySignature(
            /* modifiers */ undefined, 
            /* name */ quoted ? ts.factory.createStringLiteral(key) : key, 
            /* questionToken */ undefined, 
            /* type */ type);
        });
        return ts.factory.createTypeLiteralNode(entries);
    }
    visitCommaExpr(ast, context) {
        throw new Error('Method not implemented.');
    }
    visitWrappedNodeExpr(ast, context) {
        const node = ast.node;
        if (ts.isEntityName(node)) {
            return ts.factory.createTypeReferenceNode(node, /* typeArguments */ undefined);
        }
        else if (ts.isTypeNode(node)) {
            return node;
        }
        else if (ts.isLiteralExpression(node)) {
            return ts.factory.createLiteralTypeNode(node);
        }
        else {
            throw new Error(`Unsupported WrappedNodeExpr in TypeTranslatorVisitor: ${ts.SyntaxKind[node.kind]}`);
        }
    }
    visitTypeofExpr(ast, context) {
        const typeNode = this.translateExpression(ast.expr, context);
        if (!ts.isTypeReferenceNode(typeNode)) {
            throw new Error(`The target of a typeof expression must be a type reference, but it was
          ${ts.SyntaxKind[typeNode.kind]}`);
        }
        return ts.factory.createTypeQueryNode(typeNode.typeName);
    }
    visitVoidExpr(ast, context) {
        throw new Error('Method not implemented.');
    }
    visitParenthesizedExpr(ast, context) {
        throw new Error('Method not implemented.');
    }
    translateType(type, context) {
        const typeNode = type.visitType(this, context);
        if (!ts.isTypeNode(typeNode)) {
            throw new Error(`A Type must translate to a TypeNode, but was ${ts.SyntaxKind[typeNode.kind]}`);
        }
        return typeNode;
    }
    translateExpression(expr, context) {
        const typeNode = expr.visitExpression(this, context);
        if (!ts.isTypeNode(typeNode)) {
            throw new Error(`An Expression must translate to a TypeNode, but was ${ts.SyntaxKind[typeNode.kind]}`);
        }
        return typeNode;
    }
    translateTypeReference(type, context, viaModule) {
        const target = ts.isIdentifier(type.typeName) ? type.typeName : type.typeName.right;
        const declaration = this.reflector.getDeclarationOfIdentifier(target);
        if (declaration === null) {
            throw new Error(`Unable to statically determine the declaration file of type node ${target.text}`);
        }
        let owningModule = viaModule;
        if (typeof declaration.viaModule === 'string') {
            owningModule = {
                specifier: declaration.viaModule,
                resolutionContext: type.getSourceFile().fileName,
            };
        }
        const reference = new Reference(declaration.node, declaration.viaModule === AmbientImport ? AmbientImport : owningModule);
        const emittedType = this.refEmitter.emit(reference, this.contextFile, ImportFlags.NoAliasing | ImportFlags.AllowTypeImports | ImportFlags.AllowAmbientReferences);
        assertSuccessfulReferenceEmit(emittedType, target, 'type');
        const typeNode = this.translateExpression(emittedType.expression, context);
        if (!ts.isTypeReferenceNode(typeNode)) {
            throw new Error(`Expected TypeReferenceNode for emitted reference, got ${ts.SyntaxKind[typeNode.kind]}.`);
        }
        return typeNode;
    }
}

/**
 * Different optimizers use different annotations on a function or method call to indicate its pure
 * status.
 */
var PureAnnotation;
(function (PureAnnotation) {
    /**
     * Closure's annotation for purity is `@pureOrBreakMyCode`, but this needs to be in a semantic
     * (jsdoc) enabled comment. Thus, the actual comment text for Closure must include the `*` that
     * turns a `/*` comment into a `/**` comment, as well as surrounding whitespace.
     */
    PureAnnotation["CLOSURE"] = "* @pureOrBreakMyCode ";
    PureAnnotation["TERSER"] = "@__PURE__";
})(PureAnnotation || (PureAnnotation = {}));
/**
 * A TypeScript flavoured implementation of the AstFactory.
 */
class TypeScriptAstFactory {
    annotateForClosureCompiler;
    externalSourceFiles = new Map();
    UNARY_OPERATORS = 
    /* @__PURE__ */ (() => ({
        '+': ts.SyntaxKind.PlusToken,
        '-': ts.SyntaxKind.MinusToken,
        '!': ts.SyntaxKind.ExclamationToken,
    }))();
    BINARY_OPERATORS = 
    /* @__PURE__ */ (() => ({
        '&&': ts.SyntaxKind.AmpersandAmpersandToken,
        '>': ts.SyntaxKind.GreaterThanToken,
        '>=': ts.SyntaxKind.GreaterThanEqualsToken,
        '&': ts.SyntaxKind.AmpersandToken,
        '|': ts.SyntaxKind.BarToken,
        '/': ts.SyntaxKind.SlashToken,
        '==': ts.SyntaxKind.EqualsEqualsToken,
        '===': ts.SyntaxKind.EqualsEqualsEqualsToken,
        '<': ts.SyntaxKind.LessThanToken,
        '<=': ts.SyntaxKind.LessThanEqualsToken,
        '-': ts.SyntaxKind.MinusToken,
        '%': ts.SyntaxKind.PercentToken,
        '*': ts.SyntaxKind.AsteriskToken,
        '**': ts.SyntaxKind.AsteriskAsteriskToken,
        '!=': ts.SyntaxKind.ExclamationEqualsToken,
        '!==': ts.SyntaxKind.ExclamationEqualsEqualsToken,
        '||': ts.SyntaxKind.BarBarToken,
        '+': ts.SyntaxKind.PlusToken,
        '??': ts.SyntaxKind.QuestionQuestionToken,
        'in': ts.SyntaxKind.InKeyword,
        '=': ts.SyntaxKind.EqualsToken,
        '+=': ts.SyntaxKind.PlusEqualsToken,
        '-=': ts.SyntaxKind.MinusEqualsToken,
        '*=': ts.SyntaxKind.AsteriskEqualsToken,
        '/=': ts.SyntaxKind.SlashEqualsToken,
        '%=': ts.SyntaxKind.PercentEqualsToken,
        '**=': ts.SyntaxKind.AsteriskAsteriskEqualsToken,
        '&&=': ts.SyntaxKind.AmpersandAmpersandEqualsToken,
        '||=': ts.SyntaxKind.BarBarEqualsToken,
        '??=': ts.SyntaxKind.QuestionQuestionEqualsToken,
    }))();
    VAR_TYPES = 
    /* @__PURE__ */ (() => ({
        'const': ts.NodeFlags.Const,
        'let': ts.NodeFlags.Let,
        'var': ts.NodeFlags.None,
    }))();
    constructor(annotateForClosureCompiler) {
        this.annotateForClosureCompiler = annotateForClosureCompiler;
    }
    attachComments = attachComments;
    createArrayLiteral = ts.factory.createArrayLiteralExpression;
    createAssignment(target, operator, value) {
        return ts.factory.createBinaryExpression(target, this.BINARY_OPERATORS[operator], value);
    }
    createBinaryExpression(leftOperand, operator, rightOperand) {
        return ts.factory.createBinaryExpression(leftOperand, this.BINARY_OPERATORS[operator], rightOperand);
    }
    createBlock(body) {
        return ts.factory.createBlock(body);
    }
    createCallExpression(callee, args, pure) {
        const call = ts.factory.createCallExpression(callee, undefined, args);
        if (pure) {
            ts.addSyntheticLeadingComment(call, ts.SyntaxKind.MultiLineCommentTrivia, this.annotateForClosureCompiler ? PureAnnotation.CLOSURE : PureAnnotation.TERSER, 
            /* trailing newline */ false);
        }
        return call;
    }
    createConditional(condition, whenTrue, whenFalse) {
        return ts.factory.createConditionalExpression(condition, undefined, whenTrue, undefined, whenFalse);
    }
    createElementAccess = ts.factory.createElementAccessExpression;
    createExpressionStatement = ts.factory.createExpressionStatement;
    createDynamicImport(url) {
        return ts.factory.createCallExpression(ts.factory.createToken(ts.SyntaxKind.ImportKeyword), 
        /* type */ undefined, [typeof url === 'string' ? ts.factory.createStringLiteral(url) : url]);
    }
    createFunctionDeclaration(functionName, parameters, body) {
        if (!ts.isBlock(body)) {
            throw new Error(`Invalid syntax, expected a block, but got ${ts.SyntaxKind[body.kind]}.`);
        }
        return ts.factory.createFunctionDeclaration(undefined, undefined, functionName, undefined, parameters.map((param) => ts.factory.createParameterDeclaration(undefined, undefined, param)), undefined, body);
    }
    createFunctionExpression(functionName, parameters, body) {
        if (!ts.isBlock(body)) {
            throw new Error(`Invalid syntax, expected a block, but got ${ts.SyntaxKind[body.kind]}.`);
        }
        return ts.factory.createFunctionExpression(undefined, undefined, functionName ?? undefined, undefined, parameters.map((param) => ts.factory.createParameterDeclaration(undefined, undefined, param)), undefined, body);
    }
    createArrowFunctionExpression(parameters, body) {
        if (ts.isStatement(body) && !ts.isBlock(body)) {
            throw new Error(`Invalid syntax, expected a block, but got ${ts.SyntaxKind[body.kind]}.`);
        }
        return ts.factory.createArrowFunction(undefined, undefined, parameters.map((param) => ts.factory.createParameterDeclaration(undefined, undefined, param)), undefined, undefined, body);
    }
    createIdentifier = ts.factory.createIdentifier;
    createIfStatement(condition, thenStatement, elseStatement) {
        return ts.factory.createIfStatement(condition, thenStatement, elseStatement ?? undefined);
    }
    createLiteral(value) {
        if (value === undefined) {
            return ts.factory.createIdentifier('undefined');
        }
        else if (value === null) {
            return ts.factory.createNull();
        }
        else if (typeof value === 'boolean') {
            return value ? ts.factory.createTrue() : ts.factory.createFalse();
        }
        else if (typeof value === 'number') {
            return tsNumericExpression$1(value);
        }
        else {
            return ts.factory.createStringLiteral(value);
        }
    }
    createNewExpression(expression, args) {
        return ts.factory.createNewExpression(expression, undefined, args);
    }
    createObjectLiteral(properties) {
        return ts.factory.createObjectLiteralExpression(properties.map((prop) => ts.factory.createPropertyAssignment(prop.quoted
            ? ts.factory.createStringLiteral(prop.propertyName)
            : ts.factory.createIdentifier(prop.propertyName), prop.value)));
    }
    createParenthesizedExpression = ts.factory.createParenthesizedExpression;
    createPropertyAccess = ts.factory.createPropertyAccessExpression;
    createReturnStatement(expression) {
        return ts.factory.createReturnStatement(expression ?? undefined);
    }
    createTaggedTemplate(tag, template) {
        return ts.factory.createTaggedTemplateExpression(tag, undefined, this.createTemplateLiteral(template));
    }
    createTemplateLiteral(template) {
        let templateLiteral;
        const length = template.elements.length;
        const head = template.elements[0];
        if (length === 1) {
            templateLiteral = ts.factory.createNoSubstitutionTemplateLiteral(head.cooked, head.raw);
        }
        else {
            const spans = [];
            // Create the middle parts
            for (let i = 1; i < length - 1; i++) {
                const { cooked, raw, range } = template.elements[i];
                const middle = createTemplateMiddle(cooked, raw);
                if (range !== null) {
                    this.setSourceMapRange(middle, range);
                }
                spans.push(ts.factory.createTemplateSpan(template.expressions[i - 1], middle));
            }
            // Create the tail part
            const resolvedExpression = template.expressions[length - 2];
            const templatePart = template.elements[length - 1];
            const templateTail = createTemplateTail(templatePart.cooked, templatePart.raw);
            if (templatePart.range !== null) {
                this.setSourceMapRange(templateTail, templatePart.range);
            }
            spans.push(ts.factory.createTemplateSpan(resolvedExpression, templateTail));
            // Put it all together
            templateLiteral = ts.factory.createTemplateExpression(ts.factory.createTemplateHead(head.cooked, head.raw), spans);
        }
        if (head.range !== null) {
            this.setSourceMapRange(templateLiteral, head.range);
        }
        return templateLiteral;
    }
    createThrowStatement = ts.factory.createThrowStatement;
    createTypeOfExpression = ts.factory.createTypeOfExpression;
    createVoidExpression = ts.factory.createVoidExpression;
    createUnaryExpression(operator, operand) {
        return ts.factory.createPrefixUnaryExpression(this.UNARY_OPERATORS[operator], operand);
    }
    createVariableDeclaration(variableName, initializer, type) {
        return ts.factory.createVariableStatement(undefined, ts.factory.createVariableDeclarationList([
            ts.factory.createVariableDeclaration(variableName, undefined, undefined, initializer ?? undefined),
        ], this.VAR_TYPES[type]));
    }
    createRegularExpressionLiteral(body, flags) {
        return ts.factory.createRegularExpressionLiteral(`/${body}/${flags ?? ''}`);
    }
    setSourceMapRange(node, sourceMapRange) {
        if (sourceMapRange === null) {
            return node;
        }
        const url = sourceMapRange.url;
        if (!this.externalSourceFiles.has(url)) {
            this.externalSourceFiles.set(url, ts.createSourceMapSource(url, sourceMapRange.content, (pos) => pos));
        }
        const source = this.externalSourceFiles.get(url);
        ts.setSourceMapRange(node, {
            pos: sourceMapRange.start.offset,
            end: sourceMapRange.end.offset,
            source,
        });
        return node;
    }
}
// HACK: Use this in place of `ts.createTemplateMiddle()`.
// Revert once https://github.com/microsoft/TypeScript/issues/35374 is fixed.
function createTemplateMiddle(cooked, raw) {
    const node = ts.factory.createTemplateHead(cooked, raw);
    node.kind = ts.SyntaxKind.TemplateMiddle;
    return node;
}
// HACK: Use this in place of `ts.createTemplateTail()`.
// Revert once https://github.com/microsoft/TypeScript/issues/35374 is fixed.
function createTemplateTail(cooked, raw) {
    const node = ts.factory.createTemplateHead(cooked, raw);
    node.kind = ts.SyntaxKind.TemplateTail;
    return node;
}
/**
 * Attach the given `leadingComments` to the `statement` node.
 *
 * @param statement The statement that will have comments attached.
 * @param leadingComments The comments to attach to the statement.
 */
function attachComments(statement, leadingComments) {
    for (const comment of leadingComments) {
        const commentKind = comment.multiline
            ? ts.SyntaxKind.MultiLineCommentTrivia
            : ts.SyntaxKind.SingleLineCommentTrivia;
        if (comment.multiline) {
            ts.addSyntheticLeadingComment(statement, commentKind, comment.toString(), comment.trailingNewline);
        }
        else {
            for (const line of comment.toString().split('\n')) {
                ts.addSyntheticLeadingComment(statement, commentKind, line, comment.trailingNewline);
            }
        }
    }
}

function translateExpression(contextFile, expression, imports, options = {}) {
    return expression.visitExpression(new ExpressionTranslatorVisitor(new TypeScriptAstFactory(options.annotateForClosureCompiler === true), imports, contextFile, options), new Context$1(false));
}
function translateStatement(contextFile, statement, imports, options = {}) {
    return statement.visitStatement(new ExpressionTranslatorVisitor(new TypeScriptAstFactory(options.annotateForClosureCompiler === true), imports, contextFile, options), new Context$1(true));
}

/**
 * Keeps track of `DtsTransform`s per source file, so that it is known which source files need to
 * have their declaration file transformed.
 */
class DtsTransformRegistry {
    ivyDeclarationTransforms = new Map();
    getIvyDeclarationTransform(sf) {
        if (!this.ivyDeclarationTransforms.has(sf)) {
            this.ivyDeclarationTransforms.set(sf, new IvyDeclarationDtsTransform());
        }
        return this.ivyDeclarationTransforms.get(sf);
    }
    /**
     * Gets the dts transforms to be applied for the given source file, or `null` if no transform is
     * necessary.
     */
    getAllTransforms(sf) {
        // No need to transform if it's not a declarations file, or if no changes have been requested
        // to the input file. Due to the way TypeScript afterDeclarations transformers work, the
        // `ts.SourceFile` path is the same as the original .ts. The only way we know it's actually a
        // declaration file is via the `isDeclarationFile` property.
        if (!sf.isDeclarationFile) {
            return null;
        }
        const originalSf = ts.getOriginalNode(sf);
        let transforms = null;
        if (this.ivyDeclarationTransforms.has(originalSf)) {
            transforms = [];
            transforms.push(this.ivyDeclarationTransforms.get(originalSf));
        }
        return transforms;
    }
}
function declarationTransformFactory(transformRegistry, reflector, refEmitter, importRewriter) {
    return (context) => {
        const transformer = new DtsTransformer(context, reflector, refEmitter, importRewriter);
        return (fileOrBundle) => {
            if (ts.isBundle(fileOrBundle)) {
                // Only attempt to transform source files.
                return fileOrBundle;
            }
            const transforms = transformRegistry.getAllTransforms(fileOrBundle);
            if (transforms === null) {
                return fileOrBundle;
            }
            return transformer.transform(fileOrBundle, transforms);
        };
    };
}
/**
 * Processes .d.ts file text and adds static field declarations, with types.
 */
class DtsTransformer {
    ctx;
    reflector;
    refEmitter;
    importRewriter;
    constructor(ctx, reflector, refEmitter, importRewriter) {
        this.ctx = ctx;
        this.reflector = reflector;
        this.refEmitter = refEmitter;
        this.importRewriter = importRewriter;
    }
    /**
     * Transform the declaration file and add any declarations which were recorded.
     */
    transform(sf, transforms) {
        const imports = new ImportManager({
            ...presetImportManagerForceNamespaceImports,
            rewriter: this.importRewriter,
        });
        const visitor = (node) => {
            if (ts.isClassDeclaration(node)) {
                return this.transformClassDeclaration(node, transforms, imports);
            }
            else {
                // Otherwise return node as is.
                return ts.visitEachChild(node, visitor, this.ctx);
            }
        };
        // Recursively scan through the AST and process all nodes as desired.
        sf = ts.visitNode(sf, visitor, ts.isSourceFile) || sf;
        // Update/insert needed imports.
        return imports.transformTsFile(this.ctx, sf);
    }
    transformClassDeclaration(clazz, transforms, imports) {
        let newClazz = clazz;
        for (const transform of transforms) {
            if (transform.transformClass !== undefined) {
                newClazz = transform.transformClass(newClazz, newClazz.members, this.reflector, this.refEmitter, imports);
            }
        }
        return newClazz;
    }
}
class IvyDeclarationDtsTransform {
    declarationFields = new Map();
    addFields(decl, fields) {
        this.declarationFields.set(decl, fields);
    }
    transformClass(clazz, members, reflector, refEmitter, imports) {
        const original = ts.getOriginalNode(clazz);
        if (!this.declarationFields.has(original)) {
            return clazz;
        }
        const fields = this.declarationFields.get(original);
        const newMembers = fields.map((decl) => {
            const modifiers = [ts.factory.createModifier(ts.SyntaxKind.StaticKeyword)];
            const typeRef = translateType(decl.type, original.getSourceFile(), reflector, refEmitter, imports);
            markForEmitAsSingleLine(typeRef);
            return ts.factory.createPropertyDeclaration(
            /* modifiers */ modifiers, 
            /* name */ decl.name, 
            /* questionOrExclamationToken */ undefined, 
            /* type */ typeRef, 
            /* initializer */ undefined);
        });
        return ts.factory.updateClassDeclaration(
        /* node */ clazz, 
        /* modifiers */ clazz.modifiers, 
        /* name */ clazz.name, 
        /* typeParameters */ clazz.typeParameters, 
        /* heritageClauses */ clazz.heritageClauses, 
        /* members */ [...members, ...newMembers]);
    }
}
function markForEmitAsSingleLine(node) {
    ts.setEmitFlags(node, ts.EmitFlags.SingleLine);
    ts.forEachChild(node, markForEmitAsSingleLine);
}

/**
 * Visit a node with the given visitor and return a transformed copy.
 */
function visit(node, visitor, context) {
    return visitor._visit(node, context);
}
/**
 * Abstract base class for visitors, which processes certain nodes specially to allow insertion
 * of other nodes before them.
 */
class Visitor {
    /**
     * Maps statements to an array of statements that should be inserted before them.
     */
    _before = new Map();
    /**
     * Maps statements to an array of statements that should be inserted after them.
     */
    _after = new Map();
    _visitListEntryNode(node, visitor) {
        const result = visitor(node);
        if (result.before !== undefined) {
            // Record that some nodes should be inserted before the given declaration. The declaration's
            // parent's _visit call is responsible for performing this insertion.
            this._before.set(result.node, result.before);
        }
        if (result.after !== undefined) {
            // Same with nodes that should be inserted after.
            this._after.set(result.node, result.after);
        }
        return result.node;
    }
    /**
     * Visit types of nodes which don't have their own explicit visitor.
     */
    visitOtherNode(node) {
        return node;
    }
    /**
     * @internal
     */
    _visit(node, context) {
        // First, visit the node. visitedNode starts off as `null` but should be set after visiting
        // is completed.
        let visitedNode = null;
        node = ts.visitEachChild(node, (child) => child && this._visit(child, context), context);
        if (ts.isClassDeclaration(node)) {
            visitedNode = this._visitListEntryNode(node, (node) => this.visitClassDeclaration(node));
        }
        else {
            visitedNode = this.visitOtherNode(node);
        }
        // If the visited node has a `statements` array then process them, maybe replacing the visited
        // node and adding additional statements.
        if (visitedNode && (ts.isBlock(visitedNode) || ts.isSourceFile(visitedNode))) {
            visitedNode = this._maybeProcessStatements(visitedNode);
        }
        return visitedNode;
    }
    _maybeProcessStatements(node) {
        // Shortcut - if every statement doesn't require nodes to be prepended or appended,
        // this is a no-op.
        if (node.statements.every((stmt) => !this._before.has(stmt) && !this._after.has(stmt))) {
            return node;
        }
        // Build a new list of statements and patch it onto the clone.
        const newStatements = [];
        node.statements.forEach((stmt) => {
            if (this._before.has(stmt)) {
                newStatements.push(...this._before.get(stmt));
                this._before.delete(stmt);
            }
            newStatements.push(stmt);
            if (this._after.has(stmt)) {
                newStatements.push(...this._after.get(stmt));
                this._after.delete(stmt);
            }
        });
        const statementsArray = ts.factory.createNodeArray(newStatements, node.statements.hasTrailingComma);
        if (ts.isBlock(node)) {
            return ts.factory.updateBlock(node, statementsArray);
        }
        else {
            return ts.factory.updateSourceFile(node, statementsArray, node.isDeclarationFile, node.referencedFiles, node.typeReferenceDirectives, node.hasNoDefaultLib, node.libReferenceDirectives);
        }
    }
}

const NO_DECORATORS = new Set();
const CLOSURE_FILE_OVERVIEW_REGEXP = /\s+@fileoverview\s+/i;
function ivyTransformFactory(compilation, reflector, importRewriter, defaultImportTracker, localCompilationExtraImportsTracker, perf, isCore, isClosureCompilerEnabled, emitDeclarationOnly) {
    const recordWrappedNode = createRecorderFn(defaultImportTracker);
    return (context) => {
        return (file) => {
            return perf.inPhase(exports.PerfPhase.Compile, () => transformIvySourceFile(compilation, context, reflector, importRewriter, localCompilationExtraImportsTracker, file, isCore, isClosureCompilerEnabled, emitDeclarationOnly, recordWrappedNode));
        };
    };
}
/**
 * Visits all classes, performs Ivy compilation where Angular decorators are present and collects
 * result in a Map that associates a ts.ClassDeclaration with Ivy compilation results. This visitor
 * does NOT perform any TS transformations.
 */
class IvyCompilationVisitor extends Visitor {
    compilation;
    constantPool;
    classCompilationMap = new Map();
    deferrableImports = new Set();
    constructor(compilation, constantPool) {
        super();
        this.compilation = compilation;
        this.constantPool = constantPool;
    }
    visitClassDeclaration(node) {
        // Determine if this class has an Ivy field that needs to be added, and compile the field
        // to an expression if so.
        const result = this.compilation.compile(node, this.constantPool);
        if (result !== null) {
            this.classCompilationMap.set(node, result);
            // Collect all deferrable imports declarations into a single set,
            // so that we can pass it to the transform visitor that will drop
            // corresponding regular import declarations.
            for (const classResult of result) {
                if (classResult.deferrableImports !== null && classResult.deferrableImports.size > 0) {
                    classResult.deferrableImports.forEach((importDecl) => this.deferrableImports.add(importDecl));
                }
            }
        }
        return { node };
    }
}
/**
 * Visits all classes and performs transformation of corresponding TS nodes based on the Ivy
 * compilation results (provided as an argument).
 */
class IvyTransformationVisitor extends Visitor {
    compilation;
    classCompilationMap;
    reflector;
    importManager;
    recordWrappedNodeExpr;
    isClosureCompilerEnabled;
    isCore;
    deferrableImports;
    constructor(compilation, classCompilationMap, reflector, importManager, recordWrappedNodeExpr, isClosureCompilerEnabled, isCore, deferrableImports) {
        super();
        this.compilation = compilation;
        this.classCompilationMap = classCompilationMap;
        this.reflector = reflector;
        this.importManager = importManager;
        this.recordWrappedNodeExpr = recordWrappedNodeExpr;
        this.isClosureCompilerEnabled = isClosureCompilerEnabled;
        this.isCore = isCore;
        this.deferrableImports = deferrableImports;
    }
    visitClassDeclaration(node) {
        // If this class is not registered in the map, it means that it doesn't have Angular decorators,
        // thus no further processing is required.
        if (!this.classCompilationMap.has(node)) {
            return { node };
        }
        const translateOptions = {
            recordWrappedNode: this.recordWrappedNodeExpr,
            annotateForClosureCompiler: this.isClosureCompilerEnabled,
        };
        // There is at least one field to add.
        const statements = [];
        const members = [...node.members];
        // Note: Class may be already transformed by e.g. Tsickle and
        // not have a direct reference to the source file.
        const sourceFile = ts.getOriginalNode(node).getSourceFile();
        for (const field of this.classCompilationMap.get(node)) {
            // Type-only member.
            if (field.initializer === null) {
                continue;
            }
            // Translate the initializer for the field into TS nodes.
            const exprNode = translateExpression(sourceFile, field.initializer, this.importManager, translateOptions);
            // Create a static property declaration for the new field.
            const property = ts.factory.createPropertyDeclaration([ts.factory.createToken(ts.SyntaxKind.StaticKeyword)], field.name, undefined, undefined, exprNode);
            if (this.isClosureCompilerEnabled) {
                // Closure compiler transforms the form `Service.Éµprov = X` into `Service$Éµprov = X`. To
                // prevent this transformation, such assignments need to be annotated with @nocollapse.
                // Note that tsickle is typically responsible for adding such annotations, however it
                // doesn't yet handle synthetic fields added during other transformations.
                ts.addSyntheticLeadingComment(property, ts.SyntaxKind.MultiLineCommentTrivia, '* @nocollapse ', 
                /* hasTrailingNewLine */ false);
            }
            field.statements
                .map((stmt) => translateStatement(sourceFile, stmt, this.importManager, translateOptions))
                .forEach((stmt) => statements.push(stmt));
            members.push(property);
        }
        const filteredDecorators = 
        // Remove the decorator which triggered this compilation, leaving the others alone.
        maybeFilterDecorator(ts.getDecorators(node), this.compilation.decoratorsFor(node));
        const nodeModifiers = ts.getModifiers(node);
        let updatedModifiers;
        if (filteredDecorators?.length || nodeModifiers?.length) {
            updatedModifiers = [...(filteredDecorators || []), ...(nodeModifiers || [])];
        }
        // Replace the class declaration with an updated version.
        node = ts.factory.updateClassDeclaration(node, updatedModifiers, node.name, node.typeParameters, node.heritageClauses || [], 
        // Map over the class members and remove any Angular decorators from them.
        members.map((member) => this._stripAngularDecorators(member)));
        return { node, after: statements };
    }
    visitOtherNode(node) {
        if (ts.isImportDeclaration(node) && this.deferrableImports.has(node)) {
            // Return `null` as an indication that this node should not be present
            // in the final AST. Symbols from this import would be imported via
            // dynamic imports.
            return null;
        }
        return node;
    }
    /**
     * Return all decorators on a `Declaration` which are from @angular/core, or an empty set if none
     * are.
     */
    _angularCoreDecorators(decl) {
        const decorators = this.reflector.getDecoratorsOfDeclaration(decl);
        if (decorators === null) {
            return NO_DECORATORS;
        }
        const coreDecorators = decorators
            .filter((dec) => this.isCore || isFromAngularCore(dec))
            .map((dec) => dec.node);
        if (coreDecorators.length > 0) {
            return new Set(coreDecorators);
        }
        else {
            return NO_DECORATORS;
        }
    }
    _nonCoreDecoratorsOnly(node) {
        const decorators = ts.getDecorators(node);
        // Shortcut if the node has no decorators.
        if (decorators === undefined) {
            return undefined;
        }
        // Build a Set of the decorators on this node from @angular/core.
        const coreDecorators = this._angularCoreDecorators(node);
        if (coreDecorators.size === decorators.length) {
            // If all decorators are to be removed, return `undefined`.
            return undefined;
        }
        else if (coreDecorators.size === 0) {
            // If no decorators need to be removed, return the original decorators array.
            return nodeArrayFromDecoratorsArray(decorators);
        }
        // Filter out the core decorators.
        const filtered = decorators.filter((dec) => !coreDecorators.has(dec));
        // If no decorators survive, return `undefined`. This can only happen if a core decorator is
        // repeated on the node.
        if (filtered.length === 0) {
            return undefined;
        }
        // Create a new `NodeArray` with the filtered decorators that sourcemaps back to the original.
        return nodeArrayFromDecoratorsArray(filtered);
    }
    /**
     * Remove Angular decorators from a `ts.Node` in a shallow manner.
     *
     * This will remove decorators from class elements (getters, setters, properties, methods) as well
     * as parameters of constructors.
     */
    _stripAngularDecorators(node) {
        const modifiers = ts.canHaveModifiers(node) ? ts.getModifiers(node) : undefined;
        const nonCoreDecorators = ts.canHaveDecorators(node)
            ? this._nonCoreDecoratorsOnly(node)
            : undefined;
        const combinedModifiers = [...(nonCoreDecorators || []), ...(modifiers || [])];
        if (ts.isParameter(node)) {
            // Strip decorators from parameters (probably of the constructor).
            node = ts.factory.updateParameterDeclaration(node, combinedModifiers, node.dotDotDotToken, node.name, node.questionToken, node.type, node.initializer);
        }
        else if (ts.isMethodDeclaration(node)) {
            // Strip decorators of methods.
            node = ts.factory.updateMethodDeclaration(node, combinedModifiers, node.asteriskToken, node.name, node.questionToken, node.typeParameters, node.parameters, node.type, node.body);
        }
        else if (ts.isPropertyDeclaration(node)) {
            // Strip decorators of properties.
            node = ts.factory.updatePropertyDeclaration(node, combinedModifiers, node.name, node.questionToken, node.type, node.initializer);
        }
        else if (ts.isGetAccessor(node)) {
            // Strip decorators of getters.
            node = ts.factory.updateGetAccessorDeclaration(node, combinedModifiers, node.name, node.parameters, node.type, node.body);
        }
        else if (ts.isSetAccessor(node)) {
            // Strip decorators of setters.
            node = ts.factory.updateSetAccessorDeclaration(node, combinedModifiers, node.name, node.parameters, node.body);
        }
        else if (ts.isConstructorDeclaration(node)) {
            // For constructors, strip decorators of the parameters.
            const parameters = node.parameters.map((param) => this._stripAngularDecorators(param));
            node = ts.factory.updateConstructorDeclaration(node, modifiers, parameters, node.body);
        }
        return node;
    }
}
/**
 * A transformer which operates on ts.SourceFiles and applies changes from an `IvyCompilation`.
 */
function transformIvySourceFile(compilation, context, reflector, importRewriter, localCompilationExtraImportsTracker, file, isCore, isClosureCompilerEnabled, emitDeclarationOnly, recordWrappedNode) {
    const constantPool = new o.ConstantPool(isClosureCompilerEnabled);
    const importManager = new ImportManager({
        ...presetImportManagerForceNamespaceImports,
        rewriter: importRewriter,
    });
    // The transformation process consists of 2 steps:
    //
    //  1. Visit all classes, perform compilation and collect the results.
    //  2. Perform actual transformation of required TS nodes using compilation results from the first
    //     step.
    //
    // This is needed to have all `o.Expression`s generated before any TS transforms happen. This
    // allows `ConstantPool` to properly identify expressions that can be shared across multiple
    // components declared in the same file.
    // Step 1. Go though all classes in AST, perform compilation and collect the results.
    const compilationVisitor = new IvyCompilationVisitor(compilation, constantPool);
    visit(file, compilationVisitor, context);
    // If we are emitting declarations only, we can skip the script transforms.
    if (emitDeclarationOnly) {
        return file;
    }
    // Step 2. Scan through the AST again and perform transformations based on Ivy compilation
    // results obtained at Step 1.
    const transformationVisitor = new IvyTransformationVisitor(compilation, compilationVisitor.classCompilationMap, reflector, importManager, recordWrappedNode, isClosureCompilerEnabled, isCore, compilationVisitor.deferrableImports);
    let sf = visit(file, transformationVisitor, context);
    // Generate the constant statements first, as they may involve adding additional imports
    // to the ImportManager.
    const downlevelTranslatedCode = getLocalizeCompileTarget(context) < ts.ScriptTarget.ES2015;
    const constants = constantPool.statements.map((stmt) => translateStatement(file, stmt, importManager, {
        recordWrappedNode,
        downlevelTaggedTemplates: downlevelTranslatedCode,
        downlevelVariableDeclarations: downlevelTranslatedCode,
        annotateForClosureCompiler: isClosureCompilerEnabled,
    }));
    // Preserve @fileoverview comments required by Closure, since the location might change as a
    // result of adding extra imports and constant pool statements.
    const fileOverviewMeta = isClosureCompilerEnabled ? getFileOverviewComment(sf.statements) : null;
    // Add extra imports.
    if (localCompilationExtraImportsTracker !== null) {
        for (const moduleName of localCompilationExtraImportsTracker.getImportsForFile(sf)) {
            importManager.addSideEffectImport(sf, moduleName);
        }
    }
    // Add new imports for this file.
    sf = importManager.transformTsFile(context, sf, constants);
    if (fileOverviewMeta !== null) {
        sf = insertFileOverviewComment(sf, fileOverviewMeta);
    }
    return sf;
}
/**
 * Compute the correct target output for `$localize` messages generated by Angular
 *
 * In some versions of TypeScript, the transformation of synthetic `$localize` tagged template
 * literals is broken. See https://github.com/microsoft/TypeScript/issues/38485
 *
 * Here we compute what the expected final output target of the compilation will
 * be so that we can generate ES5 compliant `$localize` calls instead of relying upon TS to do the
 * downleveling for us.
 */
function getLocalizeCompileTarget(context) {
    const target = context.getCompilerOptions().target || ts.ScriptTarget.ES2015;
    return target !== ts.ScriptTarget.JSON ? target : ts.ScriptTarget.ES2015;
}
function getFileOverviewComment(statements) {
    if (statements.length > 0) {
        const host = statements[0];
        let trailing = false;
        let comments = ts.getSyntheticLeadingComments(host);
        // If @fileoverview tag is not found in source file, tsickle produces fake node with trailing
        // comment and inject it at the very beginning of the generated file. So we need to check for
        // leading as well as trailing comments.
        if (!comments || comments.length === 0) {
            trailing = true;
            comments = ts.getSyntheticTrailingComments(host);
        }
        if (comments && comments.length > 0 && CLOSURE_FILE_OVERVIEW_REGEXP.test(comments[0].text)) {
            return { comments, host, trailing };
        }
    }
    return null;
}
function insertFileOverviewComment(sf, fileoverview) {
    const { comments, host, trailing } = fileoverview;
    // If host statement is no longer the first one, it means that extra statements were added at the
    // very beginning, so we need to relocate @fileoverview comment and cleanup the original statement
    // that hosted it.
    if (sf.statements.length > 0 && host !== sf.statements[0]) {
        if (trailing) {
            ts.setSyntheticTrailingComments(host, undefined);
        }
        else {
            ts.setSyntheticLeadingComments(host, undefined);
        }
        // Note: Do not use the first statement as it may be elided at runtime.
        // E.g. an import declaration that is type only.
        const commentNode = ts.factory.createNotEmittedStatement(sf);
        ts.setSyntheticLeadingComments(commentNode, comments);
        return ts.factory.updateSourceFile(sf, [commentNode, ...sf.statements], sf.isDeclarationFile, sf.referencedFiles, sf.typeReferenceDirectives, sf.hasNoDefaultLib, sf.libReferenceDirectives);
    }
    return sf;
}
function maybeFilterDecorator(decorators, toRemove) {
    if (decorators === undefined) {
        return undefined;
    }
    const filtered = decorators.filter((dec) => toRemove.find((decToRemove) => ts.getOriginalNode(dec) === decToRemove) === undefined);
    if (filtered.length === 0) {
        return undefined;
    }
    return ts.factory.createNodeArray(filtered);
}
function isFromAngularCore(decorator) {
    return decorator.import !== null && decorator.import.from === '@angular/core';
}
function createRecorderFn(defaultImportTracker) {
    return (node) => {
        const importDecl = getDefaultImportDeclaration(node);
        if (importDecl !== null) {
            defaultImportTracker.recordUsedImport(importDecl);
        }
    };
}
/** Creates a `NodeArray` with the correct offsets from an array of decorators. */
function nodeArrayFromDecoratorsArray(decorators) {
    const array = ts.factory.createNodeArray(decorators);
    if (array.length > 0) {
        array.pos = decorators[0].pos;
        array.end = decorators[decorators.length - 1].end;
    }
    return array;
}

function insertDebugNameIntoCallExpression(callExpression, debugName) {
    const signalExpressionIsRequired = isRequiredSignalFunction(callExpression.expression);
    let configPosition = signalExpressionIsRequired ? 0 : 1;
    const nodeArgs = Array.from(callExpression.arguments);
    // 1. If the call expression has no arguments, we pretend that the config object is at position 0.
    // We do this so that we can insert a spread element at the start of the args list in a way where
    // undefined can be the first argument but still get tree-shaken out in production builds.
    // or
    // 2. Since `linkedSignal` with computation uses a single object for both computation logic
    // and options (unlike other signal-based primitives), we set the argument position to 0, i.e.
    // reusing the computation logic object.
    const signalExpressionHasNoArguments = callExpression.arguments.length === 0;
    const isLinkedSignal = callExpression.expression.getText() === 'linkedSignal';
    const isComputationLinkedSignal = isLinkedSignal && nodeArgs[0].kind === ts.SyntaxKind.ObjectLiteralExpression;
    if (signalExpressionHasNoArguments || isComputationLinkedSignal) {
        configPosition = 0;
    }
    let existingArgument = nodeArgs[configPosition];
    if (existingArgument === undefined) {
        existingArgument = ts.factory.createObjectLiteralExpression([]);
    }
    // Do nothing if an identifier is used as the config object
    // Ex -
    // const defaultObject = { equals: () => false };
    // signal(123, defaultObject)
    if (ts.isIdentifier(existingArgument)) {
        return callExpression;
    }
    if (!ts.isObjectLiteralExpression(existingArgument)) {
        return callExpression;
    }
    // insert debugName into the existing config object
    const properties = Array.from(existingArgument.properties);
    const debugNameExists = properties.some((prop) => ts.isPropertyAssignment(prop) && ts.isIdentifier(prop.name) && prop.name.text === 'debugName');
    if (debugNameExists) {
        return callExpression;
    }
    // We prepend instead of appending so that we don't overwrite an existing debugName Property
    // `{ foo: 'bar' }` -> `{ debugName: 'myDebugName', foo: 'bar' }`
    properties.unshift(ts.factory.createPropertyAssignment('debugName', ts.factory.createStringLiteral(debugName)));
    const transformedConfigProperties = ts.factory.createObjectLiteralExpression(properties);
    const ngDevModeIdentifier = ts.factory.createIdentifier('ngDevMode');
    let devModeCase;
    // if the signal expression has no arguments and the config object is not required,
    // we need to add an undefined identifier to the start of the args list so that we can spread the
    // config object in the right place.
    if (signalExpressionHasNoArguments && !signalExpressionIsRequired) {
        devModeCase = ts.factory.createArrayLiteralExpression([
            ts.factory.createIdentifier('undefined'),
            transformedConfigProperties,
        ]);
    }
    else {
        devModeCase = ts.factory.createArrayLiteralExpression([
            transformedConfigProperties,
            ...nodeArgs.slice(configPosition + 1),
        ]);
    }
    const nonDevModeCase = signalExpressionIsRequired
        ? ts.factory.createArrayLiteralExpression(nodeArgs)
        : ts.factory.createArrayLiteralExpression(nodeArgs.slice(configPosition));
    const spreadElementContainingUpdatedOptions = ts.factory.createSpreadElement(ts.factory.createParenthesizedExpression(ts.factory.createConditionalExpression(ngDevModeIdentifier, 
    /* question token */ undefined, devModeCase, 
    /* colon token */ undefined, nonDevModeCase)));
    let transformedSignalArgs;
    if (signalExpressionIsRequired || signalExpressionHasNoArguments || isComputationLinkedSignal) {
        // 1. If the call expression is a required signal function, there is no args other than the config object.
        // So we just use the spread element as the only argument.
        // or
        // 2. If the call expression has no arguments (ex. input(), model(), etc), we already added the undefined
        // identifier in the spread element above. So we use that spread Element as is.
        // or
        // 3. We are transforming a `linkedSignal` with computation (i.e. we have a single object for both
        // logic and options).
        transformedSignalArgs = ts.factory.createNodeArray([spreadElementContainingUpdatedOptions]);
    }
    else {
        // 3. Signal expression is not required and has arguments.
        // Here we leave the first argument as is and spread the rest.
        transformedSignalArgs = ts.factory.createNodeArray([
            nodeArgs[0],
            spreadElementContainingUpdatedOptions,
        ]);
    }
    return ts.factory.updateCallExpression(callExpression, callExpression.expression, callExpression.typeArguments, transformedSignalArgs);
}
/**
 *
 * Determines if the node is a variable declaration with a call expression initializer.
 * Ex:
 * ```ts
 * const mySignal = signal(123);
 * ```
 */
function isVariableDeclarationCase(node) {
    if (!ts.isVariableDeclaration(node)) {
        return false;
    }
    if (!node.initializer || !ts.isCallExpression(node.initializer)) {
        return false;
    }
    let expression = node.initializer.expression;
    if (ts.isPropertyAccessExpression(expression)) {
        expression = expression.expression;
    }
    return ts.isIdentifier(expression) && isSignalFunction(expression);
}
/**
 *
 * Determines if the node is a property assignment with a call expression initializer.
 *
 * Ex:
 * ```ts
 * class MyClass {
 *   mySignal: Signal<number>;
 *   constructor() {
 *    this.mySignal = signal(123);
 *   }
 * }
 * ```
 */
function isPropertyAssignmentCase(node) {
    if (!ts.isExpressionStatement(node)) {
        return false;
    }
    if (!ts.isBinaryExpression(node.expression)) {
        return false;
    }
    const binaryExpression = node.expression;
    if (binaryExpression.operatorToken.kind !== ts.SyntaxKind.EqualsToken) {
        return false;
    }
    if (!ts.isCallExpression(binaryExpression.right)) {
        return false;
    }
    if (!ts.isPropertyAccessExpression(binaryExpression.left)) {
        return false;
    }
    let expression = binaryExpression.right.expression;
    if (ts.isPropertyAccessExpression(expression)) {
        expression = expression.expression;
    }
    return ts.isIdentifier(expression) && isSignalFunction(expression);
}
/**
 *
 * Determines if the node is a property declaration with a call expression initializer.
 *
 * Ex:
 * ```ts
 * class MyClass {
 *   mySignal: Signal<number> = signal(123);
 * }
 * ```
 */
function isPropertyDeclarationCase(node) {
    if (!ts.isPropertyDeclaration(node)) {
        return false;
    }
    if (!(node.initializer && ts.isCallExpression(node.initializer))) {
        return false;
    }
    let expression = node.initializer.expression;
    if (ts.isPropertyAccessExpression(expression)) {
        expression = expression.expression;
    }
    return ts.isIdentifier(expression) && isSignalFunction(expression);
}
/**
 *
 * Determines if a node is an expression that references an @angular/core imported symbol.
 * Ex:
 * ```ts
 * import { signal } from '@angular/core';
 * const mySignal = signal(123); // expressionIsUsingAngularImportedSymbol === true
 * ```
 */
function expressionIsUsingAngularCoreImportedSymbol(program, expression) {
    const symbol = program.getTypeChecker().getSymbolAtLocation(expression);
    if (symbol === undefined) {
        return false;
    }
    const declarations = symbol.declarations;
    if (declarations === undefined || declarations.length === 0) {
        return false;
    }
    // climb up the tree from the import specifier to the import declaration
    const importSpecifier = declarations[0];
    if (!ts.isImportSpecifier(importSpecifier)) {
        return false;
    }
    const namedImports = importSpecifier.parent;
    if (!ts.isNamedImports(namedImports)) {
        return false;
    }
    const importsClause = namedImports.parent;
    if (!ts.isImportClause(importsClause)) {
        return false;
    }
    const importDeclaration = importsClause.parent;
    if (!ts.isImportDeclaration(importDeclaration) ||
        !ts.isStringLiteral(importDeclaration.moduleSpecifier)) {
        return false;
    }
    const specifier = importDeclaration.moduleSpecifier.text;
    return (specifier !== undefined &&
        (specifier === '@angular/core' || specifier.startsWith('@angular/core/')));
}
const signalFunctions = new Set([
    'signal',
    'computed',
    'linkedSignal',
    'input',
    'model',
    'viewChild',
    'viewChildren',
    'contentChild',
    'contentChildren',
    'effect',
]);
function isSignalFunction(expression) {
    const text = expression.text;
    return signalFunctions.has(text);
}
function isRequiredSignalFunction(expression) {
    // Check for a property access expression that uses the 'required' property
    if (ts.isPropertyAccessExpression(expression) &&
        ts.isIdentifier(expression.name) &&
        ts.isIdentifier(expression.expression)) {
        const accessName = expression.name.text;
        if (accessName === 'required') {
            return true;
        }
    }
    return false;
}
function transformVariableDeclaration(program, node) {
    if (!node.initializer || !ts.isCallExpression(node.initializer))
        return node;
    const expression = node.initializer.expression;
    if (ts.isPropertyAccessExpression(expression)) {
        if (!expressionIsUsingAngularCoreImportedSymbol(program, expression.expression)) {
            return node;
        }
    }
    else if (!expressionIsUsingAngularCoreImportedSymbol(program, expression)) {
        return node;
    }
    try {
        // may throw if the node does not have a source file. Ignore this case for now
        const nodeText = node.name.getText();
        return ts.factory.updateVariableDeclaration(node, node.name, node.exclamationToken, node.type, insertDebugNameIntoCallExpression(node.initializer, nodeText));
    }
    catch {
        return node;
    }
}
function transformPropertyAssignment(program, node) {
    const expression = node.expression.right.expression;
    if (ts.isPropertyAccessExpression(expression)) {
        if (!expressionIsUsingAngularCoreImportedSymbol(program, expression.expression)) {
            return node;
        }
    }
    else if (!expressionIsUsingAngularCoreImportedSymbol(program, expression)) {
        return node;
    }
    return ts.factory.updateExpressionStatement(node, ts.factory.createBinaryExpression(node.expression.left, node.expression.operatorToken, insertDebugNameIntoCallExpression(node.expression.right, node.expression.left.name.text)));
}
function transformPropertyDeclaration(program, node) {
    if (!node.initializer || !ts.isCallExpression(node.initializer))
        return node;
    const expression = node.initializer.expression;
    if (ts.isPropertyAccessExpression(expression)) {
        if (!expressionIsUsingAngularCoreImportedSymbol(program, expression.expression)) {
            return node;
        }
    }
    else if (!expressionIsUsingAngularCoreImportedSymbol(program, expression)) {
        return node;
    }
    try {
        // may throw if the node does not have a source file. Ignore this case for now.
        const nodeText = node.name.getText();
        return ts.factory.updatePropertyDeclaration(node, node.modifiers, node.name, node.questionToken, node.type, insertDebugNameIntoCallExpression(node.initializer, nodeText));
    }
    catch {
        return node;
    }
}
/**
 *
 * This transformer adds a debugName property to the config object of signal functions like
 * signal, computed, effect, etc.
 *
 * The debugName property is added conditionally based on the value of ngDevMode. This is done
 * to avoid adding the debugName property in production builds.
 *
 * Ex:
 * ```ts
 * import {signal} from '@angular/core';
 * const mySignal = signal('Hello World');
 * ```
 *
 * is transformed to:
 * ```ts
 * import {signal} from '@angular/core';
 * const mySignal = signal('Hello World', ...(ngDevMode ? [{ debugName: "mySignal" }] : []));
 * ```
 *
 * The transformer supports the following cases:
 *
 * # Variable declaration
 * ```ts
 * const mySignal = signal('Hello World');
 * ```
 *
 * becomes
 * ```
 * const  mySignal = signal('Hello World', ...(ngDevMode ? [{ debugName: "mySignal" }] : []));
 * ```
 *
 * # Property assignment
 * ```ts
 * class MyClass {
 *  mySignal: Signal<string>;
 *  constructor() {
 *    this.mySignal = signal('Hello World');
 *  }
 * }
 * ```
 * becomes
 * ```ts
 * class MyClass {
 *  mySignal: Signal<string>;
 *  constructor() {
 *   this.mySignal = signal(...(ngDevMode ? ['Hello World', { debugName: "mySignal" }] : ['Hello World']));
 *  }
 * }
 * ```
 *
 * # Property declaration
 * ```ts
 * class MyClass {
 *   mySignal = signal('Hello World');
 * }
 * ```
 * becomes
 * ```ts
 * class MyClass {
 *  mySignal = signal(...(ngDevMode ? ['Hello World', { debugName: "mySignal" }] : ['Hello World']));
 * }
 * ```
 *
 */
function signalMetadataTransform(program) {
    return (context) => (rootNode) => {
        const visit = (node) => {
            if (isVariableDeclarationCase(node)) {
                return transformVariableDeclaration(program, node);
            }
            if (isPropertyAssignmentCase(node)) {
                return transformPropertyAssignment(program, node);
            }
            if (isPropertyDeclarationCase(node)) {
                return transformPropertyDeclaration(program, node);
            }
            return ts.visitEachChild(node, visit, context);
        };
        return ts.visitNode(rootNode, visit);
    };
}

/**
 * Create a `ts.Diagnostic` which indicates the given class is part of the declarations of two or
 * more NgModules.
 *
 * The resulting `ts.Diagnostic` will have a context entry for each NgModule showing the point where
 * the directive/pipe exists in its `declarations` (if possible).
 */
function makeDuplicateDeclarationError(node, data, kind) {
    const context = [];
    for (const decl of data) {
        if (decl.rawDeclarations === null) {
            continue;
        }
        // Try to find the reference to the declaration within the declarations array, to hang the
        // error there. If it can't be found, fall back on using the NgModule's name.
        const contextNode = decl.ref.getOriginForDiagnostics(decl.rawDeclarations, decl.ngModule.name);
        context.push(makeRelatedInformation(contextNode, `'${node.name.text}' is listed in the declarations of the NgModule '${decl.ngModule.name.text}'.`));
    }
    // Finally, produce the diagnostic.
    return makeDiagnostic(exports.ErrorCode.NGMODULE_DECLARATION_NOT_UNIQUE, node.name, `The ${kind} '${node.name.text}' is declared by more than one NgModule.`, context);
}
/**
 * Creates a `FatalDiagnosticError` for a node that did not evaluate to the expected type. The
 * diagnostic that is created will include details on why the value is incorrect, i.e. it includes
 * a representation of the actual type that was unsupported, or in the case of a dynamic value the
 * trace to the node where the dynamic value originated.
 *
 * @param node The node for which the diagnostic should be produced.
 * @param value The evaluated value that has the wrong type.
 * @param messageText The message text of the error.
 */
function createValueHasWrongTypeError(node, value, messageText) {
    let chainedMessage;
    let relatedInformation;
    if (value instanceof DynamicValue) {
        chainedMessage = 'Value could not be determined statically.';
        relatedInformation = traceDynamicValue(node, value);
    }
    else if (value instanceof Reference) {
        const target = value.debugName !== null ? `'${value.debugName}'` : 'an anonymous declaration';
        chainedMessage = `Value is a reference to ${target}.`;
        const referenceNode = identifierOfNode(value.node) ?? value.node;
        relatedInformation = [makeRelatedInformation(referenceNode, 'Reference is declared here.')];
    }
    else {
        chainedMessage = `Value is of type '${describeResolvedType(value)}'.`;
    }
    const chain = {
        messageText,
        category: ts.DiagnosticCategory.Error,
        code: 0,
        next: [
            {
                messageText: chainedMessage,
                category: ts.DiagnosticCategory.Message,
                code: 0,
            },
        ],
    };
    return new FatalDiagnosticError(exports.ErrorCode.VALUE_HAS_WRONG_TYPE, node, chain, relatedInformation);
}
/**
 * Gets the diagnostics for a set of provider classes.
 * @param providerClasses Classes that should be checked.
 * @param providersDeclaration Node that declares the providers array.
 * @param registry Registry that keeps track of the registered injectable classes.
 */
function getProviderDiagnostics(providerClasses, providersDeclaration, registry) {
    const diagnostics = [];
    for (const provider of providerClasses) {
        const injectableMeta = registry.getInjectableMeta(provider.node);
        if (injectableMeta !== null) {
            // The provided type is recognized as injectable, so we don't report a diagnostic for this
            // provider.
            continue;
        }
        const contextNode = provider.getOriginForDiagnostics(providersDeclaration);
        diagnostics.push(makeDiagnostic(exports.ErrorCode.UNDECORATED_PROVIDER, contextNode, `The class '${provider.node.name.text}' cannot be created via dependency injection, as it does not have an Angular decorator. This will result in an error at runtime.

Either add the @Injectable() decorator to '${provider.node.name.text}', or configure a different provider (such as a provider with 'useFactory').
`, [makeRelatedInformation(provider.node, `'${provider.node.name.text}' is declared here.`)]));
    }
    return diagnostics;
}
function getDirectiveDiagnostics(node, injectableRegistry, evaluator, reflector, scopeRegistry, strictInjectionParameters, kind) {
    let diagnostics = [];
    const addDiagnostics = (more) => {
        if (more === null) {
            return;
        }
        else if (diagnostics === null) {
            diagnostics = Array.isArray(more) ? more : [more];
        }
        else if (Array.isArray(more)) {
            diagnostics.push(...more);
        }
        else {
            diagnostics.push(more);
        }
    };
    const duplicateDeclarations = scopeRegistry.getDuplicateDeclarations(node);
    if (duplicateDeclarations !== null) {
        addDiagnostics(makeDuplicateDeclarationError(node, duplicateDeclarations, kind));
    }
    addDiagnostics(checkInheritanceOfInjectable(node, injectableRegistry, reflector, evaluator, strictInjectionParameters, kind));
    return diagnostics;
}
function validateHostDirectives(origin, hostDirectives, metaReader) {
    const diagnostics = [];
    for (const current of hostDirectives) {
        if (!isHostDirectiveMetaForGlobalMode(current)) {
            throw new Error('Impossible state: diagnostics code path for local compilation');
        }
        const hostMeta = flattenInheritedDirectiveMetadata(metaReader, current.directive);
        if (hostMeta === null) {
            diagnostics.push(makeDiagnostic(exports.ErrorCode.HOST_DIRECTIVE_INVALID, current.directive.getOriginForDiagnostics(origin), `${current.directive.debugName} must be a standalone directive to be used as a host directive`));
            continue;
        }
        if (!hostMeta.isStandalone) {
            diagnostics.push(makeDiagnostic(exports.ErrorCode.HOST_DIRECTIVE_NOT_STANDALONE, current.directive.getOriginForDiagnostics(origin), `Host directive ${hostMeta.name} must be standalone`));
        }
        if (hostMeta.isComponent) {
            diagnostics.push(makeDiagnostic(exports.ErrorCode.HOST_DIRECTIVE_COMPONENT, current.directive.getOriginForDiagnostics(origin), `Host directive ${hostMeta.name} cannot be a component`));
        }
        const requiredInputNames = Array.from(hostMeta.inputs)
            .filter((input) => input.required)
            .map((input) => input.classPropertyName);
        validateHostDirectiveMappings('input', current, hostMeta, origin, diagnostics, requiredInputNames.length > 0 ? new Set(requiredInputNames) : null);
        validateHostDirectiveMappings('output', current, hostMeta, origin, diagnostics, null);
    }
    return diagnostics;
}
function validateHostDirectiveMappings(bindingType, hostDirectiveMeta, meta, origin, diagnostics, requiredBindings) {
    if (!isHostDirectiveMetaForGlobalMode(hostDirectiveMeta)) {
        throw new Error('Impossible state: diagnostics code path for local compilation');
    }
    const className = meta.name;
    const hostDirectiveMappings = bindingType === 'input' ? hostDirectiveMeta.inputs : hostDirectiveMeta.outputs;
    const existingBindings = bindingType === 'input' ? meta.inputs : meta.outputs;
    const exposedRequiredBindings = new Set();
    for (const publicName in hostDirectiveMappings) {
        if (hostDirectiveMappings.hasOwnProperty(publicName)) {
            const bindings = existingBindings.getByBindingPropertyName(publicName);
            if (bindings === null) {
                diagnostics.push(makeDiagnostic(exports.ErrorCode.HOST_DIRECTIVE_UNDEFINED_BINDING, hostDirectiveMeta.directive.getOriginForDiagnostics(origin), `Directive ${className} does not have an ${bindingType} with a public name of ${publicName}.`));
            }
            else if (requiredBindings !== null) {
                for (const field of bindings) {
                    if (requiredBindings.has(field.classPropertyName)) {
                        exposedRequiredBindings.add(field.classPropertyName);
                    }
                }
            }
            const remappedPublicName = hostDirectiveMappings[publicName];
            const bindingsForPublicName = existingBindings.getByBindingPropertyName(remappedPublicName);
            if (bindingsForPublicName !== null) {
                for (const binding of bindingsForPublicName) {
                    if (binding.bindingPropertyName !== publicName) {
                        diagnostics.push(makeDiagnostic(exports.ErrorCode.HOST_DIRECTIVE_CONFLICTING_ALIAS, hostDirectiveMeta.directive.getOriginForDiagnostics(origin), `Cannot alias ${bindingType} ${publicName} of host directive ${className} to ${remappedPublicName}, because it already has a different ${bindingType} with the same public name.`));
                    }
                }
            }
        }
    }
    if (requiredBindings !== null && requiredBindings.size !== exposedRequiredBindings.size) {
        const missingBindings = [];
        for (const publicName of requiredBindings) {
            if (!exposedRequiredBindings.has(publicName)) {
                const name = existingBindings.getByClassPropertyName(publicName);
                if (name) {
                    missingBindings.push(`'${name.bindingPropertyName}'`);
                }
            }
        }
        diagnostics.push(makeDiagnostic(exports.ErrorCode.HOST_DIRECTIVE_MISSING_REQUIRED_BINDING, hostDirectiveMeta.directive.getOriginForDiagnostics(origin), `Required ${bindingType}${missingBindings.length === 1 ? '' : 's'} ${missingBindings.join(', ')} from host directive ${className} must be exposed.`));
    }
}
function getUndecoratedClassWithAngularFeaturesDiagnostic(node) {
    return makeDiagnostic(exports.ErrorCode.UNDECORATED_CLASS_USING_ANGULAR_FEATURES, node.name, `Class is using Angular features but is not decorated. Please add an explicit ` +
        `Angular decorator.`);
}
function checkInheritanceOfInjectable(node, injectableRegistry, reflector, evaluator, strictInjectionParameters, kind) {
    const classWithCtor = findInheritedCtor(node, injectableRegistry, reflector, evaluator);
    if (classWithCtor === null || classWithCtor.isCtorValid) {
        // The class does not inherit a constructor, or the inherited constructor is compatible
        // with DI; no need to report a diagnostic.
        return null;
    }
    if (!classWithCtor.isDecorated) {
        // The inherited constructor exists in a class that does not have an Angular decorator.
        // This is an error, as there won't be a factory definition available for DI to invoke
        // the constructor.
        return getInheritedUndecoratedCtorDiagnostic(node, classWithCtor.ref, kind);
    }
    if (isFromDtsFile(classWithCtor.ref.node)) {
        // The inherited class is declared in a declaration file, in which case there is not enough
        // information to detect invalid constructors as `@Inject()` metadata is not present in the
        // declaration file. Consequently, we have to accept such occurrences, although they might
        // still fail at runtime.
        return null;
    }
    if (!strictInjectionParameters || isAbstractClassDeclaration(node)) {
        // An invalid constructor is only reported as error under `strictInjectionParameters` and
        // only for concrete classes; follow the same exclusions for derived types.
        return null;
    }
    return getInheritedInvalidCtorDiagnostic(node, classWithCtor.ref, kind);
}
function findInheritedCtor(node, injectableRegistry, reflector, evaluator) {
    if (!reflector.isClass(node) || reflector.getConstructorParameters(node) !== null) {
        // We should skip nodes that aren't classes. If a constructor exists, then no base class
        // definition is required on the runtime side - it's legal to inherit from any class.
        return null;
    }
    // The extends clause is an expression which can be as dynamic as the user wants. Try to
    // evaluate it, but fall back on ignoring the clause if it can't be understood. This is a View
    // Engine compatibility hack: View Engine ignores 'extends' expressions that it cannot understand.
    let baseClass = readBaseClass$1(node, reflector, evaluator);
    while (baseClass !== null) {
        if (baseClass === 'dynamic') {
            return null;
        }
        const injectableMeta = injectableRegistry.getInjectableMeta(baseClass.node);
        if (injectableMeta !== null) {
            if (injectableMeta.ctorDeps !== null) {
                // The class has an Angular decorator with a constructor.
                return {
                    ref: baseClass,
                    isCtorValid: injectableMeta.ctorDeps !== 'invalid',
                    isDecorated: true,
                };
            }
        }
        else {
            const baseClassConstructorParams = reflector.getConstructorParameters(baseClass.node);
            if (baseClassConstructorParams !== null) {
                // The class is not decorated, but it does have constructor. An undecorated class is only
                // allowed to have a constructor without parameters, otherwise it is invalid.
                return {
                    ref: baseClass,
                    isCtorValid: baseClassConstructorParams.length === 0,
                    isDecorated: false,
                };
            }
        }
        // Go up the chain and continue
        baseClass = readBaseClass$1(baseClass.node, reflector, evaluator);
    }
    return null;
}
function getInheritedInvalidCtorDiagnostic(node, baseClass, kind) {
    const baseClassName = baseClass.debugName;
    return makeDiagnostic(exports.ErrorCode.INJECTABLE_INHERITS_INVALID_CONSTRUCTOR, node.name, `The ${kind.toLowerCase()} ${node.name.text} inherits its constructor from ${baseClassName}, ` +
        `but the latter has a constructor parameter that is not compatible with dependency injection. ` +
        `Either add an explicit constructor to ${node.name.text} or change ${baseClassName}'s constructor to ` +
        `use parameters that are valid for DI.`);
}
function getInheritedUndecoratedCtorDiagnostic(node, baseClass, kind) {
    const baseClassName = baseClass.debugName;
    const baseNeedsDecorator = kind === 'Component' || kind === 'Directive' ? 'Directive' : 'Injectable';
    return makeDiagnostic(exports.ErrorCode.DIRECTIVE_INHERITS_UNDECORATED_CTOR, node.name, `The ${kind.toLowerCase()} ${node.name.text} inherits its constructor from ${baseClassName}, ` +
        `but the latter does not have an Angular decorator of its own. Dependency injection will not be able to ` +
        `resolve the parameters of ${baseClassName}'s constructor. Either add a @${baseNeedsDecorator} decorator ` +
        `to ${baseClassName}, or add an explicit constructor to ${node.name.text}.`);
}
/**
 * Throws `FatalDiagnosticError` with error code `LOCAL_COMPILATION_UNRESOLVED_CONST`
 * if the compilation mode is local and the value is not resolved due to being imported
 * from external files. This is a common scenario for errors in local compilation mode,
 * and so this helper can be used to quickly generate the relevant errors.
 *
 * @param nodeToHighlight Node to be highlighted in teh error message.
 * Will default to value.node if not provided.
 */
function assertLocalCompilationUnresolvedConst(compilationMode, value, nodeToHighlight, errorMessage) {
    if (compilationMode === exports.CompilationMode.LOCAL &&
        value instanceof DynamicValue &&
        value.isFromUnknownIdentifier()) {
        throw new FatalDiagnosticError(exports.ErrorCode.LOCAL_COMPILATION_UNRESOLVED_CONST, nodeToHighlight ?? value.node, errorMessage);
    }
}

function resolveEnumValue(evaluator, metadata, field, enumSymbolName, isCore) {
    let resolved = null;
    if (metadata.has(field)) {
        const expr = metadata.get(field);
        const value = evaluator.evaluate(expr);
        if (value instanceof EnumValue &&
            isAngularCoreReferenceWithPotentialAliasing(value.enumRef, enumSymbolName, isCore)) {
            resolved = value.resolved;
        }
        else {
            throw createValueHasWrongTypeError(expr, value, `${field} must be a member of ${enumSymbolName} enum from @angular/core`);
        }
    }
    return resolved;
}
/**
 * Resolves a EncapsulationEnum expression locally on best effort without having to calculate the
 * reference. This suites local compilation mode where each file is compiled individually.
 *
 * The static analysis is still needed in local compilation mode since the value of this enum will
 * be used later to decide the generated code for styles.
 */
function resolveEncapsulationEnumValueLocally(expr) {
    if (!expr) {
        return null;
    }
    const exprText = expr.getText().trim();
    for (const key in o.ViewEncapsulation) {
        if (!Number.isNaN(Number(key))) {
            continue;
        }
        const suffix = `ViewEncapsulation.${key}`;
        // Check whether the enum is imported by name or used by import namespace (e.g.,
        // core.ViewEncapsulation.None)
        if (exprText === suffix || exprText.endsWith(`.${suffix}`)) {
            const ans = Number(o.ViewEncapsulation[key]);
            return ans;
        }
    }
    return null;
}
/** Determines if the result of an evaluation is a string array. */
function isStringArray(resolvedValue) {
    return Array.isArray(resolvedValue) && resolvedValue.every((elem) => typeof elem === 'string');
}
function resolveLiteral(decorator, literalCache) {
    if (literalCache.has(decorator)) {
        return literalCache.get(decorator);
    }
    if (decorator.args === null || decorator.args.length !== 1) {
        throw new FatalDiagnosticError(exports.ErrorCode.DECORATOR_ARITY_WRONG, decorator.node, `Incorrect number of arguments to @${decorator.name} decorator`);
    }
    const meta = unwrapExpression(decorator.args[0]);
    if (!ts.isObjectLiteralExpression(meta)) {
        throw new FatalDiagnosticError(exports.ErrorCode.DECORATOR_ARG_NOT_LITERAL, meta, `Decorator argument must be literal.`);
    }
    literalCache.set(decorator, meta);
    return meta;
}

function compileNgFactoryDefField(metadata) {
    const res = o.compileFactoryFunction(metadata);
    return {
        name: 'Éµfac',
        initializer: res.expression,
        statements: res.statements,
        type: res.type,
        deferrableImports: null,
    };
}
function compileDeclareFactory(metadata) {
    const res = o.compileDeclareFactoryFunction(metadata);
    return {
        name: 'Éµfac',
        initializer: res.expression,
        statements: res.statements,
        type: res.type,
        deferrableImports: null,
    };
}

/**
 * Registry that keeps track of classes that can be constructed via dependency injection (e.g.
 * injectables, directives, pipes).
 */
class InjectableClassRegistry {
    host;
    isCore;
    classes = new Map();
    constructor(host, isCore) {
        this.host = host;
        this.isCore = isCore;
    }
    registerInjectable(declaration, meta) {
        this.classes.set(declaration, meta);
    }
    getInjectableMeta(declaration) {
        // Figure out whether the class is injectable based on the registered classes, otherwise
        // fall back to looking at its members since we might not have been able to register the class
        // if it was compiled in another compilation unit.
        if (this.classes.has(declaration)) {
            return this.classes.get(declaration);
        }
        if (!hasInjectableFields(declaration, this.host)) {
            return null;
        }
        const ctorDeps = getConstructorDependencies(declaration, this.host, this.isCore);
        const meta = {
            ctorDeps: unwrapConstructorDependencies(ctorDeps),
        };
        this.classes.set(declaration, meta);
        return meta;
    }
}

/**
 * Given a class declaration, generate a call to `setClassMetadata` with the Angular metadata
 * present on the class or its member fields. An ngDevMode guard is used to allow the call to be
 * tree-shaken away, as the `setClassMetadata` invocation is only needed for testing purposes.
 *
 * If no such metadata is present, this function returns `null`. Otherwise, the call is returned
 * as a `Statement` for inclusion along with the class.
 */
function extractClassMetadata(clazz, reflection, isCore, annotateForClosureCompiler, angularDecoratorTransform = (dec) => dec, undecoratedMetadataExtractor = () => null) {
    if (!reflection.isClass(clazz)) {
        return null;
    }
    const id = clazz.name;
    // Reflect over the class decorators. If none are present, or those that are aren't from
    // Angular, then return null. Otherwise, turn them into metadata.
    const classDecorators = reflection.getDecoratorsOfDeclaration(clazz);
    if (classDecorators === null) {
        return null;
    }
    const ngClassDecorators = classDecorators
        .filter((dec) => isAngularDecorator$1(dec, isCore))
        .map((decorator) => decoratorToMetadata(angularDecoratorTransform(decorator), annotateForClosureCompiler))
        // Since the `setClassMetadata` call is intended to be emitted after the class
        // declaration, we have to strip references to the existing identifiers or
        // TypeScript might generate invalid code when it emits to JS. In particular
        // this can break when emitting a class to ES5 which has a custom decorator
        // and is referenced inside of its own metadata (see #39509 for more information).
        .map((decorator) => removeIdentifierReferences(decorator, id.text));
    if (ngClassDecorators.length === 0) {
        return null;
    }
    const metaDecorators = new o.WrappedNodeExpr(ts.factory.createArrayLiteralExpression(ngClassDecorators));
    // Convert the constructor parameters to metadata, passing null if none are present.
    let metaCtorParameters = null;
    const classCtorParameters = reflection.getConstructorParameters(clazz);
    if (classCtorParameters !== null) {
        const ctorParameters = classCtorParameters.map((param) => ctorParameterToMetadata(param, isCore));
        metaCtorParameters = new o.ArrowFunctionExpr([], new o.LiteralArrayExpr(ctorParameters));
    }
    // Do the same for property decorators.
    let metaPropDecorators = null;
    const classMembers = reflection.getMembersOfClass(clazz).filter((member) => !member.isStatic &&
        // Private fields are not supported in the metadata emit
        member.accessLevel !== ClassMemberAccessLevel.EcmaScriptPrivate);
    const decoratedMembers = [];
    const seenMemberNames = new Set();
    let duplicateDecoratedMembers = null;
    for (const member of classMembers) {
        const shouldQuoteName = member.nameNode !== null && ts.isStringLiteralLike(member.nameNode);
        if (member.decorators !== null && member.decorators.length > 0) {
            decoratedMembers.push({
                key: member.name,
                quoted: shouldQuoteName,
                value: decoratedClassMemberToMetadata(member.decorators, isCore),
            });
            if (seenMemberNames.has(member.name)) {
                duplicateDecoratedMembers ??= [];
                duplicateDecoratedMembers.push(member);
            }
            else {
                seenMemberNames.add(member.name);
            }
        }
        else {
            const undecoratedMetadata = undecoratedMetadataExtractor(member);
            if (undecoratedMetadata !== null) {
                decoratedMembers.push({
                    key: member.name,
                    quoted: shouldQuoteName,
                    value: undecoratedMetadata,
                });
            }
        }
    }
    if (duplicateDecoratedMembers !== null) {
        // This should theoretically never happen, because the only way to have duplicate instance
        // member names is getter/setter pairs and decorators cannot appear in both a getter and the
        // corresponding setter.
        throw new FatalDiagnosticError(exports.ErrorCode.DUPLICATE_DECORATED_PROPERTIES, duplicateDecoratedMembers[0].nameNode ?? clazz, `Duplicate decorated properties found on class '${clazz.name.text}': ` +
            duplicateDecoratedMembers.map((member) => member.name).join(', '));
    }
    if (decoratedMembers.length > 0) {
        metaPropDecorators = o.literalMap(decoratedMembers);
    }
    return {
        type: new o.WrappedNodeExpr(id),
        decorators: metaDecorators,
        ctorParameters: metaCtorParameters,
        propDecorators: metaPropDecorators,
    };
}
/**
 * Convert a reflected constructor parameter to metadata.
 */
function ctorParameterToMetadata(param, isCore) {
    // Parameters sometimes have a type that can be referenced. If so, then use it, otherwise
    // its type is undefined.
    const type = param.typeValueReference.kind !== 2 /* TypeValueReferenceKind.UNAVAILABLE */
        ? valueReferenceToExpression(param.typeValueReference)
        : new o.LiteralExpr(undefined);
    const mapEntries = [
        { key: 'type', value: type, quoted: false },
    ];
    // If the parameter has decorators, include the ones from Angular.
    if (param.decorators !== null) {
        const ngDecorators = param.decorators
            .filter((dec) => isAngularDecorator$1(dec, isCore))
            .map((decorator) => decoratorToMetadata(decorator));
        const value = new o.WrappedNodeExpr(ts.factory.createArrayLiteralExpression(ngDecorators));
        mapEntries.push({ key: 'decorators', value, quoted: false });
    }
    return o.literalMap(mapEntries);
}
/**
 * Convert a reflected class member to metadata.
 */
function decoratedClassMemberToMetadata(decorators, isCore) {
    const ngDecorators = decorators
        .filter((dec) => isAngularDecorator$1(dec, isCore))
        .map((decorator) => new o.WrappedNodeExpr(decoratorToMetadata(decorator)));
    return new o.LiteralArrayExpr(ngDecorators);
}
/**
 * Convert a reflected decorator to metadata.
 */
function decoratorToMetadata(decorator, wrapFunctionsInParens) {
    if (decorator.identifier === null) {
        throw new Error('Illegal state: synthesized decorator cannot be emitted in class metadata.');
    }
    // Decorators have a type.
    const properties = [
        ts.factory.createPropertyAssignment('type', decorator.identifier),
    ];
    // Sometimes they have arguments.
    if (decorator.args !== null && decorator.args.length > 0) {
        const args = decorator.args.map((arg) => {
            return wrapFunctionsInParens ? wrapFunctionExpressionsInParens(arg) : arg;
        });
        properties.push(ts.factory.createPropertyAssignment('args', ts.factory.createArrayLiteralExpression(args)));
    }
    return ts.factory.createObjectLiteralExpression(properties, true);
}
/**
 * Whether a given decorator should be treated as an Angular decorator.
 *
 * Either it's used in @angular/core, or it's imported from there.
 */
function isAngularDecorator$1(decorator, isCore) {
    return isCore || (decorator.import !== null && decorator.import.from === '@angular/core');
}
/**
 * Recursively recreates all of the `Identifier` descendant nodes with a particular name inside
 * of an AST node, thus removing any references to them. Useful if a particular node has to be
 * taken from one place any emitted to another one exactly as it has been written.
 */
function removeIdentifierReferences(node, names) {
    const result = ts.transform(node, [
        (context) => (root) => ts.visitNode(root, function walk(current) {
            return (ts.isIdentifier(current) &&
                (typeof names === 'string' ? current.text === names : names.has(current.text))
                ? ts.factory.createIdentifier(current.text)
                : ts.visitEachChild(current, walk, context));
        }),
    ]);
    return result.transformed[0];
}

function extractClassDebugInfo(clazz, reflection, compilerHost, rootDirs, forbidOrphanRendering) {
    if (!reflection.isClass(clazz)) {
        return null;
    }
    const srcFile = clazz.getSourceFile();
    const srcFileMaybeRelativePath = getProjectRelativePath(srcFile.fileName, rootDirs, compilerHost);
    return {
        type: new o.WrappedNodeExpr(clazz.name),
        className: o.literal(clazz.name.getText()),
        filePath: srcFileMaybeRelativePath ? o.literal(srcFileMaybeRelativePath) : null,
        lineNumber: o.literal(srcFile.getLineAndCharacterOfPosition(clazz.name.pos).line + 1),
        forbidOrphanRendering,
    };
}

/**
 * This registry does nothing.
 */
class NoopReferencesRegistry {
    add(source, ...references) { }
}

function extractSchemas(rawExpr, evaluator, context) {
    const schemas = [];
    const result = evaluator.evaluate(rawExpr);
    if (!Array.isArray(result)) {
        throw createValueHasWrongTypeError(rawExpr, result, `${context}.schemas must be an array`);
    }
    for (const schemaRef of result) {
        if (!(schemaRef instanceof Reference)) {
            throw createValueHasWrongTypeError(rawExpr, result, `${context}.schemas must be an array of schemas`);
        }
        const id = schemaRef.getIdentityIn(schemaRef.node.getSourceFile());
        if (id === null || schemaRef.ownedByModuleGuess !== '@angular/core') {
            throw createValueHasWrongTypeError(rawExpr, result, `${context}.schemas must be an array of schemas`);
        }
        // Since `id` is the `ts.Identifier` within the schema ref's declaration file, it's safe to
        // use `id.text` here to figure out which schema is in use. Even if the actual reference was
        // renamed when the user imported it, these names will match.
        switch (id.text) {
            case 'CUSTOM_ELEMENTS_SCHEMA':
                schemas.push(o.CUSTOM_ELEMENTS_SCHEMA);
                break;
            case 'NO_ERRORS_SCHEMA':
                schemas.push(o.NO_ERRORS_SCHEMA);
                break;
            default:
                throw createValueHasWrongTypeError(rawExpr, schemaRef, `'${schemaRef.debugName}' is not a valid ${context} schema`);
        }
    }
    return schemas;
}

/*!
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.dev/license
 */
/** Generates additional fields to be added to a class that has inputs with transform functions. */
function compileInputTransformFields(inputs) {
    const extraFields = [];
    for (const input of inputs) {
        // Note: Signal inputs capture their transform `WriteT` as part of the `InputSignal`.
        // Such inputs will not have a `transform` captured and not generate coercion members.
        if (input.transform) {
            extraFields.push({
                name: `ngAcceptInputType_${input.classPropertyName}`,
                type: o.outputAst.transplantedType(input.transform.type),
                statements: [],
                initializer: null,
                deferrableImports: null,
            });
        }
    }
    return extraFields;
}

/**
 * Registry that keeps track of Angular declarations that are explicitly
 * marked for JIT compilation and are skipping compilation by trait handlers.
 */
class JitDeclarationRegistry {
    jitDeclarations = new Set();
}

/**
 * Represents a symbol that is recognizable across incremental rebuilds, which enables the captured
 * metadata to be compared to the prior compilation. This allows for semantic understanding of
 * the changes that have been made in a rebuild, which potentially enables more reuse of work
 * from the prior compilation.
 */
class SemanticSymbol {
    decl;
    /**
     * The path of the file that declares this symbol.
     */
    path;
    /**
     * The identifier of this symbol, or null if no identifier could be determined. It should
     * uniquely identify the symbol relative to `file`. This is typically just the name of a
     * top-level class declaration, as that uniquely identifies the class within the file.
     *
     * If the identifier is null, then this symbol cannot be recognized across rebuilds. In that
     * case, the symbol is always assumed to have semantically changed to guarantee a proper
     * rebuild.
     */
    identifier;
    constructor(
    /**
     * The declaration for this symbol.
     */
    decl) {
        this.decl = decl;
        this.path = absoluteFromSourceFile(decl.getSourceFile());
        this.identifier = getSymbolIdentifier(decl);
    }
}
function getSymbolIdentifier(decl) {
    if (!ts.isSourceFile(decl.parent)) {
        return null;
    }
    // If this is a top-level class declaration, the class name is used as unique identifier.
    // Other scenarios are currently not supported and causes the symbol not to be identified
    // across rebuilds, unless the declaration node has not changed.
    return decl.name.text;
}

/**
 * Represents a declaration for which no semantic symbol has been registered. For example,
 * declarations from external dependencies have not been explicitly registered and are represented
 * by this symbol. This allows the unresolved symbol to still be compared to a symbol from a prior
 * compilation.
 */
class OpaqueSymbol extends SemanticSymbol {
    isPublicApiAffected() {
        return false;
    }
    isTypeCheckApiAffected() {
        return false;
    }
}
/**
 * The semantic dependency graph of a single compilation.
 */
class SemanticDepGraph {
    files = new Map();
    // Note: the explicit type annotation is used to work around a CI failure on Windows:
    // error TS2742: The inferred type of 'symbolByDecl' cannot be named without a reference to
    // '../../../../../../../external/_main/node_modules/typescript/lib/typescript'. This is likely
    // not portable. A type annotation is necessary.
    symbolByDecl = new Map();
    /**
     * Registers a symbol in the graph. The symbol is given a unique identifier if possible, such that
     * its equivalent symbol can be obtained from a prior graph even if its declaration node has
     * changed across rebuilds. Symbols without an identifier are only able to find themselves in a
     * prior graph if their declaration node is identical.
     */
    registerSymbol(symbol) {
        this.symbolByDecl.set(symbol.decl, symbol);
        if (symbol.identifier !== null) {
            // If the symbol has a unique identifier, record it in the file that declares it. This enables
            // the symbol to be requested by its unique name.
            if (!this.files.has(symbol.path)) {
                this.files.set(symbol.path, new Map());
            }
            this.files.get(symbol.path).set(symbol.identifier, symbol);
        }
    }
    /**
     * Attempts to resolve a symbol in this graph that represents the given symbol from another graph.
     * If no matching symbol could be found, null is returned.
     *
     * @param symbol The symbol from another graph for which its equivalent in this graph should be
     * found.
     */
    getEquivalentSymbol(symbol) {
        // First lookup the symbol by its declaration. It is typical for the declaration to not have
        // changed across rebuilds, so this is likely to find the symbol. Using the declaration also
        // allows to diff symbols for which no unique identifier could be determined.
        let previousSymbol = this.getSymbolByDecl(symbol.decl);
        if (previousSymbol === null && symbol.identifier !== null) {
            // The declaration could not be resolved to a symbol in a prior compilation, which may
            // happen because the file containing the declaration has changed. In that case we want to
            // lookup the symbol based on its unique identifier, as that allows us to still compare the
            // changed declaration to the prior compilation.
            previousSymbol = this.getSymbolByName(symbol.path, symbol.identifier);
        }
        return previousSymbol;
    }
    /**
     * Attempts to find the symbol by its identifier.
     */
    getSymbolByName(path, identifier) {
        if (!this.files.has(path)) {
            return null;
        }
        const file = this.files.get(path);
        if (!file.has(identifier)) {
            return null;
        }
        return file.get(identifier);
    }
    /**
     * Attempts to resolve the declaration to its semantic symbol.
     */
    getSymbolByDecl(decl) {
        if (!this.symbolByDecl.has(decl)) {
            return null;
        }
        return this.symbolByDecl.get(decl);
    }
}
/**
 * Implements the logic to go from a previous dependency graph to a new one, along with information
 * on which files have been affected.
 */
class SemanticDepGraphUpdater {
    priorGraph;
    newGraph = new SemanticDepGraph();
    /**
     * Contains opaque symbols that were created for declarations for which there was no symbol
     * registered, which happens for e.g. external declarations.
     */
    opaqueSymbols = new Map();
    constructor(
    /**
     * The semantic dependency graph of the most recently succeeded compilation, or null if this
     * is the initial build.
     */
    priorGraph) {
        this.priorGraph = priorGraph;
    }
    /**
     * Registers the symbol in the new graph that is being created.
     */
    registerSymbol(symbol) {
        this.newGraph.registerSymbol(symbol);
    }
    /**
     * Takes all facts that have been gathered to create a new semantic dependency graph. In this
     * process, the semantic impact of the changes is determined which results in a set of files that
     * need to be emitted and/or type-checked.
     */
    finalize() {
        if (this.priorGraph === null) {
            // If no prior dependency graph is available then this was the initial build, in which case
            // we don't need to determine the semantic impact as everything is already considered
            // logically changed.
            return {
                needsEmit: new Set(),
                needsTypeCheckEmit: new Set(),
                newGraph: this.newGraph,
            };
        }
        const needsEmit = this.determineInvalidatedFiles(this.priorGraph);
        const needsTypeCheckEmit = this.determineInvalidatedTypeCheckFiles(this.priorGraph);
        return {
            needsEmit,
            needsTypeCheckEmit,
            newGraph: this.newGraph,
        };
    }
    determineInvalidatedFiles(priorGraph) {
        const isPublicApiAffected = new Set();
        // The first phase is to collect all symbols which have their public API affected. Any symbols
        // that cannot be matched up with a symbol from the prior graph are considered affected.
        for (const symbol of this.newGraph.symbolByDecl.values()) {
            const previousSymbol = priorGraph.getEquivalentSymbol(symbol);
            if (previousSymbol === null || symbol.isPublicApiAffected(previousSymbol)) {
                isPublicApiAffected.add(symbol);
            }
        }
        // The second phase is to find all symbols for which the emit result is affected, either because
        // their used declarations have changed or any of those used declarations has had its public API
        // affected as determined in the first phase.
        const needsEmit = new Set();
        for (const symbol of this.newGraph.symbolByDecl.values()) {
            if (symbol.isEmitAffected === undefined) {
                continue;
            }
            const previousSymbol = priorGraph.getEquivalentSymbol(symbol);
            if (previousSymbol === null || symbol.isEmitAffected(previousSymbol, isPublicApiAffected)) {
                needsEmit.add(symbol.path);
            }
        }
        return needsEmit;
    }
    determineInvalidatedTypeCheckFiles(priorGraph) {
        const isTypeCheckApiAffected = new Set();
        // The first phase is to collect all symbols which have their public API affected. Any symbols
        // that cannot be matched up with a symbol from the prior graph are considered affected.
        for (const symbol of this.newGraph.symbolByDecl.values()) {
            const previousSymbol = priorGraph.getEquivalentSymbol(symbol);
            if (previousSymbol === null || symbol.isTypeCheckApiAffected(previousSymbol)) {
                isTypeCheckApiAffected.add(symbol);
            }
        }
        // The second phase is to find all symbols for which the emit result is affected, either because
        // their used declarations have changed or any of those used declarations has had its public API
        // affected as determined in the first phase.
        const needsTypeCheckEmit = new Set();
        for (const symbol of this.newGraph.symbolByDecl.values()) {
            if (symbol.isTypeCheckBlockAffected === undefined) {
                continue;
            }
            const previousSymbol = priorGraph.getEquivalentSymbol(symbol);
            if (previousSymbol === null ||
                symbol.isTypeCheckBlockAffected(previousSymbol, isTypeCheckApiAffected)) {
                needsTypeCheckEmit.add(symbol.path);
            }
        }
        return needsTypeCheckEmit;
    }
    /**
     * Creates a `SemanticReference` for the reference to `decl` using the expression `expr`. See
     * the documentation of `SemanticReference` for details.
     */
    getSemanticReference(decl, expr) {
        return {
            symbol: this.getSymbol(decl),
            importPath: getImportPath(expr),
        };
    }
    /**
     * Gets the `SemanticSymbol` that was registered for `decl` during the current compilation, or
     * returns an opaque symbol that represents `decl`.
     */
    getSymbol(decl) {
        const symbol = this.newGraph.getSymbolByDecl(decl);
        if (symbol === null) {
            // No symbol has been recorded for the provided declaration, which would be the case if the
            // declaration is external. Return an opaque symbol in that case, to allow the external
            // declaration to be compared to a prior compilation.
            return this.getOpaqueSymbol(decl);
        }
        return symbol;
    }
    /**
     * Gets or creates an `OpaqueSymbol` for the provided class declaration.
     */
    getOpaqueSymbol(decl) {
        if (this.opaqueSymbols.has(decl)) {
            return this.opaqueSymbols.get(decl);
        }
        const symbol = new OpaqueSymbol(decl);
        this.opaqueSymbols.set(decl, symbol);
        return symbol;
    }
}
function getImportPath(expr) {
    if (expr instanceof o.ExternalExpr) {
        return `${expr.value.moduleName}\$${expr.value.name}`;
    }
    else {
        return null;
    }
}

/**
 * Determines whether the provided symbols represent the same declaration.
 */
function isSymbolEqual(a, b) {
    if (a.decl === b.decl) {
        // If the declaration is identical then it must represent the same symbol.
        return true;
    }
    if (a.identifier === null || b.identifier === null) {
        // Unidentifiable symbols are assumed to be different.
        return false;
    }
    return a.path === b.path && a.identifier === b.identifier;
}
/**
 * Determines whether the provided references to a semantic symbol are still equal, i.e. represent
 * the same symbol and are imported by the same path.
 */
function isReferenceEqual(a, b) {
    if (!isSymbolEqual(a.symbol, b.symbol)) {
        // If the reference's target symbols are different, the reference itself is different.
        return false;
    }
    // The reference still corresponds with the same symbol, now check that the path by which it is
    // imported has not changed.
    return a.importPath === b.importPath;
}
function referenceEquality(a, b) {
    return a === b;
}
/**
 * Determines if the provided arrays are equal to each other, using the provided equality tester
 * that is called for all entries in the array.
 */
function isArrayEqual(a, b, equalityTester = referenceEquality) {
    if (a === null || b === null) {
        return a === b;
    }
    if (a.length !== b.length) {
        return false;
    }
    return !a.some((item, index) => !equalityTester(item, b[index]));
}
/**
 * Determines if the provided sets are equal to each other, using the provided equality tester.
 * Sets that only differ in ordering are considered equal.
 */
function isSetEqual(a, b, equalityTester = referenceEquality) {
    if (a === null || b === null) {
        return a === b;
    }
    if (a.size !== b.size) {
        return false;
    }
    for (const itemA of a) {
        let found = false;
        for (const itemB of b) {
            if (equalityTester(itemA, itemB)) {
                found = true;
                break;
            }
        }
        if (!found) {
            return false;
        }
    }
    return true;
}

/**
 * Converts the type parameters of the given class into their semantic representation. If the class
 * does not have any type parameters, then `null` is returned.
 */
function extractSemanticTypeParameters(node) {
    if (!ts.isClassDeclaration(node) || node.typeParameters === undefined) {
        return null;
    }
    return node.typeParameters.map((typeParam) => ({
        hasGenericTypeBound: typeParam.constraint !== undefined,
    }));
}
/**
 * Compares the list of type parameters to determine if they can be considered equal.
 */
function areTypeParametersEqual(current, previous) {
    // First compare all type parameters one-to-one; any differences mean that the list of type
    // parameters has changed.
    if (!isArrayEqual(current, previous, isTypeParameterEqual)) {
        return false;
    }
    // If there is a current list of type parameters and if any of them has a generic type constraint,
    // then the meaning of that type parameter may have changed without us being aware; as such we
    // have to assume that the type parameters have in fact changed.
    if (current !== null && current.some((typeParam) => typeParam.hasGenericTypeBound)) {
        return false;
    }
    return true;
}
function isTypeParameterEqual(a, b) {
    return a.hasGenericTypeBound === b.hasGenericTypeBound;
}

var ComponentScopeKind;
(function (ComponentScopeKind) {
    ComponentScopeKind[ComponentScopeKind["NgModule"] = 0] = "NgModule";
    ComponentScopeKind[ComponentScopeKind["Standalone"] = 1] = "Standalone";
    ComponentScopeKind[ComponentScopeKind["Selectorless"] = 2] = "Selectorless";
})(ComponentScopeKind || (ComponentScopeKind = {}));

/**
 * A `ComponentScopeReader` that reads from an ordered set of child readers until it obtains the
 * requested scope.
 *
 * This is used to combine `ComponentScopeReader`s that read from different sources (e.g. from a
 * registry and from the incremental state).
 */
class CompoundComponentScopeReader {
    readers;
    constructor(readers) {
        this.readers = readers;
    }
    getScopeForComponent(clazz) {
        for (const reader of this.readers) {
            const meta = reader.getScopeForComponent(clazz);
            if (meta !== null) {
                return meta;
            }
        }
        return null;
    }
    getRemoteScope(clazz) {
        for (const reader of this.readers) {
            const remoteScope = reader.getRemoteScope(clazz);
            if (remoteScope !== null) {
                return remoteScope;
            }
        }
        return null;
    }
}

/**
 * Reads Angular metadata from classes declared in .d.ts files and computes an `ExportScope`.
 *
 * Given an NgModule declared in a .d.ts file, this resolver can produce a transitive `ExportScope`
 * of all of the directives/pipes it exports. It does this by reading metadata off of Ivy static
 * fields on directives, components, pipes, and NgModules.
 */
class MetadataDtsModuleScopeResolver {
    dtsMetaReader;
    aliasingHost;
    /**
     * Cache which holds fully resolved scopes for NgModule classes from .d.ts files.
     */
    cache = new Map();
    /**
     * @param dtsMetaReader a `MetadataReader` which can read metadata from `.d.ts` files.
     */
    constructor(dtsMetaReader, aliasingHost) {
        this.dtsMetaReader = dtsMetaReader;
        this.aliasingHost = aliasingHost;
    }
    /**
     * Resolve a `Reference`'d NgModule from a .d.ts file and produce a transitive `ExportScope`
     * listing the directives and pipes which that NgModule exports to others.
     *
     * This operation relies on a `Reference` instead of a direct TypeScript node as the `Reference`s
     * produced depend on how the original NgModule was imported.
     */
    resolve(ref) {
        const clazz = ref.node;
        const sourceFile = clazz.getSourceFile();
        if (!sourceFile.isDeclarationFile) {
            throw new Error(`Debug error: DtsModuleScopeResolver.read(${ref.debugName} from ${sourceFile.fileName}), but not a .d.ts file`);
        }
        if (this.cache.has(clazz)) {
            return this.cache.get(clazz);
        }
        // Build up the export scope - those directives and pipes made visible by this module.
        const dependencies = [];
        const meta = this.dtsMetaReader.getNgModuleMetadata(ref);
        if (meta === null) {
            this.cache.set(clazz, null);
            return null;
        }
        const declarations = new Set();
        for (const declRef of meta.declarations) {
            declarations.add(declRef.node);
        }
        // Only the 'exports' field of the NgModule's metadata is important. Imports and declarations
        // don't affect the export scope.
        for (const exportRef of meta.exports) {
            // Attempt to process the export as a directive.
            const directive = this.dtsMetaReader.getDirectiveMetadata(exportRef);
            if (directive !== null) {
                const isReExport = !declarations.has(exportRef.node);
                dependencies.push(this.maybeAlias(directive, sourceFile, isReExport));
                continue;
            }
            // Attempt to process the export as a pipe.
            const pipe = this.dtsMetaReader.getPipeMetadata(exportRef);
            if (pipe !== null) {
                const isReExport = !declarations.has(exportRef.node);
                dependencies.push(this.maybeAlias(pipe, sourceFile, isReExport));
                continue;
            }
            // Attempt to process the export as a module.
            const exportScope = this.resolve(exportRef);
            if (exportScope !== null) {
                // It is a module. Add exported directives and pipes to the current scope. This might
                // involve rewriting the `Reference`s to those types to have an alias expression if one is
                // required.
                if (this.aliasingHost === null) {
                    // Fast path when aliases aren't required.
                    dependencies.push(...exportScope.exported.dependencies);
                }
                else {
                    // It's necessary to rewrite the `Reference`s to add alias expressions. This way, imports
                    // generated to these directives and pipes will use a shallow import to `sourceFile`
                    // instead of a deep import directly to the directive or pipe class.
                    //
                    // One important check here is whether the directive/pipe is declared in the same
                    // source file as the re-exporting NgModule. This can happen if both a directive, its
                    // NgModule, and the re-exporting NgModule are all in the same file. In this case,
                    // no import alias is needed as it would go to the same file anyway.
                    for (const dep of exportScope.exported.dependencies) {
                        dependencies.push(this.maybeAlias(dep, sourceFile, /* isReExport */ true));
                    }
                }
            }
            continue;
            // The export was not a directive, a pipe, or a module. This is an error.
            // TODO(alxhub): produce a ts.Diagnostic
        }
        const exportScope = {
            exported: {
                dependencies,
                isPoisoned: meta.isPoisoned,
            },
        };
        this.cache.set(clazz, exportScope);
        return exportScope;
    }
    maybeAlias(dirOrPipe, maybeAliasFrom, isReExport) {
        const ref = dirOrPipe.ref;
        if (this.aliasingHost === null || ref.node.getSourceFile() === maybeAliasFrom) {
            return dirOrPipe;
        }
        const alias = this.aliasingHost.getAliasIn(ref.node, maybeAliasFrom, isReExport);
        if (alias === null) {
            return dirOrPipe;
        }
        return {
            ...dirOrPipe,
            ref: ref.cloneWithAlias(alias),
        };
    }
}

function getDiagnosticNode(ref, rawExpr) {
    // Show the diagnostic on the node within `rawExpr` which references the declaration
    // in question. `rawExpr` represents the raw expression from which `ref` was partially evaluated,
    // so use that to find the right node. Note that by the type system, `rawExpr` might be `null`, so
    // fall back on the declaration identifier in that case (even though in practice this should never
    // happen since local NgModules always have associated expressions).
    return rawExpr !== null ? ref.getOriginForDiagnostics(rawExpr) : ref.node.name;
}
function makeNotStandaloneDiagnostic(scopeReader, ref, rawExpr, kind) {
    const scope = scopeReader.getScopeForComponent(ref.node);
    let message = `The ${kind} '${ref.node.name.text}' appears in 'imports', but is not standalone and cannot be imported directly.`;
    let relatedInformation = undefined;
    if (scope !== null && scope.kind === ComponentScopeKind.NgModule) {
        // The directive/pipe in question is declared in an NgModule. Check if it's also exported.
        const isExported = scope.exported.dependencies.some((dep) => dep.ref.node === ref.node);
        const relatedInfoMessageText = isExported
            ? `It can be imported using its '${scope.ngModule.name.text}' NgModule instead.`
            : `It's declared in the '${scope.ngModule.name.text}' NgModule, but is not exported. ` +
                'Consider exporting it and importing the NgModule instead.';
        relatedInformation = [makeRelatedInformation(scope.ngModule.name, relatedInfoMessageText)];
    }
    if (relatedInformation === undefined) {
        // If no contextual pointers can be provided to suggest a specific remedy, then at least tell
        // the user broadly what they need to do.
        message += ' It must be imported via an NgModule.';
    }
    return makeDiagnostic(exports.ErrorCode.COMPONENT_IMPORT_NOT_STANDALONE, getDiagnosticNode(ref, rawExpr), message, relatedInformation);
}
function makeUnknownComponentImportDiagnostic(ref, rawExpr) {
    return makeDiagnostic(exports.ErrorCode.COMPONENT_UNKNOWN_IMPORT, getDiagnosticNode(ref, rawExpr), `Component imports must be standalone components, directives, pipes, or must be NgModules.`);
}
function makeUnknownComponentDeferredImportDiagnostic(ref, rawExpr) {
    return makeDiagnostic(exports.ErrorCode.COMPONENT_UNKNOWN_DEFERRED_IMPORT, getDiagnosticNode(ref, rawExpr), `Component deferred imports must be standalone components, directives or pipes.`);
}

/** Value used to mark a module whose scope is in the process of being resolved. */
const IN_PROGRESS_RESOLUTION = {};
/**
 * A registry which collects information about NgModules, Directives, Components, and Pipes which
 * are local (declared in the ts.Program being compiled), and can produce `LocalModuleScope`s
 * which summarize the compilation scope of a component.
 *
 * This class implements the logic of NgModule declarations, imports, and exports and can produce,
 * for a given component, the set of directives and pipes which are "visible" in that component's
 * template.
 *
 * The `LocalModuleScopeRegistry` has two "modes" of operation. During analysis, data for each
 * individual NgModule, Directive, Component, and Pipe is added to the registry. No attempt is made
 * to traverse or validate the NgModule graph (imports, exports, etc). After analysis, one of
 * `getScopeOfModule` or `getScopeForComponent` can be called, which traverses the NgModule graph
 * and applies the NgModule logic to generate a `LocalModuleScope`, the full scope for the given
 * module or component.
 *
 * The `LocalModuleScopeRegistry` is also capable of producing `ts.Diagnostic` errors when Angular
 * semantics are violated.
 */
class LocalModuleScopeRegistry {
    localReader;
    fullReader;
    dependencyScopeReader;
    refEmitter;
    aliasingHost;
    /**
     * Tracks whether the registry has been asked to produce scopes for a module or component. Once
     * this is true, the registry cannot accept registrations of new directives/pipes/modules as it
     * would invalidate the cached scope data.
     */
    sealed = false;
    /**
     * A map of components from the current compilation unit to the NgModule which declared them.
     *
     * As components and directives are not distinguished at the NgModule level, this map may also
     * contain directives. This doesn't cause any problems but isn't useful as there is no concept of
     * a directive's compilation scope.
     */
    declarationToModule = new Map();
    /**
     * This maps from the directive/pipe class to a map of data for each NgModule that declares the
     * directive/pipe. This data is needed to produce an error for the given class.
     */
    duplicateDeclarations = new Map();
    moduleToRef = new Map();
    /**
     * A cache of calculated `LocalModuleScope`s for each NgModule declared in the current program.
  
     */
    cache = new Map();
    /**
     * Tracks the `RemoteScope` for components requiring "remote scoping".
     *
     * Remote scoping is when the set of directives which apply to a given component is set in the
     * NgModule's file instead of directly on the component def (which is sometimes needed to get
     * around cyclic import issues). This is not used in calculation of `LocalModuleScope`s, but is
     * tracked here for convenience.
     */
    remoteScoping = new Map();
    /**
     * Tracks errors accumulated in the processing of scopes for each module declaration.
     */
    scopeErrors = new Map();
    /**
     * Tracks which NgModules have directives/pipes that are declared in more than one module.
     */
    modulesWithStructuralErrors = new Set();
    constructor(localReader, fullReader, dependencyScopeReader, refEmitter, aliasingHost) {
        this.localReader = localReader;
        this.fullReader = fullReader;
        this.dependencyScopeReader = dependencyScopeReader;
        this.refEmitter = refEmitter;
        this.aliasingHost = aliasingHost;
    }
    /**
     * Add an NgModule's data to the registry.
     */
    registerNgModuleMetadata(data) {
        this.assertCollecting();
        const ngModule = data.ref.node;
        this.moduleToRef.set(data.ref.node, data.ref);
        // Iterate over the module's declarations, and add them to declarationToModule. If duplicates
        // are found, they're instead tracked in duplicateDeclarations.
        for (const decl of data.declarations) {
            this.registerDeclarationOfModule(ngModule, decl, data.rawDeclarations);
        }
    }
    registerDirectiveMetadata(directive) { }
    registerPipeMetadata(pipe) { }
    getScopeForComponent(clazz) {
        const scope = !this.declarationToModule.has(clazz)
            ? null
            : this.getScopeOfModule(this.declarationToModule.get(clazz).ngModule);
        return scope;
    }
    /**
     * If `node` is declared in more than one NgModule (duplicate declaration), then get the
     * `DeclarationData` for each offending declaration.
     *
     * Ordinarily a class is only declared in one NgModule, in which case this function returns
     * `null`.
     */
    getDuplicateDeclarations(node) {
        if (!this.duplicateDeclarations.has(node)) {
            return null;
        }
        return Array.from(this.duplicateDeclarations.get(node).values());
    }
    /**
     * Collects registered data for a module and its directives/pipes and convert it into a full
     * `LocalModuleScope`.
     *
     * This method implements the logic of NgModule imports and exports. It returns the
     * `LocalModuleScope` for the given NgModule if one can be produced, `null` if no scope was ever
     * defined, or the string `'error'` if the scope contained errors.
     */
    getScopeOfModule(clazz) {
        return this.moduleToRef.has(clazz)
            ? this.getScopeOfModuleReference(this.moduleToRef.get(clazz))
            : null;
    }
    /**
     * Retrieves any `ts.Diagnostic`s produced during the calculation of the `LocalModuleScope` for
     * the given NgModule, or `null` if no errors were present.
     */
    getDiagnosticsOfModule(clazz) {
        // Required to ensure the errors are populated for the given class. If it has been processed
        // before, this will be a no-op due to the scope cache.
        this.getScopeOfModule(clazz);
        if (this.scopeErrors.has(clazz)) {
            return this.scopeErrors.get(clazz);
        }
        else {
            return null;
        }
    }
    registerDeclarationOfModule(ngModule, decl, rawDeclarations) {
        const declData = {
            ngModule,
            ref: decl,
            rawDeclarations,
        };
        // First, check for duplicate declarations of the same directive/pipe.
        if (this.duplicateDeclarations.has(decl.node)) {
            // This directive/pipe has already been identified as being duplicated. Add this module to the
            // map of modules for which a duplicate declaration exists.
            this.duplicateDeclarations.get(decl.node).set(ngModule, declData);
        }
        else if (this.declarationToModule.has(decl.node) &&
            this.declarationToModule.get(decl.node).ngModule !== ngModule) {
            // This directive/pipe is already registered as declared in another module. Mark it as a
            // duplicate instead.
            const duplicateDeclMap = new Map();
            const firstDeclData = this.declarationToModule.get(decl.node);
            // Mark both modules as having duplicate declarations.
            this.modulesWithStructuralErrors.add(firstDeclData.ngModule);
            this.modulesWithStructuralErrors.add(ngModule);
            // Being detected as a duplicate means there are two NgModules (for now) which declare this
            // directive/pipe. Add both of them to the duplicate tracking map.
            duplicateDeclMap.set(firstDeclData.ngModule, firstDeclData);
            duplicateDeclMap.set(ngModule, declData);
            this.duplicateDeclarations.set(decl.node, duplicateDeclMap);
            // Remove the directive/pipe from `declarationToModule` as it's a duplicate declaration, and
            // therefore not valid.
            this.declarationToModule.delete(decl.node);
        }
        else {
            // This is the first declaration of this directive/pipe, so map it.
            this.declarationToModule.set(decl.node, declData);
        }
    }
    /**
     * Implementation of `getScopeOfModule` which accepts a reference to a class.
     */
    getScopeOfModuleReference(ref) {
        if (this.cache.has(ref.node)) {
            const cachedValue = this.cache.get(ref.node);
            if (cachedValue !== IN_PROGRESS_RESOLUTION) {
                return cachedValue;
            }
        }
        this.cache.set(ref.node, IN_PROGRESS_RESOLUTION);
        // Seal the registry to protect the integrity of the `LocalModuleScope` cache.
        this.sealed = true;
        // `ref` should be an NgModule previously added to the registry. If not, a scope for it
        // cannot be produced.
        const ngModule = this.localReader.getNgModuleMetadata(ref);
        if (ngModule === null) {
            this.cache.set(ref.node, null);
            return null;
        }
        // Errors produced during computation of the scope are recorded here. At the end, if this array
        // isn't empty then `undefined` will be cached and returned to indicate this scope is invalid.
        const diagnostics = [];
        // At this point, the goal is to produce two distinct transitive sets:
        // - the directives and pipes which are visible to components declared in the NgModule.
        // - the directives and pipes which are exported to any NgModules which import this one.
        // Directives and pipes in the compilation scope.
        const compilationDirectives = new Map();
        const compilationPipes = new Map();
        const declared = new Set();
        // Directives and pipes exported to any importing NgModules.
        const exportDirectives = new Map();
        const exportPipes = new Map();
        // The algorithm is as follows:
        // 1) Add all of the directives/pipes from each NgModule imported into the current one to the
        //    compilation scope.
        // 2) Add directives/pipes declared in the NgModule to the compilation scope. At this point, the
        //    compilation scope is complete.
        // 3) For each entry in the NgModule's exports:
        //    a) Attempt to resolve it as an NgModule with its own exported directives/pipes. If it is
        //       one, add them to the export scope of this NgModule.
        //    b) Otherwise, it should be a class in the compilation scope of this NgModule. If it is,
        //       add it to the export scope.
        //    c) If it's neither an NgModule nor a directive/pipe in the compilation scope, then this
        //       is an error.
        //
        let isPoisoned = false;
        if (this.modulesWithStructuralErrors.has(ngModule.ref.node)) {
            // If the module contains declarations that are duplicates, then it's considered poisoned.
            isPoisoned = true;
        }
        // 1) process imports.
        for (const decl of ngModule.imports) {
            const importScope = this.getExportedScope(decl, diagnostics, ref.node, 'import');
            if (importScope !== null) {
                if (importScope === 'invalid' ||
                    importScope === 'cycle' ||
                    importScope.exported.isPoisoned) {
                    // An import was an NgModule but contained errors of its own. Record this as an error too,
                    // because this scope is always going to be incorrect if one of its imports could not be
                    // read.
                    isPoisoned = true;
                    // Prevent the module from reporting a diagnostic about itself when there's a cycle.
                    if (importScope !== 'cycle') {
                        diagnostics.push(invalidTransitiveNgModuleRef(decl, ngModule.rawImports, 'import'));
                    }
                    if (importScope === 'invalid' || importScope === 'cycle') {
                        continue;
                    }
                }
                for (const dep of importScope.exported.dependencies) {
                    if (dep.kind === MetaKind.Directive) {
                        compilationDirectives.set(dep.ref.node, dep);
                    }
                    else if (dep.kind === MetaKind.Pipe) {
                        compilationPipes.set(dep.ref.node, dep);
                    }
                }
                // Successfully processed the import as an NgModule (even if it had errors).
                continue;
            }
            // The import wasn't an NgModule. Maybe it's a standalone entity?
            const directive = this.fullReader.getDirectiveMetadata(decl);
            if (directive !== null) {
                if (directive.isStandalone) {
                    compilationDirectives.set(directive.ref.node, directive);
                }
                else {
                    // Error: can't import a non-standalone component/directive.
                    diagnostics.push(makeNotStandaloneDiagnostic(this, decl, ngModule.rawImports, directive.isComponent ? 'component' : 'directive'));
                    isPoisoned = true;
                }
                continue;
            }
            // It wasn't a directive (standalone or otherwise). Maybe a pipe?
            const pipe = this.fullReader.getPipeMetadata(decl);
            if (pipe !== null) {
                if (pipe.isStandalone) {
                    compilationPipes.set(pipe.ref.node, pipe);
                }
                else {
                    diagnostics.push(makeNotStandaloneDiagnostic(this, decl, ngModule.rawImports, 'pipe'));
                    isPoisoned = true;
                }
                continue;
            }
            // This reference was neither another NgModule nor a standalone entity. Report it as invalid.
            diagnostics.push(invalidRef(decl, ngModule.rawImports, 'import'));
            isPoisoned = true;
        }
        // 2) add declarations.
        for (const decl of ngModule.declarations) {
            const directive = this.localReader.getDirectiveMetadata(decl);
            const pipe = this.localReader.getPipeMetadata(decl);
            if (directive !== null) {
                if (directive.isStandalone) {
                    const refType = directive.isComponent ? 'Component' : 'Directive';
                    diagnostics.push(makeDiagnostic(exports.ErrorCode.NGMODULE_DECLARATION_IS_STANDALONE, decl.getOriginForDiagnostics(ngModule.rawDeclarations), `${refType} ${decl.node.name.text} is standalone, and cannot be declared in an NgModule. Did you mean to import it instead?`));
                    isPoisoned = true;
                    continue;
                }
                compilationDirectives.set(decl.node, { ...directive, ref: decl });
                if (directive.isPoisoned) {
                    isPoisoned = true;
                }
            }
            else if (pipe !== null) {
                if (pipe.isStandalone) {
                    diagnostics.push(makeDiagnostic(exports.ErrorCode.NGMODULE_DECLARATION_IS_STANDALONE, decl.getOriginForDiagnostics(ngModule.rawDeclarations), `Pipe ${decl.node.name.text} is standalone, and cannot be declared in an NgModule. Did you mean to import it instead?`));
                    isPoisoned = true;
                    continue;
                }
                compilationPipes.set(decl.node, { ...pipe, ref: decl });
            }
            else {
                const errorNode = decl.getOriginForDiagnostics(ngModule.rawDeclarations);
                diagnostics.push(makeDiagnostic(exports.ErrorCode.NGMODULE_INVALID_DECLARATION, errorNode, `The class '${decl.node.name.text}' is listed in the declarations ` +
                    `of the NgModule '${ngModule.ref.node.name.text}', but is not a directive, a component, or a pipe. ` +
                    `Either remove it from the NgModule's declarations, or add an appropriate Angular decorator.`, [makeRelatedInformation(decl.node.name, `'${decl.node.name.text}' is declared here.`)]));
                isPoisoned = true;
                continue;
            }
            declared.add(decl.node);
        }
        // 3) process exports.
        // Exports can contain modules, components, or directives. They're processed differently.
        // Modules are straightforward. Directives and pipes from exported modules are added to the
        // export maps. Directives/pipes are different - they might be exports of declared types or
        // imported types.
        for (const decl of ngModule.exports) {
            // Attempt to resolve decl as an NgModule.
            const exportScope = this.getExportedScope(decl, diagnostics, ref.node, 'export');
            if (exportScope === 'invalid' ||
                exportScope === 'cycle' ||
                (exportScope !== null && exportScope.exported.isPoisoned)) {
                // An export was an NgModule but contained errors of its own. Record this as an error too,
                // because this scope is always going to be incorrect if one of its exports could not be
                // read.
                isPoisoned = true;
                // Prevent the module from reporting a diagnostic about itself when there's a cycle.
                if (exportScope !== 'cycle') {
                    diagnostics.push(invalidTransitiveNgModuleRef(decl, ngModule.rawExports, 'export'));
                }
                if (exportScope === 'invalid' || exportScope === 'cycle') {
                    continue;
                }
            }
            else if (exportScope !== null) {
                // decl is an NgModule.
                for (const dep of exportScope.exported.dependencies) {
                    if (dep.kind == MetaKind.Directive) {
                        exportDirectives.set(dep.ref.node, dep);
                    }
                    else if (dep.kind === MetaKind.Pipe) {
                        exportPipes.set(dep.ref.node, dep);
                    }
                }
            }
            else if (compilationDirectives.has(decl.node)) {
                // decl is a directive or component in the compilation scope of this NgModule.
                const directive = compilationDirectives.get(decl.node);
                exportDirectives.set(decl.node, directive);
            }
            else if (compilationPipes.has(decl.node)) {
                // decl is a pipe in the compilation scope of this NgModule.
                const pipe = compilationPipes.get(decl.node);
                exportPipes.set(decl.node, pipe);
            }
            else {
                // decl is an unknown export.
                const dirMeta = this.fullReader.getDirectiveMetadata(decl);
                const pipeMeta = this.fullReader.getPipeMetadata(decl);
                if (dirMeta !== null || pipeMeta !== null) {
                    const isStandalone = dirMeta !== null ? dirMeta.isStandalone : pipeMeta.isStandalone;
                    diagnostics.push(invalidReexport(decl, ngModule.rawExports, isStandalone));
                }
                else {
                    diagnostics.push(invalidRef(decl, ngModule.rawExports, 'export'));
                }
                isPoisoned = true;
                continue;
            }
        }
        const exported = {
            dependencies: [...exportDirectives.values(), ...exportPipes.values()],
            isPoisoned,
        };
        const reexports = this.getReexports(ngModule, ref, declared, exported.dependencies, diagnostics);
        // Finally, produce the `LocalModuleScope` with both the compilation and export scopes.
        const scope = {
            kind: ComponentScopeKind.NgModule,
            ngModule: ngModule.ref.node,
            compilation: {
                dependencies: [...compilationDirectives.values(), ...compilationPipes.values()],
                isPoisoned,
            },
            exported,
            reexports,
            schemas: ngModule.schemas,
        };
        // Check if this scope had any errors during production.
        if (diagnostics.length > 0) {
            // Save the errors for retrieval.
            this.scopeErrors.set(ref.node, diagnostics);
            // Mark this module as being tainted.
            this.modulesWithStructuralErrors.add(ref.node);
        }
        this.cache.set(ref.node, scope);
        return scope;
    }
    /**
     * Check whether a component requires remote scoping.
     */
    getRemoteScope(node) {
        return this.remoteScoping.has(node) ? this.remoteScoping.get(node) : null;
    }
    /**
     * Set a component as requiring remote scoping, with the given directives and pipes to be
     * registered remotely.
     */
    setComponentRemoteScope(node, directives, pipes) {
        this.remoteScoping.set(node, { directives, pipes });
    }
    /**
     * Look up the `ExportScope` of a given `Reference` to an NgModule.
     *
     * The NgModule in question may be declared locally in the current ts.Program, or it may be
     * declared in a .d.ts file.
     *
     * @returns `null` if no scope could be found, or `'invalid'` if the `Reference` is not a valid
     *     NgModule.
     *
     * May also contribute diagnostics of its own by adding to the given `diagnostics`
     * array parameter.
     */
    getExportedScope(ref, diagnostics, ownerForErrors, type) {
        if (ref.node.getSourceFile().isDeclarationFile) {
            // The NgModule is declared in a .d.ts file. Resolve it with the `DependencyScopeReader`.
            if (!ts.isClassDeclaration(ref.node)) {
                // The NgModule is in a .d.ts file but is not declared as a ts.ClassDeclaration. This is an
                // error in the .d.ts metadata.
                const code = type === 'import' ? exports.ErrorCode.NGMODULE_INVALID_IMPORT : exports.ErrorCode.NGMODULE_INVALID_EXPORT;
                diagnostics.push(makeDiagnostic(code, identifierOfNode(ref.node) || ref.node, `Appears in the NgModule.${type}s of ${nodeNameForError(ownerForErrors)}, but could not be resolved to an NgModule`));
                return 'invalid';
            }
            return this.dependencyScopeReader.resolve(ref);
        }
        else {
            if (this.cache.get(ref.node) === IN_PROGRESS_RESOLUTION) {
                diagnostics.push(makeDiagnostic(type === 'import'
                    ? exports.ErrorCode.NGMODULE_INVALID_IMPORT
                    : exports.ErrorCode.NGMODULE_INVALID_EXPORT, identifierOfNode(ref.node) || ref.node, `NgModule "${type}" field contains a cycle`));
                return 'cycle';
            }
            // The NgModule is declared locally in the current program. Resolve it from the registry.
            return this.getScopeOfModuleReference(ref);
        }
    }
    getReexports(ngModule, ref, declared, exported, diagnostics) {
        let reexports = null;
        const sourceFile = ref.node.getSourceFile();
        if (this.aliasingHost === null) {
            return null;
        }
        reexports = [];
        // Track re-exports by symbol name, to produce diagnostics if two alias re-exports would share
        // the same name.
        const reexportMap = new Map();
        // Alias ngModuleRef added for readability below.
        const ngModuleRef = ref;
        const addReexport = (exportRef) => {
            if (exportRef.node.getSourceFile() === sourceFile) {
                return;
            }
            const isReExport = !declared.has(exportRef.node);
            const exportName = this.aliasingHost.maybeAliasSymbolAs(exportRef, sourceFile, ngModule.ref.node.name.text, isReExport);
            if (exportName === null) {
                return;
            }
            if (!reexportMap.has(exportName)) {
                if (exportRef.alias && exportRef.alias instanceof o.ExternalExpr) {
                    reexports.push({
                        fromModule: exportRef.alias.value.moduleName,
                        symbolName: exportRef.alias.value.name,
                        asAlias: exportName,
                    });
                }
                else {
                    const emittedRef = this.refEmitter.emit(exportRef.cloneWithNoIdentifiers(), sourceFile);
                    assertSuccessfulReferenceEmit(emittedRef, ngModuleRef.node.name, 'class');
                    const expr = emittedRef.expression;
                    if (!(expr instanceof o.ExternalExpr) ||
                        expr.value.moduleName === null ||
                        expr.value.name === null) {
                        throw new Error('Expected ExternalExpr');
                    }
                    reexports.push({
                        fromModule: expr.value.moduleName,
                        symbolName: expr.value.name,
                        asAlias: exportName,
                    });
                }
                reexportMap.set(exportName, exportRef);
            }
            else {
                // Another re-export already used this name. Produce a diagnostic.
                const prevRef = reexportMap.get(exportName);
                diagnostics.push(reexportCollision(ngModuleRef.node, prevRef, exportRef));
            }
        };
        for (const { ref } of exported) {
            addReexport(ref);
        }
        return reexports;
    }
    assertCollecting() {
        if (this.sealed) {
            throw new Error(`Assertion: LocalModuleScopeRegistry is not COLLECTING`);
        }
    }
}
/**
 * Produce a `ts.Diagnostic` for an invalid import or export from an NgModule.
 */
function invalidRef(decl, rawExpr, type) {
    const code = type === 'import' ? exports.ErrorCode.NGMODULE_INVALID_IMPORT : exports.ErrorCode.NGMODULE_INVALID_EXPORT;
    const resolveTarget = type === 'import' ? 'NgModule' : 'NgModule, Component, Directive, or Pipe';
    const message = `'${decl.node.name.text}' does not appear to be an ${resolveTarget} class.`;
    const library = decl.ownedByModuleGuess !== null ? ` (${decl.ownedByModuleGuess})` : '';
    const sf = decl.node.getSourceFile();
    let relatedMessage;
    // Provide extra context to the error for the user.
    if (!sf.isDeclarationFile) {
        // This is a file in the user's program. Highlight the class as undecorated.
        const annotationType = type === 'import' ? '@NgModule' : 'Angular';
        relatedMessage = `Is it missing an ${annotationType} annotation?`;
    }
    else if (sf.fileName.indexOf('node_modules') !== -1) {
        // This file comes from a third-party library in node_modules.
        relatedMessage =
            `This likely means that the library${library} which declares ${decl.debugName} is not ` +
                'compatible with Angular Ivy. Check if a newer version of the library is available, ' +
                "and update if so. Also consider checking with the library's authors to see if the " +
                'library is expected to be compatible with Ivy.';
    }
    else {
        // This is a monorepo style local dependency. Unfortunately these are too different to really
        // offer much moreÂ advice than this.
        relatedMessage = `This likely means that the dependency${library} which declares ${decl.debugName} is not compatible with Angular Ivy.`;
    }
    return makeDiagnostic(code, getDiagnosticNode(decl, rawExpr), message, [
        makeRelatedInformation(decl.node.name, relatedMessage),
    ]);
}
/**
 * Produce a `ts.Diagnostic` for an import or export which itself has errors.
 */
function invalidTransitiveNgModuleRef(decl, rawExpr, type) {
    const code = type === 'import' ? exports.ErrorCode.NGMODULE_INVALID_IMPORT : exports.ErrorCode.NGMODULE_INVALID_EXPORT;
    return makeDiagnostic(code, getDiagnosticNode(decl, rawExpr), `This ${type} contains errors, which may affect components that depend on this NgModule.`);
}
/**
 * Produce a `ts.Diagnostic` for an exported directive or pipe which was not declared or imported
 * by the NgModule in question.
 */
function invalidReexport(decl, rawExpr, isStandalone) {
    // The root error is the same here - this export is not valid. Give a helpful error message based
    // on the specific circumstance.
    let message = `Can't be exported from this NgModule, as `;
    if (isStandalone) {
        // Standalone types need to be imported into an NgModule before they can be re-exported.
        message += 'it must be imported first';
    }
    else if (decl.node.getSourceFile().isDeclarationFile) {
        // Non-standalone types can be re-exported, but need to be imported into the NgModule first.
        // This requires importing their own NgModule.
        message += 'it must be imported via its NgModule first';
    }
    else {
        // Local non-standalone types must either be declared directly by this NgModule, or imported as
        // above.
        message +=
            'it must be either declared by this NgModule, or imported here via its NgModule first';
    }
    return makeDiagnostic(exports.ErrorCode.NGMODULE_INVALID_REEXPORT, getDiagnosticNode(decl, rawExpr), message);
}
/**
 * Produce a `ts.Diagnostic` for a collision in re-export names between two directives/pipes.
 */
function reexportCollision(module, refA, refB) {
    const childMessageText = `This directive/pipe is part of the exports of '${module.name.text}' and shares the same name as another exported directive/pipe.`;
    return makeDiagnostic(exports.ErrorCode.NGMODULE_REEXPORT_NAME_COLLISION, module.name, `
    There was a name collision between two classes named '${refA.node.name.text}', which are both part of the exports of '${module.name.text}'.

    Angular generates re-exports of an NgModule's exported directives/pipes from the module's source file in certain cases, using the declared name of the class. If two classes of the same name are exported, this automatic naming does not work.

    To fix this problem please re-export one or both classes directly from this file.
  `.trim(), [
        makeRelatedInformation(refA.node.name, childMessageText),
        makeRelatedInformation(refB.node.name, childMessageText),
    ]);
}

/**
 * Computes the scope for a selectorless component by looking at imports within the same
 * file and resolving them to metadata.
 */
class SelectorlessComponentScopeReader {
    metaReader;
    reflector;
    cache = new Map();
    constructor(metaReader, reflector) {
        this.metaReader = metaReader;
        this.reflector = reflector;
    }
    getScopeForComponent(node) {
        if (this.cache.has(node)) {
            return this.cache.get(node);
        }
        const clazzRef = new Reference(node);
        const meta = this.metaReader.getDirectiveMetadata(clazzRef);
        if (meta === null || !meta.isComponent || !meta.isStandalone || !meta.selectorlessEnabled) {
            this.cache.set(node, null);
            return null;
        }
        const eligibleIdentifiers = this.getAvailableIdentifiers(node);
        const dependencies = new Map();
        const dependencyIdentifiers = [];
        let isPoisoned = meta.isPoisoned;
        for (const [name, identifier] of eligibleIdentifiers) {
            if (dependencies.has(name)) {
                continue;
            }
            const dep = this.getMetaFromIdentifier(meta, name, identifier);
            if (dep !== null) {
                dependencies.set(name, dep);
                dependencyIdentifiers.push(identifier);
                if (dep.kind === MetaKind.Directive && dep.isPoisoned) {
                    isPoisoned = true;
                }
            }
        }
        const scope = {
            kind: ComponentScopeKind.Selectorless,
            component: node,
            dependencies,
            dependencyIdentifiers,
            isPoisoned,
            schemas: meta.schemas ?? [],
        };
        this.cache.set(node, scope);
        return scope;
    }
    getRemoteScope() {
        return null;
    }
    /** Determines which identifiers a class has access to. */
    getAvailableIdentifiers(node) {
        const result = new Map();
        let current = ts.getOriginalNode(node).parent;
        while (current) {
            // Note: doesn't account for some cases like function parameters,
            // but we likely don't want to support those anyways.
            if (!ts.isSourceFile(current) && !ts.isBlock(current)) {
                current = current.parent;
                continue;
            }
            for (const stmt of current.statements) {
                if (this.reflector.isClass(stmt)) {
                    result.set(stmt.name.text, stmt.name);
                    continue;
                }
                if (ts.isImportDeclaration(stmt) &&
                    stmt.importClause !== undefined &&
                    !stmt.importClause.isTypeOnly) {
                    const clause = stmt.importClause;
                    if (clause.namedBindings !== undefined && ts.isNamedImports(clause.namedBindings)) {
                        for (const element of clause.namedBindings.elements) {
                            if (!element.isTypeOnly) {
                                result.set(element.name.text, element.name);
                            }
                        }
                    }
                    if (clause.name !== undefined) {
                        result.set(clause.name.text, clause.name);
                    }
                    continue;
                }
            }
            current = current.parent;
        }
        return result;
    }
    getMetaFromIdentifier(meta, localName, node) {
        // Consult the set of used names in the template so we don't hit the type checker for every
        // import in the file. Most likely a subset of imports in the file will be used in the template.
        if (meta.localReferencedSymbols === null || !meta.localReferencedSymbols.has(localName)) {
            return null;
        }
        const declaration = this.reflector.getDeclarationOfIdentifier(node);
        if (declaration === null || !this.reflector.isClass(declaration.node)) {
            return null;
        }
        const ref = new Reference(declaration.node);
        return this.metaReader.getDirectiveMetadata(ref) ?? this.metaReader.getPipeMetadata(ref);
    }
}

/**
 * Computes scope information to be used in template type checking.
 */
class TypeCheckScopeRegistry {
    scopeReader;
    metaReader;
    hostDirectivesResolver;
    /**
     * Cache of flattened directive metadata. Because flattened metadata is scope-invariant it's
     * cached individually, such that all scopes refer to the same flattened metadata.
     */
    flattenedDirectiveMetaCache = new Map();
    /**
     * Cache of the computed type check scope per NgModule declaration.
     */
    scopeCache = new Map();
    constructor(scopeReader, metaReader, hostDirectivesResolver) {
        this.scopeReader = scopeReader;
        this.metaReader = metaReader;
        this.hostDirectivesResolver = hostDirectivesResolver;
    }
    /**
     * Computes the type-check scope information for the component declaration. If the NgModule
     * contains an error, then 'error' is returned. If the component is not declared in any NgModule,
     * an empty type-check scope is returned.
     */
    getTypeCheckScope(ref) {
        const directives = [];
        const pipes = new Map();
        const scope = this.scopeReader.getScopeForComponent(ref.node);
        const hostMeta = this.getTypeCheckDirectiveMetadata(ref);
        const directivesOnHost = hostMeta === null ? null : this.combineWithHostDirectives(hostMeta);
        if (scope === null) {
            return {
                matcher: null,
                directives,
                pipes,
                schemas: [],
                isPoisoned: false,
                directivesOnHost,
            };
        }
        const isNgModuleScope = scope.kind === ComponentScopeKind.NgModule;
        const isSelectorlessScope = scope.kind === ComponentScopeKind.Selectorless;
        const cacheKey = isNgModuleScope ? scope.ngModule : scope.component;
        if (this.scopeCache.has(cacheKey)) {
            return this.scopeCache.get(cacheKey);
        }
        let matcher;
        if (isSelectorlessScope) {
            matcher = this.getSelectorlessMatcher(scope);
            for (const [name, dep] of scope.dependencies) {
                if (dep.kind === MetaKind.Directive) {
                    directives.push(dep);
                }
                else {
                    // Pipes should be available under the imported name in selectorless.
                    pipes.set(name, dep);
                }
            }
        }
        else {
            const dependencies = isNgModuleScope ? scope.compilation.dependencies : scope.dependencies;
            let allDependencies = dependencies;
            if (!isNgModuleScope &&
                Array.isArray(scope.deferredDependencies) &&
                scope.deferredDependencies.length > 0) {
                allDependencies = [...allDependencies, ...scope.deferredDependencies];
            }
            matcher = this.getSelectorMatcher(allDependencies);
            for (const dep of allDependencies) {
                if (dep.kind === MetaKind.Directive) {
                    directives.push(dep);
                }
                else if (dep.kind === MetaKind.Pipe && dep.name !== null) {
                    pipes.set(dep.name, dep);
                }
            }
        }
        const typeCheckScope = {
            matcher,
            directives,
            pipes,
            schemas: scope.schemas,
            directivesOnHost,
            isPoisoned: scope.kind === ComponentScopeKind.NgModule
                ? scope.compilation.isPoisoned || scope.exported.isPoisoned
                : scope.isPoisoned,
        };
        this.scopeCache.set(cacheKey, typeCheckScope);
        return typeCheckScope;
    }
    getTypeCheckDirectiveMetadata(ref) {
        const clazz = ref.node;
        if (this.flattenedDirectiveMetaCache.has(clazz)) {
            return this.flattenedDirectiveMetaCache.get(clazz);
        }
        const meta = flattenInheritedDirectiveMetadata(this.metaReader, ref);
        if (meta === null) {
            return null;
        }
        this.flattenedDirectiveMetaCache.set(clazz, meta);
        return meta;
    }
    applyExplicitlyDeferredFlag(meta, isExplicitlyDeferred) {
        return isExplicitlyDeferred === true ? { ...meta, isExplicitlyDeferred } : meta;
    }
    getSelectorMatcher(allDependencies) {
        const matcher = new o.SelectorMatcher();
        for (const meta of allDependencies) {
            if (meta.kind === MetaKind.Directive && meta.selector !== null) {
                const extMeta = this.getTypeCheckDirectiveMetadata(meta.ref);
                if (extMeta === null) {
                    continue;
                }
                // Carry over the `isExplicitlyDeferred` flag from the dependency info.
                const directiveMeta = this.applyExplicitlyDeferredFlag(extMeta, meta.isExplicitlyDeferred);
                matcher.addSelectables(o.CssSelector.parse(meta.selector), this.combineWithHostDirectives(directiveMeta));
            }
        }
        return matcher;
    }
    getSelectorlessMatcher(scope) {
        const registry = new Map();
        for (const [name, dep] of scope.dependencies) {
            const extMeta = dep.kind === MetaKind.Directive ? this.getTypeCheckDirectiveMetadata(dep.ref) : null;
            if (extMeta !== null) {
                registry.set(name, this.combineWithHostDirectives(extMeta));
            }
        }
        return new o.SelectorlessMatcher(registry);
    }
    combineWithHostDirectives(meta) {
        return [...this.hostDirectivesResolver.resolve(meta), meta];
    }
}

/**
 * Validates that the initializer member is compatible with the given class
 * member in terms of field access and visibility.
 *
 * @throws {FatalDiagnosticError} If the recognized initializer API is
 *   incompatible.
 */
function validateAccessOfInitializerApiMember({ api, call }, member) {
    if (!api.allowedAccessLevels.includes(member.accessLevel)) {
        throw new FatalDiagnosticError(exports.ErrorCode.INITIALIZER_API_DISALLOWED_MEMBER_VISIBILITY, call, makeDiagnosticChain(`Cannot use "${api.functionName}" on a class member that is declared as ${classMemberAccessLevelToString(member.accessLevel)}.`, [
            makeDiagnosticChain(`Update the class field to be either: ` +
                api.allowedAccessLevels.map((l) => classMemberAccessLevelToString(l)).join(', ')),
        ]));
    }
}

/**
 * Attempts to identify an Angular initializer function call.
 *
 * Note that multiple possible initializer API function names can be specified,
 * allowing for checking multiple types in one pass.
 *
 * @returns The parsed initializer API, or null if none was found.
 */
function tryParseInitializerApi(functions, expression, reflector, importTracker) {
    if (ts.isAsExpression(expression) || ts.isParenthesizedExpression(expression)) {
        return tryParseInitializerApi(functions, expression.expression, reflector, importTracker);
    }
    if (!ts.isCallExpression(expression)) {
        return null;
    }
    const staticResult = parseTopLevelCall(expression, functions, importTracker) ||
        parseTopLevelRequiredCall(expression, functions, importTracker) ||
        parseTopLevelCallFromNamespace(expression, functions, importTracker);
    if (staticResult === null) {
        return null;
    }
    const { api, apiReference, isRequired } = staticResult;
    // Once we've statically determined that the initializer is one of the APIs we're looking for, we
    // need to verify it using the type checker which accounts for things like shadowed variables.
    // This should be done as the absolute last step since using the type check can be expensive.
    const resolvedImport = reflector.getImportOfIdentifier(apiReference);
    if (resolvedImport === null ||
        api.functionName !== resolvedImport.name ||
        api.owningModule !== resolvedImport.from) {
        return null;
    }
    return {
        api,
        call: expression,
        isRequired,
    };
}
/**
 * Attempts to parse a top-level call to an initializer function,
 * e.g. `prop = input()`. Returns null if it can't be parsed.
 */
function parseTopLevelCall(call, functions, importTracker) {
    const node = call.expression;
    if (!ts.isIdentifier(node)) {
        return null;
    }
    const matchingApi = functions.find((fn) => importTracker.isPotentialReferenceToNamedImport(node, fn.functionName, fn.owningModule));
    if (matchingApi === undefined) {
        return null;
    }
    return { api: matchingApi, apiReference: node, isRequired: false };
}
/**
 * Attempts to parse a top-level call to a required initializer,
 * e.g. `prop = input.required()`. Returns null if it can't be parsed.
 */
function parseTopLevelRequiredCall(call, functions, importTracker) {
    const node = call.expression;
    if (!ts.isPropertyAccessExpression(node) ||
        !ts.isIdentifier(node.expression) ||
        node.name.text !== 'required') {
        return null;
    }
    const expression = node.expression;
    const matchingApi = functions.find((fn) => importTracker.isPotentialReferenceToNamedImport(expression, fn.functionName, fn.owningModule));
    if (matchingApi === undefined) {
        return null;
    }
    return { api: matchingApi, apiReference: expression, isRequired: true };
}
/**
 * Attempts to parse a top-level call to a function referenced via a namespace import,
 * e.g. `prop = core.input.required()`. Returns null if it can't be parsed.
 */
function parseTopLevelCallFromNamespace(call, functions, importTracker) {
    const node = call.expression;
    if (!ts.isPropertyAccessExpression(node)) {
        return null;
    }
    let apiReference = null;
    let matchingApi = undefined;
    let isRequired = false;
    // `prop = core.input()`
    if (ts.isIdentifier(node.expression) && ts.isIdentifier(node.name)) {
        const namespaceRef = node.expression;
        apiReference = node.name;
        matchingApi = functions.find((fn) => node.name.text === fn.functionName &&
            importTracker.isPotentialReferenceToNamespaceImport(namespaceRef, fn.owningModule));
    }
    else if (
    // `prop = core.input.required()`
    ts.isPropertyAccessExpression(node.expression) &&
        ts.isIdentifier(node.expression.expression) &&
        ts.isIdentifier(node.expression.name) &&
        node.name.text === 'required') {
        const potentialName = node.expression.name.text;
        const namespaceRef = node.expression.expression;
        apiReference = node.expression.name;
        matchingApi = functions.find((fn) => fn.functionName === potentialName &&
            importTracker.isPotentialReferenceToNamespaceImport(namespaceRef, fn.owningModule));
        isRequired = true;
    }
    if (matchingApi === undefined || apiReference === null) {
        return null;
    }
    return { api: matchingApi, apiReference, isRequired };
}

/**
 * Parses and validates input and output initializer function options.
 *
 * This currently only parses the `alias` option and returns it. The other
 * options for signal inputs are runtime constructs that aren't relevant at
 * compile time.
 */
function parseAndValidateInputAndOutputOptions(optionsNode) {
    if (!ts.isObjectLiteralExpression(optionsNode)) {
        throw new FatalDiagnosticError(exports.ErrorCode.VALUE_HAS_WRONG_TYPE, optionsNode, 'Argument needs to be an object literal that is statically analyzable.');
    }
    const options = reflectObjectLiteral(optionsNode);
    let alias = undefined;
    if (options.has('alias')) {
        const aliasExpr = options.get('alias');
        if (!ts.isStringLiteralLike(aliasExpr)) {
            throw new FatalDiagnosticError(exports.ErrorCode.VALUE_HAS_WRONG_TYPE, aliasExpr, 'Alias needs to be a string that is statically analyzable.');
        }
        alias = aliasExpr.text;
    }
    return { alias };
}

/** Represents a function that can declare an input. */
const INPUT_INITIALIZER_FN = {
    functionName: 'input',
    owningModule: '@angular/core',
    // Inputs are accessed from parents, via the `property` instruction.
    // Conceptually, the fields need to be publicly readable, but in practice,
    // accessing `protected` or `private` members works at runtime, so we can allow
    // cases where the input is intentionally not part of the public API, programmatically.
    // Note: `private` is omitted intentionally as this would be a conceptual confusion point.
    allowedAccessLevels: [
        ClassMemberAccessLevel.PublicWritable,
        ClassMemberAccessLevel.PublicReadonly,
        ClassMemberAccessLevel.Protected,
    ],
};
/**
 * Attempts to parse a signal input class member. Returns the parsed
 * input mapping if possible.
 */
function tryParseSignalInputMapping(member, reflector, importTracker) {
    if (member.value === null) {
        return null;
    }
    const signalInput = tryParseInitializerApi([INPUT_INITIALIZER_FN], member.value, reflector, importTracker);
    if (signalInput === null) {
        return null;
    }
    validateAccessOfInitializerApiMember(signalInput, member);
    const optionsNode = (signalInput.isRequired ? signalInput.call.arguments[0] : signalInput.call.arguments[1]);
    const options = optionsNode !== undefined ? parseAndValidateInputAndOutputOptions(optionsNode) : null;
    const classPropertyName = member.name;
    return {
        isSignal: true,
        classPropertyName,
        bindingPropertyName: options?.alias ?? classPropertyName,
        required: signalInput.isRequired,
        // Signal inputs do not capture complex transform metadata.
        // See more details in the `transform` type of `InputMapping`.
        transform: null,
    };
}

/** Represents a function that can declare a model. */
const MODEL_INITIALIZER_FN = {
    functionName: 'model',
    owningModule: '@angular/core',
    // Inputs are accessed from parents, via the `property` instruction.
    // Conceptually, the fields need to be publicly readable, but in practice,
    // accessing `protected` or `private` members works at runtime, so we can allow
    // cases where the input is intentionally not part of the public API, programmatically.
    allowedAccessLevels: [
        ClassMemberAccessLevel.PublicWritable,
        ClassMemberAccessLevel.PublicReadonly,
        ClassMemberAccessLevel.Protected,
    ],
};
/**
 * Attempts to parse a model class member. Returns the parsed model mapping if possible.
 */
function tryParseSignalModelMapping(member, reflector, importTracker) {
    if (member.value === null) {
        return null;
    }
    const model = tryParseInitializerApi([MODEL_INITIALIZER_FN], member.value, reflector, importTracker);
    if (model === null) {
        return null;
    }
    validateAccessOfInitializerApiMember(model, member);
    const optionsNode = (model.isRequired ? model.call.arguments[0] : model.call.arguments[1]);
    const options = optionsNode !== undefined ? parseAndValidateInputAndOutputOptions(optionsNode) : null;
    const classPropertyName = member.name;
    const bindingPropertyName = options?.alias ?? classPropertyName;
    return {
        call: model.call,
        input: {
            isSignal: true,
            transform: null,
            classPropertyName,
            bindingPropertyName,
            required: model.isRequired,
        },
        output: {
            isSignal: false,
            classPropertyName,
            bindingPropertyName: bindingPropertyName + 'Change',
        },
    };
}

// Outputs are accessed from parents, via the `listener` instruction.
// Conceptually, the fields need to be publicly readable, but in practice,
// accessing `protected` or `private` members works at runtime, so we can allow
// such outputs that may not want to expose the `OutputRef` as part of the
// component API, programmatically.
// Note: `private` is omitted intentionally as this would be a conceptual confusion point.
const allowedAccessLevels = [
    ClassMemberAccessLevel.PublicWritable,
    ClassMemberAccessLevel.PublicReadonly,
    ClassMemberAccessLevel.Protected,
];
/** Possible functions that can declare an output. */
const OUTPUT_INITIALIZER_FNS = [
    {
        functionName: 'output',
        owningModule: '@angular/core',
        allowedAccessLevels,
    },
    {
        functionName: 'outputFromObservable',
        owningModule: '@angular/core/rxjs-interop',
        allowedAccessLevels,
    },
];
/**
 * Attempts to parse a signal output class member. Returns the parsed
 * input mapping if possible.
 */
function tryParseInitializerBasedOutput(member, reflector, importTracker) {
    if (member.value === null) {
        return null;
    }
    const output = tryParseInitializerApi(OUTPUT_INITIALIZER_FNS, member.value, reflector, importTracker);
    if (output === null) {
        return null;
    }
    if (output.isRequired) {
        throw new FatalDiagnosticError(exports.ErrorCode.INITIALIZER_API_NO_REQUIRED_FUNCTION, output.call, `Output does not support ".required()".`);
    }
    validateAccessOfInitializerApiMember(output, member);
    // Options are the first parameter for `output()`, while for
    // the interop `outputFromObservable()` they are the second argument.
    const optionsNode = (output.api.functionName === 'output' ? output.call.arguments[0] : output.call.arguments[1]);
    const options = optionsNode !== undefined ? parseAndValidateInputAndOutputOptions(optionsNode) : null;
    const classPropertyName = member.name;
    return {
        call: output.call,
        metadata: {
            // Outputs are not signal-based.
            isSignal: false,
            classPropertyName,
            bindingPropertyName: options?.alias ?? classPropertyName,
        },
    };
}

/** Possible names of query initializer APIs. */
const queryFunctionNames = [
    'viewChild',
    'viewChildren',
    'contentChild',
    'contentChildren',
];
/** Possible query initializer API functions. */
const QUERY_INITIALIZER_FNS = queryFunctionNames.map((fnName) => ({
    functionName: fnName,
    owningModule: '@angular/core',
    // Queries are accessed from within static blocks, via the query definition functions.
    // Conceptually, the fields could access private membersâ even ES private fields.
    // Support for ES private fields requires special caution and complexity when partial
    // output is linkedâ hence not supported. TS private members are allowed in static blocks.
    allowedAccessLevels: [
        ClassMemberAccessLevel.PublicWritable,
        ClassMemberAccessLevel.PublicReadonly,
        ClassMemberAccessLevel.Protected,
        ClassMemberAccessLevel.Private,
    ],
}));
// The `descendants` option is enabled by default, except for content children.
const defaultDescendantsValue = (type) => type !== 'contentChildren';
/**
 * Attempts to detect a possible query definition for the given class member.
 *
 * This function checks for all possible variants of queries and matches the
 * first one. The query is then analyzed and its resolved metadata is returned.
 *
 * @returns Resolved query metadata, or null if no query is declared.
 */
function tryParseSignalQueryFromInitializer(member, reflector, importTracker) {
    if (member.value === null) {
        return null;
    }
    const query = tryParseInitializerApi(QUERY_INITIALIZER_FNS, member.value, reflector, importTracker);
    if (query === null) {
        return null;
    }
    validateAccessOfInitializerApiMember(query, member);
    const { functionName } = query.api;
    const isSingleQuery = functionName === 'viewChild' || functionName === 'contentChild';
    const predicateNode = query.call.arguments[0];
    if (predicateNode === undefined) {
        throw new FatalDiagnosticError(exports.ErrorCode.VALUE_HAS_WRONG_TYPE, query.call, 'No locator specified.');
    }
    const optionsNode = query.call.arguments[1];
    if (optionsNode !== undefined && !ts.isObjectLiteralExpression(optionsNode)) {
        throw new FatalDiagnosticError(exports.ErrorCode.VALUE_HAS_WRONG_TYPE, optionsNode, 'Argument needs to be an object literal.');
    }
    const options = optionsNode && reflectObjectLiteral(optionsNode);
    const read = options?.has('read') ? parseReadOption(options.get('read')) : null;
    const descendants = options?.has('descendants')
        ? parseDescendantsOption(options.get('descendants'))
        : defaultDescendantsValue(functionName);
    return {
        name: functionName,
        call: query.call,
        metadata: {
            isSignal: true,
            propertyName: member.name,
            static: false,
            emitDistinctChangesOnly: true,
            predicate: parseLocator(predicateNode, reflector),
            first: isSingleQuery,
            read,
            descendants,
        },
    };
}
/** Parses the locator/predicate of the query. */
function parseLocator(expression, reflector) {
    // Attempt to unwrap `forwardRef` calls.
    const unwrappedExpression = tryUnwrapForwardRef(expression, reflector);
    if (unwrappedExpression !== null) {
        expression = unwrappedExpression;
    }
    if (ts.isStringLiteralLike(expression)) {
        return [expression.text];
    }
    return o.createMayBeForwardRefExpression(new o.outputAst.WrappedNodeExpr(expression), unwrappedExpression !== null ? 2 /* ForwardRefHandling.Unwrapped */ : 0 /* ForwardRefHandling.None */);
}
/**
 * Parses the `read` option of a query.
 *
 * We only support the following patterns for the `read` option:
 *     - `read: someImport.BLA`,
 *     - `read: BLA`
 *
 * That is because we cannot trivially support complex expressions,
 * especially those referencing `this`. The read provider token will
 * live outside of the class in the static class definition.
 */
function parseReadOption(value) {
    if (ts.isExpressionWithTypeArguments(value) ||
        ts.isParenthesizedExpression(value) ||
        ts.isAsExpression(value)) {
        return parseReadOption(value.expression);
    }
    if ((ts.isPropertyAccessExpression(value) && ts.isIdentifier(value.expression)) ||
        ts.isIdentifier(value)) {
        return new o.outputAst.WrappedNodeExpr(value);
    }
    throw new FatalDiagnosticError(exports.ErrorCode.VALUE_NOT_LITERAL, value, `Query "read" option expected a literal class reference.`);
}
/** Parses the `descendants` option of a query. */
function parseDescendantsOption(value) {
    if (value.kind === ts.SyntaxKind.TrueKeyword) {
        return true;
    }
    else if (value.kind === ts.SyntaxKind.FalseKeyword) {
        return false;
    }
    throw new FatalDiagnosticError(exports.ErrorCode.VALUE_HAS_WRONG_TYPE, value, `Expected "descendants" option to be a boolean literal.`);
}

const EMPTY_OBJECT = {};
const queryDecoratorNames = [
    'ViewChild',
    'ViewChildren',
    'ContentChild',
    'ContentChildren',
];
const QUERY_TYPES = new Set(queryDecoratorNames);
/**
 * Helper function to extract metadata from a `Directive` or `Component`. `Directive`s without a
 * selector are allowed to be used for abstract base classes. These abstract directives should not
 * appear in the declarations of an `NgModule` and additional verification is done when processing
 * the module.
 */
function extractDirectiveMetadata(clazz, decorator, reflector, importTracker, evaluator, refEmitter, referencesRegistry, isCore, annotateForClosureCompiler, compilationMode, defaultSelector, strictStandalone, implicitStandaloneValue, emitDeclarationOnly) {
    let directive;
    if (decorator.args === null || decorator.args.length === 0) {
        directive = new Map();
    }
    else if (decorator.args.length !== 1) {
        throw new FatalDiagnosticError(exports.ErrorCode.DECORATOR_ARITY_WRONG, decorator.node, `Incorrect number of arguments to @${decorator.name} decorator`);
    }
    else {
        const meta = unwrapExpression(decorator.args[0]);
        if (!ts.isObjectLiteralExpression(meta)) {
            throw new FatalDiagnosticError(exports.ErrorCode.DECORATOR_ARG_NOT_LITERAL, meta, `@${decorator.name} argument must be an object literal`);
        }
        directive = reflectObjectLiteral(meta);
    }
    if (directive.has('jit')) {
        // The only allowed value is true, so there's no need to expand further.
        return { jitForced: true };
    }
    const members = reflector.getMembersOfClass(clazz);
    // Precompute a list of ts.ClassElements that have decorators. This includes things like @Input,
    // @Output, @HostBinding, etc.
    const decoratedElements = members.filter((member) => !member.isStatic && member.decorators !== null);
    const coreModule = isCore ? undefined : '@angular/core';
    // Construct the map of inputs both from the @Directive/@Component
    // decorator, and the decorated fields.
    const inputsFromMeta = parseInputsArray(clazz, directive, evaluator, reflector, refEmitter, compilationMode, emitDeclarationOnly);
    const inputsFromFields = parseInputFields(clazz, members, evaluator, reflector, importTracker, refEmitter, isCore, compilationMode, inputsFromMeta, decorator, emitDeclarationOnly);
    const inputs = ClassPropertyMapping.fromMappedObject({ ...inputsFromMeta, ...inputsFromFields });
    // And outputs.
    const outputsFromMeta = parseOutputsArray(directive, evaluator);
    const outputsFromFields = parseOutputFields(clazz, decorator, members, isCore, reflector, importTracker, evaluator, outputsFromMeta);
    const outputs = ClassPropertyMapping.fromMappedObject({ ...outputsFromMeta, ...outputsFromFields });
    // Parse queries of fields.
    const { viewQueries, contentQueries } = parseQueriesOfClassFields(members, reflector, importTracker, evaluator, isCore);
    if (directive.has('queries')) {
        const signalQueryFields = new Set([...viewQueries, ...contentQueries].filter((q) => q.isSignal).map((q) => q.propertyName));
        const queriesFromDecorator = extractQueriesFromDecorator(directive.get('queries'), reflector, evaluator, isCore);
        // Checks if the query is already declared/reserved via class members declaration.
        // If so, we throw a fatal diagnostic error to prevent this unintentional pattern.
        const checkAndUnwrapQuery = (q) => {
            if (signalQueryFields.has(q.metadata.propertyName)) {
                throw new FatalDiagnosticError(exports.ErrorCode.INITIALIZER_API_DECORATOR_METADATA_COLLISION, q.expr, `Query is declared multiple times. "@${decorator.name}" declares a query for the same property.`);
            }
            return q.metadata;
        };
        contentQueries.push(...queriesFromDecorator.content.map((q) => checkAndUnwrapQuery(q)));
        viewQueries.push(...queriesFromDecorator.view.map((q) => checkAndUnwrapQuery(q)));
    }
    // Parse the selector.
    let selector = defaultSelector;
    if (directive.has('selector')) {
        const expr = directive.get('selector');
        const resolved = evaluator.evaluate(expr);
        assertLocalCompilationUnresolvedConst(compilationMode, resolved, null, 'Unresolved identifier found for @Component.selector field! Did you ' +
            'import this identifier from a file outside of the compilation unit? ' +
            'This is not allowed when Angular compiler runs in local mode. Possible ' +
            'solutions: 1) Move the declarations into a file within the compilation ' +
            'unit, 2) Inline the selector');
        if (typeof resolved !== 'string') {
            throw createValueHasWrongTypeError(expr, resolved, `selector must be a string`);
        }
        // use default selector in case selector is an empty string
        selector = resolved === '' ? defaultSelector : resolved;
        if (!selector) {
            throw new FatalDiagnosticError(exports.ErrorCode.DIRECTIVE_MISSING_SELECTOR, expr, `Directive ${clazz.name.text} has no selector, please add it!`);
        }
    }
    const hostBindingNodes = {
        literal: null,
        bindingDecorators: new Set(),
        listenerDecorators: new Set(),
    };
    const host = extractHostBindings(decoratedElements, evaluator, coreModule, compilationMode, hostBindingNodes, directive);
    const providers = directive.has('providers')
        ? new o.WrappedNodeExpr(annotateForClosureCompiler
            ? wrapFunctionExpressionsInParens(directive.get('providers'))
            : directive.get('providers'))
        : null;
    // Determine if `ngOnChanges` is a lifecycle hook defined on the component.
    const usesOnChanges = members.some((member) => !member.isStatic && member.kind === ClassMemberKind.Method && member.name === 'ngOnChanges');
    // Parse exportAs.
    let exportAs = null;
    if (directive.has('exportAs')) {
        const expr = directive.get('exportAs');
        const resolved = evaluator.evaluate(expr);
        assertLocalCompilationUnresolvedConst(compilationMode, resolved, null, 'Unresolved identifier found for exportAs field! Did you import this ' +
            'identifier from a file outside of the compilation unit? This is not ' +
            'allowed when Angular compiler runs in local mode. Possible solutions: ' +
            '1) Move the declarations into a file within the compilation unit, ' +
            '2) Inline the selector');
        if (typeof resolved !== 'string') {
            throw createValueHasWrongTypeError(expr, resolved, `exportAs must be a string`);
        }
        exportAs = resolved.split(',').map((part) => part.trim());
    }
    const rawCtorDeps = getConstructorDependencies(clazz, reflector, isCore);
    // Non-abstract directives (those with a selector) require valid constructor dependencies, whereas
    // abstract directives are allowed to have invalid dependencies, given that a subclass may call
    // the constructor explicitly.
    const ctorDeps = selector !== null
        ? validateConstructorDependencies(clazz, rawCtorDeps)
        : unwrapConstructorDependencies(rawCtorDeps);
    // Structural directives must have a `TemplateRef` dependency.
    const isStructural = ctorDeps !== null &&
        ctorDeps !== 'invalid' &&
        ctorDeps.some((dep) => dep.token instanceof o.ExternalExpr &&
            dep.token.value.moduleName === '@angular/core' &&
            dep.token.value.name === 'TemplateRef');
    let isStandalone = implicitStandaloneValue;
    if (directive.has('standalone')) {
        const expr = directive.get('standalone');
        const resolved = evaluator.evaluate(expr);
        if (typeof resolved !== 'boolean') {
            throw createValueHasWrongTypeError(expr, resolved, `standalone flag must be a boolean`);
        }
        isStandalone = resolved;
        if (!isStandalone && strictStandalone) {
            throw new FatalDiagnosticError(exports.ErrorCode.NON_STANDALONE_NOT_ALLOWED, expr, `Only standalone components/directives are allowed when 'strictStandalone' is enabled.`);
        }
    }
    let isSignal = false;
    if (directive.has('signals')) {
        const expr = directive.get('signals');
        const resolved = evaluator.evaluate(expr);
        if (typeof resolved !== 'boolean') {
            throw createValueHasWrongTypeError(expr, resolved, `signals flag must be a boolean`);
        }
        isSignal = resolved;
    }
    // Detect if the component inherits from another class
    const usesInheritance = reflector.hasBaseClass(clazz);
    const sourceFile = clazz.getSourceFile();
    const type = wrapTypeReference(reflector, clazz);
    const rawHostDirectives = directive.get('hostDirectives') || null;
    const hostDirectives = rawHostDirectives === null
        ? null
        : extractHostDirectives(rawHostDirectives, evaluator, reflector, compilationMode, createForwardRefResolver(isCore), emitDeclarationOnly);
    if (compilationMode !== exports.CompilationMode.LOCAL && hostDirectives !== null) {
        // In global compilation mode where we do type checking, the template type-checker will need to
        // import host directive types, so add them as referenced by `clazz`. This will ensure that
        // libraries are required to export host directives which are visible from publicly exported
        // components.
        referencesRegistry.add(clazz, ...hostDirectives.map((hostDir) => {
            if (!isHostDirectiveMetaForGlobalMode(hostDir)) {
                throw new Error('Impossible state');
            }
            return hostDir.directive;
        }));
    }
    const metadata = {
        name: clazz.name.text,
        deps: ctorDeps,
        host: {
            ...host,
        },
        lifecycle: {
            usesOnChanges,
        },
        inputs: inputs.toJointMappedObject(toR3InputMetadata),
        outputs: outputs.toDirectMappedObject(),
        queries: contentQueries,
        viewQueries,
        selector,
        fullInheritance: false,
        type,
        typeArgumentCount: reflector.getGenericArityOfClass(clazz) || 0,
        typeSourceSpan: createSourceSpan(clazz.name),
        usesInheritance,
        exportAs,
        providers,
        isStandalone,
        isSignal,
        hostDirectives: hostDirectives?.map((hostDir) => toHostDirectiveMetadata(hostDir, sourceFile, refEmitter)) ||
            null,
    };
    return {
        jitForced: false,
        decorator: directive,
        metadata,
        inputs,
        outputs,
        isStructural,
        hostDirectives,
        rawHostDirectives,
        hostBindingNodes,
        // Track inputs from class metadata. This is useful for migration efforts.
        inputFieldNamesFromMetadataArray: new Set(Object.values(inputsFromMeta).map((i) => i.classPropertyName)),
    };
}
function extractDecoratorQueryMetadata(exprNode, name, args, propertyName, reflector, evaluator) {
    if (args.length === 0) {
        throw new FatalDiagnosticError(exports.ErrorCode.DECORATOR_ARITY_WRONG, exprNode, `@${name} must have arguments`);
    }
    const first = name === 'ViewChild' || name === 'ContentChild';
    const forwardReferenceTarget = tryUnwrapForwardRef(args[0], reflector);
    const node = forwardReferenceTarget ?? args[0];
    const arg = evaluator.evaluate(node);
    /** Whether or not this query should collect only static results (see view/api.ts)  */
    let isStatic = false;
    // Extract the predicate
    let predicate = null;
    if (arg instanceof Reference || arg instanceof DynamicValue) {
        // References and predicates that could not be evaluated statically are emitted as is.
        predicate = o.createMayBeForwardRefExpression(new o.WrappedNodeExpr(node), forwardReferenceTarget !== null ? 2 /* ForwardRefHandling.Unwrapped */ : 0 /* ForwardRefHandling.None */);
    }
    else if (typeof arg === 'string') {
        predicate = [arg];
    }
    else if (isStringArrayOrDie(arg, `@${name} predicate`, node)) {
        predicate = arg;
    }
    else {
        throw createValueHasWrongTypeError(node, arg, `@${name} predicate cannot be interpreted`);
    }
    // Extract the read and descendants options.
    let read = null;
    // The default value for descendants is true for every decorator except @ContentChildren.
    let descendants = name !== 'ContentChildren';
    let emitDistinctChangesOnly = o.emitDistinctChangesOnlyDefaultValue;
    if (args.length === 2) {
        const optionsExpr = unwrapExpression(args[1]);
        if (!ts.isObjectLiteralExpression(optionsExpr)) {
            throw new FatalDiagnosticError(exports.ErrorCode.DECORATOR_ARG_NOT_LITERAL, optionsExpr, `@${name} options must be an object literal`);
        }
        const options = reflectObjectLiteral(optionsExpr);
        if (options.has('read')) {
            read = new o.WrappedNodeExpr(options.get('read'));
        }
        if (options.has('descendants')) {
            const descendantsExpr = options.get('descendants');
            const descendantsValue = evaluator.evaluate(descendantsExpr);
            if (typeof descendantsValue !== 'boolean') {
                throw createValueHasWrongTypeError(descendantsExpr, descendantsValue, `@${name} options.descendants must be a boolean`);
            }
            descendants = descendantsValue;
        }
        if (options.has('emitDistinctChangesOnly')) {
            const emitDistinctChangesOnlyExpr = options.get('emitDistinctChangesOnly');
            const emitDistinctChangesOnlyValue = evaluator.evaluate(emitDistinctChangesOnlyExpr);
            if (typeof emitDistinctChangesOnlyValue !== 'boolean') {
                throw createValueHasWrongTypeError(emitDistinctChangesOnlyExpr, emitDistinctChangesOnlyValue, `@${name} options.emitDistinctChangesOnly must be a boolean`);
            }
            emitDistinctChangesOnly = emitDistinctChangesOnlyValue;
        }
        if (options.has('static')) {
            const staticValue = evaluator.evaluate(options.get('static'));
            if (typeof staticValue !== 'boolean') {
                throw createValueHasWrongTypeError(node, staticValue, `@${name} options.static must be a boolean`);
            }
            isStatic = staticValue;
        }
    }
    else if (args.length > 2) {
        // Too many arguments.
        throw new FatalDiagnosticError(exports.ErrorCode.DECORATOR_ARITY_WRONG, node, `@${name} has too many arguments`);
    }
    return {
        isSignal: false,
        propertyName,
        predicate,
        first,
        descendants,
        read,
        static: isStatic,
        emitDistinctChangesOnly,
    };
}
function extractHostBindings(members, evaluator, coreModule, compilationMode, hostBindingNodes, metadata) {
    let bindings;
    if (metadata && metadata.has('host')) {
        const hostExpression = metadata.get('host');
        bindings = evaluateHostExpressionBindings(hostExpression, evaluator);
        if (ts.isObjectLiteralExpression(hostExpression)) {
            hostBindingNodes.literal = hostExpression;
        }
    }
    else {
        bindings = o.parseHostBindings({});
    }
    filterToMembersWithDecorator(members, 'HostBinding', coreModule).forEach(({ member, decorators }) => {
        decorators.forEach((decorator) => {
            let hostPropertyName = member.name;
            if (decorator.args !== null && decorator.args.length > 0) {
                if (decorator.args.length !== 1) {
                    throw new FatalDiagnosticError(exports.ErrorCode.DECORATOR_ARITY_WRONG, decorator.node, `@HostBinding can have at most one argument, got ${decorator.args.length} argument(s)`);
                }
                const resolved = evaluator.evaluate(decorator.args[0]);
                // Specific error for local compilation mode if the argument cannot be resolved
                assertLocalCompilationUnresolvedConst(compilationMode, resolved, null, "Unresolved identifier found for @HostBinding's argument! Did " +
                    'you import this identifier from a file outside of the compilation ' +
                    'unit? This is not allowed when Angular compiler runs in local mode. ' +
                    'Possible solutions: 1) Move the declaration into a file within ' +
                    'the compilation unit, 2) Inline the argument');
                if (typeof resolved !== 'string') {
                    throw createValueHasWrongTypeError(decorator.node, resolved, `@HostBinding's argument must be a string`);
                }
                hostPropertyName = resolved;
            }
            if (ts.isDecorator(decorator.node)) {
                hostBindingNodes.bindingDecorators.add(decorator.node);
            }
            // Since this is a decorator, we know that the value is a class member. Always access it
            // through `this` so that further down the line it can't be confused for a literal value
            // (e.g. if there's a property called `true`). There is no size penalty, because all
            // values (except literals) are converted to `ctx.propName` eventually.
            bindings.properties[hostPropertyName] = o.getSafePropertyAccessString('this', member.name);
        });
    });
    filterToMembersWithDecorator(members, 'HostListener', coreModule).forEach(({ member, decorators }) => {
        decorators.forEach((decorator) => {
            let eventName = member.name;
            let args = [];
            if (decorator.args !== null && decorator.args.length > 0) {
                if (decorator.args.length > 2) {
                    throw new FatalDiagnosticError(exports.ErrorCode.DECORATOR_ARITY_WRONG, decorator.args[2], `@HostListener can have at most two arguments`);
                }
                const resolved = evaluator.evaluate(decorator.args[0]);
                // Specific error for local compilation mode if the event name cannot be resolved
                assertLocalCompilationUnresolvedConst(compilationMode, resolved, null, "Unresolved identifier found for @HostListener's event name " +
                    'argument! Did you import this identifier from a file outside of ' +
                    'the compilation unit? This is not allowed when Angular compiler ' +
                    'runs in local mode. Possible solutions: 1) Move the declaration ' +
                    'into a file within the compilation unit, 2) Inline the argument');
                if (typeof resolved !== 'string') {
                    throw createValueHasWrongTypeError(decorator.args[0], resolved, `@HostListener's event name argument must be a string`);
                }
                eventName = resolved;
                if (decorator.args.length === 2) {
                    const expression = decorator.args[1];
                    const resolvedArgs = evaluator.evaluate(decorator.args[1]);
                    if (!isStringArrayOrDie(resolvedArgs, '@HostListener.args', expression)) {
                        throw createValueHasWrongTypeError(decorator.args[1], resolvedArgs, `@HostListener's second argument must be a string array`);
                    }
                    args = resolvedArgs;
                }
            }
            if (ts.isDecorator(decorator.node)) {
                hostBindingNodes.listenerDecorators.add(decorator.node);
            }
            bindings.listeners[eventName] = `${member.name}(${args.join(',')})`;
        });
    });
    return bindings;
}
function extractQueriesFromDecorator(queryData, reflector, evaluator, isCore) {
    const content = [];
    const view = [];
    if (!ts.isObjectLiteralExpression(queryData)) {
        throw new FatalDiagnosticError(exports.ErrorCode.VALUE_HAS_WRONG_TYPE, queryData, 'Decorator queries metadata must be an object literal');
    }
    reflectObjectLiteral(queryData).forEach((queryExpr, propertyName) => {
        queryExpr = unwrapExpression(queryExpr);
        if (!ts.isNewExpression(queryExpr)) {
            throw new FatalDiagnosticError(exports.ErrorCode.VALUE_HAS_WRONG_TYPE, queryData, 'Decorator query metadata must be an instance of a query type');
        }
        const queryType = ts.isPropertyAccessExpression(queryExpr.expression)
            ? queryExpr.expression.name
            : queryExpr.expression;
        if (!ts.isIdentifier(queryType)) {
            throw new FatalDiagnosticError(exports.ErrorCode.VALUE_HAS_WRONG_TYPE, queryData, 'Decorator query metadata must be an instance of a query type');
        }
        const type = reflector.getImportOfIdentifier(queryType);
        if (type === null ||
            (!isCore && type.from !== '@angular/core') ||
            !QUERY_TYPES.has(type.name)) {
            throw new FatalDiagnosticError(exports.ErrorCode.VALUE_HAS_WRONG_TYPE, queryData, 'Decorator query metadata must be an instance of a query type');
        }
        const query = extractDecoratorQueryMetadata(queryExpr, type.name, queryExpr.arguments || [], propertyName, reflector, evaluator);
        if (type.name.startsWith('Content')) {
            content.push({ expr: queryExpr, metadata: query });
        }
        else {
            view.push({ expr: queryExpr, metadata: query });
        }
    });
    return { content, view };
}
function parseDirectiveStyles(directive, evaluator, compilationMode) {
    const expression = directive.get('styles');
    if (!expression) {
        return null;
    }
    const evaluated = evaluator.evaluate(expression);
    const value = typeof evaluated === 'string' ? [evaluated] : evaluated;
    // Check if the identifier used for @Component.styles cannot be resolved in local compilation
    // mode. if the case, an error specific to this situation is generated.
    if (compilationMode === exports.CompilationMode.LOCAL) {
        let unresolvedNode = null;
        if (Array.isArray(value)) {
            const entry = value.find((e) => e instanceof DynamicValue && e.isFromUnknownIdentifier());
            unresolvedNode = entry?.node ?? null;
        }
        else if (value instanceof DynamicValue && value.isFromUnknownIdentifier()) {
            unresolvedNode = value.node;
        }
        if (unresolvedNode !== null) {
            throw new FatalDiagnosticError(exports.ErrorCode.LOCAL_COMPILATION_UNRESOLVED_CONST, unresolvedNode, 'Unresolved identifier found for @Component.styles field! Did you import ' +
                'this identifier from a file outside of the compilation unit? This is ' +
                'not allowed when Angular compiler runs in local mode. Possible ' +
                'solutions: 1) Move the declarations into a file within the compilation ' +
                'unit, 2) Inline the styles, 3) Move the styles into separate files and ' +
                'include it using @Component.styleUrls');
        }
    }
    if (!isStringArrayOrDie(value, 'styles', expression)) {
        throw createValueHasWrongTypeError(expression, value, `Failed to resolve @Component.styles to a string or an array of strings`);
    }
    return value;
}
function parseFieldStringArrayValue(directive, field, evaluator) {
    if (!directive.has(field)) {
        return null;
    }
    // Resolve the field of interest from the directive metadata to a string[].
    const expression = directive.get(field);
    const value = evaluator.evaluate(expression);
    if (!isStringArrayOrDie(value, field, expression)) {
        throw createValueHasWrongTypeError(expression, value, `Failed to resolve @Directive.${field} to a string array`);
    }
    return value;
}
/**
 * Returns a function that can be used to extract data for the `setClassMetadata`
 * calls from undecorated directive class members.
 */
function getDirectiveUndecoratedMetadataExtractor(reflector, importTracker) {
    return (member) => {
        const input = tryParseSignalInputMapping(member, reflector, importTracker);
        if (input !== null) {
            return getDecoratorMetaArray([
                [new o.ExternalExpr(o.R3Identifiers.inputDecorator), memberMetadataFromSignalInput(input)],
            ]);
        }
        const output = tryParseInitializerBasedOutput(member, reflector, importTracker);
        if (output !== null) {
            return getDecoratorMetaArray([
                [
                    new o.ExternalExpr(o.R3Identifiers.outputDecorator),
                    memberMetadataFromInitializerOutput(output.metadata),
                ],
            ]);
        }
        const model = tryParseSignalModelMapping(member, reflector, importTracker);
        if (model !== null) {
            return getDecoratorMetaArray([
                [
                    new o.ExternalExpr(o.R3Identifiers.inputDecorator),
                    memberMetadataFromSignalInput(model.input),
                ],
                [
                    new o.ExternalExpr(o.R3Identifiers.outputDecorator),
                    memberMetadataFromInitializerOutput(model.output),
                ],
            ]);
        }
        const query = tryParseSignalQueryFromInitializer(member, reflector, importTracker);
        if (query !== null) {
            let identifier;
            if (query.name === 'viewChild') {
                identifier = o.R3Identifiers.viewChildDecorator;
            }
            else if (query.name === 'viewChildren') {
                identifier = o.R3Identifiers.viewChildrenDecorator;
            }
            else if (query.name === 'contentChild') {
                identifier = o.R3Identifiers.contentChildDecorator;
            }
            else if (query.name === 'contentChildren') {
                identifier = o.R3Identifiers.contentChildrenDecorator;
            }
            else {
                return null;
            }
            return getDecoratorMetaArray([
                [new o.ExternalExpr(identifier), memberMetadataFromSignalQuery(query.call)],
            ]);
        }
        return null;
    };
}
function getDecoratorMetaArray(decorators) {
    return new o.LiteralArrayExpr(decorators.map(([type, args]) => o.literalMap([
        { key: 'type', value: type, quoted: false },
        { key: 'args', value: args, quoted: false },
    ])));
}
function memberMetadataFromSignalInput(input) {
    // Note that for signal inputs the transform is captured in the signal
    // initializer so we don't need to capture it here.
    return new o.LiteralArrayExpr([
        o.literalMap([
            {
                key: 'isSignal',
                value: o.literal(true),
                quoted: false,
            },
            {
                key: 'alias',
                value: o.literal(input.bindingPropertyName),
                quoted: false,
            },
            {
                key: 'required',
                value: o.literal(input.required),
                quoted: false,
            },
        ]),
    ]);
}
function memberMetadataFromInitializerOutput(output) {
    return new o.LiteralArrayExpr([o.literal(output.bindingPropertyName)]);
}
function memberMetadataFromSignalQuery(call) {
    const firstArg = call.arguments[0];
    const firstArgMeta = ts.isStringLiteralLike(firstArg) || ts.isCallExpression(firstArg)
        ? new o.WrappedNodeExpr(firstArg)
        : // If the first argument is a class reference, we need to wrap it in a `forwardRef`
            // because the reference might occur after the current class. This wouldn't be flagged
            // on the query initializer, because it executes after the class is initialized, whereas
            // `setClassMetadata` runs immediately.
            new o.ExternalExpr(o.R3Identifiers.forwardRef).callFn([
                new o.ArrowFunctionExpr([], new o.WrappedNodeExpr(firstArg)),
            ]);
    const entries = [
        // We use wrapped nodes here, because the output AST doesn't support spread assignments.
        firstArgMeta,
        new o.WrappedNodeExpr(ts.factory.createObjectLiteralExpression([
            ...(call.arguments.length > 1
                ? [ts.factory.createSpreadAssignment(call.arguments[1])]
                : []),
            ts.factory.createPropertyAssignment('isSignal', ts.factory.createTrue()),
        ])),
    ];
    return new o.LiteralArrayExpr(entries);
}
function isStringArrayOrDie(value, name, node) {
    if (!Array.isArray(value)) {
        return false;
    }
    for (let i = 0; i < value.length; i++) {
        if (typeof value[i] !== 'string') {
            throw createValueHasWrongTypeError(node, value[i], `Failed to resolve ${name} at position ${i} to a string`);
        }
    }
    return true;
}
function tryGetQueryFromFieldDecorator(member, reflector, evaluator, isCore) {
    const decorators = member.decorators;
    if (decorators === null) {
        return null;
    }
    const queryDecorators = getAngularDecorators(decorators, queryDecoratorNames, isCore);
    if (queryDecorators.length === 0) {
        return null;
    }
    if (queryDecorators.length !== 1) {
        throw new FatalDiagnosticError(exports.ErrorCode.DECORATOR_COLLISION, member.node ?? queryDecorators[0].node, 'Cannot combine multiple query decorators.');
    }
    const decorator = queryDecorators[0];
    const node = member.node || decorator.node;
    // Throw in case of `@Input() @ContentChild('foo') foo: any`, which is not supported in Ivy
    if (decorators.some((v) => v.name === 'Input')) {
        throw new FatalDiagnosticError(exports.ErrorCode.DECORATOR_COLLISION, node, 'Cannot combine @Input decorators with query decorators');
    }
    if (!isPropertyTypeMember(member)) {
        throw new FatalDiagnosticError(exports.ErrorCode.DECORATOR_UNEXPECTED, node, 'Query decorator must go on a property-type member');
    }
    // Either the decorator was aliased, or is referenced directly with
    // the proper query name.
    const name = (decorator.import?.name ?? decorator.name);
    return {
        name,
        decorator,
        metadata: extractDecoratorQueryMetadata(node, name, decorator.args || [], member.name, reflector, evaluator),
    };
}
function isPropertyTypeMember(member) {
    return (member.kind === ClassMemberKind.Getter ||
        member.kind === ClassMemberKind.Setter ||
        member.kind === ClassMemberKind.Property);
}
function parseMappingStringArray(values) {
    return values.reduce((results, value) => {
        if (typeof value !== 'string') {
            throw new Error('Mapping value must be a string');
        }
        const [bindingPropertyName, fieldName] = parseMappingString(value);
        results[fieldName] = bindingPropertyName;
        return results;
    }, {});
}
function parseMappingString(value) {
    // Either the value is 'field' or 'field: property'. In the first case, `property` will
    // be undefined, in which case the field name should also be used as the property name.
    const [fieldName, bindingPropertyName] = value.split(':', 2).map((str) => str.trim());
    return [bindingPropertyName ?? fieldName, fieldName];
}
/** Parses the `inputs` array of a directive/component decorator. */
function parseInputsArray(clazz, decoratorMetadata, evaluator, reflector, refEmitter, compilationMode, emitDeclarationOnly) {
    const inputsField = decoratorMetadata.get('inputs');
    if (inputsField === undefined) {
        return {};
    }
    const inputs = {};
    const inputsArray = evaluator.evaluate(inputsField);
    if (!Array.isArray(inputsArray)) {
        throw createValueHasWrongTypeError(inputsField, inputsArray, `Failed to resolve @Directive.inputs to an array`);
    }
    for (let i = 0; i < inputsArray.length; i++) {
        const value = inputsArray[i];
        if (typeof value === 'string') {
            // If the value is a string, we treat it as a mapping string.
            const [bindingPropertyName, classPropertyName] = parseMappingString(value);
            inputs[classPropertyName] = {
                bindingPropertyName,
                classPropertyName,
                required: false,
                transform: null,
                // Note: Signal inputs are not allowed with the array form.
                isSignal: false,
            };
        }
        else if (value instanceof Map) {
            // If it's a map, we treat it as a config object.
            const name = value.get('name');
            const alias = value.get('alias');
            const required = value.get('required');
            let transform = null;
            if (typeof name !== 'string') {
                throw createValueHasWrongTypeError(inputsField, name, `Value at position ${i} of @Directive.inputs array must have a "name" property`);
            }
            if (value.has('transform')) {
                const transformValue = value.get('transform');
                if (!(transformValue instanceof DynamicValue) && !(transformValue instanceof Reference)) {
                    throw createValueHasWrongTypeError(inputsField, transformValue, `Transform of value at position ${i} of @Directive.inputs array must be a function`);
                }
                transform = parseDecoratorInputTransformFunction(clazz, name, transformValue, reflector, refEmitter, compilationMode, emitDeclarationOnly);
            }
            inputs[name] = {
                classPropertyName: name,
                bindingPropertyName: typeof alias === 'string' ? alias : name,
                required: required === true,
                // Note: Signal inputs are not allowed with the array form.
                isSignal: false,
                transform,
            };
        }
        else {
            throw createValueHasWrongTypeError(inputsField, value, `@Directive.inputs array can only contain strings or object literals`);
        }
    }
    return inputs;
}
/** Attempts to find a given Angular decorator on the class member. */
function tryGetDecoratorOnMember(member, decoratorName, isCore) {
    if (member.decorators === null) {
        return null;
    }
    for (const decorator of member.decorators) {
        if (isAngularDecorator$2(decorator, decoratorName, isCore)) {
            return decorator;
        }
    }
    return null;
}
function tryParseInputFieldMapping(clazz, member, evaluator, reflector, importTracker, isCore, refEmitter, compilationMode, emitDeclarationOnly) {
    const classPropertyName = member.name;
    const decorator = tryGetDecoratorOnMember(member, 'Input', isCore);
    const signalInputMapping = tryParseSignalInputMapping(member, reflector, importTracker);
    const modelInputMapping = tryParseSignalModelMapping(member, reflector, importTracker);
    if (decorator !== null && signalInputMapping !== null) {
        throw new FatalDiagnosticError(exports.ErrorCode.INITIALIZER_API_WITH_DISALLOWED_DECORATOR, decorator.node, `Using @Input with a signal input is not allowed.`);
    }
    if (decorator !== null && modelInputMapping !== null) {
        throw new FatalDiagnosticError(exports.ErrorCode.INITIALIZER_API_WITH_DISALLOWED_DECORATOR, decorator.node, `Using @Input with a model input is not allowed.`);
    }
    // Check `@Input` case.
    if (decorator !== null) {
        if (decorator.args !== null && decorator.args.length > 1) {
            throw new FatalDiagnosticError(exports.ErrorCode.DECORATOR_ARITY_WRONG, decorator.node, `@${decorator.name} can have at most one argument, got ${decorator.args.length} argument(s)`);
        }
        const optionsNode = decorator.args !== null && decorator.args.length === 1 ? decorator.args[0] : undefined;
        const options = optionsNode !== undefined ? evaluator.evaluate(optionsNode) : null;
        const required = options instanceof Map ? options.get('required') === true : false;
        // To preserve old behavior: Even though TypeScript types ensure proper options are
        // passed, we sanity check for unsupported values here again.
        if (options !== null && typeof options !== 'string' && !(options instanceof Map)) {
            throw createValueHasWrongTypeError(decorator.node, options, `@${decorator.name} decorator argument must resolve to a string or an object literal`);
        }
        let alias = null;
        if (typeof options === 'string') {
            alias = options;
        }
        else if (options instanceof Map && typeof options.get('alias') === 'string') {
            alias = options.get('alias');
        }
        const publicInputName = alias ?? classPropertyName;
        let transform = null;
        if (options instanceof Map && options.has('transform')) {
            const transformValue = options.get('transform');
            if (!(transformValue instanceof DynamicValue) && !(transformValue instanceof Reference)) {
                throw createValueHasWrongTypeError(optionsNode, transformValue, `Input transform must be a function`);
            }
            transform = parseDecoratorInputTransformFunction(clazz, classPropertyName, transformValue, reflector, refEmitter, compilationMode, emitDeclarationOnly);
        }
        return {
            isSignal: false,
            classPropertyName,
            bindingPropertyName: publicInputName,
            transform,
            required,
        };
    }
    // Look for signal inputs. e.g. `memberName = input()`
    if (signalInputMapping !== null) {
        return signalInputMapping;
    }
    if (modelInputMapping !== null) {
        return modelInputMapping.input;
    }
    return null;
}
/** Parses the class members that declare inputs (via decorator or initializer). */
function parseInputFields(clazz, members, evaluator, reflector, importTracker, refEmitter, isCore, compilationMode, inputsFromClassDecorator, classDecorator, emitDeclarationOnly) {
    const inputs = {};
    for (const member of members) {
        const classPropertyName = member.name;
        const inputMapping = tryParseInputFieldMapping(clazz, member, evaluator, reflector, importTracker, isCore, refEmitter, compilationMode, emitDeclarationOnly);
        if (inputMapping === null) {
            continue;
        }
        if (member.isStatic) {
            throw new FatalDiagnosticError(exports.ErrorCode.INCORRECTLY_DECLARED_ON_STATIC_MEMBER, member.node ?? clazz, `Input "${member.name}" is incorrectly declared as static member of "${clazz.name.text}".`);
        }
        // Validate that signal inputs are not accidentally declared in the `inputs` metadata.
        if (inputMapping.isSignal && inputsFromClassDecorator.hasOwnProperty(classPropertyName)) {
            throw new FatalDiagnosticError(exports.ErrorCode.INITIALIZER_API_DECORATOR_METADATA_COLLISION, member.node ?? clazz, `Input "${member.name}" is also declared as non-signal in @${classDecorator.name}.`);
        }
        inputs[classPropertyName] = inputMapping;
    }
    return inputs;
}
/**
 * Parses the `transform` function and its type for a decorator `@Input`.
 *
 * This logic verifies feasibility of extracting the transform write type
 * into a different place, so that the input write type can be captured at
 * a later point in a static acceptance member.
 *
 * Note: This is not needed for signal inputs where the transform type is
 * automatically captured in the type of the `InputSignal`.
 *
 */
function parseDecoratorInputTransformFunction(clazz, classPropertyName, value, reflector, refEmitter, compilationMode, emitDeclarationOnly) {
    if (emitDeclarationOnly) {
        const chain = {
            messageText: '@Input decorators with a transform function are not supported in experimental declaration-only emission mode',
            category: ts.DiagnosticCategory.Error,
            code: 0,
            next: [
                {
                    messageText: `Consider converting '${clazz.name.text}.${classPropertyName}' to an input signal`,
                    category: ts.DiagnosticCategory.Message,
                    code: 0,
                },
            ],
        };
        throw new FatalDiagnosticError(exports.ErrorCode.DECORATOR_UNEXPECTED, value.node, chain);
    }
    // In local compilation mode we can skip type checking the function args. This is because usually
    // the type check is done in a separate build which runs in full compilation mode. So here we skip
    // all the diagnostics.
    if (compilationMode === exports.CompilationMode.LOCAL) {
        const node = value instanceof Reference ? value.getIdentityIn(clazz.getSourceFile()) : value.node;
        // This should never be null since we know the reference originates
        // from the same file, but we null check it just in case.
        if (node === null) {
            throw createValueHasWrongTypeError(value.node, value, 'Input transform function could not be referenced');
        }
        return {
            node,
            type: new Reference(ts.factory.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword)),
        };
    }
    const definition = reflector.getDefinitionOfFunction(value.node);
    if (definition === null) {
        throw createValueHasWrongTypeError(value.node, value, 'Input transform must be a function');
    }
    if (definition.typeParameters !== null && definition.typeParameters.length > 0) {
        throw createValueHasWrongTypeError(value.node, value, 'Input transform function cannot be generic');
    }
    if (definition.signatureCount > 1) {
        throw createValueHasWrongTypeError(value.node, value, 'Input transform function cannot have multiple signatures');
    }
    const members = reflector.getMembersOfClass(clazz);
    for (const member of members) {
        const conflictingName = `ngAcceptInputType_${classPropertyName}`;
        if (member.name === conflictingName && member.isStatic) {
            throw new FatalDiagnosticError(exports.ErrorCode.CONFLICTING_INPUT_TRANSFORM, value.node, `Class cannot have both a transform function on Input ${classPropertyName} and a static member called ${conflictingName}`);
        }
    }
    const node = value instanceof Reference ? value.getIdentityIn(clazz.getSourceFile()) : value.node;
    // This should never be null since we know the reference originates
    // from the same file, but we null check it just in case.
    if (node === null) {
        throw createValueHasWrongTypeError(value.node, value, 'Input transform function could not be referenced');
    }
    // Skip over `this` parameters since they're typing the context, not the actual parameter.
    // `this` parameters are guaranteed to be first if they exist, and the only to distinguish them
    // is using the name, TS doesn't have a special AST for them.
    const firstParam = definition.parameters[0]?.name === 'this' ? definition.parameters[1] : definition.parameters[0];
    // Treat functions with no arguments as `unknown` since returning
    // the same value from the transform function is valid.
    if (!firstParam) {
        return {
            node,
            type: new Reference(ts.factory.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword)),
        };
    }
    // This should be caught by `noImplicitAny` already, but null check it just in case.
    if (!firstParam.type) {
        throw createValueHasWrongTypeError(value.node, value, 'Input transform function first parameter must have a type');
    }
    if (firstParam.node.dotDotDotToken) {
        throw createValueHasWrongTypeError(value.node, value, 'Input transform function first parameter cannot be a spread parameter');
    }
    assertEmittableInputType(firstParam.type, clazz.getSourceFile(), reflector, refEmitter);
    const viaModule = value instanceof Reference ? value.bestGuessOwningModule : null;
    return { node, type: new Reference(firstParam.type, viaModule) };
}
/**
 * Verifies that a type and all types contained within
 * it can be referenced in a specific context file.
 */
function assertEmittableInputType(type, contextFile, reflector, refEmitter) {
    (function walk(node) {
        if (ts.isTypeReferenceNode(node) && ts.isIdentifier(node.typeName)) {
            const declaration = reflector.getDeclarationOfIdentifier(node.typeName);
            if (declaration !== null) {
                // If the type is declared in a different file, we have to check that it can be imported
                // into the context file. If they're in the same file, we need to verify that they're
                // exported, otherwise TS won't emit it to the .d.ts.
                if (declaration.node.getSourceFile() !== contextFile) {
                    const emittedType = refEmitter.emit(new Reference(declaration.node, declaration.viaModule === AmbientImport ? AmbientImport : null), contextFile, ImportFlags.NoAliasing |
                        ImportFlags.AllowTypeImports |
                        ImportFlags.AllowRelativeDtsImports |
                        ImportFlags.AllowAmbientReferences);
                    assertSuccessfulReferenceEmit(emittedType, node, 'type');
                }
                else if (!reflector.isStaticallyExported(declaration.node)) {
                    throw new FatalDiagnosticError(exports.ErrorCode.SYMBOL_NOT_EXPORTED, type, `Symbol must be exported in order to be used as the type of an Input transform function`, [makeRelatedInformation(declaration.node, `The symbol is declared here.`)]);
                }
            }
        }
        node.forEachChild(walk);
    })(type);
}
/**
 * Iterates through all specified class members and attempts to detect
 * view and content queries defined.
 *
 * Queries may be either defined via decorators, or through class member
 * initializers for signal-based queries.
 */
function parseQueriesOfClassFields(members, reflector, importTracker, evaluator, isCore) {
    const viewQueries = [];
    const contentQueries = [];
    // For backwards compatibility, decorator-based queries are grouped and
    // ordered in a specific way. The order needs to match with what we had in:
    // https://github.com/angular/angular/blob/8737544d6963bf664f752de273e919575cca08ac/packages/compiler-cli/src/ngtsc/annotations/directive/src/shared.ts#L94-L111.
    const decoratorViewChild = [];
    const decoratorViewChildren = [];
    const decoratorContentChild = [];
    const decoratorContentChildren = [];
    for (const member of members) {
        const decoratorQuery = tryGetQueryFromFieldDecorator(member, reflector, evaluator, isCore);
        const signalQuery = tryParseSignalQueryFromInitializer(member, reflector, importTracker);
        if (decoratorQuery !== null && signalQuery !== null) {
            throw new FatalDiagnosticError(exports.ErrorCode.INITIALIZER_API_WITH_DISALLOWED_DECORATOR, decoratorQuery.decorator.node, `Using @${decoratorQuery.name} with a signal-based query is not allowed.`);
        }
        const queryNode = decoratorQuery?.decorator.node ?? signalQuery?.call;
        if (queryNode !== undefined && member.isStatic) {
            throw new FatalDiagnosticError(exports.ErrorCode.INCORRECTLY_DECLARED_ON_STATIC_MEMBER, queryNode, `Query is incorrectly declared on a static class member.`);
        }
        if (decoratorQuery !== null) {
            switch (decoratorQuery.name) {
                case 'ViewChild':
                    decoratorViewChild.push(decoratorQuery.metadata);
                    break;
                case 'ViewChildren':
                    decoratorViewChildren.push(decoratorQuery.metadata);
                    break;
                case 'ContentChild':
                    decoratorContentChild.push(decoratorQuery.metadata);
                    break;
                case 'ContentChildren':
                    decoratorContentChildren.push(decoratorQuery.metadata);
                    break;
            }
        }
        else if (signalQuery !== null) {
            switch (signalQuery.name) {
                case 'viewChild':
                case 'viewChildren':
                    viewQueries.push(signalQuery.metadata);
                    break;
                case 'contentChild':
                case 'contentChildren':
                    contentQueries.push(signalQuery.metadata);
                    break;
            }
        }
    }
    return {
        viewQueries: [...viewQueries, ...decoratorViewChild, ...decoratorViewChildren],
        contentQueries: [...contentQueries, ...decoratorContentChild, ...decoratorContentChildren],
    };
}
/** Parses the `outputs` array of a directive/component. */
function parseOutputsArray(directive, evaluator) {
    const metaValues = parseFieldStringArrayValue(directive, 'outputs', evaluator);
    return metaValues ? parseMappingStringArray(metaValues) : EMPTY_OBJECT;
}
/** Parses the class members that are outputs. */
function parseOutputFields(clazz, classDecorator, members, isCore, reflector, importTracker, evaluator, outputsFromMeta) {
    const outputs = {};
    for (const member of members) {
        const decoratorOutput = tryParseDecoratorOutput(member, evaluator, isCore);
        const initializerOutput = tryParseInitializerBasedOutput(member, reflector, importTracker);
        const modelMapping = tryParseSignalModelMapping(member, reflector, importTracker);
        if (decoratorOutput !== null && initializerOutput !== null) {
            throw new FatalDiagnosticError(exports.ErrorCode.INITIALIZER_API_WITH_DISALLOWED_DECORATOR, decoratorOutput.decorator.node, `Using "@Output" with "output()" is not allowed.`);
        }
        if (decoratorOutput !== null && modelMapping !== null) {
            throw new FatalDiagnosticError(exports.ErrorCode.INITIALIZER_API_WITH_DISALLOWED_DECORATOR, decoratorOutput.decorator.node, `Using @Output with a model input is not allowed.`);
        }
        const queryNode = decoratorOutput?.decorator.node ?? initializerOutput?.call ?? modelMapping?.call;
        if (queryNode !== undefined && member.isStatic) {
            throw new FatalDiagnosticError(exports.ErrorCode.INCORRECTLY_DECLARED_ON_STATIC_MEMBER, queryNode, `Output is incorrectly declared on a static class member.`);
        }
        let bindingPropertyName;
        if (decoratorOutput !== null) {
            bindingPropertyName = decoratorOutput.metadata.bindingPropertyName;
        }
        else if (initializerOutput !== null) {
            bindingPropertyName = initializerOutput.metadata.bindingPropertyName;
        }
        else if (modelMapping !== null) {
            bindingPropertyName = modelMapping.output.bindingPropertyName;
        }
        else {
            continue;
        }
        // Validate that initializer-based outputs are not accidentally declared
        // in the `outputs` class metadata.
        if ((initializerOutput !== null || modelMapping !== null) &&
            outputsFromMeta.hasOwnProperty(member.name)) {
            throw new FatalDiagnosticError(exports.ErrorCode.INITIALIZER_API_DECORATOR_METADATA_COLLISION, member.node ?? clazz, `Output "${member.name}" is unexpectedly declared in @${classDecorator.name} as well.`);
        }
        outputs[member.name] = bindingPropertyName;
    }
    return outputs;
}
/** Attempts to parse a decorator-based @Output. */
function tryParseDecoratorOutput(member, evaluator, isCore) {
    const decorator = tryGetDecoratorOnMember(member, 'Output', isCore);
    if (decorator === null) {
        return null;
    }
    if (decorator.args !== null && decorator.args.length > 1) {
        throw new FatalDiagnosticError(exports.ErrorCode.DECORATOR_ARITY_WRONG, decorator.node, `@Output can have at most one argument, got ${decorator.args.length} argument(s)`);
    }
    const classPropertyName = member.name;
    let alias = null;
    if (decorator.args?.length === 1) {
        const resolvedAlias = evaluator.evaluate(decorator.args[0]);
        if (typeof resolvedAlias !== 'string') {
            throw createValueHasWrongTypeError(decorator.node, resolvedAlias, `@Output decorator argument must resolve to a string`);
        }
        alias = resolvedAlias;
    }
    return {
        decorator,
        metadata: {
            isSignal: false,
            classPropertyName,
            bindingPropertyName: alias ?? classPropertyName,
        },
    };
}
function evaluateHostExpressionBindings(hostExpr, evaluator) {
    const hostMetaMap = evaluator.evaluate(hostExpr);
    if (!(hostMetaMap instanceof Map)) {
        throw createValueHasWrongTypeError(hostExpr, hostMetaMap, `Decorator host metadata must be an object`);
    }
    const hostMetadata = {};
    hostMetaMap.forEach((value, key) => {
        // Resolve Enum references to their declared value.
        if (value instanceof EnumValue) {
            value = value.resolved;
        }
        if (typeof key !== 'string') {
            throw createValueHasWrongTypeError(hostExpr, key, `Decorator host metadata must be a string -> string object, but found unparseable key`);
        }
        if (typeof value == 'string') {
            hostMetadata[key] = value;
        }
        else if (value instanceof DynamicValue) {
            hostMetadata[key] = new o.WrappedNodeExpr(value.node);
        }
        else {
            throw createValueHasWrongTypeError(hostExpr, value, `Decorator host metadata must be a string -> string object, but found unparseable value`);
        }
    });
    const bindings = o.parseHostBindings(hostMetadata);
    const errors = o.verifyHostBindings(bindings, createSourceSpan(hostExpr));
    if (errors.length > 0) {
        throw new FatalDiagnosticError(exports.ErrorCode.HOST_BINDING_PARSE_ERROR, getHostBindingErrorNode(errors[0], hostExpr), errors.map((error) => error.msg).join('\n'));
    }
    return bindings;
}
/**
 * Attempts to match a parser error to the host binding expression that caused it.
 * @param error Error to match.
 * @param hostExpr Expression declaring the host bindings.
 */
function getHostBindingErrorNode(error, hostExpr) {
    // In the most common case the `host` object is an object literal with string values. We can
    // confidently match the error to its expression by looking at the string value that the parser
    // failed to parse and the initializers for each of the properties. If we fail to match, we fall
    // back to the old behavior where the error is reported on the entire `host` object.
    if (ts.isObjectLiteralExpression(hostExpr)) {
        for (const prop of hostExpr.properties) {
            if (ts.isPropertyAssignment(prop) &&
                ts.isStringLiteralLike(prop.initializer) &&
                error.msg.includes(`[${prop.initializer.text}]`)) {
                return prop.initializer;
            }
        }
    }
    return hostExpr;
}
/**
 * Extracts and prepares the host directives metadata from an array literal expression.
 * @param rawHostDirectives Expression that defined the `hostDirectives`.
 */
function extractHostDirectives(rawHostDirectives, evaluator, reflector, compilationMode, forwardRefResolver, emitDeclarationOnly) {
    const resolved = evaluator.evaluate(rawHostDirectives, forwardRefResolver);
    if (!Array.isArray(resolved)) {
        throw createValueHasWrongTypeError(rawHostDirectives, resolved, 'hostDirectives must be an array');
    }
    return resolved.map((value) => {
        const hostReference = value instanceof Map ? value.get('directive') : value;
        // Diagnostics
        if (compilationMode !== exports.CompilationMode.LOCAL) {
            if (!(hostReference instanceof Reference)) {
                throw createValueHasWrongTypeError(rawHostDirectives, hostReference, 'Host directive must be a reference');
            }
            if (!isNamedClassDeclaration(hostReference.node)) {
                throw createValueHasWrongTypeError(rawHostDirectives, hostReference, 'Host directive reference must be a class');
            }
        }
        let directive;
        let nameForErrors = (fieldName) => '@Directive.hostDirectives';
        if (compilationMode === exports.CompilationMode.LOCAL && hostReference instanceof DynamicValue) {
            // At the moment in local compilation we only support simple array for host directives, i.e.,
            // an array consisting of the directive identifiers. We don't support forward refs or other
            // expressions applied on externally imported directives. The main reason is simplicity, and
            // that almost nobody wants to use host directives this way (e.g., what would be the point of
            // forward ref for imported symbols?!)
            if (!ts.isIdentifier(hostReference.node) &&
                !ts.isPropertyAccessExpression(hostReference.node)) {
                const compilationModeName = emitDeclarationOnly
                    ? 'experimental declaration-only emission'
                    : 'local compilation';
                throw new FatalDiagnosticError(exports.ErrorCode.LOCAL_COMPILATION_UNSUPPORTED_EXPRESSION, hostReference.node, `In ${compilationModeName} mode, host directive cannot be an expression. Use an identifier instead`);
            }
            if (emitDeclarationOnly) {
                if (ts.isIdentifier(hostReference.node)) {
                    const importInfo = reflector.getImportOfIdentifier(hostReference.node);
                    if (importInfo) {
                        directive = new o.ExternalReference(importInfo.from, importInfo.name);
                    }
                    else {
                        throw new FatalDiagnosticError(exports.ErrorCode.LOCAL_COMPILATION_UNSUPPORTED_EXPRESSION, hostReference.node, `In experimental declaration-only emission mode, host directive cannot use indirect external indentifiers. Use a direct external identifier instead`);
                    }
                }
                else {
                    throw new FatalDiagnosticError(exports.ErrorCode.LOCAL_COMPILATION_UNSUPPORTED_EXPRESSION, hostReference.node, `In experimental declaration-only emission mode, host directive cannot be an expression. Use an identifier instead`);
                }
            }
            else {
                directive = new o.WrappedNodeExpr(hostReference.node);
            }
        }
        else if (hostReference instanceof Reference) {
            directive = hostReference;
            nameForErrors = (fieldName) => `@Directive.hostDirectives.${directive.node.name.text}.${fieldName}`;
        }
        else {
            throw new Error('Impossible state');
        }
        const meta = {
            directive,
            isForwardReference: hostReference instanceof Reference && hostReference.synthetic,
            inputs: parseHostDirectivesMapping('inputs', value, nameForErrors('input'), rawHostDirectives),
            outputs: parseHostDirectivesMapping('outputs', value, nameForErrors('output'), rawHostDirectives),
        };
        return meta;
    });
}
/**
 * Parses the expression that defines the `inputs` or `outputs` of a host directive.
 * @param field Name of the field that is being parsed.
 * @param resolvedValue Evaluated value of the expression that defined the field.
 * @param classReference Reference to the host directive class.
 * @param sourceExpression Expression that the host directive is referenced in.
 */
function parseHostDirectivesMapping(field, resolvedValue, nameForErrors, sourceExpression) {
    if (resolvedValue instanceof Map && resolvedValue.has(field)) {
        const rawInputs = resolvedValue.get(field);
        if (isStringArrayOrDie(rawInputs, nameForErrors, sourceExpression)) {
            return parseMappingStringArray(rawInputs);
        }
    }
    return null;
}
/** Converts the parsed host directive information into metadata. */
function toHostDirectiveMetadata(hostDirective, context, refEmitter) {
    let directive;
    if (hostDirective.directive instanceof Reference) {
        directive = toR3Reference(hostDirective.directive.node, hostDirective.directive, context, refEmitter);
    }
    else if (hostDirective.directive instanceof o.ExternalReference) {
        directive = {
            value: new o.ExternalExpr(hostDirective.directive),
            type: new o.ExternalExpr(hostDirective.directive),
        };
    }
    else {
        directive = {
            value: hostDirective.directive,
            type: hostDirective.directive,
        };
    }
    return {
        directive,
        isForwardReference: hostDirective.isForwardReference,
        inputs: hostDirective.inputs || null,
        outputs: hostDirective.outputs || null,
    };
}
/** Converts the parsed input information into metadata. */
function toR3InputMetadata(mapping) {
    return {
        classPropertyName: mapping.classPropertyName,
        bindingPropertyName: mapping.bindingPropertyName,
        required: mapping.required,
        transformFunction: mapping.transform !== null ? new o.WrappedNodeExpr(mapping.transform.node) : null,
        isSignal: mapping.isSignal,
    };
}
function extractHostBindingResources(nodes) {
    const result = new Set();
    if (nodes.literal !== null) {
        result.add({ path: null, node: nodes.literal });
    }
    for (const current of nodes.bindingDecorators) {
        result.add({ path: null, node: current.expression });
    }
    for (const current of nodes.listenerDecorators) {
        result.add({ path: null, node: current.expression });
    }
    return result;
}

/**
 * Represents an Angular directive. Components are represented by `ComponentSymbol`, which inherits
 * from this symbol.
 */
class DirectiveSymbol extends SemanticSymbol {
    selector;
    inputs;
    outputs;
    exportAs;
    typeCheckMeta;
    typeParameters;
    baseClass = null;
    constructor(decl, selector, inputs, outputs, exportAs, typeCheckMeta, typeParameters) {
        super(decl);
        this.selector = selector;
        this.inputs = inputs;
        this.outputs = outputs;
        this.exportAs = exportAs;
        this.typeCheckMeta = typeCheckMeta;
        this.typeParameters = typeParameters;
    }
    isPublicApiAffected(previousSymbol) {
        // Note: since components and directives have exactly the same items contributing to their
        // public API, it is okay for a directive to change into a component and vice versa without
        // the API being affected.
        if (!(previousSymbol instanceof DirectiveSymbol)) {
            return true;
        }
        // Directives and components have a public API of:
        //  1. Their selector.
        //  2. The binding names of their inputs and outputs; a change in ordering is also considered
        //     to be a change in public API.
        //  3. The list of exportAs names and its ordering.
        return (this.selector !== previousSymbol.selector ||
            !isArrayEqual(this.inputs.propertyNames, previousSymbol.inputs.propertyNames) ||
            !isArrayEqual(this.outputs.propertyNames, previousSymbol.outputs.propertyNames) ||
            !isArrayEqual(this.exportAs, previousSymbol.exportAs));
    }
    isTypeCheckApiAffected(previousSymbol) {
        // If the public API of the directive has changed, then so has its type-check API.
        if (this.isPublicApiAffected(previousSymbol)) {
            return true;
        }
        if (!(previousSymbol instanceof DirectiveSymbol)) {
            return true;
        }
        // The type-check block also depends on the class property names, as writes property bindings
        // directly into the backing fields.
        if (!isArrayEqual(Array.from(this.inputs), Array.from(previousSymbol.inputs), isInputMappingEqual) ||
            !isArrayEqual(Array.from(this.outputs), Array.from(previousSymbol.outputs), isInputOrOutputEqual)) {
            return true;
        }
        // The type parameters of a directive are emitted into the type constructors in the type-check
        // block of a component, so if the type parameters are not considered equal then consider the
        // type-check API of this directive to be affected.
        if (!areTypeParametersEqual(this.typeParameters, previousSymbol.typeParameters)) {
            return true;
        }
        // The type-check metadata is used during TCB code generation, so any changes should invalidate
        // prior type-check files.
        if (!isTypeCheckMetaEqual(this.typeCheckMeta, previousSymbol.typeCheckMeta)) {
            return true;
        }
        // Changing the base class of a directive means that its inputs/outputs etc may have changed,
        // so the type-check block of components that use this directive needs to be regenerated.
        if (!isBaseClassEqual(this.baseClass, previousSymbol.baseClass)) {
            return true;
        }
        return false;
    }
}
function isInputMappingEqual(current, previous) {
    return isInputOrOutputEqual(current, previous) && current.required === previous.required;
}
function isInputOrOutputEqual(current, previous) {
    return (current.classPropertyName === previous.classPropertyName &&
        current.bindingPropertyName === previous.bindingPropertyName &&
        current.isSignal === previous.isSignal);
}
function isTypeCheckMetaEqual(current, previous) {
    if (current.hasNgTemplateContextGuard !== previous.hasNgTemplateContextGuard) {
        return false;
    }
    if (current.isGeneric !== previous.isGeneric) {
        // Note: changes in the number of type parameters is also considered in
        // `areTypeParametersEqual` so this check is technically not needed; it is done anyway for
        // completeness in terms of whether the `DirectiveTypeCheckMeta` struct itself compares
        // equal or not.
        return false;
    }
    if (!isArrayEqual(current.ngTemplateGuards, previous.ngTemplateGuards, isTemplateGuardEqual)) {
        return false;
    }
    if (!isSetEqual(current.coercedInputFields, previous.coercedInputFields)) {
        return false;
    }
    if (!isSetEqual(current.restrictedInputFields, previous.restrictedInputFields)) {
        return false;
    }
    if (!isSetEqual(current.stringLiteralInputFields, previous.stringLiteralInputFields)) {
        return false;
    }
    if (!isSetEqual(current.undeclaredInputFields, previous.undeclaredInputFields)) {
        return false;
    }
    return true;
}
function isTemplateGuardEqual(current, previous) {
    return current.inputName === previous.inputName && current.type === previous.type;
}
function isBaseClassEqual(current, previous) {
    if (current === null || previous === null) {
        return current === previous;
    }
    return isSymbolEqual(current, previous);
}

const parseSpanComment = /^(\d+),(\d+)$/;
/**
 * Reads the trailing comments and finds the first match which is a span comment (i.e. 4,10) on a
 * node and returns it as an `AbsoluteSourceSpan`.
 *
 * Will return `null` if no trailing comments on the node match the expected form of a source span.
 */
function readSpanComment(node, sourceFile = node.getSourceFile()) {
    return (ts.forEachTrailingCommentRange(sourceFile.text, node.getEnd(), (pos, end, kind) => {
        if (kind !== ts.SyntaxKind.MultiLineCommentTrivia) {
            return null;
        }
        const commentText = sourceFile.text.substring(pos + 2, end - 2);
        const match = commentText.match(parseSpanComment);
        if (match === null) {
            return null;
        }
        return new o.AbsoluteSourceSpan(+match[1], +match[2]);
    }) || null);
}
/** Used to identify what type the comment is. */
var CommentTriviaType;
(function (CommentTriviaType) {
    CommentTriviaType["DIAGNOSTIC"] = "D";
    CommentTriviaType["EXPRESSION_TYPE_IDENTIFIER"] = "T";
})(CommentTriviaType || (CommentTriviaType = {}));
/** Identifies what the TCB expression is for (for example, a directive declaration). */
var ExpressionIdentifier;
(function (ExpressionIdentifier) {
    ExpressionIdentifier["DIRECTIVE"] = "DIR";
    ExpressionIdentifier["COMPONENT_COMPLETION"] = "COMPCOMP";
    ExpressionIdentifier["EVENT_PARAMETER"] = "EP";
    ExpressionIdentifier["VARIABLE_AS_EXPRESSION"] = "VAE";
})(ExpressionIdentifier || (ExpressionIdentifier = {}));
/** Tags the node with the given expression identifier. */
function addExpressionIdentifier(node, identifier) {
    ts.addSyntheticTrailingComment(node, ts.SyntaxKind.MultiLineCommentTrivia, `${CommentTriviaType.EXPRESSION_TYPE_IDENTIFIER}:${identifier}`, 
    /* hasTrailingNewLine */ false);
}
const IGNORE_FOR_DIAGNOSTICS_MARKER = `${CommentTriviaType.DIAGNOSTIC}:ignore`;
/**
 * Tag the `ts.Node` with an indication that any errors arising from the evaluation of the node
 * should be ignored.
 */
function markIgnoreDiagnostics(node) {
    ts.addSyntheticTrailingComment(node, ts.SyntaxKind.MultiLineCommentTrivia, IGNORE_FOR_DIAGNOSTICS_MARKER, 
    /* hasTrailingNewLine */ false);
}
/** Returns true if the node has a marker that indicates diagnostics errors should be ignored.  */
function hasIgnoreForDiagnosticsMarker(node, sourceFile) {
    return (ts.forEachTrailingCommentRange(sourceFile.text, node.getEnd(), (pos, end, kind) => {
        if (kind !== ts.SyntaxKind.MultiLineCommentTrivia) {
            return null;
        }
        const commentText = sourceFile.text.substring(pos + 2, end - 2);
        return commentText === IGNORE_FOR_DIAGNOSTICS_MARKER;
    }) === true);
}
function makeRecursiveVisitor(visitor) {
    function recursiveVisitor(node) {
        const res = visitor(node);
        return res !== null ? res : node.forEachChild(recursiveVisitor);
    }
    return recursiveVisitor;
}
function getSpanFromOptions(opts) {
    let withSpan = null;
    if (opts.withSpan !== undefined) {
        if (opts.withSpan instanceof o.AbsoluteSourceSpan) {
            withSpan = opts.withSpan;
        }
        else {
            withSpan = { start: opts.withSpan.start.offset, end: opts.withSpan.end.offset };
        }
    }
    return withSpan;
}
/**
 * Given a `ts.Node` with finds the first node whose matching the criteria specified
 * by the `FindOptions`.
 *
 * Returns `null` when no `ts.Node` matches the given conditions.
 */
function findFirstMatchingNode(tcb, opts) {
    const withSpan = getSpanFromOptions(opts);
    const withExpressionIdentifier = opts.withExpressionIdentifier;
    const sf = tcb.getSourceFile();
    const visitor = makeRecursiveVisitor((node) => {
        if (!opts.filter(node)) {
            return null;
        }
        if (withSpan !== null) {
            const comment = readSpanComment(node, sf);
            if (comment === null || withSpan.start !== comment.start || withSpan.end !== comment.end) {
                return null;
            }
        }
        if (withExpressionIdentifier !== undefined &&
            !hasExpressionIdentifier(sf, node, withExpressionIdentifier)) {
            return null;
        }
        return node;
    });
    return tcb.forEachChild(visitor) ?? null;
}
/**
 * Given a `ts.Node` with source span comments, finds the first node whose source span comment
 * matches the given `sourceSpan`. Additionally, the `filter` function allows matching only
 * `ts.Nodes` of a given type, which provides the ability to select only matches of a given type
 * when there may be more than one.
 *
 * Returns `null` when no `ts.Node` matches the given conditions.
 */
function findAllMatchingNodes(tcb, opts) {
    const withSpan = getSpanFromOptions(opts);
    const withExpressionIdentifier = opts.withExpressionIdentifier;
    const results = [];
    const stack = [tcb];
    const sf = tcb.getSourceFile();
    while (stack.length > 0) {
        const node = stack.pop();
        if (!opts.filter(node)) {
            stack.push(...node.getChildren());
            continue;
        }
        if (withSpan !== null) {
            const comment = readSpanComment(node, sf);
            if (comment === null || withSpan.start !== comment.start || withSpan.end !== comment.end) {
                stack.push(...node.getChildren());
                continue;
            }
        }
        if (withExpressionIdentifier !== undefined &&
            !hasExpressionIdentifier(sf, node, withExpressionIdentifier)) {
            continue;
        }
        results.push(node);
    }
    return results;
}
function hasExpressionIdentifier(sourceFile, node, identifier) {
    return (ts.forEachTrailingCommentRange(sourceFile.text, node.getEnd(), (pos, end, kind) => {
        if (kind !== ts.SyntaxKind.MultiLineCommentTrivia) {
            return false;
        }
        const commentText = sourceFile.text.substring(pos + 2, end - 2);
        return commentText === `${CommentTriviaType.EXPRESSION_TYPE_IDENTIFIER}:${identifier}`;
    }) || false);
}

/**
 * A `Set` of `ts.SyntaxKind`s of `ts.Expression` which are safe to wrap in a `ts.AsExpression`
 * without needing to be wrapped in parentheses.
 *
 * For example, `foo.bar()` is a `ts.CallExpression`, and can be safely cast to `any` with
 * `foo.bar() as any`. however, `foo !== bar` is a `ts.BinaryExpression`, and attempting to cast
 * without the parentheses yields the expression `foo !== bar as any`. This is semantically
 * equivalent to `foo !== (bar as any)`, which is not what was intended. Thus,
 * `ts.BinaryExpression`s need to be wrapped in parentheses before casting.
 */
//
let SAFE_TO_CAST_WITHOUT_PARENS = null;
function tsCastToAny(expr) {
    if (SAFE_TO_CAST_WITHOUT_PARENS === null) {
        SAFE_TO_CAST_WITHOUT_PARENS = new Set([
            // Expressions which are already parenthesized can be cast without further wrapping.
            ts.SyntaxKind.ParenthesizedExpression,
            // Expressions which form a single lexical unit leave no room for precedence issues with the cast.
            ts.SyntaxKind.Identifier,
            ts.SyntaxKind.CallExpression,
            ts.SyntaxKind.NonNullExpression,
            ts.SyntaxKind.ElementAccessExpression,
            ts.SyntaxKind.PropertyAccessExpression,
            ts.SyntaxKind.ArrayLiteralExpression,
            ts.SyntaxKind.ObjectLiteralExpression,
            // The same goes for various literals.
            ts.SyntaxKind.StringLiteral,
            ts.SyntaxKind.NumericLiteral,
            ts.SyntaxKind.TrueKeyword,
            ts.SyntaxKind.FalseKeyword,
            ts.SyntaxKind.NullKeyword,
            ts.SyntaxKind.UndefinedKeyword,
        ]);
    }
    // Wrap `expr` in parentheses if needed (see `SAFE_TO_CAST_WITHOUT_PARENS` above).
    if (!SAFE_TO_CAST_WITHOUT_PARENS.has(expr.kind)) {
        expr = ts.factory.createParenthesizedExpression(expr);
    }
    // The outer expression is always wrapped in parentheses.
    return ts.factory.createParenthesizedExpression(ts.factory.createAsExpression(expr, ts.factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword)));
}
/**
 * Create an expression which instantiates an element by its HTML tagName.
 *
 * Thanks to narrowing of `document.createElement()`, this expression will have its type inferred
 * based on the tag name, including for custom elements that have appropriate .d.ts definitions.
 */
function tsCreateElement(...tagNames) {
    const createElement = ts.factory.createPropertyAccessExpression(
    /* expression */ ts.factory.createIdentifier('document'), 'createElement');
    let arg;
    if (tagNames.length === 1) {
        // If there's only one tag name, we can pass it in directly.
        arg = ts.factory.createStringLiteral(tagNames[0]);
    }
    else {
        // If there's more than one name, we have to generate a union of all the tag names. To do so,
        // create an expression in the form of `null! as 'tag-1' | 'tag-2' | 'tag-3'`. This allows
        // TypeScript to infer the type as a union of the differnet tags.
        const assertedNullExpression = ts.factory.createNonNullExpression(ts.factory.createNull());
        const type = ts.factory.createUnionTypeNode(tagNames.map((tag) => ts.factory.createLiteralTypeNode(ts.factory.createStringLiteral(tag))));
        arg = ts.factory.createAsExpression(assertedNullExpression, type);
    }
    return ts.factory.createCallExpression(
    /* expression */ createElement, 
    /* typeArguments */ undefined, 
    /* argumentsArray */ [arg]);
}
/**
 * Create a `ts.VariableStatement` which declares a variable without explicit initialization.
 *
 * The initializer `null!` is used to bypass strict variable initialization checks.
 *
 * Unlike with `tsCreateVariable`, the type of the variable is explicitly specified.
 */
function tsDeclareVariable(id, type) {
    // When we create a variable like `var _t1: boolean = null!`, TypeScript actually infers `_t1`
    // to be `never`, instead of a `boolean`. To work around it, we cast the value
    // in the initializer, e.g. `var _t1 = null! as boolean;`.
    addExpressionIdentifier(type, ExpressionIdentifier.VARIABLE_AS_EXPRESSION);
    const initializer = ts.factory.createAsExpression(ts.factory.createNonNullExpression(ts.factory.createNull()), type);
    const decl = ts.factory.createVariableDeclaration(
    /* name */ id, 
    /* exclamationToken */ undefined, 
    /* type */ undefined, 
    /* initializer */ initializer);
    return ts.factory.createVariableStatement(
    /* modifiers */ undefined, 
    /* declarationList */ [decl]);
}
/**
 * Creates a `ts.TypeQueryNode` for a coerced input.
 *
 * For example: `typeof MatInput.ngAcceptInputType_value`, where MatInput is `typeName` and `value`
 * is the `coercedInputName`.
 *
 * @param typeName The `EntityName` of the Directive where the static coerced input is defined.
 * @param coercedInputName The field name of the coerced input.
 */
function tsCreateTypeQueryForCoercedInput(typeName, coercedInputName) {
    return ts.factory.createTypeQueryNode(ts.factory.createQualifiedName(typeName, `ngAcceptInputType_${coercedInputName}`));
}
/**
 * Create a `ts.VariableStatement` that initializes a variable with a given expression.
 *
 * Unlike with `tsDeclareVariable`, the type of the variable is inferred from the initializer
 * expression.
 */
function tsCreateVariable(id, initializer, flags = null) {
    const decl = ts.factory.createVariableDeclaration(
    /* name */ id, 
    /* exclamationToken */ undefined, 
    /* type */ undefined, 
    /* initializer */ initializer);
    return ts.factory.createVariableStatement(
    /* modifiers */ undefined, 
    /* declarationList */ flags === null
        ? [decl]
        : ts.factory.createVariableDeclarationList([decl], flags));
}
/**
 * Construct a `ts.CallExpression` that calls a method on a receiver.
 */
function tsCallMethod(receiver, methodName, args = []) {
    const methodAccess = ts.factory.createPropertyAccessExpression(receiver, methodName);
    return ts.factory.createCallExpression(
    /* expression */ methodAccess, 
    /* typeArguments */ undefined, 
    /* argumentsArray */ args);
}
function isAccessExpression(node) {
    return ts.isPropertyAccessExpression(node) || ts.isElementAccessExpression(node);
}
/**
 * Creates a TypeScript node representing a numeric value.
 */
function tsNumericExpression(value) {
    // As of TypeScript 5.3 negative numbers are represented as `prefixUnaryOperator` and passing a
    // negative number (even as a string) into `createNumericLiteral` will result in an error.
    if (value < 0) {
        const operand = ts.factory.createNumericLiteral(Math.abs(value));
        return ts.factory.createPrefixUnaryExpression(ts.SyntaxKind.MinusToken, operand);
    }
    return ts.factory.createNumericLiteral(value);
}
/**
 * Check if a node represents a directive declaration in a TypeCheck Block.
 * Directive declarations can be either:
 * - var _t1: TestDir /*T:D*\/ = null! as TestDir;
 * - var _t1 /*T:D*\/ = _ctor1({});
 */
function isDirectiveDeclaration(node) {
    const sourceFile = node.getSourceFile();
    return ((ts.isTypeNode(node) || ts.isIdentifier(node)) &&
        ts.isVariableDeclaration(node.parent) &&
        hasExpressionIdentifier(sourceFile, node, ExpressionIdentifier.DIRECTIVE));
}
/**
 * Check if the lastSymbol is an alias of the firstSymbol. For example:
 *
 * The NewBarComponent is an alias of BarComponent.
 *
 * But the NotAliasBarComponent is not an alias of BarComponent, because
 * the NotAliasBarComponent is a new variable.
 *
 * This should work for most cases.
 *
 * https://github.com/microsoft/TypeScript/blob/9e20e032effad965567d4a1e1c30d5433b0a3332/src/compiler/checker.ts#L3638-L3652
 *
 * ```
 * // a.ts
 * export class BarComponent {};
 * // b.ts
 * export {BarComponent as NewBarComponent} from "./a";
 * // c.ts
 * import {BarComponent} from "./a"
 * const NotAliasBarComponent = BarComponent;
 * export {NotAliasBarComponent};
 * ```
 */
function isSymbolAliasOf(firstSymbol, lastSymbol, typeChecker) {
    let currentSymbol = lastSymbol;
    const seenSymbol = new Set();
    while (firstSymbol !== currentSymbol &&
        currentSymbol !== undefined &&
        currentSymbol.flags & ts.SymbolFlags.Alias) {
        if (seenSymbol.has(currentSymbol)) {
            break;
        }
        seenSymbol.add(currentSymbol);
        currentSymbol = typeChecker.getImmediateAliasedSymbol(currentSymbol);
        if (currentSymbol === firstSymbol) {
            return true;
        }
    }
    return false;
}

const NgOriginalFile = Symbol('NgOriginalFile');
exports.UpdateMode = void 0;
(function (UpdateMode) {
    /**
     * A complete update creates a completely new overlay of type-checking code on top of the user's
     * original program, which doesn't include type-checking code from previous calls to
     * `updateFiles`.
     */
    UpdateMode[UpdateMode["Complete"] = 0] = "Complete";
    /**
     * An incremental update changes the contents of some files in the type-checking program without
     * reverting any prior changes.
     */
    UpdateMode[UpdateMode["Incremental"] = 1] = "Incremental";
})(exports.UpdateMode || (exports.UpdateMode = {}));

/**
 * A `Symbol` which is used to patch extension data onto `ts.SourceFile`s.
 */
const NgExtension = Symbol('NgExtension');
/**
 * Narrows a `ts.SourceFile` if it has an `NgExtension` property.
 */
function isExtended(sf) {
    return sf[NgExtension] !== undefined;
}
/**
 * Returns the `NgExtensionData` for a given `ts.SourceFile`, adding it if none exists.
 */
function sfExtensionData(sf) {
    const extSf = sf;
    if (extSf[NgExtension] !== undefined) {
        // The file already has extension data, so return it directly.
        return extSf[NgExtension];
    }
    // The file has no existing extension data, so add it and return it.
    const extension = {
        isTopLevelShim: false,
        fileShim: null,
        originalReferencedFiles: null,
        taggedReferenceFiles: null,
    };
    extSf[NgExtension] = extension;
    return extension;
}
/**
 * Check whether `sf` is a per-file shim `ts.SourceFile`.
 */
function isFileShimSourceFile(sf) {
    return isExtended(sf) && sf[NgExtension].fileShim !== null;
}
/**
 * Check whether `sf` is a shim `ts.SourceFile` (either a per-file shim or a top-level shim).
 */
function isShim(sf) {
    return isExtended(sf) && (sf[NgExtension].fileShim !== null || sf[NgExtension].isTopLevelShim);
}
/**
 * Copy any shim data from one `ts.SourceFile` to another.
 */
function copyFileShimData(from, to) {
    if (!isFileShimSourceFile(from)) {
        return;
    }
    sfExtensionData(to).fileShim = sfExtensionData(from).fileShim;
}
/**
 * For those `ts.SourceFile`s in the `program` which have previously been tagged by a
 * `ShimReferenceTagger`, restore the original `referencedFiles` array that does not have shim tags.
 */
function untagAllTsFiles(program) {
    for (const sf of program.getSourceFiles()) {
        untagTsFile(sf);
    }
}
/**
 * For those `ts.SourceFile`s in the `program` which have previously been tagged by a
 * `ShimReferenceTagger`, re-apply the effects of tagging by updating the `referencedFiles` array to
 * the tagged version produced previously.
 */
function retagAllTsFiles(program) {
    for (const sf of program.getSourceFiles()) {
        retagTsFile(sf);
    }
}
/**
 * Restore the original `referencedFiles` for the given `ts.SourceFile`.
 */
function untagTsFile(sf) {
    if (sf.isDeclarationFile || !isExtended(sf)) {
        return;
    }
    const ext = sfExtensionData(sf);
    if (ext.originalReferencedFiles !== null) {
        sf.referencedFiles = ext.originalReferencedFiles;
    }
}
/**
 * Apply the previously tagged `referencedFiles` to the given `ts.SourceFile`, if it was previously
 * tagged.
 */
function retagTsFile(sf) {
    if (sf.isDeclarationFile || !isExtended(sf)) {
        return;
    }
    const ext = sfExtensionData(sf);
    if (ext.taggedReferenceFiles !== null) {
        sf.referencedFiles = ext.taggedReferenceFiles;
    }
}

/**
 * Describes the scope of the caller's interest in template type-checking results.
 */
exports.OptimizeFor = void 0;
(function (OptimizeFor) {
    /**
     * Indicates that a consumer of a `TemplateTypeChecker` is only interested in results for a
     * given file, and wants them as fast as possible.
     *
     * Calling `TemplateTypeChecker` methods successively for multiple files while specifying
     * `OptimizeFor.SingleFile` can result in significant unnecessary overhead overall.
     */
    OptimizeFor[OptimizeFor["SingleFile"] = 0] = "SingleFile";
    /**
     * Indicates that a consumer of a `TemplateTypeChecker` intends to query for results pertaining
     * to the entire user program, and so the type-checker should internally optimize for this case.
     *
     * Initial calls to retrieve type-checking information may take longer, but repeated calls to
     * gather information for the whole user program will be significantly faster with this mode of
     * optimization.
     */
    OptimizeFor[OptimizeFor["WholeProgram"] = 1] = "WholeProgram";
})(exports.OptimizeFor || (exports.OptimizeFor = {}));

/**
 * Discriminant of an autocompletion source (a `Completion`).
 */
var CompletionKind;
(function (CompletionKind) {
    CompletionKind[CompletionKind["Reference"] = 0] = "Reference";
    CompletionKind[CompletionKind["Variable"] = 1] = "Variable";
    CompletionKind[CompletionKind["LetDeclaration"] = 2] = "LetDeclaration";
})(CompletionKind || (CompletionKind = {}));

/**
 * Which kind of Angular Trait the import targets.
 */
exports.PotentialImportKind = void 0;
(function (PotentialImportKind) {
    PotentialImportKind[PotentialImportKind["NgModule"] = 0] = "NgModule";
    PotentialImportKind[PotentialImportKind["Standalone"] = 1] = "Standalone";
})(exports.PotentialImportKind || (exports.PotentialImportKind = {}));
/**
 * Possible modes in which to look up a potential import.
 */
exports.PotentialImportMode = void 0;
(function (PotentialImportMode) {
    /** Whether an import is standalone is inferred based on its metadata. */
    PotentialImportMode[PotentialImportMode["Normal"] = 0] = "Normal";
    /**
     * An import is assumed to be standalone and is imported directly. This is useful for migrations
     * where a declaration wasn't standalone when the program was created, but will become standalone
     * as a part of the migration.
     */
    PotentialImportMode[PotentialImportMode["ForceDirect"] = 1] = "ForceDirect";
})(exports.PotentialImportMode || (exports.PotentialImportMode = {}));

exports.SymbolKind = void 0;
(function (SymbolKind) {
    SymbolKind[SymbolKind["Input"] = 0] = "Input";
    SymbolKind[SymbolKind["Output"] = 1] = "Output";
    SymbolKind[SymbolKind["Binding"] = 2] = "Binding";
    SymbolKind[SymbolKind["Reference"] = 3] = "Reference";
    SymbolKind[SymbolKind["Variable"] = 4] = "Variable";
    SymbolKind[SymbolKind["Directive"] = 5] = "Directive";
    SymbolKind[SymbolKind["Element"] = 6] = "Element";
    SymbolKind[SymbolKind["Template"] = 7] = "Template";
    SymbolKind[SymbolKind["Expression"] = 8] = "Expression";
    SymbolKind[SymbolKind["DomBinding"] = 9] = "DomBinding";
    SymbolKind[SymbolKind["Pipe"] = 10] = "Pipe";
    SymbolKind[SymbolKind["LetDeclaration"] = 11] = "LetDeclaration";
    SymbolKind[SymbolKind["SelectorlessComponent"] = 12] = "SelectorlessComponent";
    SymbolKind[SymbolKind["SelectorlessDirective"] = 13] = "SelectorlessDirective";
})(exports.SymbolKind || (exports.SymbolKind = {}));

/**
 * Constructs a `ts.Diagnostic` for a given `ParseSourceSpan` within a template.
 *
 * @param deprecatedDiagInfo Optional information about deprecation and related messages.
 */
function makeTemplateDiagnostic(id, mapping, span, category, code, messageText, relatedMessages, deprecatedDiagInfo) {
    if (mapping.type === 'direct') {
        let relatedInformation = [];
        if (relatedMessages !== undefined) {
            for (const relatedMessage of relatedMessages) {
                relatedInformation.push({
                    category: ts.DiagnosticCategory.Message,
                    code: 0,
                    file: relatedMessage.sourceFile,
                    start: relatedMessage.start,
                    length: relatedMessage.end - relatedMessage.start,
                    messageText: relatedMessage.text,
                });
            }
        }
        if (deprecatedDiagInfo !== undefined) {
            relatedInformation.push(...(deprecatedDiagInfo.relatedMessages ?? []));
        }
        // For direct mappings, the error is shown inline as ngtsc was able to pinpoint a string
        // constant within the `@Component` decorator for the template. This allows us to map the error
        // directly into the bytes of the source file.
        return {
            source: 'ngtsc',
            code,
            category,
            messageText,
            file: mapping.node.getSourceFile(),
            sourceFile: mapping.node.getSourceFile(),
            typeCheckId: id,
            start: span.start.offset,
            length: span.end.offset - span.start.offset,
            relatedInformation,
            reportsDeprecated: deprecatedDiagInfo?.reportsDeprecated,
        };
    }
    else if (mapping.type === 'indirect' || mapping.type === 'external') {
        // For indirect mappings (template was declared inline, but ngtsc couldn't map it directly
        // to a string constant in the decorator), the component's file name is given with a suffix
        // indicating it's not the TS file being displayed, but a template.
        // For external temoplates, the HTML filename is used.
        const componentSf = mapping.componentClass.getSourceFile();
        const componentName = mapping.componentClass.name.text;
        const fileName = mapping.type === 'indirect'
            ? `${componentSf.fileName} (${componentName} template)`
            : mapping.templateUrl;
        let relatedInformation = [];
        if (relatedMessages !== undefined) {
            for (const relatedMessage of relatedMessages) {
                relatedInformation.push({
                    category: ts.DiagnosticCategory.Message,
                    code: 0,
                    file: relatedMessage.sourceFile,
                    start: relatedMessage.start,
                    length: relatedMessage.end - relatedMessage.start,
                    messageText: relatedMessage.text,
                });
            }
        }
        let sf;
        try {
            sf = getParsedTemplateSourceFile(fileName, mapping);
        }
        catch (e) {
            const failureChain = makeDiagnosticChain(`Failed to report an error in '${fileName}' at ${span.start.line + 1}:${span.start.col + 1}`, [makeDiagnosticChain(e?.stack ?? `${e}`)]);
            return {
                source: 'ngtsc',
                category,
                code,
                messageText: addDiagnosticChain(messageText, [failureChain]),
                file: componentSf,
                sourceFile: componentSf,
                typeCheckId: id,
                // mapping.node represents either the 'template' or 'templateUrl' expression. getStart()
                // and getEnd() are used because they don't include surrounding whitespace.
                start: mapping.node.getStart(),
                length: mapping.node.getEnd() - mapping.node.getStart(),
                relatedInformation,
                reportsDeprecated: deprecatedDiagInfo?.reportsDeprecated,
            };
        }
        let typeForMessage;
        if (category === ts.DiagnosticCategory.Warning) {
            typeForMessage = 'Warning';
        }
        else if (category === ts.DiagnosticCategory.Suggestion) {
            typeForMessage = 'Suggestion';
        }
        else if (category === ts.DiagnosticCategory.Message) {
            typeForMessage = 'Message';
        }
        else {
            typeForMessage = 'Error';
        }
        if (deprecatedDiagInfo !== undefined) {
            relatedInformation.push(...(deprecatedDiagInfo.relatedMessages ?? []));
        }
        relatedInformation.push({
            category: ts.DiagnosticCategory.Message,
            code: 0,
            file: componentSf,
            // mapping.node represents either the 'template' or 'templateUrl' expression. getStart()
            // and getEnd() are used because they don't include surrounding whitespace.
            start: mapping.node.getStart(),
            length: mapping.node.getEnd() - mapping.node.getStart(),
            messageText: `${typeForMessage} occurs in the template of component ${componentName}.`,
        });
        return {
            source: 'ngtsc',
            category,
            code,
            messageText,
            file: sf,
            sourceFile: componentSf,
            typeCheckId: id,
            start: span.start.offset,
            length: span.end.offset - span.start.offset,
            // Show a secondary message indicating the component whose template contains the error.
            relatedInformation,
            reportsDeprecated: deprecatedDiagInfo?.reportsDeprecated,
        };
    }
    else {
        throw new Error(`Unexpected source mapping type: ${mapping.type}`);
    }
}
const TemplateSourceFile = Symbol('TemplateSourceFile');
function getParsedTemplateSourceFile(fileName, mapping) {
    if (mapping[TemplateSourceFile] === undefined) {
        mapping[TemplateSourceFile] = parseTemplateAsSourceFile(fileName, mapping.template);
    }
    return mapping[TemplateSourceFile];
}
function parseTemplateAsSourceFile(fileName, template) {
    // TODO(alxhub): investigate creating a fake `ts.SourceFile` here instead of invoking the TS
    // parser against the template (HTML is just really syntactically invalid TypeScript code ;).
    return ts.createSourceFile(fileName, template, ts.ScriptTarget.Latest, 
    /* setParentNodes */ false, ts.ScriptKind.JSX);
}

const TYPE_CHECK_ID_MAP = Symbol('TypeCheckId');
function getTypeCheckId$1(clazz) {
    const sf = clazz.getSourceFile();
    if (sf[TYPE_CHECK_ID_MAP] === undefined) {
        sf[TYPE_CHECK_ID_MAP] = new Map();
    }
    if (sf[TYPE_CHECK_ID_MAP].get(clazz) === undefined) {
        sf[TYPE_CHECK_ID_MAP].set(clazz, `tcb${sf[TYPE_CHECK_ID_MAP].size + 1}`);
    }
    return sf[TYPE_CHECK_ID_MAP].get(clazz);
}

/**
 * Powers autocompletion for a specific component.
 *
 * Internally caches autocompletion results, and must be discarded if the component template or
 * surrounding TS program have changed.
 */
class CompletionEngine {
    tcb;
    data;
    tcbPath;
    tcbIsShim;
    componentContext;
    /**
     * Get the `TcbLocation` for the global context, which is the location of the `this` variable.
     */
    globalTsContext;
    /**
     * Cache of completions for various levels of the template, including the root template (`null`).
     * Memoizes `getTemplateContextCompletions`.
     */
    templateContextCache = new Map();
    expressionCompletionCache = new Map();
    constructor(tcb, data, tcbPath, tcbIsShim) {
        this.tcb = tcb;
        this.data = data;
        this.tcbPath = tcbPath;
        this.tcbIsShim = tcbIsShim;
        // Find the component completion expression within the TCB. This looks like: `ctx. /* ... */;`
        const globalRead = findFirstMatchingNode(this.tcb, {
            filter: ts.isPropertyAccessExpression,
            withExpressionIdentifier: ExpressionIdentifier.COMPONENT_COMPLETION,
        });
        if (globalRead !== null) {
            this.componentContext = {
                tcbPath: this.tcbPath,
                isShimFile: this.tcbIsShim,
                // `globalRead.name` is an empty `ts.Identifier`, so its start position immediately follows
                // the `.` in `ctx.`. TS autocompletion APIs can then be used to access completion results
                // for the component context.
                positionInFile: globalRead.name.getStart(),
            };
            this.globalTsContext = {
                tcbPath: this.tcbPath,
                isShimFile: this.tcbIsShim,
                positionInFile: globalRead.name.getStart() - 1,
            };
        }
        else {
            this.componentContext = null;
            this.globalTsContext = null;
        }
    }
    getGlobalTsContext() {
        return this.globalTsContext;
    }
    /**
     * Get global completions within the given template context and AST node.
     *
     * @param context the given template context - either a `TmplAstTemplate` embedded view, or `null`
     *     for the root
     * template context.
     * @param node the given AST node
     */
    getGlobalCompletions(context, node) {
        if (this.componentContext === null) {
            return null;
        }
        const templateContext = this.getTemplateContextCompletions(context);
        if (templateContext === null) {
            return null;
        }
        let nodeContext = null;
        if (node instanceof o.EmptyExpr) {
            const nodeLocation = findFirstMatchingNode(this.tcb, {
                filter: ts.isIdentifier,
                withSpan: node.sourceSpan,
            });
            if (nodeLocation !== null) {
                nodeContext = {
                    tcbPath: this.tcbPath,
                    isShimFile: this.tcbIsShim,
                    positionInFile: nodeLocation.getStart(),
                };
            }
        }
        if (node instanceof o.PropertyRead && node.receiver instanceof o.ImplicitReceiver) {
            const nodeLocation = findFirstMatchingNode(this.tcb, {
                filter: ts.isPropertyAccessExpression,
                withSpan: node.sourceSpan,
            });
            if (nodeLocation) {
                nodeContext = {
                    tcbPath: this.tcbPath,
                    isShimFile: this.tcbIsShim,
                    positionInFile: nodeLocation.getStart(),
                };
            }
        }
        return {
            componentContext: this.componentContext,
            templateContext,
            nodeContext,
        };
    }
    getExpressionCompletionLocation(expr) {
        if (this.expressionCompletionCache.has(expr)) {
            return this.expressionCompletionCache.get(expr);
        }
        // Completion works inside property reads and method calls.
        let tsExpr = null;
        if (expr instanceof o.PropertyRead) {
            // Non-safe navigation operations are trivial: `foo.bar` or `foo.bar()`
            tsExpr = findFirstMatchingNode(this.tcb, {
                filter: ts.isPropertyAccessExpression,
                withSpan: expr.nameSpan,
            });
        }
        else if (expr instanceof o.SafePropertyRead) {
            // Safe navigation operations are a little more complex, and involve a ternary. Completion
            // happens in the "true" case of the ternary.
            const ternaryExpr = findFirstMatchingNode(this.tcb, {
                filter: ts.isParenthesizedExpression,
                withSpan: expr.sourceSpan,
            });
            if (ternaryExpr === null || !ts.isConditionalExpression(ternaryExpr.expression)) {
                return null;
            }
            const whenTrue = ternaryExpr.expression.whenTrue;
            if (ts.isPropertyAccessExpression(whenTrue)) {
                tsExpr = whenTrue;
            }
            else if (ts.isCallExpression(whenTrue) &&
                ts.isPropertyAccessExpression(whenTrue.expression)) {
                tsExpr = whenTrue.expression;
            }
        }
        if (tsExpr === null) {
            return null;
        }
        const res = {
            tcbPath: this.tcbPath,
            isShimFile: this.tcbIsShim,
            positionInFile: tsExpr.name.getEnd(),
        };
        this.expressionCompletionCache.set(expr, res);
        return res;
    }
    getLiteralCompletionLocation(expr) {
        if (this.expressionCompletionCache.has(expr)) {
            return this.expressionCompletionCache.get(expr);
        }
        let tsExpr = null;
        if (expr instanceof o.TmplAstTextAttribute) {
            const strNode = findFirstMatchingNode(this.tcb, {
                filter: ts.isParenthesizedExpression,
                withSpan: expr.sourceSpan,
            });
            if (strNode !== null && ts.isStringLiteral(strNode.expression)) {
                tsExpr = strNode.expression;
            }
        }
        else {
            tsExpr = findFirstMatchingNode(this.tcb, {
                filter: (n) => ts.isStringLiteral(n) || ts.isNumericLiteral(n),
                withSpan: expr.sourceSpan,
            });
        }
        if (tsExpr === null) {
            return null;
        }
        let positionInShimFile = tsExpr.getEnd();
        if (ts.isStringLiteral(tsExpr)) {
            // In the shimFile, if `tsExpr` is a string, the position should be in the quotes.
            positionInShimFile -= 1;
        }
        const res = {
            tcbPath: this.tcbPath,
            isShimFile: this.tcbIsShim,
            positionInFile: positionInShimFile,
        };
        this.expressionCompletionCache.set(expr, res);
        return res;
    }
    /**
     * Get global completions within the given template context - either a `TmplAstTemplate` embedded
     * view, or `null` for the root context.
     */
    getTemplateContextCompletions(context) {
        if (this.templateContextCache.has(context)) {
            return this.templateContextCache.get(context);
        }
        const templateContext = new Map();
        // The bound template already has details about the references and variables in scope in the
        // `context` template - they just need to be converted to `Completion`s.
        for (const node of this.data.boundTarget.getEntitiesInScope(context)) {
            if (node instanceof o.TmplAstReference) {
                templateContext.set(node.name, {
                    kind: CompletionKind.Reference,
                    node,
                });
            }
            else if (node instanceof o.TmplAstLetDeclaration) {
                templateContext.set(node.name, {
                    kind: CompletionKind.LetDeclaration,
                    node,
                });
            }
            else {
                templateContext.set(node.name, {
                    kind: CompletionKind.Variable,
                    node,
                });
            }
        }
        this.templateContextCache.set(context, templateContext);
        return templateContext;
    }
}

// src/vlq.ts
var comma = ",".charCodeAt(0);
var semicolon = ";".charCodeAt(0);
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var intToChar = new Uint8Array(64);
var charToInt = new Uint8Array(128);
for (let i = 0; i < chars.length; i++) {
  const c = chars.charCodeAt(i);
  intToChar[i] = c;
  charToInt[c] = i;
}
function encodeInteger(builder, num, relative) {
  let delta = num - relative;
  delta = delta < 0 ? -delta << 1 | 1 : delta << 1;
  do {
    let clamped = delta & 31;
    delta >>>= 5;
    if (delta > 0) clamped |= 32;
    builder.write(intToChar[clamped]);
  } while (delta > 0);
  return num;
}

// src/strings.ts
var bufLength = 1024 * 16;
var td = typeof TextDecoder !== "undefined" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer !== "undefined" ? {
  decode(buf) {
    const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
    return out.toString();
  }
} : {
  decode(buf) {
    let out = "";
    for (let i = 0; i < buf.length; i++) {
      out += String.fromCharCode(buf[i]);
    }
    return out;
  }
};
var StringWriter = class {
  constructor() {
    this.pos = 0;
    this.out = "";
    this.buffer = new Uint8Array(bufLength);
  }
  write(v) {
    const { buffer } = this;
    buffer[this.pos++] = v;
    if (this.pos === bufLength) {
      this.out += td.decode(buffer);
      this.pos = 0;
    }
  }
  flush() {
    const { buffer, out, pos } = this;
    return pos > 0 ? out + td.decode(buffer.subarray(0, pos)) : out;
  }
};
function encode(decoded) {
  const writer = new StringWriter();
  let sourcesIndex = 0;
  let sourceLine = 0;
  let sourceColumn = 0;
  let namesIndex = 0;
  for (let i = 0; i < decoded.length; i++) {
    const line = decoded[i];
    if (i > 0) writer.write(semicolon);
    if (line.length === 0) continue;
    let genColumn = 0;
    for (let j = 0; j < line.length; j++) {
      const segment = line[j];
      if (j > 0) writer.write(comma);
      genColumn = encodeInteger(writer, segment[0], genColumn);
      if (segment.length === 1) continue;
      sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);
      sourceLine = encodeInteger(writer, segment[2], sourceLine);
      sourceColumn = encodeInteger(writer, segment[3], sourceColumn);
      if (segment.length === 4) continue;
      namesIndex = encodeInteger(writer, segment[4], namesIndex);
    }
  }
  return writer.flush();
}

class BitSet {
	constructor(arg) {
		this.bits = arg instanceof BitSet ? arg.bits.slice() : [];
	}

	add(n) {
		this.bits[n >> 5] |= 1 << (n & 31);
	}

	has(n) {
		return !!(this.bits[n >> 5] & (1 << (n & 31)));
	}
}

class Chunk {
	constructor(start, end, content) {
		this.start = start;
		this.end = end;
		this.original = content;

		this.intro = '';
		this.outro = '';

		this.content = content;
		this.storeName = false;
		this.edited = false;

		{
			this.previous = null;
			this.next = null;
		}
	}

	appendLeft(content) {
		this.outro += content;
	}

	appendRight(content) {
		this.intro = this.intro + content;
	}

	clone() {
		const chunk = new Chunk(this.start, this.end, this.original);

		chunk.intro = this.intro;
		chunk.outro = this.outro;
		chunk.content = this.content;
		chunk.storeName = this.storeName;
		chunk.edited = this.edited;

		return chunk;
	}

	contains(index) {
		return this.start < index && index < this.end;
	}

	eachNext(fn) {
		let chunk = this;
		while (chunk) {
			fn(chunk);
			chunk = chunk.next;
		}
	}

	eachPrevious(fn) {
		let chunk = this;
		while (chunk) {
			fn(chunk);
			chunk = chunk.previous;
		}
	}

	edit(content, storeName, contentOnly) {
		this.content = content;
		if (!contentOnly) {
			this.intro = '';
			this.outro = '';
		}
		this.storeName = storeName;

		this.edited = true;

		return this;
	}

	prependLeft(content) {
		this.outro = content + this.outro;
	}

	prependRight(content) {
		this.intro = content + this.intro;
	}

	reset() {
		this.intro = '';
		this.outro = '';
		if (this.edited) {
			this.content = this.original;
			this.storeName = false;
			this.edited = false;
		}
	}

	split(index) {
		const sliceIndex = index - this.start;

		const originalBefore = this.original.slice(0, sliceIndex);
		const originalAfter = this.original.slice(sliceIndex);

		this.original = originalBefore;

		const newChunk = new Chunk(index, this.end, originalAfter);
		newChunk.outro = this.outro;
		this.outro = '';

		this.end = index;

		if (this.edited) {
			// after split we should save the edit content record into the correct chunk
			// to make sure sourcemap correct
			// For example:
			// '  test'.trim()
			//     split   -> '  ' + 'test'
			//   âï¸ edit    -> '' + 'test'
			//   âï¸ edit    -> 'test' + ''
			// TODO is this block necessary?...
			newChunk.edit('', false);
			this.content = '';
		} else {
			this.content = originalBefore;
		}

		newChunk.next = this.next;
		if (newChunk.next) newChunk.next.previous = newChunk;
		newChunk.previous = this;
		this.next = newChunk;

		return newChunk;
	}

	toString() {
		return this.intro + this.content + this.outro;
	}

	trimEnd(rx) {
		this.outro = this.outro.replace(rx, '');
		if (this.outro.length) return true;

		const trimmed = this.content.replace(rx, '');

		if (trimmed.length) {
			if (trimmed !== this.content) {
				this.split(this.start + trimmed.length).edit('', undefined, true);
				if (this.edited) {
					// save the change, if it has been edited
					this.edit(trimmed, this.storeName, true);
				}
			}
			return true;
		} else {
			this.edit('', undefined, true);

			this.intro = this.intro.replace(rx, '');
			if (this.intro.length) return true;
		}
	}

	trimStart(rx) {
		this.intro = this.intro.replace(rx, '');
		if (this.intro.length) return true;

		const trimmed = this.content.replace(rx, '');

		if (trimmed.length) {
			if (trimmed !== this.content) {
				const newChunk = this.split(this.end - trimmed.length);
				if (this.edited) {
					// save the change, if it has been edited
					newChunk.edit(trimmed, this.storeName, true);
				}
				this.edit('', undefined, true);
			}
			return true;
		} else {
			this.edit('', undefined, true);

			this.outro = this.outro.replace(rx, '');
			if (this.outro.length) return true;
		}
	}
}

function getBtoa() {
	if (typeof globalThis !== 'undefined' && typeof globalThis.btoa === 'function') {
		return (str) => globalThis.btoa(unescape(encodeURIComponent(str)));
	} else if (typeof Buffer === 'function') {
		return (str) => Buffer.from(str, 'utf-8').toString('base64');
	} else {
		return () => {
			throw new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');
		};
	}
}

const btoa = /*#__PURE__*/ getBtoa();

class SourceMap {
	constructor(properties) {
		this.version = 3;
		this.file = properties.file;
		this.sources = properties.sources;
		this.sourcesContent = properties.sourcesContent;
		this.names = properties.names;
		this.mappings = encode(properties.mappings);
		if (typeof properties.x_google_ignoreList !== 'undefined') {
			this.x_google_ignoreList = properties.x_google_ignoreList;
		}
		if (typeof properties.debugId !== 'undefined') {
			this.debugId = properties.debugId;
		}
	}

	toString() {
		return JSON.stringify(this);
	}

	toUrl() {
		return 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());
	}
}

function guessIndent(code) {
	const lines = code.split('\n');

	const tabbed = lines.filter((line) => /^\t+/.test(line));
	const spaced = lines.filter((line) => /^ {2,}/.test(line));

	if (tabbed.length === 0 && spaced.length === 0) {
		return null;
	}

	// More lines tabbed than spaced? Assume tabs, and
	// default to tabs in the case of a tie (or nothing
	// to go on)
	if (tabbed.length >= spaced.length) {
		return '\t';
	}

	// Otherwise, we need to guess the multiple
	const min = spaced.reduce((previous, current) => {
		const numSpaces = /^ +/.exec(current)[0].length;
		return Math.min(numSpaces, previous);
	}, Infinity);

	return new Array(min + 1).join(' ');
}

function getRelativePath(from, to) {
	const fromParts = from.split(/[/\\]/);
	const toParts = to.split(/[/\\]/);

	fromParts.pop(); // get dirname

	while (fromParts[0] === toParts[0]) {
		fromParts.shift();
		toParts.shift();
	}

	if (fromParts.length) {
		let i = fromParts.length;
		while (i--) fromParts[i] = '..';
	}

	return fromParts.concat(toParts).join('/');
}

const toString = Object.prototype.toString;

function isObject(thing) {
	return toString.call(thing) === '[object Object]';
}

function getLocator(source) {
	const originalLines = source.split('\n');
	const lineOffsets = [];

	for (let i = 0, pos = 0; i < originalLines.length; i++) {
		lineOffsets.push(pos);
		pos += originalLines[i].length + 1;
	}

	return function locate(index) {
		let i = 0;
		let j = lineOffsets.length;
		while (i < j) {
			const m = (i + j) >> 1;
			if (index < lineOffsets[m]) {
				j = m;
			} else {
				i = m + 1;
			}
		}
		const line = i - 1;
		const column = index - lineOffsets[line];
		return { line, column };
	};
}

const wordRegex = /\w/;

class Mappings {
	constructor(hires) {
		this.hires = hires;
		this.generatedCodeLine = 0;
		this.generatedCodeColumn = 0;
		this.raw = [];
		this.rawSegments = this.raw[this.generatedCodeLine] = [];
		this.pending = null;
	}

	addEdit(sourceIndex, content, loc, nameIndex) {
		if (content.length) {
			const contentLengthMinusOne = content.length - 1;
			let contentLineEnd = content.indexOf('\n', 0);
			let previousContentLineEnd = -1;
			// Loop through each line in the content and add a segment, but stop if the last line is empty,
			// else code afterwards would fill one line too many
			while (contentLineEnd >= 0 && contentLengthMinusOne > contentLineEnd) {
				const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
				if (nameIndex >= 0) {
					segment.push(nameIndex);
				}
				this.rawSegments.push(segment);

				this.generatedCodeLine += 1;
				this.raw[this.generatedCodeLine] = this.rawSegments = [];
				this.generatedCodeColumn = 0;

				previousContentLineEnd = contentLineEnd;
				contentLineEnd = content.indexOf('\n', contentLineEnd + 1);
			}

			const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
			if (nameIndex >= 0) {
				segment.push(nameIndex);
			}
			this.rawSegments.push(segment);

			this.advance(content.slice(previousContentLineEnd + 1));
		} else if (this.pending) {
			this.rawSegments.push(this.pending);
			this.advance(content);
		}

		this.pending = null;
	}

	addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {
		let originalCharIndex = chunk.start;
		let first = true;
		// when iterating each char, check if it's in a word boundary
		let charInHiresBoundary = false;

		while (originalCharIndex < chunk.end) {
			if (original[originalCharIndex] === '\n') {
				loc.line += 1;
				loc.column = 0;
				this.generatedCodeLine += 1;
				this.raw[this.generatedCodeLine] = this.rawSegments = [];
				this.generatedCodeColumn = 0;
				first = true;
				charInHiresBoundary = false;
			} else {
				if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {
					const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];

					if (this.hires === 'boundary') {
						// in hires "boundary", group segments per word boundary than per char
						if (wordRegex.test(original[originalCharIndex])) {
							// for first char in the boundary found, start the boundary by pushing a segment
							if (!charInHiresBoundary) {
								this.rawSegments.push(segment);
								charInHiresBoundary = true;
							}
						} else {
							// for non-word char, end the boundary by pushing a segment
							this.rawSegments.push(segment);
							charInHiresBoundary = false;
						}
					} else {
						this.rawSegments.push(segment);
					}
				}

				loc.column += 1;
				this.generatedCodeColumn += 1;
				first = false;
			}

			originalCharIndex += 1;
		}

		this.pending = null;
	}

	advance(str) {
		if (!str) return;

		const lines = str.split('\n');

		if (lines.length > 1) {
			for (let i = 0; i < lines.length - 1; i++) {
				this.generatedCodeLine++;
				this.raw[this.generatedCodeLine] = this.rawSegments = [];
			}
			this.generatedCodeColumn = 0;
		}

		this.generatedCodeColumn += lines[lines.length - 1].length;
	}
}

const n = '\n';

const warned = {
	insertLeft: false,
	insertRight: false,
	storeName: false,
};

class MagicString {
	constructor(string, options = {}) {
		const chunk = new Chunk(0, string.length, string);

		Object.defineProperties(this, {
			original: { writable: true, value: string },
			outro: { writable: true, value: '' },
			intro: { writable: true, value: '' },
			firstChunk: { writable: true, value: chunk },
			lastChunk: { writable: true, value: chunk },
			lastSearchedChunk: { writable: true, value: chunk },
			byStart: { writable: true, value: {} },
			byEnd: { writable: true, value: {} },
			filename: { writable: true, value: options.filename },
			indentExclusionRanges: { writable: true, value: options.indentExclusionRanges },
			sourcemapLocations: { writable: true, value: new BitSet() },
			storedNames: { writable: true, value: {} },
			indentStr: { writable: true, value: undefined },
			ignoreList: { writable: true, value: options.ignoreList },
			offset: { writable: true, value: options.offset || 0 },
		});

		this.byStart[0] = chunk;
		this.byEnd[string.length] = chunk;
	}

	addSourcemapLocation(char) {
		this.sourcemapLocations.add(char);
	}

	append(content) {
		if (typeof content !== 'string') throw new TypeError('outro content must be a string');

		this.outro += content;
		return this;
	}

	appendLeft(index, content) {
		index = index + this.offset;

		if (typeof content !== 'string') throw new TypeError('inserted content must be a string');

		this._split(index);

		const chunk = this.byEnd[index];

		if (chunk) {
			chunk.appendLeft(content);
		} else {
			this.intro += content;
		}
		return this;
	}

	appendRight(index, content) {
		index = index + this.offset;

		if (typeof content !== 'string') throw new TypeError('inserted content must be a string');

		this._split(index);

		const chunk = this.byStart[index];

		if (chunk) {
			chunk.appendRight(content);
		} else {
			this.outro += content;
		}
		return this;
	}

	clone() {
		const cloned = new MagicString(this.original, { filename: this.filename, offset: this.offset });

		let originalChunk = this.firstChunk;
		let clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone());

		while (originalChunk) {
			cloned.byStart[clonedChunk.start] = clonedChunk;
			cloned.byEnd[clonedChunk.end] = clonedChunk;

			const nextOriginalChunk = originalChunk.next;
			const nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();

			if (nextClonedChunk) {
				clonedChunk.next = nextClonedChunk;
				nextClonedChunk.previous = clonedChunk;

				clonedChunk = nextClonedChunk;
			}

			originalChunk = nextOriginalChunk;
		}

		cloned.lastChunk = clonedChunk;

		if (this.indentExclusionRanges) {
			cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
		}

		cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);

		cloned.intro = this.intro;
		cloned.outro = this.outro;

		return cloned;
	}

	generateDecodedMap(options) {
		options = options || {};

		const sourceIndex = 0;
		const names = Object.keys(this.storedNames);
		const mappings = new Mappings(options.hires);

		const locate = getLocator(this.original);

		if (this.intro) {
			mappings.advance(this.intro);
		}

		this.firstChunk.eachNext((chunk) => {
			const loc = locate(chunk.start);

			if (chunk.intro.length) mappings.advance(chunk.intro);

			if (chunk.edited) {
				mappings.addEdit(
					sourceIndex,
					chunk.content,
					loc,
					chunk.storeName ? names.indexOf(chunk.original) : -1,
				);
			} else {
				mappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);
			}

			if (chunk.outro.length) mappings.advance(chunk.outro);
		});

		if (this.outro) {
			mappings.advance(this.outro);
		}

		return {
			file: options.file ? options.file.split(/[/\\]/).pop() : undefined,
			sources: [
				options.source ? getRelativePath(options.file || '', options.source) : options.file || '',
			],
			sourcesContent: options.includeContent ? [this.original] : undefined,
			names,
			mappings: mappings.raw,
			x_google_ignoreList: this.ignoreList ? [sourceIndex] : undefined,
		};
	}

	generateMap(options) {
		return new SourceMap(this.generateDecodedMap(options));
	}

	_ensureindentStr() {
		if (this.indentStr === undefined) {
			this.indentStr = guessIndent(this.original);
		}
	}

	_getRawIndentString() {
		this._ensureindentStr();
		return this.indentStr;
	}

	getIndentString() {
		this._ensureindentStr();
		return this.indentStr === null ? '\t' : this.indentStr;
	}

	indent(indentStr, options) {
		const pattern = /^[^\r\n]/gm;

		if (isObject(indentStr)) {
			options = indentStr;
			indentStr = undefined;
		}

		if (indentStr === undefined) {
			this._ensureindentStr();
			indentStr = this.indentStr || '\t';
		}

		if (indentStr === '') return this; // noop

		options = options || {};

		// Process exclusion ranges
		const isExcluded = {};

		if (options.exclude) {
			const exclusions =
				typeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;
			exclusions.forEach((exclusion) => {
				for (let i = exclusion[0]; i < exclusion[1]; i += 1) {
					isExcluded[i] = true;
				}
			});
		}

		let shouldIndentNextCharacter = options.indentStart !== false;
		const replacer = (match) => {
			if (shouldIndentNextCharacter) return `${indentStr}${match}`;
			shouldIndentNextCharacter = true;
			return match;
		};

		this.intro = this.intro.replace(pattern, replacer);

		let charIndex = 0;
		let chunk = this.firstChunk;

		while (chunk) {
			const end = chunk.end;

			if (chunk.edited) {
				if (!isExcluded[charIndex]) {
					chunk.content = chunk.content.replace(pattern, replacer);

					if (chunk.content.length) {
						shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\n';
					}
				}
			} else {
				charIndex = chunk.start;

				while (charIndex < end) {
					if (!isExcluded[charIndex]) {
						const char = this.original[charIndex];

						if (char === '\n') {
							shouldIndentNextCharacter = true;
						} else if (char !== '\r' && shouldIndentNextCharacter) {
							shouldIndentNextCharacter = false;

							if (charIndex === chunk.start) {
								chunk.prependRight(indentStr);
							} else {
								this._splitChunk(chunk, charIndex);
								chunk = chunk.next;
								chunk.prependRight(indentStr);
							}
						}
					}

					charIndex += 1;
				}
			}

			charIndex = chunk.end;
			chunk = chunk.next;
		}

		this.outro = this.outro.replace(pattern, replacer);

		return this;
	}

	insert() {
		throw new Error(
			'magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)',
		);
	}

	insertLeft(index, content) {
		if (!warned.insertLeft) {
			console.warn(
				'magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead',
			);
			warned.insertLeft = true;
		}

		return this.appendLeft(index, content);
	}

	insertRight(index, content) {
		if (!warned.insertRight) {
			console.warn(
				'magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead',
			);
			warned.insertRight = true;
		}

		return this.prependRight(index, content);
	}

	move(start, end, index) {
		start = start + this.offset;
		end = end + this.offset;
		index = index + this.offset;

		if (index >= start && index <= end) throw new Error('Cannot move a selection inside itself');

		this._split(start);
		this._split(end);
		this._split(index);

		const first = this.byStart[start];
		const last = this.byEnd[end];

		const oldLeft = first.previous;
		const oldRight = last.next;

		const newRight = this.byStart[index];
		if (!newRight && last === this.lastChunk) return this;
		const newLeft = newRight ? newRight.previous : this.lastChunk;

		if (oldLeft) oldLeft.next = oldRight;
		if (oldRight) oldRight.previous = oldLeft;

		if (newLeft) newLeft.next = first;
		if (newRight) newRight.previous = last;

		if (!first.previous) this.firstChunk = last.next;
		if (!last.next) {
			this.lastChunk = first.previous;
			this.lastChunk.next = null;
		}

		first.previous = newLeft;
		last.next = newRight || null;

		if (!newLeft) this.firstChunk = first;
		if (!newRight) this.lastChunk = last;
		return this;
	}

	overwrite(start, end, content, options) {
		options = options || {};
		return this.update(start, end, content, { ...options, overwrite: !options.contentOnly });
	}

	update(start, end, content, options) {
		start = start + this.offset;
		end = end + this.offset;

		if (typeof content !== 'string') throw new TypeError('replacement content must be a string');

		if (this.original.length !== 0) {
			while (start < 0) start += this.original.length;
			while (end < 0) end += this.original.length;
		}

		if (end > this.original.length) throw new Error('end is out of bounds');
		if (start === end)
			throw new Error(
				'Cannot overwrite a zero-length range â use appendLeft or prependRight instead',
			);

		this._split(start);
		this._split(end);

		if (options === true) {
			if (!warned.storeName) {
				console.warn(
					'The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string',
				);
				warned.storeName = true;
			}

			options = { storeName: true };
		}
		const storeName = options !== undefined ? options.storeName : false;
		const overwrite = options !== undefined ? options.overwrite : false;

		if (storeName) {
			const original = this.original.slice(start, end);
			Object.defineProperty(this.storedNames, original, {
				writable: true,
				value: true,
				enumerable: true,
			});
		}

		const first = this.byStart[start];
		const last = this.byEnd[end];

		if (first) {
			let chunk = first;
			while (chunk !== last) {
				if (chunk.next !== this.byStart[chunk.end]) {
					throw new Error('Cannot overwrite across a split point');
				}
				chunk = chunk.next;
				chunk.edit('', false);
			}

			first.edit(content, storeName, !overwrite);
		} else {
			// must be inserting at the end
			const newChunk = new Chunk(start, end, '').edit(content, storeName);

			// TODO last chunk in the array may not be the last chunk, if it's moved...
			last.next = newChunk;
			newChunk.previous = last;
		}
		return this;
	}

	prepend(content) {
		if (typeof content !== 'string') throw new TypeError('outro content must be a string');

		this.intro = content + this.intro;
		return this;
	}

	prependLeft(index, content) {
		index = index + this.offset;

		if (typeof content !== 'string') throw new TypeError('inserted content must be a string');

		this._split(index);

		const chunk = this.byEnd[index];

		if (chunk) {
			chunk.prependLeft(content);
		} else {
			this.intro = content + this.intro;
		}
		return this;
	}

	prependRight(index, content) {
		index = index + this.offset;

		if (typeof content !== 'string') throw new TypeError('inserted content must be a string');

		this._split(index);

		const chunk = this.byStart[index];

		if (chunk) {
			chunk.prependRight(content);
		} else {
			this.outro = content + this.outro;
		}
		return this;
	}

	remove(start, end) {
		start = start + this.offset;
		end = end + this.offset;

		if (this.original.length !== 0) {
			while (start < 0) start += this.original.length;
			while (end < 0) end += this.original.length;
		}

		if (start === end) return this;

		if (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');
		if (start > end) throw new Error('end must be greater than start');

		this._split(start);
		this._split(end);

		let chunk = this.byStart[start];

		while (chunk) {
			chunk.intro = '';
			chunk.outro = '';
			chunk.edit('');

			chunk = end > chunk.end ? this.byStart[chunk.end] : null;
		}
		return this;
	}

	reset(start, end) {
		start = start + this.offset;
		end = end + this.offset;

		if (this.original.length !== 0) {
			while (start < 0) start += this.original.length;
			while (end < 0) end += this.original.length;
		}

		if (start === end) return this;

		if (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');
		if (start > end) throw new Error('end must be greater than start');

		this._split(start);
		this._split(end);

		let chunk = this.byStart[start];

		while (chunk) {
			chunk.reset();

			chunk = end > chunk.end ? this.byStart[chunk.end] : null;
		}
		return this;
	}

	lastChar() {
		if (this.outro.length) return this.outro[this.outro.length - 1];
		let chunk = this.lastChunk;
		do {
			if (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];
			if (chunk.content.length) return chunk.content[chunk.content.length - 1];
			if (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];
		} while ((chunk = chunk.previous));
		if (this.intro.length) return this.intro[this.intro.length - 1];
		return '';
	}

	lastLine() {
		let lineIndex = this.outro.lastIndexOf(n);
		if (lineIndex !== -1) return this.outro.substr(lineIndex + 1);
		let lineStr = this.outro;
		let chunk = this.lastChunk;
		do {
			if (chunk.outro.length > 0) {
				lineIndex = chunk.outro.lastIndexOf(n);
				if (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;
				lineStr = chunk.outro + lineStr;
			}

			if (chunk.content.length > 0) {
				lineIndex = chunk.content.lastIndexOf(n);
				if (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;
				lineStr = chunk.content + lineStr;
			}

			if (chunk.intro.length > 0) {
				lineIndex = chunk.intro.lastIndexOf(n);
				if (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;
				lineStr = chunk.intro + lineStr;
			}
		} while ((chunk = chunk.previous));
		lineIndex = this.intro.lastIndexOf(n);
		if (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;
		return this.intro + lineStr;
	}

	slice(start = 0, end = this.original.length - this.offset) {
		start = start + this.offset;
		end = end + this.offset;

		if (this.original.length !== 0) {
			while (start < 0) start += this.original.length;
			while (end < 0) end += this.original.length;
		}

		let result = '';

		// find start chunk
		let chunk = this.firstChunk;
		while (chunk && (chunk.start > start || chunk.end <= start)) {
			// found end chunk before start
			if (chunk.start < end && chunk.end >= end) {
				return result;
			}

			chunk = chunk.next;
		}

		if (chunk && chunk.edited && chunk.start !== start)
			throw new Error(`Cannot use replaced character ${start} as slice start anchor.`);

		const startChunk = chunk;
		while (chunk) {
			if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {
				result += chunk.intro;
			}

			const containsEnd = chunk.start < end && chunk.end >= end;
			if (containsEnd && chunk.edited && chunk.end !== end)
				throw new Error(`Cannot use replaced character ${end} as slice end anchor.`);

			const sliceStart = startChunk === chunk ? start - chunk.start : 0;
			const sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;

			result += chunk.content.slice(sliceStart, sliceEnd);

			if (chunk.outro && (!containsEnd || chunk.end === end)) {
				result += chunk.outro;
			}

			if (containsEnd) {
				break;
			}

			chunk = chunk.next;
		}

		return result;
	}

	// TODO deprecate this? not really very useful
	snip(start, end) {
		const clone = this.clone();
		clone.remove(0, start);
		clone.remove(end, clone.original.length);

		return clone;
	}

	_split(index) {
		if (this.byStart[index] || this.byEnd[index]) return;

		let chunk = this.lastSearchedChunk;
		let previousChunk = chunk;
		const searchForward = index > chunk.end;

		while (chunk) {
			if (chunk.contains(index)) return this._splitChunk(chunk, index);

			chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];

			// Prevent infinite loop (e.g. via empty chunks, where start === end)
			if (chunk === previousChunk) return;

			previousChunk = chunk;
		}
	}

	_splitChunk(chunk, index) {
		if (chunk.edited && chunk.content.length) {
			// zero-length edited chunks are a special case (overlapping replacements)
			const loc = getLocator(this.original)(index);
			throw new Error(
				`Cannot split a chunk that has already been edited (${loc.line}:${loc.column} â "${chunk.original}")`,
			);
		}

		const newChunk = chunk.split(index);

		this.byEnd[index] = chunk;
		this.byStart[index] = newChunk;
		this.byEnd[newChunk.end] = newChunk;

		if (chunk === this.lastChunk) this.lastChunk = newChunk;

		this.lastSearchedChunk = chunk;
		return true;
	}

	toString() {
		let str = this.intro;

		let chunk = this.firstChunk;
		while (chunk) {
			str += chunk.toString();
			chunk = chunk.next;
		}

		return str + this.outro;
	}

	isEmpty() {
		let chunk = this.firstChunk;
		do {
			if (
				(chunk.intro.length && chunk.intro.trim()) ||
				(chunk.content.length && chunk.content.trim()) ||
				(chunk.outro.length && chunk.outro.trim())
			)
				return false;
		} while ((chunk = chunk.next));
		return true;
	}

	length() {
		let chunk = this.firstChunk;
		let length = 0;
		do {
			length += chunk.intro.length + chunk.content.length + chunk.outro.length;
		} while ((chunk = chunk.next));
		return length;
	}

	trimLines() {
		return this.trim('[\\r\\n]');
	}

	trim(charType) {
		return this.trimStart(charType).trimEnd(charType);
	}

	trimEndAborted(charType) {
		const rx = new RegExp((charType || '\\s') + '+$');

		this.outro = this.outro.replace(rx, '');
		if (this.outro.length) return true;

		let chunk = this.lastChunk;

		do {
			const end = chunk.end;
			const aborted = chunk.trimEnd(rx);

			// if chunk was trimmed, we have a new lastChunk
			if (chunk.end !== end) {
				if (this.lastChunk === chunk) {
					this.lastChunk = chunk.next;
				}

				this.byEnd[chunk.end] = chunk;
				this.byStart[chunk.next.start] = chunk.next;
				this.byEnd[chunk.next.end] = chunk.next;
			}

			if (aborted) return true;
			chunk = chunk.previous;
		} while (chunk);

		return false;
	}

	trimEnd(charType) {
		this.trimEndAborted(charType);
		return this;
	}
	trimStartAborted(charType) {
		const rx = new RegExp('^' + (charType || '\\s') + '+');

		this.intro = this.intro.replace(rx, '');
		if (this.intro.length) return true;

		let chunk = this.firstChunk;

		do {
			const end = chunk.end;
			const aborted = chunk.trimStart(rx);

			if (chunk.end !== end) {
				// special case...
				if (chunk === this.lastChunk) this.lastChunk = chunk.next;

				this.byEnd[chunk.end] = chunk;
				this.byStart[chunk.next.start] = chunk.next;
				this.byEnd[chunk.next.end] = chunk.next;
			}

			if (aborted) return true;
			chunk = chunk.next;
		} while (chunk);

		return false;
	}

	trimStart(charType) {
		this.trimStartAborted(charType);
		return this;
	}

	hasChanged() {
		return this.original !== this.toString();
	}

	_replaceRegexp(searchValue, replacement) {
		function getReplacement(match, str) {
			if (typeof replacement === 'string') {
				return replacement.replace(/\$(\$|&|\d+)/g, (_, i) => {
					// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_a_parameter
					if (i === '$') return '$';
					if (i === '&') return match[0];
					const num = +i;
					if (num < match.length) return match[+i];
					return `$${i}`;
				});
			} else {
				return replacement(...match, match.index, str, match.groups);
			}
		}
		function matchAll(re, str) {
			let match;
			const matches = [];
			while ((match = re.exec(str))) {
				matches.push(match);
			}
			return matches;
		}
		if (searchValue.global) {
			const matches = matchAll(searchValue, this.original);
			matches.forEach((match) => {
				if (match.index != null) {
					const replacement = getReplacement(match, this.original);
					if (replacement !== match[0]) {
						this.overwrite(match.index, match.index + match[0].length, replacement);
					}
				}
			});
		} else {
			const match = this.original.match(searchValue);
			if (match && match.index != null) {
				const replacement = getReplacement(match, this.original);
				if (replacement !== match[0]) {
					this.overwrite(match.index, match.index + match[0].length, replacement);
				}
			}
		}
		return this;
	}

	_replaceString(string, replacement) {
		const { original } = this;
		const index = original.indexOf(string);

		if (index !== -1) {
			if (typeof replacement === 'function') {
				replacement = replacement(string, index, original);
			}
			if (string !== replacement) {
				this.overwrite(index, index + string.length, replacement);
			}
		}

		return this;
	}

	replace(searchValue, replacement) {
		if (typeof searchValue === 'string') {
			return this._replaceString(searchValue, replacement);
		}

		return this._replaceRegexp(searchValue, replacement);
	}

	_replaceAllString(string, replacement) {
		const { original } = this;
		const stringLength = string.length;
		for (
			let index = original.indexOf(string);
			index !== -1;
			index = original.indexOf(string, index + stringLength)
		) {
			const previous = original.slice(index, index + stringLength);
			let _replacement = replacement;
			if (typeof replacement === 'function') {
				_replacement = replacement(previous, index, original);
			}
			if (previous !== _replacement) this.overwrite(index, index + stringLength, _replacement);
		}

		return this;
	}

	replaceAll(searchValue, replacement) {
		if (typeof searchValue === 'string') {
			return this._replaceAllString(searchValue, replacement);
		}

		if (!searchValue.global) {
			throw new TypeError(
				'MagicString.prototype.replaceAll called with a non-global RegExp argument',
			);
		}

		return this._replaceRegexp(searchValue, replacement);
	}
}

const REGISTRY$1 = new o.DomElementSchemaRegistry();
const REMOVE_XHTML_REGEX = /^:xhtml:/;
/**
 * Checks non-Angular elements and properties against the `DomElementSchemaRegistry`, a schema
 * maintained by the Angular team via extraction from a browser IDL.
 */
class RegistryDomSchemaChecker {
    resolver;
    _diagnostics = [];
    get diagnostics() {
        return this._diagnostics;
    }
    constructor(resolver) {
        this.resolver = resolver;
    }
    checkElement(id, tagName, sourceSpanForDiagnostics, schemas, hostIsStandalone) {
        // HTML elements inside an SVG `foreignObject` are declared in the `xhtml` namespace.
        // We need to strip it before handing it over to the registry because all HTML tag names
        // in the registry are without a namespace.
        const name = tagName.replace(REMOVE_XHTML_REGEX, '');
        if (!REGISTRY$1.hasElement(name, schemas)) {
            const mapping = this.resolver.getTemplateSourceMapping(id);
            const schemas = `'${hostIsStandalone ? '@Component' : '@NgModule'}.schemas'`;
            let errorMsg = `'${name}' is not a known element:\n`;
            errorMsg += `1. If '${name}' is an Angular component, then verify that it is ${hostIsStandalone
                ? "included in the '@Component.imports' of this component"
                : 'part of this module'}.\n`;
            if (name.indexOf('-') > -1) {
                errorMsg += `2. If '${name}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the ${schemas} of this component to suppress this message.`;
            }
            else {
                errorMsg += `2. To allow any element add 'NO_ERRORS_SCHEMA' to the ${schemas} of this component.`;
            }
            const diag = makeTemplateDiagnostic(id, mapping, sourceSpanForDiagnostics, ts.DiagnosticCategory.Error, ngErrorCode(exports.ErrorCode.SCHEMA_INVALID_ELEMENT), errorMsg);
            this._diagnostics.push(diag);
        }
    }
    checkTemplateElementProperty(id, tagName, name, span, schemas, hostIsStandalone) {
        if (!REGISTRY$1.hasProperty(tagName, name, schemas)) {
            const mapping = this.resolver.getTemplateSourceMapping(id);
            const decorator = hostIsStandalone ? '@Component' : '@NgModule';
            const schemas = `'${decorator}.schemas'`;
            let errorMsg = `Can't bind to '${name}' since it isn't a known property of '${tagName}'.`;
            if (tagName.startsWith('ng-')) {
                errorMsg +=
                    `\n1. If '${name}' is an Angular directive, then add 'CommonModule' to the '${decorator}.imports' of this component.` +
                        `\n2. To allow any property add 'NO_ERRORS_SCHEMA' to the ${schemas} of this component.`;
            }
            else if (tagName.indexOf('-') > -1) {
                errorMsg +=
                    `\n1. If '${tagName}' is an Angular component and it has '${name}' input, then verify that it is ${hostIsStandalone
                        ? "included in the '@Component.imports' of this component"
                        : 'part of this module'}.` +
                        `\n2. If '${tagName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the ${schemas} of this component to suppress this message.` +
                        `\n3. To allow any property add 'NO_ERRORS_SCHEMA' to the ${schemas} of this component.`;
            }
            const diag = makeTemplateDiagnostic(id, mapping, span, ts.DiagnosticCategory.Error, ngErrorCode(exports.ErrorCode.SCHEMA_INVALID_ATTRIBUTE), errorMsg);
            this._diagnostics.push(diag);
        }
    }
    checkHostElementProperty(id, element, name, span, schemas) {
        for (const tagName of element.tagNames) {
            if (REGISTRY$1.hasProperty(tagName, name, schemas)) {
                continue;
            }
            const errorMessage = `Can't bind to '${name}' since it isn't a known property of '${tagName}'.`;
            const mapping = this.resolver.getHostBindingsMapping(id);
            const diag = makeTemplateDiagnostic(id, mapping, span, ts.DiagnosticCategory.Error, ngErrorCode(exports.ErrorCode.SCHEMA_INVALID_ATTRIBUTE), errorMessage);
            this._diagnostics.push(diag);
            break;
        }
    }
}

/**
 * An environment for a given source file that can be used to emit references.
 *
 * This can be used by the type-checking block, or constructor logic to generate
 * references to directives or other symbols or types.
 */
class ReferenceEmitEnvironment {
    importManager;
    refEmitter;
    reflector;
    contextFile;
    constructor(importManager, refEmitter, reflector, contextFile) {
        this.importManager = importManager;
        this.refEmitter = refEmitter;
        this.reflector = reflector;
        this.contextFile = contextFile;
    }
    canReferenceType(ref, flags = ImportFlags.NoAliasing |
        ImportFlags.AllowTypeImports |
        ImportFlags.AllowRelativeDtsImports) {
        const result = this.refEmitter.emit(ref, this.contextFile, flags);
        return result.kind === exports.ReferenceEmitKind.Success;
    }
    /**
     * Generate a `ts.TypeNode` that references the given node as a type.
     *
     * This may involve importing the node into the file if it's not declared there already.
     */
    referenceType(ref, flags = ImportFlags.NoAliasing |
        ImportFlags.AllowTypeImports |
        ImportFlags.AllowRelativeDtsImports) {
        const ngExpr = this.refEmitter.emit(ref, this.contextFile, flags);
        assertSuccessfulReferenceEmit(ngExpr, this.contextFile, 'symbol');
        // Create an `ExpressionType` from the `Expression` and translate it via `translateType`.
        // TODO(alxhub): support references to types with generic arguments in a clean way.
        return translateType(new o.ExpressionType(ngExpr.expression), this.contextFile, this.reflector, this.refEmitter, this.importManager);
    }
    /**
     * Generate a `ts.Expression` that refers to the external symbol. This
     * may result in new imports being generated.
     */
    referenceExternalSymbol(moduleName, name) {
        const external = new o.ExternalExpr({ moduleName, name });
        return translateExpression(this.contextFile, external, this.importManager);
    }
    /**
     * Generate a `ts.TypeNode` that references a given type from the provided module.
     *
     * This will involve importing the type into the file, and will also add type parameters if
     * provided.
     */
    referenceExternalType(moduleName, name, typeParams) {
        const external = new o.ExternalExpr({ moduleName, name });
        return translateType(new o.ExpressionType(external, o.TypeModifier.None, typeParams), this.contextFile, this.reflector, this.refEmitter, this.importManager);
    }
    /**
     * Generates a `ts.TypeNode` representing a type that is being referenced from a different place
     * in the program. Any type references inside the transplanted type will be rewritten so that
     * they can be imported in the context file.
     */
    referenceTransplantedType(type) {
        return translateType(type, this.contextFile, this.reflector, this.refEmitter, this.importManager);
    }
}

/**
 * See `TypeEmitter` for more information on the emitting process.
 */
class TypeParameterEmitter {
    typeParameters;
    reflector;
    constructor(typeParameters, reflector) {
        this.typeParameters = typeParameters;
        this.reflector = reflector;
    }
    /**
     * Determines whether the type parameters can be emitted. If this returns true, then a call to
     * `emit` is known to succeed. Vice versa, if false is returned then `emit` should not be
     * called, as it would fail.
     */
    canEmit(canEmitReference) {
        if (this.typeParameters === undefined) {
            return true;
        }
        return this.typeParameters.every((typeParam) => {
            return (this.canEmitType(typeParam.constraint, canEmitReference) &&
                this.canEmitType(typeParam.default, canEmitReference));
        });
    }
    canEmitType(type, canEmitReference) {
        if (type === undefined) {
            return true;
        }
        return canEmitType(type, (typeReference) => {
            const reference = this.resolveTypeReference(typeReference);
            if (reference === null) {
                return false;
            }
            if (reference instanceof Reference) {
                return canEmitReference(reference);
            }
            return true;
        });
    }
    /**
     * Emits the type parameters using the provided emitter function for `Reference`s.
     */
    emit(emitReference) {
        if (this.typeParameters === undefined) {
            return undefined;
        }
        const emitter = new TypeEmitter((type) => this.translateTypeReference(type, emitReference));
        return this.typeParameters.map((typeParam) => {
            const constraint = typeParam.constraint !== undefined ? emitter.emitType(typeParam.constraint) : undefined;
            const defaultType = typeParam.default !== undefined ? emitter.emitType(typeParam.default) : undefined;
            return ts.factory.updateTypeParameterDeclaration(typeParam, typeParam.modifiers, typeParam.name, constraint, defaultType);
        });
    }
    resolveTypeReference(type) {
        const target = ts.isIdentifier(type.typeName) ? type.typeName : type.typeName.right;
        const declaration = this.reflector.getDeclarationOfIdentifier(target);
        // If no declaration could be resolved or does not have a `ts.Declaration`, the type cannot be
        // resolved.
        if (declaration === null || declaration.node === null) {
            return null;
        }
        // If the declaration corresponds with a local type parameter, the type reference can be used
        // as is.
        if (this.isLocalTypeParameter(declaration.node)) {
            return type;
        }
        let owningModule = null;
        if (typeof declaration.viaModule === 'string') {
            owningModule = {
                specifier: declaration.viaModule,
                resolutionContext: type.getSourceFile().fileName,
            };
        }
        return new Reference(declaration.node, declaration.viaModule === AmbientImport ? AmbientImport : owningModule);
    }
    translateTypeReference(type, emitReference) {
        const reference = this.resolveTypeReference(type);
        if (!(reference instanceof Reference)) {
            return reference;
        }
        const typeNode = emitReference(reference);
        if (typeNode === null) {
            return null;
        }
        if (!ts.isTypeReferenceNode(typeNode)) {
            throw new Error(`Expected TypeReferenceNode for emitted reference, got ${ts.SyntaxKind[typeNode.kind]}.`);
        }
        return typeNode;
    }
    isLocalTypeParameter(decl) {
        // Checking for local type parameters only occurs during resolution of type parameters, so it is
        // guaranteed that type parameters are present.
        return this.typeParameters.some((param) => param === decl);
    }
}

/*!
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.dev/license
 */
/**
 * Comment attached to an AST node that serves as a guard to distinguish nodes
 * used for type checking host bindings from ones used for templates.
 */
const GUARD_COMMENT_TEXT = 'hostBindingsBlockGuard';
/**
 * Creates an AST node that represents the host element of a directive.
 * Can return null if there are no valid bindings to be checked.
 * @param type Whether the host element is for a directive or a component.
 * @param selector Selector of the directive.
 * @param sourceNode Class declaration for the directive.
 * @param literal `host` object literal from the decorator.
 * @param bindingDecorators `HostBinding` decorators discovered on the node.
 * @param listenerDecorators `HostListener` decorators discovered on the node.
 */
function createHostElement(type, selector, sourceNode, literal, bindingDecorators, listenerDecorators) {
    const bindings = [];
    const listeners = [];
    let parser = null;
    if (literal !== null) {
        for (const prop of literal.properties) {
            // We only support type checking of static bindings.
            if (ts.isPropertyAssignment(prop) &&
                ts.isStringLiteralLike(prop.initializer) &&
                isStaticName(prop.name)) {
                parser ??= o.makeBindingParser();
                createNodeFromHostLiteralProperty(prop, parser, bindings, listeners);
            }
        }
    }
    for (const decorator of bindingDecorators) {
        createNodeFromBindingDecorator(decorator, bindings);
    }
    for (const decorator of listenerDecorators) {
        parser ??= o.makeBindingParser();
        createNodeFromListenerDecorator(decorator, parser, listeners);
    }
    // The element will be a no-op if there are no bindings.
    if (bindings.length === 0 && listeners.length === 0) {
        return null;
    }
    const tagNames = [];
    if (selector !== null) {
        const parts = o.CssSelector.parse(selector);
        for (const part of parts) {
            if (part.element !== null) {
                tagNames.push(part.element);
            }
        }
    }
    // If none of the selectors have a tag name, fall back to `ng-component`/`ng-directive`.
    // This is how the runtime handles components without tag names as well.
    if (tagNames.length === 0) {
        tagNames.push(`ng-${type}`);
    }
    return new o.TmplAstHostElement(tagNames, bindings, listeners, createSourceSpan(sourceNode.name));
}
/**
 * Creates an AST node that can be used as a guard in `if` statements to distinguish TypeScript
 * nodes used for checking host bindings from ones used for checking templates.
 */
function createHostBindingsBlockGuard() {
    // Note that the comment text is quite generic. This doesn't really matter, because it is
    // used only inside a TCB and there's no way for users to produce a comment there.
    // `true /*hostBindings*/`.
    const trueExpr = ts.addSyntheticTrailingComment(ts.factory.createTrue(), ts.SyntaxKind.MultiLineCommentTrivia, GUARD_COMMENT_TEXT);
    // Wrap the expression in parentheses to ensure that the comment is attached to the correct node.
    return ts.factory.createParenthesizedExpression(trueExpr);
}
/**
 * Determines if a given node is a guard that indicates that descendant nodes are used to check
 * host bindings.
 */
function isHostBindingsBlockGuard(node) {
    if (!ts.isIfStatement(node)) {
        return false;
    }
    // Needs to be kept in sync with `createHostBindingsMarker`.
    const expr = node.expression;
    if (!ts.isParenthesizedExpression(expr) || expr.expression.kind !== ts.SyntaxKind.TrueKeyword) {
        return false;
    }
    const text = expr.getSourceFile().text;
    return (ts.forEachTrailingCommentRange(text, expr.expression.getEnd(), (pos, end, kind) => kind === ts.SyntaxKind.MultiLineCommentTrivia &&
        text.substring(pos + 2, end - 2) === GUARD_COMMENT_TEXT) || false);
}
/**
 * If possible, creates and tracks the relevant AST node for a binding declared
 * through a property on the `host` literal.
 * @param prop Property to parse.
 * @param parser Binding parser used to parse the expressions.
 * @param bindings Array tracking the bound attributes of the host element.
 * @param listeners Array tracking the event listeners of the host element.
 */
function createNodeFromHostLiteralProperty(property, parser, bindings, listeners) {
    // TODO(crisbeto): surface parsing errors here, because currently they just get ignored.
    // They'll still get reported when the handler tries to parse the bindings, but here we
    // can highlight the nodes more accurately.
    const { name, initializer } = property;
    if (name.text.startsWith('[') && name.text.endsWith(']')) {
        const { attrName, type } = inferBoundAttribute(name.text.slice(1, -1));
        const valueSpan = createStaticExpressionSpan(initializer);
        const ast = parser.parseBinding(initializer.text, true, valueSpan, valueSpan.start.offset);
        if (ast.errors.length > 0) {
            return; // See TODO above.
        }
        fixupSpans(ast, initializer);
        bindings.push(new o.TmplAstBoundAttribute(attrName, type, 0, ast, null, createSourceSpan(property), createStaticExpressionSpan(name), valueSpan, undefined));
    }
    else if (name.text.startsWith('(') && name.text.endsWith(')')) {
        const events = [];
        parser.parseEvent(name.text.slice(1, -1), initializer.text, false, createSourceSpan(property), createStaticExpressionSpan(initializer), [], events, createStaticExpressionSpan(name));
        if (events.length === 0 || events[0].handler.errors.length > 0) {
            return; // See TODO above.
        }
        fixupSpans(events[0].handler, initializer);
        listeners.push(o.TmplAstBoundEvent.fromParsedEvent(events[0]));
    }
}
/**
 * If possible, creates and tracks a bound attribute node from a `HostBinding` decorator.
 * @param decorator Decorator from which to create the node.
 * @param bindings Array tracking the bound attributes of the host element.
 */
function createNodeFromBindingDecorator(decorator, bindings) {
    // We only support decorators that are being called.
    if (!ts.isCallExpression(decorator.expression)) {
        return;
    }
    const args = decorator.expression.arguments;
    const property = decorator.parent;
    let nameNode = null;
    let propertyName = null;
    if (property && ts.isPropertyDeclaration(property) && isStaticName(property.name)) {
        propertyName = property.name;
    }
    // The first parameter is optional. If omitted, the name
    // of the class member is used as the property.
    if (args.length === 0) {
        nameNode = propertyName;
    }
    else if (ts.isStringLiteralLike(args[0])) {
        nameNode = args[0];
    }
    else {
        return;
    }
    if (nameNode === null || propertyName === null) {
        return;
    }
    // We can't synthesize a fake expression here and pass it through the binding parser, because
    // it constructs all the spans based on the source code origin and they aren't easily mappable
    // back to the source. E.g. `@HostBinding('foo') id = '123'` in source code would look
    // something like `[foo]="this.id"` in the AST. Instead we construct the expressions
    // manually here. Note that we use a dummy span with -1/-1 as offsets, because it isn't
    // used for type checking and constructing it accurately would take some effort.
    const span = new o.ParseSpan(-1, -1);
    const propertyStart = property.getStart();
    const receiver = new o.ThisReceiver(span, new o.AbsoluteSourceSpan(propertyStart, propertyStart));
    const nameSpan = new o.AbsoluteSourceSpan(propertyName.getStart(), propertyName.getEnd());
    const read = ts.isIdentifier(propertyName)
        ? new o.PropertyRead(span, nameSpan, nameSpan, receiver, propertyName.text)
        : new o.KeyedRead(span, nameSpan, receiver, new o.LiteralPrimitive(span, nameSpan, propertyName.text));
    const { attrName, type } = inferBoundAttribute(nameNode.text);
    bindings.push(new o.TmplAstBoundAttribute(attrName, type, 0, read, null, createSourceSpan(decorator), createStaticExpressionSpan(nameNode), createSourceSpan(decorator), undefined));
}
/**
 * If possible, creates and tracks a bound event node from a `HostBinding` decorator.
 * @param decorator Decorator from which to create the node.
 * @param parser Binding parser used to parse the expressions.
 * @param bindings Array tracking the bound events of the host element.
 */
function createNodeFromListenerDecorator(decorator, parser, listeners) {
    // We only support decorators that are being called with at least one argument.
    if (!ts.isCallExpression(decorator.expression) || decorator.expression.arguments.length === 0) {
        return;
    }
    const args = decorator.expression.arguments;
    const method = decorator.parent;
    // Only handle decorators that are statically analyzable.
    if (!method ||
        !ts.isMethodDeclaration(method) ||
        !isStaticName(method.name) ||
        !ts.isStringLiteralLike(args[0])) {
        return;
    }
    // We can't synthesize a fake expression here and pass it through the binding parser, because
    // it constructs all the spans based on the source code origin and they aren't easily mappable
    // back to the source. E.g. `@HostListener('foo') handleFoo() {}` in source code would look
    // something like `(foo)="handleFoo()"` in the AST. Instead we construct the expressions
    // manually here. Note that we use a dummy span with -1/-1 as offsets, because it isn't
    // used for type checking and constructing it accurately would take some effort.
    const span = new o.ParseSpan(-1, -1);
    const argNodes = [];
    const methodStart = method.getStart();
    const methodReceiver = new o.ThisReceiver(span, new o.AbsoluteSourceSpan(methodStart, methodStart));
    const nameSpan = new o.AbsoluteSourceSpan(method.name.getStart(), method.name.getEnd());
    const receiver = ts.isIdentifier(method.name)
        ? new o.PropertyRead(span, nameSpan, nameSpan, methodReceiver, method.name.text)
        : new o.KeyedRead(span, nameSpan, methodReceiver, new o.LiteralPrimitive(span, nameSpan, method.name.text));
    if (args.length > 1 && ts.isArrayLiteralExpression(args[1])) {
        for (const expr of args[1].elements) {
            // If the parameter is a static string, parse it using the binding parser since it can be any
            // expression, otherwise treat it as `any` so the rest of the parameters can be checked.
            if (ts.isStringLiteralLike(expr)) {
                const span = createStaticExpressionSpan(expr);
                const ast = parser.parseBinding(expr.text, true, span, span.start.offset);
                fixupSpans(ast, expr);
                argNodes.push(ast);
            }
            else {
                // Represents `$any(0)`. We need to construct it manually in order to set the right spans.
                const expressionSpan = new o.AbsoluteSourceSpan(expr.getStart(), expr.getEnd());
                const anyRead = new o.PropertyRead(span, expressionSpan, expressionSpan, new o.ImplicitReceiver(span, expressionSpan), '$any');
                const anyCall = new o.Call(span, expressionSpan, anyRead, [new o.LiteralPrimitive(span, expressionSpan, 0)], expressionSpan);
                argNodes.push(anyCall);
            }
        }
    }
    const callNode = new o.Call(span, nameSpan, receiver, argNodes, span);
    const eventNameNode = args[0];
    let type;
    let eventName;
    let phase;
    let target;
    if (eventNameNode.text.startsWith('@')) {
        const parsedName = parser.parseLegacyAnimationEventName(eventNameNode.text);
        type = o.ParsedEventType.LegacyAnimation;
        eventName = parsedName.eventName;
        phase = parsedName.phase;
        target = null;
    }
    else {
        const parsedName = parser.parseEventListenerName(eventNameNode.text);
        type = o.ParsedEventType.Regular;
        eventName = parsedName.eventName;
        target = parsedName.target;
        phase = null;
    }
    listeners.push(new o.TmplAstBoundEvent(eventName, type, callNode, target, phase, createSourceSpan(decorator), createSourceSpan(decorator), createStaticExpressionSpan(eventNameNode)));
}
/**
 * Infers the attribute name and binding type of a bound attribute based on its raw name.
 * @param name Name from which to infer the information.
 */
function inferBoundAttribute(name) {
    const attrPrefix = 'attr.';
    const classPrefix = 'class.';
    const stylePrefix = 'style.';
    const animationPrefix = 'animate.';
    const legacyAnimationPrefix = '@';
    let attrName;
    let type;
    // Infer the binding type based on the prefix.
    if (name.startsWith(attrPrefix)) {
        attrName = name.slice(attrPrefix.length);
        type = o.BindingType.Attribute;
    }
    else if (name.startsWith(classPrefix)) {
        attrName = name.slice(classPrefix.length);
        type = o.BindingType.Class;
    }
    else if (name.startsWith(stylePrefix)) {
        attrName = name.slice(stylePrefix.length);
        type = o.BindingType.Style;
    }
    else if (name.startsWith(animationPrefix)) {
        attrName = name;
        type = o.BindingType.Animation;
    }
    else if (name.startsWith(legacyAnimationPrefix)) {
        attrName = name.slice(legacyAnimationPrefix.length);
        type = o.BindingType.LegacyAnimation;
    }
    else {
        attrName = name;
        type = o.BindingType.Property;
    }
    return { attrName, type };
}
/** Checks whether the specified node is a static name node. */
function isStaticName(node) {
    return ts.isIdentifier(node) || ts.isStringLiteralLike(node);
}
/** Creates a `ParseSourceSpan` pointing to a static expression AST node's source. */
function createStaticExpressionSpan(node) {
    const span = createSourceSpan(node);
    // Offset by one on both sides to skip over the quotes.
    if (ts.isStringLiteralLike(node)) {
        span.fullStart = span.fullStart.moveBy(1);
        span.start = span.start.moveBy(1);
        span.end = span.end.moveBy(-1);
    }
    return span;
}
/**
 * Adjusts the spans of a parsed AST so that they're appropriate for a host bindings context.
 * @param ast The parsed AST that may need to be adjusted.
 * @param initializer TypeScript node from which the source of the AST was extracted.
 */
function fixupSpans(ast, initializer) {
    // When parsing the initializer as a property/event binding, we use `.text` which excludes escaped
    // quotes and is generally what we want, because preserving them would result in a parser error,
    // however it has the downside in that the spans of the expressions following the escaped
    // characters are no longer accurate relative to the source code. The more escaped characters
    // there are before a node, the more inaccurate its span will be. If we detect cases like that,
    // we override the spans of all nodes following the escaped string to point to the entire
    // initializer string so that we don't surface diagnostics with mangled spans. This isn't ideal,
    // but is likely rare in user code. Some workarounds that were attempted and ultimately discarded:
    // 1. Counting the number of escaped strings before a node and adjusting its span accordingly -
    // There's a prototype of this approach in https://github.com/crisbeto/angular/commit/1eb92353784a609f6be7e6653ae5a9faef549e6a
    // It works for the most part, but is complex and somewhat brittle, because it's not just the
    // escaped literals that need to be updated, but also any nodes _after_ them and any nodes
    // _containing_ them which gets increasingly complex with more complicated ASTs.
    // 2. Replacing escape characters with whitespaces, for example `\'foo\' + 123` would become
    // ` 'foo ' + 123` - this appears to produce accurate ASTs for some simpler use cases, but has
    // the potential of either changing the user's code into something that's no longer parseable or
    // causing type checking errors (e.g. the typings might require the exact string 'foo').
    // 3. Passing the raw text (e.g. `initializer.getText().slice(1, -1)`) into the binding parser -
    // This will preserve the right mappings, but can lead to parsing errors, because some of the
    // strings won't have to be escaped anymore. We could add a mode to the parser that allows it to
    // recover from such cases, but it'll introduce more complexity that we may not want to take on.
    // 4. Constructing some sort of string like `<host ${name.getText()}=${initializer.getText()}/>`,
    // passing it through the HTML parser and extracting the first attribute from it - wasn't explored
    // much, but likely has the same issues as approach #3.
    const escapeIndex = initializer.getText().indexOf('\\', 1);
    if (escapeIndex > -1) {
        const newSpan = new o.ParseSpan(0, initializer.getWidth());
        const newSourceSpan = new o.AbsoluteSourceSpan(initializer.getStart(), initializer.getEnd());
        ast.visit(new ReplaceSpanVisitor(escapeIndex, newSpan, newSourceSpan));
    }
}
/**
 * Visitor that replaces the spans of all nodes with new ones,
 * if they're defined after a specific index.
 */
class ReplaceSpanVisitor extends o.RecursiveAstVisitor {
    afterIndex;
    overrideSpan;
    overrideSourceSpan;
    constructor(afterIndex, overrideSpan, overrideSourceSpan) {
        super();
        this.afterIndex = afterIndex;
        this.overrideSpan = overrideSpan;
        this.overrideSourceSpan = overrideSourceSpan;
    }
    visit(ast) {
        // Only nodes after the index need to be adjusted, but all nodes should be visited.
        if (ast.span.start >= this.afterIndex || ast.span.end >= this.afterIndex) {
            ast.span = this.overrideSpan;
            ast.sourceSpan = this.overrideSourceSpan;
            if (ast instanceof o.ASTWithName) {
                ast.nameSpan = this.overrideSourceSpan;
            }
            if (ast instanceof o.Call || ast instanceof o.SafeCall) {
                ast.argumentSpan = this.overrideSourceSpan;
            }
        }
        super.visit(ast);
    }
}

/**
 * External modules/identifiers that always should exist for type check
 * block files.
 *
 * Importing the modules in preparation helps ensuring a stable import graph
 * that would not degrade TypeScript's incremental program structure re-use.
 *
 * Note: For inline type check blocks, or type constructors, we cannot add preparation
 * imports, but ideally the required modules are already imported and can be re-used
 * to not incur a structural TypeScript program re-use discarding.
 */
const TCB_FILE_IMPORT_GRAPH_PREPARE_IDENTIFIERS = [
    // Imports may be added for signal input checking. We wouldn't want to change the
    // import graph for incremental compilations when suddenly a signal input is used,
    // or removed.
    o.R3Identifiers.InputSignalBrandWriteType,
];
/**
 * Indicates whether a particular component requires an inline type check block.
 *
 * This is not a boolean state as inlining might only be required to get the best possible
 * type-checking, but the component could theoretically still be checked without it.
 */
var TcbInliningRequirement;
(function (TcbInliningRequirement) {
    /**
     * There is no way to type check this component without inlining.
     */
    TcbInliningRequirement[TcbInliningRequirement["MustInline"] = 0] = "MustInline";
    /**
     * Inlining should be used due to the component's generic bounds, but a non-inlining fallback
     * method can be used if that's not possible.
     */
    TcbInliningRequirement[TcbInliningRequirement["ShouldInlineForGenericBounds"] = 1] = "ShouldInlineForGenericBounds";
    /**
     * There is no requirement for this component's TCB to be inlined.
     */
    TcbInliningRequirement[TcbInliningRequirement["None"] = 2] = "None";
})(TcbInliningRequirement || (TcbInliningRequirement = {}));
function requiresInlineTypeCheckBlock(ref, env, usedPipes, reflector) {
    // In order to qualify for a declared TCB (not inline) two conditions must be met:
    // 1) the class must be suitable to be referenced from `env` (e.g. it must be exported)
    // 2) it must not have contextual generic type bounds
    if (!env.canReferenceType(ref)) {
        // Condition 1 is false, the class is not exported.
        return TcbInliningRequirement.MustInline;
    }
    else if (!checkIfGenericTypeBoundsCanBeEmitted(ref.node, reflector, env)) {
        // Condition 2 is false, the class has constrained generic types. It should be checked with an
        // inline TCB if possible, but can potentially use fallbacks to avoid inlining if not.
        return TcbInliningRequirement.ShouldInlineForGenericBounds;
    }
    else if (usedPipes.some((pipeRef) => !env.canReferenceType(pipeRef))) {
        // If one of the pipes used by the component is not exported, a non-inline TCB will not be able
        // to import it, so this requires an inline TCB.
        return TcbInliningRequirement.MustInline;
    }
    else {
        return TcbInliningRequirement.None;
    }
}
/** Maps a shim position back to a source code location. */
function getSourceMapping(shimSf, position, resolver, isDiagnosticRequest) {
    const node = getTokenAtPosition(shimSf, position);
    const sourceLocation = findSourceLocation(node, shimSf, isDiagnosticRequest);
    if (sourceLocation === null) {
        return null;
    }
    if (isInHostBindingTcb(node)) {
        const hostSourceMapping = resolver.getHostBindingsMapping(sourceLocation.id);
        const span = resolver.toHostParseSourceSpan(sourceLocation.id, sourceLocation.span);
        if (span === null) {
            return null;
        }
        return { sourceLocation, sourceMapping: hostSourceMapping, span };
    }
    const span = resolver.toTemplateParseSourceSpan(sourceLocation.id, sourceLocation.span);
    if (span === null) {
        return null;
    }
    // TODO(atscott): Consider adding a context span by walking up from `node` until we get a
    // different span.
    return {
        sourceLocation,
        sourceMapping: resolver.getTemplateSourceMapping(sourceLocation.id),
        span,
    };
}
function isInHostBindingTcb(node) {
    let current = node;
    while (current && !ts.isFunctionDeclaration(current)) {
        if (isHostBindingsBlockGuard(current)) {
            return true;
        }
        current = current.parent;
    }
    return false;
}
function findTypeCheckBlock(file, id, isDiagnosticRequest) {
    // This prioritised-level statements using a breadth-first search
    // This is usually sufficient to find the TCB we're looking for
    for (const stmt of file.statements) {
        if (ts.isFunctionDeclaration(stmt) && getTypeCheckId(stmt, file, isDiagnosticRequest) === id) {
            return stmt;
        }
    }
    // In case the TCB we're looking for is nested (which is not common)
    // eg: when a directive is declared inside a function, as it can happen in test files
    return findNodeInFile(file, (node) => ts.isFunctionDeclaration(node) && getTypeCheckId(node, file, isDiagnosticRequest) === id);
}
/**
 * Traverses up the AST starting from the given node to extract the source location from comments
 * that have been emitted into the TCB. If the node does not exist within a TCB, or if an ignore
 * marker comment is found up the tree (and this is part of a diagnostic request), this function
 * returns null.
 */
function findSourceLocation(node, sourceFile, isDiagnosticsRequest) {
    // Search for comments until the TCB's function declaration is encountered.
    while (node !== undefined && !ts.isFunctionDeclaration(node)) {
        if (hasIgnoreForDiagnosticsMarker(node, sourceFile) && isDiagnosticsRequest) {
            // There's an ignore marker on this node, so the diagnostic should not be reported.
            return null;
        }
        const span = readSpanComment(node, sourceFile);
        if (span !== null) {
            // Once the positional information has been extracted, search further up the TCB to extract
            // the unique id that is attached with the TCB's function declaration.
            const id = getTypeCheckId(node, sourceFile, isDiagnosticsRequest);
            if (id === null) {
                return null;
            }
            return { id, span };
        }
        node = node.parent;
    }
    return null;
}
function getTypeCheckId(node, sourceFile, isDiagnosticRequest) {
    // Walk up to the function declaration of the TCB, the file information is attached there.
    while (!ts.isFunctionDeclaration(node)) {
        if (hasIgnoreForDiagnosticsMarker(node, sourceFile) && isDiagnosticRequest) {
            // There's an ignore marker on this node, so the diagnostic should not be reported.
            return null;
        }
        node = node.parent;
        // Bail once we have reached the root.
        if (node === undefined) {
            return null;
        }
    }
    const start = node.getFullStart();
    return (ts.forEachLeadingCommentRange(sourceFile.text, start, (pos, end, kind) => {
        if (kind !== ts.SyntaxKind.MultiLineCommentTrivia) {
            return null;
        }
        const commentText = sourceFile.text.substring(pos + 2, end - 2);
        return commentText;
    }) || null);
}
/**
 * Ensure imports for certain external modules that should always
 * exist are generated. These are ensured to exist to avoid frequent
 * import graph changes whenever e.g. a signal input is introduced in user code.
 */
function ensureTypeCheckFilePreparationImports(env) {
    for (const identifier of TCB_FILE_IMPORT_GRAPH_PREPARE_IDENTIFIERS) {
        env.importManager.addImport({
            exportModuleSpecifier: identifier.moduleName,
            exportSymbolName: identifier.name,
            requestedFile: env.contextFile,
        });
    }
}
function checkIfGenericTypeBoundsCanBeEmitted(node, reflector, env) {
    // Generic type parameters are considered context free if they can be emitted into any context.
    const emitter = new TypeParameterEmitter(node.typeParameters, reflector);
    return emitter.canEmit((ref) => env.canReferenceType(ref));
}
function findNodeInFile(file, predicate) {
    const visit = (node) => {
        if (predicate(node)) {
            return node;
        }
        return ts.forEachChild(node, visit) ?? null;
    };
    return ts.forEachChild(file, visit) ?? null;
}

function generateTypeCtorDeclarationFn(env, meta, nodeTypeRef, typeParams) {
    const rawTypeArgs = typeParams !== undefined ? generateGenericArgs(typeParams) : undefined;
    const rawType = ts.factory.createTypeReferenceNode(nodeTypeRef, rawTypeArgs);
    const initParam = constructTypeCtorParameter(env, meta, rawType);
    const typeParameters = typeParametersWithDefaultTypes(typeParams);
    if (meta.body) {
        const fnType = ts.factory.createFunctionTypeNode(
        /* typeParameters */ typeParameters, 
        /* parameters */ [initParam], 
        /* type */ rawType);
        const decl = ts.factory.createVariableDeclaration(
        /* name */ meta.fnName, 
        /* exclamationToken */ undefined, 
        /* type */ fnType, 
        /* body */ ts.factory.createNonNullExpression(ts.factory.createNull()));
        const declList = ts.factory.createVariableDeclarationList([decl], ts.NodeFlags.Const);
        return ts.factory.createVariableStatement(
        /* modifiers */ undefined, 
        /* declarationList */ declList);
    }
    else {
        return ts.factory.createFunctionDeclaration(
        /* modifiers */ [ts.factory.createModifier(ts.SyntaxKind.DeclareKeyword)], 
        /* asteriskToken */ undefined, 
        /* name */ meta.fnName, 
        /* typeParameters */ typeParameters, 
        /* parameters */ [initParam], 
        /* type */ rawType, 
        /* body */ undefined);
    }
}
/**
 * Generate an inline type constructor for the given class and metadata.
 *
 * An inline type constructor is a specially shaped TypeScript static method, intended to be placed
 * within a directive class itself, that permits type inference of any generic type parameters of
 * the class from the types of expressions bound to inputs or outputs, and the types of elements
 * that match queries performed by the directive. It also catches any errors in the types of these
 * expressions. This method is never called at runtime, but is used in type-check blocks to
 * construct directive types.
 *
 * An inline type constructor for NgFor looks like:
 *
 * static ngTypeCtor<T>(init: Pick<NgForOf<T>, 'ngForOf'|'ngForTrackBy'|'ngForTemplate'>):
 *   NgForOf<T>;
 *
 * A typical constructor would be:
 *
 * NgForOf.ngTypeCtor(init: {
 *   ngForOf: ['foo', 'bar'],
 *   ngForTrackBy: null as any,
 *   ngForTemplate: null as any,
 * }); // Infers a type of NgForOf<string>.
 *
 * Any inputs declared on the type for which no property binding is present are assigned a value of
 * type `any`, to avoid producing any type errors for unset inputs.
 *
 * Inline type constructors are used when the type being created has bounded generic types which
 * make writing a declared type constructor (via `generateTypeCtorDeclarationFn`) difficult or
 * impossible.
 *
 * @param node the `ClassDeclaration<ts.ClassDeclaration>` for which a type constructor will be
 * generated.
 * @param meta additional metadata required to generate the type constructor.
 * @returns a `ts.MethodDeclaration` for the type constructor.
 */
function generateInlineTypeCtor(env, node, meta) {
    // Build rawType, a `ts.TypeNode` of the class with its generic parameters passed through from
    // the definition without any type bounds. For example, if the class is
    // `FooDirective<T extends Bar>`, its rawType would be `FooDirective<T>`.
    const rawTypeArgs = node.typeParameters !== undefined ? generateGenericArgs(node.typeParameters) : undefined;
    const rawType = ts.factory.createTypeReferenceNode(node.name, rawTypeArgs);
    const initParam = constructTypeCtorParameter(env, meta, rawType);
    // If this constructor is being generated into a .ts file, then it needs a fake body. The body
    // is set to a return of `null!`. If the type constructor is being generated into a .d.ts file,
    // it needs no body.
    let body = undefined;
    if (meta.body) {
        body = ts.factory.createBlock([
            ts.factory.createReturnStatement(ts.factory.createNonNullExpression(ts.factory.createNull())),
        ]);
    }
    // Create the type constructor method declaration.
    return ts.factory.createMethodDeclaration(
    /* modifiers */ [ts.factory.createModifier(ts.SyntaxKind.StaticKeyword)], 
    /* asteriskToken */ undefined, 
    /* name */ meta.fnName, 
    /* questionToken */ undefined, 
    /* typeParameters */ typeParametersWithDefaultTypes(node.typeParameters), 
    /* parameters */ [initParam], 
    /* type */ rawType, 
    /* body */ body);
}
function constructTypeCtorParameter(env, meta, rawType) {
    // initType is the type of 'init', the single argument to the type constructor method.
    // If the Directive has any inputs, its initType will be:
    //
    // Pick<rawType, 'inputA'|'inputB'>
    //
    // Pick here is used to select only those fields from which the generic type parameters of the
    // directive will be inferred.
    //
    // In the special case there are no inputs, initType is set to {}.
    let initType = null;
    const plainKeys = [];
    const coercedKeys = [];
    const signalInputKeys = [];
    for (const { classPropertyName, transform, isSignal } of meta.fields.inputs) {
        if (isSignal) {
            signalInputKeys.push(ts.factory.createLiteralTypeNode(ts.factory.createStringLiteral(classPropertyName)));
        }
        else if (!meta.coercedInputFields.has(classPropertyName)) {
            plainKeys.push(ts.factory.createLiteralTypeNode(ts.factory.createStringLiteral(classPropertyName)));
        }
        else {
            const coercionType = transform != null
                ? transform.type.node
                : tsCreateTypeQueryForCoercedInput(rawType.typeName, classPropertyName);
            coercedKeys.push(ts.factory.createPropertySignature(
            /* modifiers */ undefined, 
            /* name */ classPropertyName, 
            /* questionToken */ undefined, 
            /* type */ coercionType));
        }
    }
    if (plainKeys.length > 0) {
        // Construct a union of all the field names.
        const keyTypeUnion = ts.factory.createUnionTypeNode(plainKeys);
        // Construct the Pick<rawType, keyTypeUnion>.
        initType = ts.factory.createTypeReferenceNode('Pick', [rawType, keyTypeUnion]);
    }
    if (coercedKeys.length > 0) {
        const coercedLiteral = ts.factory.createTypeLiteralNode(coercedKeys);
        initType =
            initType !== null
                ? ts.factory.createIntersectionTypeNode([initType, coercedLiteral])
                : coercedLiteral;
    }
    if (signalInputKeys.length > 0) {
        const keyTypeUnion = ts.factory.createUnionTypeNode(signalInputKeys);
        // Construct the UnwrapDirectiveSignalInputs<rawType, keyTypeUnion>.
        const unwrapDirectiveSignalInputsExpr = env.referenceExternalType(o.R3Identifiers.UnwrapDirectiveSignalInputs.moduleName, o.R3Identifiers.UnwrapDirectiveSignalInputs.name, [
            // TODO:
            new o.ExpressionType(new o.WrappedNodeExpr(rawType)),
            new o.ExpressionType(new o.WrappedNodeExpr(keyTypeUnion)),
        ]);
        initType =
            initType !== null
                ? ts.factory.createIntersectionTypeNode([initType, unwrapDirectiveSignalInputsExpr])
                : unwrapDirectiveSignalInputsExpr;
    }
    if (initType === null) {
        // Special case - no inputs, outputs, or other fields which could influence the result type.
        initType = ts.factory.createTypeLiteralNode([]);
    }
    // Create the 'init' parameter itself.
    return ts.factory.createParameterDeclaration(
    /* modifiers */ undefined, 
    /* dotDotDotToken */ undefined, 
    /* name */ 'init', 
    /* questionToken */ undefined, 
    /* type */ initType, 
    /* initializer */ undefined);
}
function generateGenericArgs(params) {
    return params.map((param) => ts.factory.createTypeReferenceNode(param.name, undefined));
}
function requiresInlineTypeCtor(node, host, env) {
    // The class requires an inline type constructor if it has generic type bounds that can not be
    // emitted into the provided type-check environment.
    return !checkIfGenericTypeBoundsCanBeEmitted(node, host, env);
}
/**
 * Add a default `= any` to type parameters that don't have a default value already.
 *
 * TypeScript uses the default type of a type parameter whenever inference of that parameter
 * fails. This can happen when inferring a complex type from 'any'. For example, if `NgFor`'s
 * inference is done with the TCB code:
 *
 * ```ts
 * class NgFor<T> {
 *   ngForOf: T[];
 * }
 *
 * declare function ctor<T>(o: Pick<NgFor<T>, 'ngForOf'|'ngForTrackBy'|'ngForTemplate'>):
 * NgFor<T>;
 * ```
 *
 * An invocation looks like:
 *
 * ```ts
 * var _t1 = ctor({ngForOf: [1, 2], ngForTrackBy: null as any, ngForTemplate: null as any});
 * ```
 *
 * This correctly infers the type `NgFor<number>` for `_t1`, since `T` is inferred from the
 * assignment of type `number[]` to `ngForOf`'s type `T[]`. However, if `any` is passed instead:
 *
 * ```ts
 * var _t2 = ctor({ngForOf: [1, 2] as any, ngForTrackBy: null as any, ngForTemplate: null as
 * any});
 * ```
 *
 * then inference for `T` fails (it cannot be inferred from `T[] = any`). In this case, `T`
 * takes the type `{}`, and so `_t2` is inferred as `NgFor<{}>`. This is obviously wrong.
 *
 * Adding a default type to the generic declaration in the constructor solves this problem, as
 * the default type will be used in the event that inference fails.
 *
 * ```ts
 * declare function ctor<T = any>(o: Pick<NgFor<T>, 'ngForOf'>): NgFor<T>;
 *
 * var _t3 = ctor({ngForOf: [1, 2] as any});
 * ```
 *
 * This correctly infers `T` as `any`, and therefore `_t3` as `NgFor<any>`.
 */
function typeParametersWithDefaultTypes(params) {
    if (params === undefined) {
        return undefined;
    }
    return params.map((param) => {
        if (param.default === undefined) {
            return ts.factory.updateTypeParameterDeclaration(param, param.modifiers, param.name, param.constraint, ts.factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword));
        }
        else {
            return param;
        }
    });
}

/**
 * A context which hosts one or more Type Check Blocks (TCBs).
 *
 * An `Environment` supports the generation of TCBs by tracking necessary imports, declarations of
 * type constructors, and other statements beyond the type-checking code within the TCB itself.
 * Through method calls on `Environment`, the TCB generator can request `ts.Expression`s which
 * reference declarations in the `Environment` for these artifacts`.
 *
 * `Environment` can be used in a standalone fashion, or can be extended to support more specialized
 * usage.
 */
class Environment extends ReferenceEmitEnvironment {
    config;
    nextIds = {
        pipeInst: 1,
        typeCtor: 1,
    };
    typeCtors = new Map();
    typeCtorStatements = [];
    pipeInsts = new Map();
    pipeInstStatements = [];
    constructor(config, importManager, refEmitter, reflector, contextFile) {
        super(importManager, refEmitter, reflector, contextFile);
        this.config = config;
    }
    /**
     * Get an expression referring to a type constructor for the given directive.
     *
     * Depending on the shape of the directive itself, this could be either a reference to a declared
     * type constructor, or to an inline type constructor.
     */
    typeCtorFor(dir) {
        const dirRef = dir.ref;
        const node = dirRef.node;
        if (this.typeCtors.has(node)) {
            return this.typeCtors.get(node);
        }
        if (requiresInlineTypeCtor(node, this.reflector, this)) {
            // The constructor has already been created inline, we just need to construct a reference to
            // it.
            const ref = this.reference(dirRef);
            const typeCtorExpr = ts.factory.createPropertyAccessExpression(ref, 'ngTypeCtor');
            this.typeCtors.set(node, typeCtorExpr);
            return typeCtorExpr;
        }
        else {
            const fnName = `_ctor${this.nextIds.typeCtor++}`;
            const nodeTypeRef = this.referenceType(dirRef);
            if (!ts.isTypeReferenceNode(nodeTypeRef)) {
                throw new Error(`Expected TypeReferenceNode from reference to ${dirRef.debugName}`);
            }
            const meta = {
                fnName,
                body: true,
                fields: {
                    inputs: dir.inputs,
                    // TODO: support queries
                    queries: dir.queries,
                },
                coercedInputFields: dir.coercedInputFields,
            };
            const typeParams = this.emitTypeParameters(node);
            const typeCtor = generateTypeCtorDeclarationFn(this, meta, nodeTypeRef.typeName, typeParams);
            this.typeCtorStatements.push(typeCtor);
            const fnId = ts.factory.createIdentifier(fnName);
            this.typeCtors.set(node, fnId);
            return fnId;
        }
    }
    /*
     * Get an expression referring to an instance of the given pipe.
     */
    pipeInst(ref) {
        if (this.pipeInsts.has(ref.node)) {
            return this.pipeInsts.get(ref.node);
        }
        const pipeType = this.referenceType(ref);
        const pipeInstId = ts.factory.createIdentifier(`_pipe${this.nextIds.pipeInst++}`);
        this.pipeInstStatements.push(tsDeclareVariable(pipeInstId, pipeType));
        this.pipeInsts.set(ref.node, pipeInstId);
        return pipeInstId;
    }
    /**
     * Generate a `ts.Expression` that references the given node.
     *
     * This may involve importing the node into the file if it's not declared there already.
     */
    reference(ref) {
        // Disable aliasing for imports generated in a template type-checking context, as there is no
        // guarantee that any alias re-exports exist in the .d.ts files. It's safe to use direct imports
        // in these cases as there is no strict dependency checking during the template type-checking
        // pass.
        const ngExpr = this.refEmitter.emit(ref, this.contextFile, ImportFlags.NoAliasing);
        assertSuccessfulReferenceEmit(ngExpr, this.contextFile, 'class');
        // Use `translateExpression` to convert the `Expression` into a `ts.Expression`.
        return translateExpression(this.contextFile, ngExpr.expression, this.importManager);
    }
    emitTypeParameters(declaration) {
        const emitter = new TypeParameterEmitter(declaration.typeParameters, this.reflector);
        return emitter.emit((ref) => this.referenceType(ref));
    }
    getPreludeStatements() {
        return [...this.pipeInstStatements, ...this.typeCtorStatements];
    }
}

class OutOfBandDiagnosticRecorderImpl {
    resolver;
    _diagnostics = [];
    /**
     * Tracks which `BindingPipe` nodes have already been recorded as invalid, so only one diagnostic
     * is ever produced per node.
     */
    recordedPipes = new Set();
    /** Common pipes that can be suggested to users. */
    pipeSuggestions = new Map([
        ['async', 'AsyncPipe'],
        ['uppercase', 'UpperCasePipe'],
        ['lowercase', 'LowerCasePipe'],
        ['json', 'JsonPipe'],
        ['slice', 'SlicePipe'],
        ['number', 'DecimalPipe'],
        ['percent', 'PercentPipe'],
        ['titlecase', 'TitleCasePipe'],
        ['currency', 'CurrencyPipe'],
        ['date', 'DatePipe'],
        ['i18nPlural', 'I18nPluralPipe'],
        ['i18nSelect', 'I18nSelectPipe'],
        ['keyvalue', 'KeyValuePipe'],
    ]);
    constructor(resolver) {
        this.resolver = resolver;
    }
    get diagnostics() {
        return this._diagnostics;
    }
    missingReferenceTarget(id, ref) {
        const mapping = this.resolver.getTemplateSourceMapping(id);
        const value = ref.value.trim();
        const errorMsg = `No directive found with exportAs '${value}'.`;
        this._diagnostics.push(makeTemplateDiagnostic(id, mapping, ref.valueSpan || ref.sourceSpan, ts.DiagnosticCategory.Error, ngErrorCode(exports.ErrorCode.MISSING_REFERENCE_TARGET), errorMsg));
    }
    missingPipe(id, ast, isStandalone) {
        if (this.recordedPipes.has(ast)) {
            return;
        }
        const sourceSpan = this.resolver.toTemplateParseSourceSpan(id, ast.nameSpan);
        if (sourceSpan === null) {
            throw new Error(`Assertion failure: no SourceLocation found for usage of pipe '${ast.name}'.`);
        }
        const mapping = this.resolver.getTemplateSourceMapping(id);
        let errorMsg = `No pipe found with name '${ast.name}'.`;
        if (this.pipeSuggestions.has(ast.name)) {
            const suggestedClassName = this.pipeSuggestions.get(ast.name);
            const suggestedImport = '@angular/common';
            if (isStandalone) {
                errorMsg +=
                    `\nTo fix this, import the "${suggestedClassName}" class from "${suggestedImport}"` +
                        ` and add it to the "imports" array of the component.`;
            }
            else {
                errorMsg +=
                    `\nTo fix this, import the "${suggestedClassName}" class from "${suggestedImport}"` +
                        ` and add it to the "imports" array of the module declaring the component.`;
            }
        }
        this._diagnostics.push(makeTemplateDiagnostic(id, mapping, sourceSpan, ts.DiagnosticCategory.Error, ngErrorCode(exports.ErrorCode.MISSING_PIPE), errorMsg));
        this.recordedPipes.add(ast);
    }
    deferredPipeUsedEagerly(id, ast) {
        if (this.recordedPipes.has(ast)) {
            return;
        }
        const mapping = this.resolver.getTemplateSourceMapping(id);
        const errorMsg = `Pipe '${ast.name}' was imported  via \`@Component.deferredImports\`, ` +
            `but was used outside of a \`@defer\` block in a template. To fix this, either ` +
            `use the '${ast.name}' pipe inside of a \`@defer\` block or import this dependency ` +
            `using the \`@Component.imports\` field.`;
        const sourceSpan = this.resolver.toTemplateParseSourceSpan(id, ast.nameSpan);
        if (sourceSpan === null) {
            throw new Error(`Assertion failure: no SourceLocation found for usage of pipe '${ast.name}'.`);
        }
        this._diagnostics.push(makeTemplateDiagnostic(id, mapping, sourceSpan, ts.DiagnosticCategory.Error, ngErrorCode(exports.ErrorCode.DEFERRED_PIPE_USED_EAGERLY), errorMsg));
        this.recordedPipes.add(ast);
    }
    deferredComponentUsedEagerly(id, element) {
        const mapping = this.resolver.getTemplateSourceMapping(id);
        const errorMsg = `Element '${element.name}' contains a component or a directive that ` +
            `was imported  via \`@Component.deferredImports\`, but the element itself is located ` +
            `outside of a \`@defer\` block in a template. To fix this, either ` +
            `use the '${element.name}' element inside of a \`@defer\` block or ` +
            `import referenced component/directive dependency using the \`@Component.imports\` field.`;
        const { start, end } = element.startSourceSpan;
        const absoluteSourceSpan = new o.AbsoluteSourceSpan(start.offset, end.offset);
        const sourceSpan = this.resolver.toTemplateParseSourceSpan(id, absoluteSourceSpan);
        if (sourceSpan === null) {
            throw new Error(`Assertion failure: no SourceLocation found for usage of pipe '${element.name}'.`);
        }
        this._diagnostics.push(makeTemplateDiagnostic(id, mapping, sourceSpan, ts.DiagnosticCategory.Error, ngErrorCode(exports.ErrorCode.DEFERRED_DIRECTIVE_USED_EAGERLY), errorMsg));
    }
    duplicateTemplateVar(id, variable, firstDecl) {
        const mapping = this.resolver.getTemplateSourceMapping(id);
        const errorMsg = `Cannot redeclare variable '${variable.name}' as it was previously declared elsewhere for the same template.`;
        // The allocation of the error here is pretty useless for variables declared in microsyntax,
        // since the sourceSpan refers to the entire microsyntax property, not a span for the specific
        // variable in question.
        //
        // TODO(alxhub): allocate to a tighter span once one is available.
        this._diagnostics.push(makeTemplateDiagnostic(id, mapping, variable.sourceSpan, ts.DiagnosticCategory.Error, ngErrorCode(exports.ErrorCode.DUPLICATE_VARIABLE_DECLARATION), errorMsg, [
            {
                text: `The variable '${firstDecl.name}' was first declared here.`,
                start: firstDecl.sourceSpan.start.offset,
                end: firstDecl.sourceSpan.end.offset,
                sourceFile: mapping.node.getSourceFile(),
            },
        ]));
    }
    requiresInlineTcb(id, node) {
        this._diagnostics.push(makeInlineDiagnostic(id, exports.ErrorCode.INLINE_TCB_REQUIRED, node.name, `This component requires inline template type-checking, which is not supported by the current environment.`));
    }
    requiresInlineTypeConstructors(id, node, directives) {
        let message;
        if (directives.length > 1) {
            message = `This component uses directives which require inline type constructors, which are not supported by the current environment.`;
        }
        else {
            message = `This component uses a directive which requires an inline type constructor, which is not supported by the current environment.`;
        }
        this._diagnostics.push(makeInlineDiagnostic(id, exports.ErrorCode.INLINE_TYPE_CTOR_REQUIRED, node.name, message, directives.map((dir) => makeRelatedInformation(dir.name, `Requires an inline type constructor.`))));
    }
    suboptimalTypeInference(id, variables) {
        const mapping = this.resolver.getTemplateSourceMapping(id);
        // Select one of the template variables that's most suitable for reporting the diagnostic. Any
        // variable will do, but prefer one bound to the context's $implicit if present.
        let diagnosticVar = null;
        for (const variable of variables) {
            if (diagnosticVar === null || variable.value === '' || variable.value === '$implicit') {
                diagnosticVar = variable;
            }
        }
        if (diagnosticVar === null) {
            // There is no variable on which to report the diagnostic.
            return;
        }
        let varIdentification = `'${diagnosticVar.name}'`;
        if (variables.length === 2) {
            varIdentification += ` (and 1 other)`;
        }
        else if (variables.length > 2) {
            varIdentification += ` (and ${variables.length - 1} others)`;
        }
        const message = `This structural directive supports advanced type inference, but the current compiler configuration prevents its usage. The variable ${varIdentification} will have type 'any' as a result.\n\nConsider enabling the 'strictTemplates' option in your tsconfig.json for better type inference within this template.`;
        this._diagnostics.push(makeTemplateDiagnostic(id, mapping, diagnosticVar.keySpan, ts.DiagnosticCategory.Suggestion, ngErrorCode(exports.ErrorCode.SUGGEST_SUBOPTIMAL_TYPE_INFERENCE), message));
    }
    splitTwoWayBinding(id, input, output, inputConsumer, outputConsumer) {
        const mapping = this.resolver.getTemplateSourceMapping(id);
        const errorMsg = `The property and event halves of the two-way binding '${input.name}' are not bound to the same target.
            Find more at https://angular.dev/guide/templates/two-way-binding#how-two-way-binding-works`;
        const relatedMessages = [];
        relatedMessages.push({
            text: `The property half of the binding is to the '${inputConsumer.name.text}' component.`,
            start: inputConsumer.name.getStart(),
            end: inputConsumer.name.getEnd(),
            sourceFile: inputConsumer.name.getSourceFile(),
        });
        if (outputConsumer instanceof o.TmplAstElement) {
            let message = `The event half of the binding is to a native event called '${input.name}' on the <${outputConsumer.name}> DOM element.`;
            if (!mapping.node.getSourceFile().isDeclarationFile) {
                message += `\n \n Are you missing an output declaration called '${output.name}'?`;
            }
            relatedMessages.push({
                text: message,
                start: outputConsumer.sourceSpan.start.offset + 1,
                end: outputConsumer.sourceSpan.start.offset + outputConsumer.name.length + 1,
                sourceFile: mapping.node.getSourceFile(),
            });
        }
        else {
            relatedMessages.push({
                text: `The event half of the binding is to the '${outputConsumer.name.text}' component.`,
                start: outputConsumer.name.getStart(),
                end: outputConsumer.name.getEnd(),
                sourceFile: outputConsumer.name.getSourceFile(),
            });
        }
        this._diagnostics.push(makeTemplateDiagnostic(id, mapping, input.keySpan, ts.DiagnosticCategory.Error, ngErrorCode(exports.ErrorCode.SPLIT_TWO_WAY_BINDING), errorMsg, relatedMessages));
    }
    missingRequiredInputs(id, element, directiveName, isComponent, inputAliases) {
        const message = `Required input${inputAliases.length === 1 ? '' : 's'} ${inputAliases
            .map((n) => `'${n}'`)
            .join(', ')} from ${isComponent ? 'component' : 'directive'} ${directiveName} must be specified.`;
        this._diagnostics.push(makeTemplateDiagnostic(id, this.resolver.getTemplateSourceMapping(id), element.startSourceSpan, ts.DiagnosticCategory.Error, ngErrorCode(exports.ErrorCode.MISSING_REQUIRED_INPUTS), message));
    }
    illegalForLoopTrackAccess(id, block, access) {
        const sourceSpan = this.resolver.toTemplateParseSourceSpan(id, access.sourceSpan);
        if (sourceSpan === null) {
            throw new Error(`Assertion failure: no SourceLocation found for property read.`);
        }
        const messageVars = [block.item, ...block.contextVariables.filter((v) => v.value === '$index')]
            .map((v) => `'${v.name}'`)
            .join(', ');
        const message = `Cannot access '${access.name}' inside of a track expression. ` +
            `Only ${messageVars} and properties on the containing component are available to this expression.`;
        this._diagnostics.push(makeTemplateDiagnostic(id, this.resolver.getTemplateSourceMapping(id), sourceSpan, ts.DiagnosticCategory.Error, ngErrorCode(exports.ErrorCode.ILLEGAL_FOR_LOOP_TRACK_ACCESS), message));
    }
    inaccessibleDeferredTriggerElement(id, trigger) {
        let message;
        if (trigger.reference === null) {
            message =
                `Trigger cannot find reference. Make sure that the @defer block has a ` +
                    `@placeholder with at least one root element node.`;
        }
        else {
            message =
                `Trigger cannot find reference "${trigger.reference}".\nCheck that an element with #${trigger.reference} exists in the same template and it's accessible from the ` +
                    `@defer block.\nDeferred blocks can only access triggers in same view, a parent ` +
                    `embedded view or the root view of the @placeholder block.`;
        }
        this._diagnostics.push(makeTemplateDiagnostic(id, this.resolver.getTemplateSourceMapping(id), trigger.sourceSpan, ts.DiagnosticCategory.Error, ngErrorCode(exports.ErrorCode.INACCESSIBLE_DEFERRED_TRIGGER_ELEMENT), message));
    }
    controlFlowPreventingContentProjection(id, category, projectionNode, componentName, slotSelector, controlFlowNode, preservesWhitespaces) {
        const blockName = controlFlowNode.nameSpan.toString().trim();
        const lines = [
            `Node matches the "${slotSelector}" slot of the "${componentName}" component, but will not be projected into the specific slot because the surrounding ${blockName} has more than one node at its root. To project the node in the right slot, you can:\n`,
            `1. Wrap the content of the ${blockName} block in an <ng-container/> that matches the "${slotSelector}" selector.`,
            `2. Split the content of the ${blockName} block across multiple ${blockName} blocks such that each one only has a single projectable node at its root.`,
            `3. Remove all content from the ${blockName} block, except for the node being projected.`,
        ];
        if (preservesWhitespaces) {
            lines.push('Note: the host component has `preserveWhitespaces: true` which may ' +
                'cause whitespace to affect content projection.');
        }
        lines.push('', 'This check can be disabled using the `extendedDiagnostics.checks.' +
            'controlFlowPreventingContentProjection = "suppress" compiler option.`');
        this._diagnostics.push(makeTemplateDiagnostic(id, this.resolver.getTemplateSourceMapping(id), projectionNode.startSourceSpan, category, ngErrorCode(exports.ErrorCode.CONTROL_FLOW_PREVENTING_CONTENT_PROJECTION), lines.join('\n')));
    }
    illegalWriteToLetDeclaration(id, node, target) {
        const sourceSpan = this.resolver.toTemplateParseSourceSpan(id, node.sourceSpan);
        if (sourceSpan === null) {
            throw new Error(`Assertion failure: no SourceLocation found for property write.`);
        }
        this._diagnostics.push(makeTemplateDiagnostic(id, this.resolver.getTemplateSourceMapping(id), sourceSpan, ts.DiagnosticCategory.Error, ngErrorCode(exports.ErrorCode.ILLEGAL_LET_WRITE), `Cannot assign to @let declaration '${target.name}'.`));
    }
    letUsedBeforeDefinition(id, node, target) {
        const sourceSpan = this.resolver.toTemplateParseSourceSpan(id, node.sourceSpan);
        if (sourceSpan === null) {
            throw new Error(`Assertion failure: no SourceLocation found for property read.`);
        }
        this._diagnostics.push(makeTemplateDiagnostic(id, this.resolver.getTemplateSourceMapping(id), sourceSpan, ts.DiagnosticCategory.Error, ngErrorCode(exports.ErrorCode.LET_USED_BEFORE_DEFINITION), `Cannot read @let declaration '${target.name}' before it has been defined.`));
    }
    conflictingDeclaration(id, decl) {
        const mapping = this.resolver.getTemplateSourceMapping(id);
        const errorMsg = `Cannot declare @let called '${decl.name}' as there is another symbol in the template with the same name.`;
        this._diagnostics.push(makeTemplateDiagnostic(id, mapping, decl.sourceSpan, ts.DiagnosticCategory.Error, ngErrorCode(exports.ErrorCode.CONFLICTING_LET_DECLARATION), errorMsg));
    }
    missingNamedTemplateDependency(id, node) {
        this._diagnostics.push(makeTemplateDiagnostic(id, this.resolver.getTemplateSourceMapping(id), node.startSourceSpan, ts.DiagnosticCategory.Error, ngErrorCode(exports.ErrorCode.MISSING_NAMED_TEMPLATE_DEPENDENCY), 
        // Wording is meant to mimic the wording TS uses in their diagnostic for missing symbols.
        `Cannot find name "${node instanceof o.TmplAstDirective ? node.name : node.componentName}". ` +
            `Selectorless references are only supported to classes or non-type import statements.`));
    }
    incorrectTemplateDependencyType(id, node) {
        this._diagnostics.push(makeTemplateDiagnostic(id, this.resolver.getTemplateSourceMapping(id), node.startSourceSpan, ts.DiagnosticCategory.Error, ngErrorCode(exports.ErrorCode.INCORRECT_NAMED_TEMPLATE_DEPENDENCY_TYPE), `Incorrect reference type. Type must be a standalone ${node instanceof o.TmplAstComponent ? '@Component' : '@Directive'}.`));
    }
    unclaimedDirectiveBinding(id, directive, node) {
        const errorMsg = `Directive ${directive.name} does not have an ` +
            `${node instanceof o.TmplAstBoundEvent ? 'output' : 'input'} named "${node.name}". ` +
            `Bindings to directives must target existing inputs or outputs.`;
        this._diagnostics.push(makeTemplateDiagnostic(id, this.resolver.getTemplateSourceMapping(id), node.keySpan || node.sourceSpan, ts.DiagnosticCategory.Error, ngErrorCode(exports.ErrorCode.UNCLAIMED_DIRECTIVE_BINDING), errorMsg));
    }
    deferImplicitTriggerMissingPlaceholder(id, trigger) {
        this._diagnostics.push(makeTemplateDiagnostic(id, this.resolver.getTemplateSourceMapping(id), trigger.sourceSpan, ts.DiagnosticCategory.Error, ngErrorCode(exports.ErrorCode.DEFER_IMPLICIT_TRIGGER_MISSING_PLACEHOLDER), 'Trigger with no target can only be placed on an @defer that has a @placeholder block'));
    }
    deferImplicitTriggerInvalidPlaceholder(id, trigger) {
        this._diagnostics.push(makeTemplateDiagnostic(id, this.resolver.getTemplateSourceMapping(id), trigger.sourceSpan, ts.DiagnosticCategory.Error, ngErrorCode(exports.ErrorCode.DEFER_IMPLICIT_TRIGGER_INVALID_PLACEHOLDER), 'Trigger with no target can only be placed on an @defer that has a ' +
            '@placeholder block with exactly one root element node'));
    }
}
function makeInlineDiagnostic(id, code, node, messageText, relatedInformation) {
    return {
        ...makeDiagnostic(code, node, messageText, relatedInformation),
        sourceFile: node.getSourceFile(),
        typeCheckId: id,
    };
}

/**
 * A `ShimGenerator` which adds type-checking files to the `ts.Program`.
 *
 * This is a requirement for performant template type-checking, as TypeScript will only reuse
 * information in the main program when creating the type-checking program if the set of files in
 * each are exactly the same. Thus, the main program also needs the synthetic type-checking files.
 */
class TypeCheckShimGenerator {
    extensionPrefix = 'ngtypecheck';
    shouldEmit = false;
    generateShimForFile(sf, genFilePath, priorShimSf) {
        if (priorShimSf !== null) {
            // If this shim existed in the previous program, reuse it now. It might not be correct, but
            // reusing it in the main program allows the shape of its imports to potentially remain the
            // same and TS can then use the fastest path for incremental program creation. Later during
            // the type-checking phase it's going to either be reused, or replaced anyways. Thus there's
            // no harm in reuse here even if it's out of date.
            return priorShimSf;
        }
        return ts.createSourceFile(genFilePath, 'export const USED_FOR_NG_TYPE_CHECKING = true;', ts.ScriptTarget.Latest, true, ts.ScriptKind.TS);
    }
    static shimFor(fileName) {
        return absoluteFrom(fileName.replace(/\.tsx?$/, '.ngtypecheck.ts'));
    }
}

/**
 * Wraps the node in parenthesis such that inserted span comments become attached to the proper
 * node. This is an alias for `ts.factory.createParenthesizedExpression` with the benefit that it
 * signifies that the inserted parenthesis are for diagnostic purposes, not for correctness of the
 * rendered TCB code.
 *
 * Note that it is important that nodes and its attached comment are not wrapped into parenthesis
 * by default, as it prevents correct translation of e.g. diagnostics produced for incorrect method
 * arguments. Such diagnostics would then be produced for the parenthesised node whereas the
 * positional comment would be located within that node, resulting in a mismatch.
 */
function wrapForDiagnostics(expr) {
    return ts.factory.createParenthesizedExpression(expr);
}
/**
 * Wraps the node in parenthesis such that inserted span comments become attached to the proper
 * node. This is an alias for `ts.factory.createParenthesizedExpression` with the benefit that it
 * signifies that the inserted parenthesis are for use by the type checker, not for correctness of
 * the rendered TCB code.
 */
function wrapForTypeChecker(expr) {
    return ts.factory.createParenthesizedExpression(expr);
}
/**
 * Adds a synthetic comment to the expression that represents the parse span of the provided node.
 * This comment can later be retrieved as trivia of a node to recover original source locations.
 */
function addParseSpanInfo(node, span) {
    let commentText;
    if (span instanceof o.AbsoluteSourceSpan) {
        commentText = `${span.start},${span.end}`;
    }
    else {
        commentText = `${span.start.offset},${span.end.offset}`;
    }
    ts.addSyntheticTrailingComment(node, ts.SyntaxKind.MultiLineCommentTrivia, commentText, 
    /* hasTrailingNewLine */ false);
}
/**
 * Adds a synthetic comment to the function declaration that contains the type checking ID
 * of the class declaration.
 */
function addTypeCheckId(tcb, id) {
    ts.addSyntheticLeadingComment(tcb, ts.SyntaxKind.MultiLineCommentTrivia, id, true);
}
/**
 * Determines if the diagnostic should be reported. Some diagnostics are produced because of the
 * way TCBs are generated; those diagnostics should not be reported as type check errors of the
 * template.
 */
function shouldReportDiagnostic(diagnostic) {
    const { code } = diagnostic;
    if (code === 6133 /* $var is declared but its value is never read. */) {
        return false;
    }
    else if (code === 6199 /* All variables are unused. */) {
        return false;
    }
    else if (code === 2695 /* Left side of comma operator is unused and has no side effects. */) {
        return false;
    }
    else if (code === 7006 /* Parameter '$event' implicitly has an 'any' type. */) {
        return false;
    }
    return true;
}
/**
 * Attempts to translate a TypeScript diagnostic produced during template type-checking to their
 * location of origin, based on the comments that are emitted in the TCB code.
 *
 * If the diagnostic could not be translated, `null` is returned to indicate that the diagnostic
 * should not be reported at all. This prevents diagnostics from non-TCB code in a user's source
 * file from being reported as type-check errors.
 */
function translateDiagnostic(diagnostic, resolver) {
    if (diagnostic.file === undefined || diagnostic.start === undefined) {
        return null;
    }
    const fullMapping = getSourceMapping(diagnostic.file, diagnostic.start, resolver, 
    /*isDiagnosticsRequest*/ true);
    if (fullMapping === null) {
        return null;
    }
    const { sourceLocation, sourceMapping: templateSourceMapping, span } = fullMapping;
    return makeTemplateDiagnostic(sourceLocation.id, templateSourceMapping, span, diagnostic.category, diagnostic.code, diagnostic.messageText, undefined, diagnostic.reportsDeprecated !== undefined
        ? {
            reportsDeprecated: diagnostic.reportsDeprecated,
            relatedMessages: diagnostic.relatedInformation,
        }
        : undefined);
}

/**
 * Gets an expression that is cast to any. Currently represented as `0 as any`.
 *
 * Historically this expression was using `null as any`, but a newly-added check in TypeScript 5.6
 * (https://devblogs.microsoft.com/typescript/announcing-typescript-5-6-beta/#disallowed-nullish-and-truthy-checks)
 * started flagging it as always being nullish. Other options that were considered:
 * - `NaN as any` or `Infinity as any` - not used, because they don't work if the `noLib` compiler
 *   option is enabled. Also they require more characters.
 * - Some flavor of function call, like `isNan(0) as any` - requires even more characters than the
 *   NaN option and has the same issue with `noLib`.
 */
function getAnyExpression() {
    return ts.factory.createAsExpression(ts.factory.createNumericLiteral('0'), ts.factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword));
}
/**
 * Convert an `AST` to TypeScript code directly, without going through an intermediate `Expression`
 * AST.
 */
function astToTypescript(ast, maybeResolve, config) {
    const translator = new AstTranslator(maybeResolve, config);
    return translator.translate(ast);
}
class AstTranslator {
    maybeResolve;
    config;
    UNDEFINED = ts.factory.createIdentifier('undefined');
    UNARY_OPS = new Map([
        ['+', ts.SyntaxKind.PlusToken],
        ['-', ts.SyntaxKind.MinusToken],
    ]);
    BINARY_OPS = new Map([
        ['+', ts.SyntaxKind.PlusToken],
        ['-', ts.SyntaxKind.MinusToken],
        ['<', ts.SyntaxKind.LessThanToken],
        ['>', ts.SyntaxKind.GreaterThanToken],
        ['<=', ts.SyntaxKind.LessThanEqualsToken],
        ['>=', ts.SyntaxKind.GreaterThanEqualsToken],
        ['=', ts.SyntaxKind.EqualsToken],
        ['==', ts.SyntaxKind.EqualsEqualsToken],
        ['===', ts.SyntaxKind.EqualsEqualsEqualsToken],
        ['*', ts.SyntaxKind.AsteriskToken],
        ['**', ts.SyntaxKind.AsteriskAsteriskToken],
        ['/', ts.SyntaxKind.SlashToken],
        ['%', ts.SyntaxKind.PercentToken],
        ['!=', ts.SyntaxKind.ExclamationEqualsToken],
        ['!==', ts.SyntaxKind.ExclamationEqualsEqualsToken],
        ['||', ts.SyntaxKind.BarBarToken],
        ['&&', ts.SyntaxKind.AmpersandAmpersandToken],
        ['&', ts.SyntaxKind.AmpersandToken],
        ['|', ts.SyntaxKind.BarToken],
        ['??', ts.SyntaxKind.QuestionQuestionToken],
        ['in', ts.SyntaxKind.InKeyword],
        ['=', ts.SyntaxKind.EqualsToken],
        ['+=', ts.SyntaxKind.PlusEqualsToken],
        ['-=', ts.SyntaxKind.MinusEqualsToken],
        ['*=', ts.SyntaxKind.AsteriskEqualsToken],
        ['/=', ts.SyntaxKind.SlashEqualsToken],
        ['%=', ts.SyntaxKind.PercentEqualsToken],
        ['**=', ts.SyntaxKind.AsteriskAsteriskEqualsToken],
        ['&&=', ts.SyntaxKind.AmpersandAmpersandEqualsToken],
        ['||=', ts.SyntaxKind.BarBarEqualsToken],
        ['??=', ts.SyntaxKind.QuestionQuestionEqualsToken],
    ]);
    constructor(maybeResolve, config) {
        this.maybeResolve = maybeResolve;
        this.config = config;
    }
    translate(ast) {
        // Skip over an `ASTWithSource` as its `visit` method calls directly into its ast's `visit`,
        // which would prevent any custom resolution through `maybeResolve` for that node.
        if (ast instanceof o.ASTWithSource) {
            ast = ast.ast;
        }
        // The `EmptyExpr` doesn't have a dedicated method on `AstVisitor`, so it's special cased here.
        if (ast instanceof o.EmptyExpr) {
            const res = ts.factory.createIdentifier('undefined');
            addParseSpanInfo(res, ast.sourceSpan);
            return res;
        }
        // First attempt to let any custom resolution logic provide a translation for the given node.
        const resolved = this.maybeResolve(ast);
        if (resolved !== null) {
            return resolved;
        }
        return ast.visit(this);
    }
    visitUnary(ast) {
        const expr = this.translate(ast.expr);
        const op = this.UNARY_OPS.get(ast.operator);
        if (op === undefined) {
            throw new Error(`Unsupported Unary.operator: ${ast.operator}`);
        }
        const node = wrapForDiagnostics(ts.factory.createPrefixUnaryExpression(op, expr));
        addParseSpanInfo(node, ast.sourceSpan);
        return node;
    }
    visitBinary(ast) {
        const lhs = wrapForDiagnostics(this.translate(ast.left));
        const rhs = wrapForDiagnostics(this.translate(ast.right));
        const op = this.BINARY_OPS.get(ast.operation);
        if (op === undefined) {
            throw new Error(`Unsupported Binary.operation: ${ast.operation}`);
        }
        const node = ts.factory.createBinaryExpression(lhs, op, rhs);
        addParseSpanInfo(node, ast.sourceSpan);
        return node;
    }
    visitChain(ast) {
        const elements = ast.expressions.map((expr) => this.translate(expr));
        const node = wrapForDiagnostics(ts.factory.createCommaListExpression(elements));
        addParseSpanInfo(node, ast.sourceSpan);
        return node;
    }
    visitConditional(ast) {
        const condExpr = this.translate(ast.condition);
        const trueExpr = this.translate(ast.trueExp);
        // Wrap `falseExpr` in parens so that the trailing parse span info is not attributed to the
        // whole conditional.
        // In the following example, the last source span comment (5,6) could be seen as the
        // trailing comment for _either_ the whole conditional expression _or_ just the `falseExpr` that
        // is immediately before it:
        // `conditional /*1,2*/ ? trueExpr /*3,4*/ : falseExpr /*5,6*/`
        // This should be instead be `conditional /*1,2*/ ? trueExpr /*3,4*/ : (falseExpr /*5,6*/)`
        const falseExpr = wrapForTypeChecker(this.translate(ast.falseExp));
        const node = ts.factory.createParenthesizedExpression(ts.factory.createConditionalExpression(condExpr, undefined, trueExpr, undefined, falseExpr));
        addParseSpanInfo(node, ast.sourceSpan);
        return node;
    }
    visitImplicitReceiver(ast) {
        throw new Error('Method not implemented.');
    }
    visitThisReceiver(ast) {
        throw new Error('Method not implemented.');
    }
    visitRegularExpressionLiteral(ast, context) {
        return wrapForTypeChecker(ts.factory.createRegularExpressionLiteral(`/${ast.body}/${ast.flags ?? ''}`));
    }
    visitInterpolation(ast) {
        // Build up a chain of binary + operations to simulate the string concatenation of the
        // interpolation's expressions. The chain is started using an actual string literal to ensure
        // the type is inferred as 'string'.
        return ast.expressions.reduce((lhs, ast) => ts.factory.createBinaryExpression(lhs, ts.SyntaxKind.PlusToken, wrapForTypeChecker(this.translate(ast))), ts.factory.createStringLiteral(''));
    }
    visitKeyedRead(ast) {
        const receiver = wrapForDiagnostics(this.translate(ast.receiver));
        const key = this.translate(ast.key);
        const node = ts.factory.createElementAccessExpression(receiver, key);
        addParseSpanInfo(node, ast.sourceSpan);
        return node;
    }
    visitLiteralArray(ast) {
        const elements = ast.expressions.map((expr) => this.translate(expr));
        const literal = ts.factory.createArrayLiteralExpression(elements);
        // If strictLiteralTypes is disabled, array literals are cast to `any`.
        const node = this.config.strictLiteralTypes ? literal : tsCastToAny(literal);
        addParseSpanInfo(node, ast.sourceSpan);
        return node;
    }
    visitLiteralMap(ast) {
        const properties = ast.keys.map(({ key }, idx) => {
            const value = this.translate(ast.values[idx]);
            return ts.factory.createPropertyAssignment(ts.factory.createStringLiteral(key), value);
        });
        const literal = ts.factory.createObjectLiteralExpression(properties, true);
        // If strictLiteralTypes is disabled, object literals are cast to `any`.
        const node = this.config.strictLiteralTypes ? literal : tsCastToAny(literal);
        addParseSpanInfo(node, ast.sourceSpan);
        return node;
    }
    visitLiteralPrimitive(ast) {
        let node;
        if (ast.value === undefined) {
            node = ts.factory.createIdentifier('undefined');
        }
        else if (ast.value === null) {
            node = ts.factory.createNull();
        }
        else if (typeof ast.value === 'string') {
            node = ts.factory.createStringLiteral(ast.value);
        }
        else if (typeof ast.value === 'number') {
            node = tsNumericExpression(ast.value);
        }
        else if (typeof ast.value === 'boolean') {
            node = ast.value ? ts.factory.createTrue() : ts.factory.createFalse();
        }
        else {
            throw Error(`Unsupported AST value of type ${typeof ast.value}`);
        }
        addParseSpanInfo(node, ast.sourceSpan);
        return node;
    }
    visitNonNullAssert(ast) {
        const expr = wrapForDiagnostics(this.translate(ast.expression));
        const node = ts.factory.createNonNullExpression(expr);
        addParseSpanInfo(node, ast.sourceSpan);
        return node;
    }
    visitPipe(ast) {
        throw new Error('Method not implemented.');
    }
    visitPrefixNot(ast) {
        const expression = wrapForDiagnostics(this.translate(ast.expression));
        const node = ts.factory.createLogicalNot(expression);
        addParseSpanInfo(node, ast.sourceSpan);
        return node;
    }
    visitTypeofExpression(ast) {
        const expression = wrapForDiagnostics(this.translate(ast.expression));
        const node = ts.factory.createTypeOfExpression(expression);
        addParseSpanInfo(node, ast.sourceSpan);
        return node;
    }
    visitVoidExpression(ast) {
        const expression = wrapForDiagnostics(this.translate(ast.expression));
        const node = ts.factory.createVoidExpression(expression);
        addParseSpanInfo(node, ast.sourceSpan);
        return node;
    }
    visitPropertyRead(ast) {
        // This is a normal property read - convert the receiver to an expression and emit the correct
        // TypeScript expression to read the property.
        const receiver = wrapForDiagnostics(this.translate(ast.receiver));
        const name = ts.factory.createPropertyAccessExpression(receiver, ast.name);
        addParseSpanInfo(name, ast.nameSpan);
        const node = wrapForDiagnostics(name);
        addParseSpanInfo(node, ast.sourceSpan);
        return node;
    }
    visitSafePropertyRead(ast) {
        let node;
        const receiver = wrapForDiagnostics(this.translate(ast.receiver));
        // The form of safe property reads depends on whether strictness is in use.
        if (this.config.strictSafeNavigationTypes) {
            // Basically, the return here is either the type of the complete expression with a null-safe
            // property read, or `undefined`. So a ternary is used to create an "or" type:
            // "a?.b" becomes (0 as any ? a!.b : undefined)
            // The type of this expression is (typeof a!.b) | undefined, which is exactly as desired.
            const expr = ts.factory.createPropertyAccessExpression(ts.factory.createNonNullExpression(receiver), ast.name);
            addParseSpanInfo(expr, ast.nameSpan);
            node = ts.factory.createParenthesizedExpression(ts.factory.createConditionalExpression(getAnyExpression(), undefined, expr, undefined, this.UNDEFINED));
        }
        else if (VeSafeLhsInferenceBugDetector.veWillInferAnyFor(ast)) {
            // Emulate a View Engine bug where 'any' is inferred for the left-hand side of the safe
            // navigation operation. With this bug, the type of the left-hand side is regarded as any.
            // Therefore, the left-hand side only needs repeating in the output (to validate it), and then
            // 'any' is used for the rest of the expression. This is done using a comma operator:
            // "a?.b" becomes (a as any).b, which will of course have type 'any'.
            node = ts.factory.createPropertyAccessExpression(tsCastToAny(receiver), ast.name);
        }
        else {
            // The View Engine bug isn't active, so check the entire type of the expression, but the final
            // result is still inferred as `any`.
            // "a?.b" becomes (a!.b as any)
            const expr = ts.factory.createPropertyAccessExpression(ts.factory.createNonNullExpression(receiver), ast.name);
            addParseSpanInfo(expr, ast.nameSpan);
            node = tsCastToAny(expr);
        }
        addParseSpanInfo(node, ast.sourceSpan);
        return node;
    }
    visitSafeKeyedRead(ast) {
        const receiver = wrapForDiagnostics(this.translate(ast.receiver));
        const key = this.translate(ast.key);
        let node;
        // The form of safe property reads depends on whether strictness is in use.
        if (this.config.strictSafeNavigationTypes) {
            // "a?.[...]" becomes (0 as any ? a![...] : undefined)
            const expr = ts.factory.createElementAccessExpression(ts.factory.createNonNullExpression(receiver), key);
            addParseSpanInfo(expr, ast.sourceSpan);
            node = ts.factory.createParenthesizedExpression(ts.factory.createConditionalExpression(getAnyExpression(), undefined, expr, undefined, this.UNDEFINED));
        }
        else if (VeSafeLhsInferenceBugDetector.veWillInferAnyFor(ast)) {
            // "a?.[...]" becomes (a as any)[...]
            node = ts.factory.createElementAccessExpression(tsCastToAny(receiver), key);
        }
        else {
            // "a?.[...]" becomes (a!.[...] as any)
            const expr = ts.factory.createElementAccessExpression(ts.factory.createNonNullExpression(receiver), key);
            addParseSpanInfo(expr, ast.sourceSpan);
            node = tsCastToAny(expr);
        }
        addParseSpanInfo(node, ast.sourceSpan);
        return node;
    }
    visitCall(ast) {
        const args = ast.args.map((expr) => this.translate(expr));
        let expr;
        const receiver = ast.receiver;
        // For calls that have a property read as receiver, we have to special-case their emit to avoid
        // inserting superfluous parenthesis as they prevent TypeScript from applying a narrowing effect
        // if the method acts as a type guard.
        if (receiver instanceof o.PropertyRead) {
            const resolved = this.maybeResolve(receiver);
            if (resolved !== null) {
                expr = resolved;
            }
            else {
                const propertyReceiver = wrapForDiagnostics(this.translate(receiver.receiver));
                expr = ts.factory.createPropertyAccessExpression(propertyReceiver, receiver.name);
                addParseSpanInfo(expr, receiver.nameSpan);
            }
        }
        else {
            expr = this.translate(receiver);
        }
        let node;
        // Safe property/keyed reads will produce a ternary whose value is nullable.
        // We have to generate a similar ternary around the call.
        if (ast.receiver instanceof o.SafePropertyRead || ast.receiver instanceof o.SafeKeyedRead) {
            node = this.convertToSafeCall(ast, expr, args);
        }
        else {
            node = ts.factory.createCallExpression(expr, undefined, args);
        }
        addParseSpanInfo(node, ast.sourceSpan);
        return node;
    }
    visitSafeCall(ast) {
        const args = ast.args.map((expr) => this.translate(expr));
        const expr = wrapForDiagnostics(this.translate(ast.receiver));
        const node = this.convertToSafeCall(ast, expr, args);
        addParseSpanInfo(node, ast.sourceSpan);
        return node;
    }
    visitTemplateLiteral(ast) {
        const length = ast.elements.length;
        const head = ast.elements[0];
        let result;
        if (length === 1) {
            result = ts.factory.createNoSubstitutionTemplateLiteral(head.text);
        }
        else {
            const spans = [];
            const tailIndex = length - 1;
            for (let i = 1; i < tailIndex; i++) {
                const middle = ts.factory.createTemplateMiddle(ast.elements[i].text);
                spans.push(ts.factory.createTemplateSpan(this.translate(ast.expressions[i - 1]), middle));
            }
            const resolvedExpression = this.translate(ast.expressions[tailIndex - 1]);
            const templateTail = ts.factory.createTemplateTail(ast.elements[tailIndex].text);
            spans.push(ts.factory.createTemplateSpan(resolvedExpression, templateTail));
            result = ts.factory.createTemplateExpression(ts.factory.createTemplateHead(head.text), spans);
        }
        return result;
    }
    visitTemplateLiteralElement(ast, context) {
        throw new Error('Method not implemented');
    }
    visitTaggedTemplateLiteral(ast) {
        return ts.factory.createTaggedTemplateExpression(this.translate(ast.tag), undefined, this.visitTemplateLiteral(ast.template));
    }
    visitParenthesizedExpression(ast) {
        return ts.factory.createParenthesizedExpression(this.translate(ast.expression));
    }
    convertToSafeCall(ast, expr, args) {
        if (this.config.strictSafeNavigationTypes) {
            // "a?.method(...)" becomes (0 as any ? a!.method(...) : undefined)
            const call = ts.factory.createCallExpression(ts.factory.createNonNullExpression(expr), undefined, args);
            return ts.factory.createParenthesizedExpression(ts.factory.createConditionalExpression(getAnyExpression(), undefined, call, undefined, this.UNDEFINED));
        }
        if (VeSafeLhsInferenceBugDetector.veWillInferAnyFor(ast)) {
            // "a?.method(...)" becomes (a as any).method(...)
            return ts.factory.createCallExpression(tsCastToAny(expr), undefined, args);
        }
        // "a?.method(...)" becomes (a!.method(...) as any)
        return tsCastToAny(ts.factory.createCallExpression(ts.factory.createNonNullExpression(expr), undefined, args));
    }
}
/**
 * Checks whether View Engine will infer a type of 'any' for the left-hand side of a safe navigation
 * operation.
 *
 * In View Engine's template type-checker, certain receivers of safe navigation operations will
 * cause a temporary variable to be allocated as part of the checking expression, to save the value
 * of the receiver and use it more than once in the expression. This temporary variable has type
 * 'any'. In practice, this means certain receivers cause View Engine to not check the full
 * expression, and other receivers will receive more complete checking.
 *
 * For compatibility, this logic is adapted from View Engine's expression_converter.ts so that the
 * Ivy checker can emulate this bug when needed.
 */
class VeSafeLhsInferenceBugDetector {
    static SINGLETON = new VeSafeLhsInferenceBugDetector();
    static veWillInferAnyFor(ast) {
        const visitor = VeSafeLhsInferenceBugDetector.SINGLETON;
        return ast instanceof o.Call ? ast.visit(visitor) : ast.receiver.visit(visitor);
    }
    visitUnary(ast) {
        return ast.expr.visit(this);
    }
    visitBinary(ast) {
        return ast.left.visit(this) || ast.right.visit(this);
    }
    visitChain(ast) {
        return false;
    }
    visitConditional(ast) {
        return ast.condition.visit(this) || ast.trueExp.visit(this) || ast.falseExp.visit(this);
    }
    visitCall(ast) {
        return true;
    }
    visitSafeCall(ast) {
        return false;
    }
    visitImplicitReceiver(ast) {
        return false;
    }
    visitThisReceiver(ast) {
        return false;
    }
    visitInterpolation(ast) {
        return ast.expressions.some((exp) => exp.visit(this));
    }
    visitKeyedRead(ast) {
        return false;
    }
    visitLiteralArray(ast) {
        return true;
    }
    visitLiteralMap(ast) {
        return true;
    }
    visitLiteralPrimitive(ast) {
        return false;
    }
    visitPipe(ast) {
        return true;
    }
    visitPrefixNot(ast) {
        return ast.expression.visit(this);
    }
    visitTypeofExpression(ast) {
        return ast.expression.visit(this);
    }
    visitVoidExpression(ast) {
        return ast.expression.visit(this);
    }
    visitNonNullAssert(ast) {
        return ast.expression.visit(this);
    }
    visitPropertyRead(ast) {
        return false;
    }
    visitSafePropertyRead(ast) {
        return false;
    }
    visitSafeKeyedRead(ast) {
        return false;
    }
    visitTemplateLiteral(ast, context) {
        return false;
    }
    visitTemplateLiteralElement(ast, context) {
        return false;
    }
    visitTaggedTemplateLiteral(ast, context) {
        return false;
    }
    visitParenthesizedExpression(ast, context) {
        return ast.expression.visit(this);
    }
    visitRegularExpressionLiteral(ast, context) {
        return false;
    }
}

/**
 * Controls how generics for the component context class will be handled during TCB generation.
 */
var TcbGenericContextBehavior;
(function (TcbGenericContextBehavior) {
    /**
     * References to generic parameter bounds will be emitted via the `TypeParameterEmitter`.
     *
     * The caller must verify that all parameter bounds are emittable in order to use this mode.
     */
    TcbGenericContextBehavior[TcbGenericContextBehavior["UseEmitter"] = 0] = "UseEmitter";
    /**
     * Generic parameter declarations will be copied directly from the `ts.ClassDeclaration` of the
     * component class.
     *
     * The caller must only use the generated TCB code in a context where such copies will still be
     * valid, such as an inline type check block.
     */
    TcbGenericContextBehavior[TcbGenericContextBehavior["CopyClassNodes"] = 1] = "CopyClassNodes";
    /**
     * Any generic parameters for the component context class will be set to `any`.
     *
     * Produces a less useful type, but is always safe to use.
     */
    TcbGenericContextBehavior[TcbGenericContextBehavior["FallbackToAny"] = 2] = "FallbackToAny";
})(TcbGenericContextBehavior || (TcbGenericContextBehavior = {}));
/**
 * Given a `ts.ClassDeclaration` for a component, and metadata regarding that component, compose a
 * "type check block" function.
 *
 * When passed through TypeScript's TypeChecker, type errors that arise within the type check block
 * function indicate issues in the template itself.
 *
 * As a side effect of generating a TCB for the component, `ts.Diagnostic`s may also be produced
 * directly for issues within the template which are identified during generation. These issues are
 * recorded in either the `domSchemaChecker` (which checks usage of DOM elements and bindings) as
 * well as the `oobRecorder` (which records errors when the type-checking code generator is unable
 * to sufficiently understand a template).
 *
 * @param env an `Environment` into which type-checking code will be generated.
 * @param ref a `Reference` to the component class which should be type-checked.
 * @param name a `ts.Identifier` to use for the generated `ts.FunctionDeclaration`.
 * @param meta metadata about the component's template and the function being generated.
 * @param domSchemaChecker used to check and record errors regarding improper usage of DOM elements
 * and bindings.
 * @param oobRecorder used to record errors regarding template elements which could not be correctly
 * translated into types during TCB generation.
 * @param genericContextBehavior controls how generic parameters (especially parameters with generic
 * bounds) will be referenced from the generated TCB code.
 */
function generateTypeCheckBlock(env, ref, name, meta, domSchemaChecker, oobRecorder, genericContextBehavior) {
    const tcb = new Context(env, domSchemaChecker, oobRecorder, meta.id, meta.boundTarget, meta.pipes, meta.schemas, meta.isStandalone, meta.preserveWhitespaces);
    const ctxRawType = env.referenceType(ref);
    if (!ts.isTypeReferenceNode(ctxRawType)) {
        throw new Error(`Expected TypeReferenceNode when referencing the ctx param for ${ref.debugName}`);
    }
    let typeParameters = undefined;
    let typeArguments = undefined;
    if (ref.node.typeParameters !== undefined) {
        if (!env.config.useContextGenericType) {
            genericContextBehavior = TcbGenericContextBehavior.FallbackToAny;
        }
        switch (genericContextBehavior) {
            case TcbGenericContextBehavior.UseEmitter:
                // Guaranteed to emit type parameters since we checked that the class has them above.
                typeParameters = new TypeParameterEmitter(ref.node.typeParameters, env.reflector).emit((typeRef) => env.referenceType(typeRef));
                typeArguments = typeParameters.map((param) => ts.factory.createTypeReferenceNode(param.name));
                break;
            case TcbGenericContextBehavior.CopyClassNodes:
                typeParameters = [...ref.node.typeParameters];
                typeArguments = typeParameters.map((param) => ts.factory.createTypeReferenceNode(param.name));
                break;
            case TcbGenericContextBehavior.FallbackToAny:
                typeArguments = ref.node.typeParameters.map(() => ts.factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword));
                break;
        }
    }
    const paramList = [tcbThisParam(ctxRawType.typeName, typeArguments)];
    const statements = [];
    // Add the template type checking code.
    if (tcb.boundTarget.target.template !== undefined) {
        const templateScope = Scope.forNodes(tcb, null, null, tcb.boundTarget.target.template, 
        /* guard */ null);
        statements.push(renderBlockStatements(env, templateScope, ts.factory.createTrue()));
    }
    // Add the host bindings type checking code.
    if (tcb.boundTarget.target.host !== undefined) {
        const hostScope = Scope.forNodes(tcb, null, tcb.boundTarget.target.host.node, null, null);
        statements.push(renderBlockStatements(env, hostScope, createHostBindingsBlockGuard()));
    }
    const body = ts.factory.createBlock(statements);
    const fnDecl = ts.factory.createFunctionDeclaration(
    /* modifiers */ undefined, 
    /* asteriskToken */ undefined, 
    /* name */ name, 
    /* typeParameters */ env.config.useContextGenericType ? typeParameters : undefined, 
    /* parameters */ paramList, 
    /* type */ undefined, 
    /* body */ body);
    addTypeCheckId(fnDecl, meta.id);
    return fnDecl;
}
function renderBlockStatements(env, scope, wrapperExpression) {
    const scopeStatements = scope.render();
    const innerBody = ts.factory.createBlock([...env.getPreludeStatements(), ...scopeStatements]);
    // Wrap the body in an if statement. This serves two purposes:
    // 1. It allows us to distinguish between the sections of the block (e.g. host or template).
    // 2. It allows the `ts.Printer` to produce better-looking output.
    return ts.factory.createIfStatement(wrapperExpression, innerBody);
}
/**
 * A code generation operation that's involved in the construction of a Type Check Block.
 *
 * The generation of a TCB is non-linear. Bindings within a template may result in the need to
 * construct certain types earlier than they otherwise would be constructed. That is, if the
 * generation of a TCB for a template is broken down into specific operations (constructing a
 * directive, extracting a variable from a let- operation, etc), then it's possible for operations
 * earlier in the sequence to depend on operations which occur later in the sequence.
 *
 * `TcbOp` abstracts the different types of operations which are required to convert a template into
 * a TCB. This allows for two phases of processing for the template, where 1) a linear sequence of
 * `TcbOp`s is generated, and then 2) these operations are executed, not necessarily in linear
 * order.
 *
 * Each `TcbOp` may insert statements into the body of the TCB, and also optionally return a
 * `ts.Expression` which can be used to reference the operation's result.
 */
class TcbOp {
    /**
     * Replacement value or operation used while this `TcbOp` is executing (i.e. to resolve circular
     * references during its execution).
     *
     * This is usually a `null!` expression (which asks TS to infer an appropriate type), but another
     * `TcbOp` can be returned in cases where additional code generation is necessary to deal with
     * circular references.
     */
    circularFallback() {
        // Value used to break a circular reference between `TcbOp`s.
        //
        // This value is returned whenever `TcbOp`s have a circular dependency. The
        // expression is a non-null assertion of the null value (in TypeScript, the
        // expression `null!`). This construction will infer the least narrow type
        // for whatever it's assigned to.
        return ts.factory.createNonNullExpression(ts.factory.createNull());
    }
}
/**
 * A `TcbOp` which creates an expression for a native DOM element (or web component) from a
 * `TmplAstElement`.
 *
 * Executing this operation returns a reference to the element variable.
 */
class TcbElementOp extends TcbOp {
    tcb;
    scope;
    element;
    constructor(tcb, scope, element) {
        super();
        this.tcb = tcb;
        this.scope = scope;
        this.element = element;
    }
    get optional() {
        // The statement generated by this operation is only used for type-inference of the DOM
        // element's type and won't report diagnostics by itself, so the operation is marked as optional
        // to avoid generating statements for DOM elements that are never referenced.
        return true;
    }
    execute() {
        const id = this.tcb.allocateId();
        // Add the declaration of the element using document.createElement.
        const initializer = tsCreateElement(this.element.name);
        addParseSpanInfo(initializer, this.element.startSourceSpan || this.element.sourceSpan);
        this.scope.addStatement(tsCreateVariable(id, initializer));
        return id;
    }
}
/**
 * A `TcbOp` which creates an expression for particular let- `TmplAstVariable` on a
 * `TmplAstTemplate`'s context.
 *
 * Executing this operation returns a reference to the variable variable (lol).
 */
class TcbTemplateVariableOp extends TcbOp {
    tcb;
    scope;
    template;
    variable;
    constructor(tcb, scope, template, variable) {
        super();
        this.tcb = tcb;
        this.scope = scope;
        this.template = template;
        this.variable = variable;
    }
    get optional() {
        return false;
    }
    execute() {
        // Look for a context variable for the template.
        const ctx = this.scope.resolve(this.template);
        // Allocate an identifier for the TmplAstVariable, and initialize it to a read of the variable
        // on the template context.
        const id = this.tcb.allocateId();
        const initializer = ts.factory.createPropertyAccessExpression(
        /* expression */ ctx, 
        /* name */ this.variable.value || '$implicit');
        addParseSpanInfo(id, this.variable.keySpan);
        // Declare the variable, and return its identifier.
        let variable;
        if (this.variable.valueSpan !== undefined) {
            addParseSpanInfo(initializer, this.variable.valueSpan);
            variable = tsCreateVariable(id, wrapForTypeChecker(initializer));
        }
        else {
            variable = tsCreateVariable(id, initializer);
        }
        addParseSpanInfo(variable.declarationList.declarations[0], this.variable.sourceSpan);
        this.scope.addStatement(variable);
        return id;
    }
}
/**
 * A `TcbOp` which generates a variable for a `TmplAstTemplate`'s context.
 *
 * Executing this operation returns a reference to the template's context variable.
 */
class TcbTemplateContextOp extends TcbOp {
    tcb;
    scope;
    constructor(tcb, scope) {
        super();
        this.tcb = tcb;
        this.scope = scope;
    }
    // The declaration of the context variable is only needed when the context is actually referenced.
    optional = true;
    execute() {
        // Allocate a template ctx variable and declare it with an 'any' type. The type of this variable
        // may be narrowed as a result of template guard conditions.
        const ctx = this.tcb.allocateId();
        const type = ts.factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword);
        this.scope.addStatement(tsDeclareVariable(ctx, type));
        return ctx;
    }
}
/**
 * A `TcbOp` which generates a constant for a `TmplAstLetDeclaration`.
 *
 * Executing this operation returns a reference to the `@let` declaration.
 */
class TcbLetDeclarationOp extends TcbOp {
    tcb;
    scope;
    node;
    constructor(tcb, scope, node) {
        super();
        this.tcb = tcb;
        this.scope = scope;
        this.node = node;
    }
    /**
     * `@let` declarations are mandatory, because their expressions
     * should be checked even if they aren't referenced anywhere.
     */
    optional = false;
    execute() {
        const id = this.tcb.allocateId();
        addParseSpanInfo(id, this.node.nameSpan);
        const value = tcbExpression(this.node.value, this.tcb, this.scope);
        // Value needs to be wrapped, because spans for the expressions inside of it can
        // be picked up incorrectly as belonging to the full variable declaration.
        const varStatement = tsCreateVariable(id, wrapForTypeChecker(value), ts.NodeFlags.Const);
        addParseSpanInfo(varStatement.declarationList.declarations[0], this.node.sourceSpan);
        this.scope.addStatement(varStatement);
        return id;
    }
}
/**
 * A `TcbOp` which descends into a `TmplAstTemplate`'s children and generates type-checking code for
 * them.
 *
 * This operation wraps the children's type-checking code in an `if` block, which may include one
 * or more type guard conditions that narrow types within the template body.
 */
class TcbTemplateBodyOp extends TcbOp {
    tcb;
    scope;
    template;
    constructor(tcb, scope, template) {
        super();
        this.tcb = tcb;
        this.scope = scope;
        this.template = template;
    }
    get optional() {
        return false;
    }
    execute() {
        // An `if` will be constructed, within which the template's children will be type checked. The
        // `if` is used for two reasons: it creates a new syntactic scope, isolating variables declared
        // in the template's TCB from the outer context, and it allows any directives on the templates
        // to perform type narrowing of either expressions or the template's context.
        //
        // The guard is the `if` block's condition. It's usually set to `true` but directives that exist
        // on the template can trigger extra guard expressions that serve to narrow types within the
        // `if`. `guard` is calculated by starting with `true` and adding other conditions as needed.
        // Collect these into `guards` by processing the directives.
        // By default the guard is simply `true`.
        let guard = null;
        const directiveGuards = [];
        this.addDirectiveGuards(directiveGuards, this.template, this.tcb.boundTarget.getDirectivesOfNode(this.template));
        for (const directive of this.template.directives) {
            this.addDirectiveGuards(directiveGuards, directive, this.tcb.boundTarget.getDirectivesOfNode(directive));
        }
        // If there are any guards from directives, use them instead.
        if (directiveGuards.length > 0) {
            // Pop the first value and use it as the initializer to reduce(). This way, a single guard
            // will be used on its own, but two or more will be combined into binary AND expressions.
            guard = directiveGuards.reduce((expr, dirGuard) => ts.factory.createBinaryExpression(expr, ts.SyntaxKind.AmpersandAmpersandToken, dirGuard), directiveGuards.pop());
        }
        // Create a new Scope for the template. This constructs the list of operations for the template
        // children, as well as tracks bindings within the template.
        const tmplScope = Scope.forNodes(this.tcb, this.scope, this.template, this.template.children, guard);
        // Render the template's `Scope` into its statements.
        const statements = tmplScope.render();
        if (statements.length === 0) {
            // As an optimization, don't generate the scope's block if it has no statements. This is
            // beneficial for templates that contain for example `<span *ngIf="first"></span>`, in which
            // case there's no need to render the `NgIf` guard expression. This seems like a minor
            // improvement, however it reduces the number of flow-node antecedents that TypeScript needs
            // to keep into account for such cases, resulting in an overall reduction of
            // type-checking time.
            return null;
        }
        let tmplBlock = ts.factory.createBlock(statements);
        if (guard !== null) {
            // The scope has a guard that needs to be applied, so wrap the template block into an `if`
            // statement containing the guard expression.
            tmplBlock = ts.factory.createIfStatement(
            /* expression */ guard, 
            /* thenStatement */ tmplBlock);
        }
        this.scope.addStatement(tmplBlock);
        return null;
    }
    addDirectiveGuards(guards, hostNode, directives) {
        if (directives === null || directives.length === 0) {
            return;
        }
        const isTemplate = hostNode instanceof o.TmplAstTemplate;
        for (const dir of directives) {
            const dirInstId = this.scope.resolve(hostNode, dir);
            const dirId = this.tcb.env.reference(dir.ref);
            // There are two kinds of guards. Template guards (ngTemplateGuards) allow type narrowing of
            // the expression passed to an @Input of the directive. Scan the directive to see if it has
            // any template guards, and generate them if needed.
            dir.ngTemplateGuards.forEach((guard) => {
                // For each template guard function on the directive, look for a binding to that input.
                const boundInput = hostNode.inputs.find((i) => i.name === guard.inputName) ||
                    (isTemplate
                        ? hostNode.templateAttrs.find((input) => {
                            return input instanceof o.TmplAstBoundAttribute && input.name === guard.inputName;
                        })
                        : undefined);
                if (boundInput !== undefined) {
                    // If there is such a binding, generate an expression for it.
                    const expr = tcbExpression(boundInput.value, this.tcb, this.scope);
                    // The expression has already been checked in the type constructor invocation, so
                    // it should be ignored when used within a template guard.
                    markIgnoreDiagnostics(expr);
                    if (guard.type === 'binding') {
                        // Use the binding expression itself as guard.
                        guards.push(expr);
                    }
                    else {
                        // Call the guard function on the directive with the directive instance and that
                        // expression.
                        const guardInvoke = tsCallMethod(dirId, `ngTemplateGuard_${guard.inputName}`, [
                            dirInstId,
                            expr,
                        ]);
                        addParseSpanInfo(guardInvoke, boundInput.value.sourceSpan);
                        guards.push(guardInvoke);
                    }
                }
            });
            // The second kind of guard is a template context guard. This guard narrows the template
            // rendering context variable `ctx`.
            if (dir.hasNgTemplateContextGuard) {
                if (this.tcb.env.config.applyTemplateContextGuards) {
                    const ctx = this.scope.resolve(hostNode);
                    const guardInvoke = tsCallMethod(dirId, 'ngTemplateContextGuard', [dirInstId, ctx]);
                    markIgnoreDiagnostics(guardInvoke);
                    addParseSpanInfo(guardInvoke, hostNode.sourceSpan);
                    guards.push(guardInvoke);
                }
                else if (isTemplate &&
                    hostNode.variables.length > 0 &&
                    this.tcb.env.config.suggestionsForSuboptimalTypeInference) {
                    // The compiler could have inferred a better type for the variables in this template,
                    // but was prevented from doing so by the type-checking configuration. Issue a warning
                    // diagnostic.
                    this.tcb.oobRecorder.suboptimalTypeInference(this.tcb.id, hostNode.variables);
                }
            }
        }
    }
}
/**
 * A `TcbOp` which renders an Angular expression (e.g. `{{foo() && bar.baz}}`).
 *
 * Executing this operation returns nothing.
 */
class TcbExpressionOp extends TcbOp {
    tcb;
    scope;
    expression;
    constructor(tcb, scope, expression) {
        super();
        this.tcb = tcb;
        this.scope = scope;
        this.expression = expression;
    }
    get optional() {
        return false;
    }
    execute() {
        const expr = tcbExpression(this.expression, this.tcb, this.scope);
        this.scope.addStatement(ts.factory.createExpressionStatement(expr));
        return null;
    }
}
/**
 * A `TcbOp` which constructs an instance of a directive. For generic directives, generic
 * parameters are set to `any` type.
 */
class TcbDirectiveTypeOpBase extends TcbOp {
    tcb;
    scope;
    node;
    dir;
    constructor(tcb, scope, node, dir) {
        super();
        this.tcb = tcb;
        this.scope = scope;
        this.node = node;
        this.dir = dir;
    }
    get optional() {
        // The statement generated by this operation is only used to declare the directive's type and
        // won't report diagnostics by itself, so the operation is marked as optional to avoid
        // generating declarations for directives that don't have any inputs/outputs.
        return true;
    }
    execute() {
        const dirRef = this.dir.ref;
        const rawType = this.tcb.env.referenceType(this.dir.ref);
        let type;
        let span;
        if (this.dir.isGeneric === false || dirRef.node.typeParameters === undefined) {
            type = rawType;
        }
        else {
            if (!ts.isTypeReferenceNode(rawType)) {
                throw new Error(`Expected TypeReferenceNode when referencing the type for ${this.dir.ref.debugName}`);
            }
            const typeArguments = dirRef.node.typeParameters.map(() => ts.factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword));
            type = ts.factory.createTypeReferenceNode(rawType.typeName, typeArguments);
        }
        if (this.node instanceof o.TmplAstHostElement) {
            span = this.node.sourceSpan;
        }
        else {
            span = this.node.startSourceSpan || this.node.sourceSpan;
        }
        const id = this.tcb.allocateId();
        addExpressionIdentifier(id, ExpressionIdentifier.DIRECTIVE);
        addParseSpanInfo(id, span);
        this.scope.addStatement(tsDeclareVariable(id, type));
        return id;
    }
}
/**
 * A `TcbOp` which constructs an instance of a non-generic directive _without_ setting any of its
 * inputs. Inputs are later set in the `TcbDirectiveInputsOp`. Type checking was found to be
 * faster when done in this way as opposed to `TcbDirectiveCtorOp` which is only necessary when the
 * directive is generic.
 *
 * Executing this operation returns a reference to the directive instance variable with its inferred
 * type.
 */
class TcbNonGenericDirectiveTypeOp extends TcbDirectiveTypeOpBase {
    /**
     * Creates a variable declaration for this op's directive of the argument type. Returns the id of
     * the newly created variable.
     */
    execute() {
        const dirRef = this.dir.ref;
        if (this.dir.isGeneric) {
            throw new Error(`Assertion Error: expected ${dirRef.debugName} not to be generic.`);
        }
        return super.execute();
    }
}
/**
 * A `TcbOp` which constructs an instance of a generic directive with its generic parameters set
 * to `any` type. This op is like `TcbDirectiveTypeOp`, except that generic parameters are set to
 * `any` type. This is used for situations where we want to avoid inlining.
 *
 * Executing this operation returns a reference to the directive instance variable with its generic
 * type parameters set to `any`.
 */
class TcbGenericDirectiveTypeWithAnyParamsOp extends TcbDirectiveTypeOpBase {
    execute() {
        const dirRef = this.dir.ref;
        if (dirRef.node.typeParameters === undefined) {
            throw new Error(`Assertion Error: expected typeParameters when creating a declaration for ${dirRef.debugName}`);
        }
        return super.execute();
    }
}
/**
 * A `TcbOp` which creates a variable for a local ref in a template.
 * The initializer for the variable is the variable expression for the directive, template, or
 * element the ref refers to. When the reference is used in the template, those TCB statements will
 * access this variable as well. For example:
 * ```ts
 * var _t1 = document.createElement('div');
 * var _t2 = _t1;
 * _t2.value
 * ```
 * This operation supports more fluent lookups for the `TemplateTypeChecker` when getting a symbol
 * for a reference. In most cases, this isn't essential; that is, the information for the symbol
 * could be gathered without this operation using the `BoundTarget`. However, for the case of
 * ng-template references, we will need this reference variable to not only provide a location in
 * the shim file, but also to narrow the variable to the correct `TemplateRef<T>` type rather than
 * `TemplateRef<any>` (this work is still TODO).
 *
 * Executing this operation returns a reference to the directive instance variable with its inferred
 * type.
 */
class TcbReferenceOp extends TcbOp {
    tcb;
    scope;
    node;
    host;
    target;
    constructor(tcb, scope, node, host, target) {
        super();
        this.tcb = tcb;
        this.scope = scope;
        this.node = node;
        this.host = host;
        this.target = target;
    }
    // The statement generated by this operation is only used to for the Type Checker
    // so it can map a reference variable in the template directly to a node in the TCB.
    optional = true;
    execute() {
        const id = this.tcb.allocateId();
        let initializer = this.target instanceof o.TmplAstTemplate || this.target instanceof o.TmplAstElement
            ? this.scope.resolve(this.target)
            : this.scope.resolve(this.host, this.target);
        // The reference is either to an element, an <ng-template> node, or to a directive on an
        // element or template.
        if ((this.target instanceof o.TmplAstElement && !this.tcb.env.config.checkTypeOfDomReferences) ||
            !this.tcb.env.config.checkTypeOfNonDomReferences) {
            // References to DOM nodes are pinned to 'any' when `checkTypeOfDomReferences` is `false`.
            // References to `TemplateRef`s and directives are pinned to 'any' when
            // `checkTypeOfNonDomReferences` is `false`.
            initializer = ts.factory.createAsExpression(initializer, ts.factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword));
        }
        else if (this.target instanceof o.TmplAstTemplate) {
            // Direct references to an <ng-template> node simply require a value of type
            // `TemplateRef<any>`. To get this, an expression of the form
            // `(_t1 as any as TemplateRef<any>)` is constructed.
            initializer = ts.factory.createAsExpression(initializer, ts.factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword));
            initializer = ts.factory.createAsExpression(initializer, this.tcb.env.referenceExternalType('@angular/core', 'TemplateRef', [o.DYNAMIC_TYPE]));
            initializer = ts.factory.createParenthesizedExpression(initializer);
        }
        addParseSpanInfo(initializer, this.node.sourceSpan);
        addParseSpanInfo(id, this.node.keySpan);
        this.scope.addStatement(tsCreateVariable(id, initializer));
        return id;
    }
}
/**
 * A `TcbOp` which is used when the target of a reference is missing. This operation generates a
 * variable of type any for usages of the invalid reference to resolve to. The invalid reference
 * itself is recorded out-of-band.
 */
class TcbInvalidReferenceOp extends TcbOp {
    tcb;
    scope;
    constructor(tcb, scope) {
        super();
        this.tcb = tcb;
        this.scope = scope;
    }
    // The declaration of a missing reference is only needed when the reference is resolved.
    optional = true;
    execute() {
        const id = this.tcb.allocateId();
        this.scope.addStatement(tsCreateVariable(id, getAnyExpression()));
        return id;
    }
}
/**
 * A `TcbOp` which constructs an instance of a directive with types inferred from its inputs. The
 * inputs themselves are not checked here; checking of inputs is achieved in `TcbDirectiveInputsOp`.
 * Any errors reported in this statement are ignored, as the type constructor call is only present
 * for type-inference.
 *
 * When a Directive is generic, it is required that the TCB generates the instance using this method
 * in order to infer the type information correctly.
 *
 * Executing this operation returns a reference to the directive instance variable with its inferred
 * type.
 */
class TcbDirectiveCtorOp extends TcbOp {
    tcb;
    scope;
    node;
    dir;
    constructor(tcb, scope, node, dir) {
        super();
        this.tcb = tcb;
        this.scope = scope;
        this.node = node;
        this.dir = dir;
    }
    get optional() {
        // The statement generated by this operation is only used to infer the directive's type and
        // won't report diagnostics by itself, so the operation is marked as optional.
        return true;
    }
    execute() {
        const genericInputs = new Map();
        const id = this.tcb.allocateId();
        let boundAttrs;
        let span;
        if (this.node instanceof o.TmplAstHostElement) {
            // Host elements can't bind to their own inputs so we don't resolve any.
            boundAttrs = [];
            span = this.node.sourceSpan;
        }
        else {
            boundAttrs = getBoundAttributes(this.dir, this.node);
            span = this.node.startSourceSpan || this.node.sourceSpan;
        }
        addExpressionIdentifier(id, ExpressionIdentifier.DIRECTIVE);
        addParseSpanInfo(id, span);
        for (const attr of boundAttrs) {
            // Skip text attributes if configured to do so.
            if (!this.tcb.env.config.checkTypeOfAttributes &&
                attr.attribute instanceof o.TmplAstTextAttribute) {
                continue;
            }
            for (const { fieldName, isTwoWayBinding } of attr.inputs) {
                // Skip the field if an attribute has already been bound to it; we can't have a duplicate
                // key in the type constructor call.
                if (genericInputs.has(fieldName)) {
                    continue;
                }
                const expression = translateInput(attr.attribute, this.tcb, this.scope);
                genericInputs.set(fieldName, {
                    type: 'binding',
                    field: fieldName,
                    expression,
                    sourceSpan: attr.attribute.sourceSpan,
                    isTwoWayBinding,
                });
            }
        }
        // Add unset directive inputs for each of the remaining unset fields.
        for (const { classPropertyName } of this.dir.inputs) {
            if (!genericInputs.has(classPropertyName)) {
                genericInputs.set(classPropertyName, { type: 'unset', field: classPropertyName });
            }
        }
        // Call the type constructor of the directive to infer a type, and assign the directive
        // instance.
        const typeCtor = tcbCallTypeCtor(this.dir, this.tcb, Array.from(genericInputs.values()));
        markIgnoreDiagnostics(typeCtor);
        this.scope.addStatement(tsCreateVariable(id, typeCtor));
        return id;
    }
    circularFallback() {
        return new TcbDirectiveCtorCircularFallbackOp(this.tcb, this.scope, this.dir);
    }
}
/**
 * A `TcbOp` which generates code to check input bindings on an element that correspond with the
 * members of a directive.
 *
 * Executing this operation returns nothing.
 */
class TcbDirectiveInputsOp extends TcbOp {
    tcb;
    scope;
    node;
    dir;
    constructor(tcb, scope, node, dir) {
        super();
        this.tcb = tcb;
        this.scope = scope;
        this.node = node;
        this.dir = dir;
    }
    get optional() {
        return false;
    }
    execute() {
        let dirId = null;
        // TODO(joost): report duplicate properties
        const boundAttrs = getBoundAttributes(this.dir, this.node);
        const seenRequiredInputs = new Set();
        for (const attr of boundAttrs) {
            // For bound inputs, the property is assigned the binding expression.
            const expr = widenBinding(translateInput(attr.attribute, this.tcb, this.scope), this.tcb);
            let assignment = wrapForDiagnostics(expr);
            for (const { fieldName, required, transformType, isSignal, isTwoWayBinding } of attr.inputs) {
                let target;
                if (required) {
                    seenRequiredInputs.add(fieldName);
                }
                // Note: There is no special logic for transforms/coercion with signal inputs.
                // For signal inputs, a `transformType` will never be set as we do not capture
                // the transform in the compiler metadata. Signal inputs incorporate their
                // transform write type into their member type, and we extract it below when
                // setting the `WriteT` of such `InputSignalWithTransform<_, WriteT>`.
                if (this.dir.coercedInputFields.has(fieldName)) {
                    let type;
                    if (transformType !== null) {
                        type = this.tcb.env.referenceTransplantedType(new o.TransplantedType(transformType));
                    }
                    else {
                        // The input has a coercion declaration which should be used instead of assigning the
                        // expression into the input field directly. To achieve this, a variable is declared
                        // with a type of `typeof Directive.ngAcceptInputType_fieldName` which is then used as
                        // target of the assignment.
                        const dirTypeRef = this.tcb.env.referenceType(this.dir.ref);
                        if (!ts.isTypeReferenceNode(dirTypeRef)) {
                            throw new Error(`Expected TypeReferenceNode from reference to ${this.dir.ref.debugName}`);
                        }
                        type = tsCreateTypeQueryForCoercedInput(dirTypeRef.typeName, fieldName);
                    }
                    const id = this.tcb.allocateId();
                    this.scope.addStatement(tsDeclareVariable(id, type));
                    target = id;
                }
                else if (this.dir.undeclaredInputFields.has(fieldName)) {
                    // If no coercion declaration is present nor is the field declared (i.e. the input is
                    // declared in a `@Directive` or `@Component` decorator's `inputs` property) there is no
                    // assignment target available, so this field is skipped.
                    continue;
                }
                else if (!this.tcb.env.config.honorAccessModifiersForInputBindings &&
                    this.dir.restrictedInputFields.has(fieldName)) {
                    // If strict checking of access modifiers is disabled and the field is restricted
                    // (i.e. private/protected/readonly), generate an assignment into a temporary variable
                    // that has the type of the field. This achieves type-checking but circumvents the access
                    // modifiers.
                    if (dirId === null) {
                        dirId = this.scope.resolve(this.node, this.dir);
                    }
                    const id = this.tcb.allocateId();
                    const dirTypeRef = this.tcb.env.referenceType(this.dir.ref);
                    if (!ts.isTypeReferenceNode(dirTypeRef)) {
                        throw new Error(`Expected TypeReferenceNode from reference to ${this.dir.ref.debugName}`);
                    }
                    const type = ts.factory.createIndexedAccessTypeNode(ts.factory.createTypeQueryNode(dirId), ts.factory.createLiteralTypeNode(ts.factory.createStringLiteral(fieldName)));
                    const temp = tsDeclareVariable(id, type);
                    this.scope.addStatement(temp);
                    target = id;
                }
                else {
                    if (dirId === null) {
                        dirId = this.scope.resolve(this.node, this.dir);
                    }
                    // To get errors assign directly to the fields on the instance, using property access
                    // when possible. String literal fields may not be valid JS identifiers so we use
                    // literal element access instead for those cases.
                    target = this.dir.stringLiteralInputFields.has(fieldName)
                        ? ts.factory.createElementAccessExpression(dirId, ts.factory.createStringLiteral(fieldName))
                        : ts.factory.createPropertyAccessExpression(dirId, ts.factory.createIdentifier(fieldName));
                }
                // For signal inputs, we unwrap the target `InputSignal`. Note that
                // we intentionally do the following things:
                //   1. keep the direct access to `dir.[field]` so that modifiers are honored.
                //   2. follow the existing pattern where multiple targets assign a single expression.
                //      This is a significant requirement for language service auto-completion.
                if (isSignal) {
                    const inputSignalBrandWriteSymbol = this.tcb.env.referenceExternalSymbol(o.R3Identifiers.InputSignalBrandWriteType.moduleName, o.R3Identifiers.InputSignalBrandWriteType.name);
                    if (!ts.isIdentifier(inputSignalBrandWriteSymbol) &&
                        !ts.isPropertyAccessExpression(inputSignalBrandWriteSymbol)) {
                        throw new Error(`Expected identifier or property access for reference to ${o.R3Identifiers.InputSignalBrandWriteType.name}`);
                    }
                    target = ts.factory.createElementAccessExpression(target, inputSignalBrandWriteSymbol);
                }
                if (attr.attribute.keySpan !== undefined) {
                    addParseSpanInfo(target, attr.attribute.keySpan);
                }
                // Two-way bindings accept `T | WritableSignal<T>` so we have to unwrap the value.
                if (isTwoWayBinding && this.tcb.env.config.allowSignalsInTwoWayBindings) {
                    assignment = unwrapWritableSignal(assignment, this.tcb);
                }
                // Finally the assignment is extended by assigning it into the target expression.
                assignment = ts.factory.createBinaryExpression(target, ts.SyntaxKind.EqualsToken, assignment);
            }
            addParseSpanInfo(assignment, attr.attribute.sourceSpan);
            // Ignore diagnostics for text attributes if configured to do so.
            if (!this.tcb.env.config.checkTypeOfAttributes &&
                attr.attribute instanceof o.TmplAstTextAttribute) {
                markIgnoreDiagnostics(assignment);
            }
            this.scope.addStatement(ts.factory.createExpressionStatement(assignment));
        }
        this.checkRequiredInputs(seenRequiredInputs);
        return null;
    }
    checkRequiredInputs(seenRequiredInputs) {
        const missing = [];
        for (const input of this.dir.inputs) {
            if (input.required && !seenRequiredInputs.has(input.classPropertyName)) {
                missing.push(input.bindingPropertyName);
            }
        }
        if (missing.length > 0) {
            this.tcb.oobRecorder.missingRequiredInputs(this.tcb.id, this.node, this.dir.name, this.dir.isComponent, missing);
        }
    }
}
/**
 * A `TcbOp` which is used to generate a fallback expression if the inference of a directive type
 * via `TcbDirectiveCtorOp` requires a reference to its own type. This can happen using a template
 * reference:
 *
 * ```html
 * <some-cmp #ref [prop]="ref.foo"></some-cmp>
 * ```
 *
 * In this case, `TcbDirectiveCtorCircularFallbackOp` will add a second inference of the directive
 * type to the type-check block, this time calling the directive's type constructor without any
 * input expressions. This infers the widest possible supertype for the directive, which is used to
 * resolve any recursive references required to infer the real type.
 */
class TcbDirectiveCtorCircularFallbackOp extends TcbOp {
    tcb;
    scope;
    dir;
    constructor(tcb, scope, dir) {
        super();
        this.tcb = tcb;
        this.scope = scope;
        this.dir = dir;
    }
    get optional() {
        return false;
    }
    execute() {
        const id = this.tcb.allocateId();
        const typeCtor = this.tcb.env.typeCtorFor(this.dir);
        const circularPlaceholder = ts.factory.createCallExpression(typeCtor, 
        /* typeArguments */ undefined, [ts.factory.createNonNullExpression(ts.factory.createNull())]);
        this.scope.addStatement(tsCreateVariable(id, circularPlaceholder));
        return id;
    }
}
/**
 * A `TcbOp` which feeds elements and unclaimed properties to the `DomSchemaChecker`.
 *
 * The DOM schema is not checked via TCB code generation. Instead, the `DomSchemaChecker` ingests
 * elements and property bindings and accumulates synthetic `ts.Diagnostic`s out-of-band. These are
 * later merged with the diagnostics generated from the TCB.
 *
 * For convenience, the TCB iteration of the template is used to drive the `DomSchemaChecker` via
 * the `TcbDomSchemaCheckerOp`.
 */
class TcbDomSchemaCheckerOp extends TcbOp {
    tcb;
    element;
    checkElement;
    claimedInputs;
    constructor(tcb, element, checkElement, claimedInputs) {
        super();
        this.tcb = tcb;
        this.element = element;
        this.checkElement = checkElement;
        this.claimedInputs = claimedInputs;
    }
    get optional() {
        return false;
    }
    execute() {
        const element = this.element;
        const isTemplateElement = element instanceof o.TmplAstElement || element instanceof o.TmplAstComponent;
        const bindings = isTemplateElement ? element.inputs : element.bindings;
        if (this.checkElement && isTemplateElement) {
            this.tcb.domSchemaChecker.checkElement(this.tcb.id, this.getTagName(element), element.startSourceSpan, this.tcb.schemas, this.tcb.hostIsStandalone);
        }
        // TODO(alxhub): this could be more efficient.
        for (const binding of bindings) {
            const isPropertyBinding = binding.type === o.BindingType.Property || binding.type === o.BindingType.TwoWay;
            if (isPropertyBinding && this.claimedInputs?.has(binding.name)) {
                // Skip this binding as it was claimed by a directive.
                continue;
            }
            if (isPropertyBinding && binding.name !== 'style' && binding.name !== 'class') {
                // A direct binding to a property.
                const propertyName = REGISTRY$1.getMappedPropName(binding.name);
                if (isTemplateElement) {
                    this.tcb.domSchemaChecker.checkTemplateElementProperty(this.tcb.id, this.getTagName(element), propertyName, binding.sourceSpan, this.tcb.schemas, this.tcb.hostIsStandalone);
                }
                else {
                    this.tcb.domSchemaChecker.checkHostElementProperty(this.tcb.id, element, propertyName, binding.keySpan, this.tcb.schemas);
                }
            }
        }
        return null;
    }
    getTagName(node) {
        return node instanceof o.TmplAstElement ? node.name : getComponentTagName(node);
    }
}
/**
 * A `TcbOp` that finds and flags control flow nodes that interfere with content projection.
 *
 * Context:
 * Control flow blocks try to emulate the content projection behavior of `*ngIf` and `*ngFor`
 * in order to reduce breakages when moving from one syntax to the other (see #52414), however the
 * approach only works if there's only one element at the root of the control flow expression.
 * This means that a stray sibling node (e.g. text) can prevent an element from being projected
 * into the right slot. The purpose of the `TcbOp` is to find any places where a node at the root
 * of a control flow expression *would have been projected* into a specific slot, if the control
 * flow node didn't exist.
 */
class TcbControlFlowContentProjectionOp extends TcbOp {
    tcb;
    element;
    ngContentSelectors;
    componentName;
    category;
    constructor(tcb, element, ngContentSelectors, componentName) {
        super();
        this.tcb = tcb;
        this.element = element;
        this.ngContentSelectors = ngContentSelectors;
        this.componentName = componentName;
        // We only need to account for `error` and `warning` since
        // this check won't be enabled for `suppress`.
        this.category =
            tcb.env.config.controlFlowPreventingContentProjection === 'error'
                ? ts.DiagnosticCategory.Error
                : ts.DiagnosticCategory.Warning;
    }
    optional = false;
    execute() {
        const controlFlowToCheck = this.findPotentialControlFlowNodes();
        if (controlFlowToCheck.length > 0) {
            const matcher = new o.SelectorMatcher();
            for (const selector of this.ngContentSelectors) {
                // `*` is a special selector for the catch-all slot.
                if (selector !== '*') {
                    matcher.addSelectables(o.CssSelector.parse(selector), selector);
                }
            }
            for (const root of controlFlowToCheck) {
                for (const child of root.children) {
                    if (child instanceof o.TmplAstElement || child instanceof o.TmplAstTemplate) {
                        matcher.match(o.createCssSelectorFromNode(child), (_, originalSelector) => {
                            this.tcb.oobRecorder.controlFlowPreventingContentProjection(this.tcb.id, this.category, child, this.componentName, originalSelector, root, this.tcb.hostPreserveWhitespaces);
                        });
                    }
                }
            }
        }
        return null;
    }
    findPotentialControlFlowNodes() {
        const result = [];
        for (const child of this.element.children) {
            if (child instanceof o.TmplAstForLoopBlock) {
                if (this.shouldCheck(child)) {
                    result.push(child);
                }
                if (child.empty !== null && this.shouldCheck(child.empty)) {
                    result.push(child.empty);
                }
            }
            else if (child instanceof o.TmplAstIfBlock) {
                for (const branch of child.branches) {
                    if (this.shouldCheck(branch)) {
                        result.push(branch);
                    }
                }
            }
            else if (child instanceof o.TmplAstSwitchBlock) {
                for (const current of child.cases) {
                    if (this.shouldCheck(current)) {
                        result.push(current);
                    }
                }
            }
        }
        return result;
    }
    shouldCheck(node) {
        // Skip nodes with less than two children since it's impossible
        // for them to run into the issue that we're checking for.
        if (node.children.length < 2) {
            return false;
        }
        let hasSeenRootNode = false;
        // Check the number of root nodes while skipping empty text where relevant.
        for (const child of node.children) {
            // Normally `preserveWhitspaces` would have been accounted for during parsing, however
            // in `ngtsc/annotations/component/src/resources.ts#parseExtractedTemplate` we enable
            // `preserveWhitespaces` to preserve the accuracy of source maps diagnostics. This means
            // that we have to account for it here since the presence of text nodes affects the
            // content projection behavior.
            if (!(child instanceof o.TmplAstText) ||
                this.tcb.hostPreserveWhitespaces ||
                child.value.trim().length > 0) {
                // Content projection will be affected if there's more than one root node.
                if (hasSeenRootNode) {
                    return true;
                }
                hasSeenRootNode = true;
            }
        }
        return false;
    }
}
/**
 * A `TcbOp` which creates an expression for a the host element of a directive.
 *
 * Executing this operation returns a reference to the element variable.
 */
class TcbHostElementOp extends TcbOp {
    tcb;
    scope;
    element;
    optional = true;
    constructor(tcb, scope, element) {
        super();
        this.tcb = tcb;
        this.scope = scope;
        this.element = element;
    }
    execute() {
        const id = this.tcb.allocateId();
        const initializer = tsCreateElement(...this.element.tagNames);
        addParseSpanInfo(initializer, this.element.sourceSpan);
        this.scope.addStatement(tsCreateVariable(id, initializer));
        return id;
    }
}
/**
 * A `TcbOp` which creates an expression for a native DOM element from a `TmplAstComponent`.
 *
 * Executing this operation returns a reference to the element variable.
 */
class TcbComponentNodeOp extends TcbOp {
    tcb;
    scope;
    component;
    optional = true;
    constructor(tcb, scope, component) {
        super();
        this.tcb = tcb;
        this.scope = scope;
        this.component = component;
    }
    execute() {
        const id = this.tcb.allocateId();
        const initializer = tsCreateElement(getComponentTagName(this.component));
        addParseSpanInfo(initializer, this.component.startSourceSpan || this.component.sourceSpan);
        this.scope.addStatement(tsCreateVariable(id, initializer));
        return id;
    }
}
/**
 * A `TcbOp` which generates code to check "unclaimed inputs" - bindings on an element which were
 * not attributed to any directive or component, and are instead processed against the HTML element
 * itself.
 *
 * Currently, only the expressions of these bindings are checked. The targets of the bindings are
 * checked against the DOM schema via a `TcbDomSchemaCheckerOp`.
 *
 * Executing this operation returns nothing.
 */
class TcbUnclaimedInputsOp extends TcbOp {
    tcb;
    scope;
    inputs;
    target;
    claimedInputs;
    constructor(tcb, scope, inputs, target, claimedInputs) {
        super();
        this.tcb = tcb;
        this.scope = scope;
        this.inputs = inputs;
        this.target = target;
        this.claimedInputs = claimedInputs;
    }
    get optional() {
        return false;
    }
    execute() {
        // `this.inputs` contains only those bindings not matched by any directive. These bindings go to
        // the element itself.
        let elId = null;
        // TODO(alxhub): this could be more efficient.
        for (const binding of this.inputs) {
            const isPropertyBinding = binding.type === o.BindingType.Property || binding.type === o.BindingType.TwoWay;
            if (isPropertyBinding && this.claimedInputs?.has(binding.name)) {
                // Skip this binding as it was claimed by a directive.
                continue;
            }
            const expr = widenBinding(tcbExpression(binding.value, this.tcb, this.scope), this.tcb);
            if (this.tcb.env.config.checkTypeOfDomBindings && isPropertyBinding) {
                if (binding.name !== 'style' && binding.name !== 'class') {
                    if (elId === null) {
                        elId = this.scope.resolve(this.target);
                    }
                    // A direct binding to a property.
                    const propertyName = REGISTRY$1.getMappedPropName(binding.name);
                    const prop = ts.factory.createElementAccessExpression(elId, ts.factory.createStringLiteral(propertyName));
                    const stmt = ts.factory.createBinaryExpression(prop, ts.SyntaxKind.EqualsToken, wrapForDiagnostics(expr));
                    addParseSpanInfo(stmt, binding.sourceSpan);
                    this.scope.addStatement(ts.factory.createExpressionStatement(stmt));
                }
                else {
                    this.scope.addStatement(ts.factory.createExpressionStatement(expr));
                }
            }
            else {
                // A binding to an animation, attribute, class or style. For now, only validate the right-
                // hand side of the expression.
                // TODO: properly check class and style bindings.
                this.scope.addStatement(ts.factory.createExpressionStatement(expr));
            }
        }
        return null;
    }
}
/**
 * A `TcbOp` which generates code to check event bindings on an element that correspond with the
 * outputs of a directive.
 *
 * Executing this operation returns nothing.
 */
class TcbDirectiveOutputsOp extends TcbOp {
    tcb;
    scope;
    node;
    inputs;
    outputs;
    dir;
    constructor(tcb, scope, node, inputs, outputs, dir) {
        super();
        this.tcb = tcb;
        this.scope = scope;
        this.node = node;
        this.inputs = inputs;
        this.outputs = outputs;
        this.dir = dir;
    }
    get optional() {
        return false;
    }
    execute() {
        let dirId = null;
        const outputs = this.dir.outputs;
        for (const output of this.outputs) {
            if (output.type === o.ParsedEventType.LegacyAnimation ||
                !outputs.hasBindingPropertyName(output.name)) {
                continue;
            }
            if (this.tcb.env.config.checkTypeOfOutputEvents &&
                this.inputs !== null &&
                output.name.endsWith('Change')) {
                const inputName = output.name.slice(0, -6);
                checkSplitTwoWayBinding(inputName, output, this.inputs, this.tcb);
            }
            // TODO(alxhub): consider supporting multiple fields with the same property name for outputs.
            const field = outputs.getByBindingPropertyName(output.name)[0].classPropertyName;
            if (dirId === null) {
                dirId = this.scope.resolve(this.node, this.dir);
            }
            const outputField = ts.factory.createElementAccessExpression(dirId, ts.factory.createStringLiteral(field));
            addParseSpanInfo(outputField, output.keySpan);
            if (this.tcb.env.config.checkTypeOfOutputEvents) {
                // For strict checking of directive events, generate a call to the `subscribe` method
                // on the directive's output field to let type information flow into the handler function's
                // `$event` parameter.
                const handler = tcbCreateEventHandler(output, this.tcb, this.scope, 0 /* EventParamType.Infer */);
                const subscribeFn = ts.factory.createPropertyAccessExpression(outputField, 'subscribe');
                const call = ts.factory.createCallExpression(subscribeFn, /* typeArguments */ undefined, [
                    handler,
                ]);
                addParseSpanInfo(call, output.sourceSpan);
                this.scope.addStatement(ts.factory.createExpressionStatement(call));
            }
            else {
                // If strict checking of directive events is disabled:
                //
                // * We still generate the access to the output field as a statement in the TCB so consumers
                //   of the `TemplateTypeChecker` can still find the node for the class member for the
                //   output.
                // * Emit a handler function where the `$event` parameter has an explicit `any` type.
                this.scope.addStatement(ts.factory.createExpressionStatement(outputField));
                const handler = tcbCreateEventHandler(output, this.tcb, this.scope, 1 /* EventParamType.Any */);
                this.scope.addStatement(ts.factory.createExpressionStatement(handler));
            }
        }
        return null;
    }
}
/**
 * A `TcbOp` which generates code to check "unclaimed outputs" - event bindings on an element which
 * were not attributed to any directive or component, and are instead processed against the HTML
 * element itself.
 *
 * Executing this operation returns nothing.
 */
class TcbUnclaimedOutputsOp extends TcbOp {
    tcb;
    scope;
    target;
    outputs;
    inputs;
    claimedOutputs;
    constructor(tcb, scope, target, outputs, inputs, claimedOutputs) {
        super();
        this.tcb = tcb;
        this.scope = scope;
        this.target = target;
        this.outputs = outputs;
        this.inputs = inputs;
        this.claimedOutputs = claimedOutputs;
    }
    get optional() {
        return false;
    }
    execute() {
        let elId = null;
        // TODO(alxhub): this could be more efficient.
        for (const output of this.outputs) {
            if (this.claimedOutputs?.has(output.name)) {
                // Skip this event handler as it was claimed by a directive.
                continue;
            }
            if (this.tcb.env.config.checkTypeOfOutputEvents &&
                this.inputs !== null &&
                output.name.endsWith('Change')) {
                const inputName = output.name.slice(0, -6);
                if (checkSplitTwoWayBinding(inputName, output, this.inputs, this.tcb)) {
                    // Skip this event handler as the error was already handled.
                    continue;
                }
            }
            if (output.type === o.ParsedEventType.LegacyAnimation) {
                // Animation output bindings always have an `$event` parameter of type `AnimationEvent`.
                const eventType = this.tcb.env.config.checkTypeOfAnimationEvents
                    ? this.tcb.env.referenceExternalType('@angular/animations', 'AnimationEvent')
                    : 1 /* EventParamType.Any */;
                const handler = tcbCreateEventHandler(output, this.tcb, this.scope, eventType);
                this.scope.addStatement(ts.factory.createExpressionStatement(handler));
            }
            else if (output.type === o.ParsedEventType.Animation) {
                const eventType = this.tcb.env.referenceExternalType('@angular/core', 'AnimationCallbackEvent');
                const handler = tcbCreateEventHandler(output, this.tcb, this.scope, eventType);
                this.scope.addStatement(ts.factory.createExpressionStatement(handler));
            }
            else if (this.tcb.env.config.checkTypeOfDomEvents) {
                // If strict checking of DOM events is enabled, generate a call to `addEventListener` on
                // the element instance so that TypeScript's type inference for
                // `HTMLElement.addEventListener` using `HTMLElementEventMap` to infer an accurate type for
                // `$event` depending on the event name. For unknown event names, TypeScript resorts to the
                // base `Event` type.
                let target;
                let domEventAssertion;
                // Only check for `window` and `document` since in theory any target can be passed.
                if (output.target === 'window' || output.target === 'document') {
                    target = ts.factory.createIdentifier(output.target);
                }
                else if (elId === null) {
                    target = elId = this.scope.resolve(this.target);
                }
                else {
                    target = elId;
                }
                // By default the target of an event is `EventTarget | null`, because of bubbling
                // and custom events. This can be inconvenient in some common cases like `input` elements
                // since we don't have the ability to type cast in templates. We can improve the type
                // checking for some of these cases by inferring the target based on the element it was
                // bound to. We can only do this safely if the element is a void element (e.g. `input` or
                // `img`), because we know that it couldn't have bubbled from a child. The event handler
                // with the assertion would look as follows:
                //
                // ```
                // const _t1 = document.createElement('input');
                //
                // _t1.addEventListener('input', ($event) => {
                //   ÉµassertType<typeof _t1>($event.target);
                //   handler($event.target);
                // });
                // ```
                if (this.target instanceof o.TmplAstElement &&
                    this.target.isVoid &&
                    ts.isIdentifier(target) &&
                    this.tcb.env.config.allowDomEventAssertion) {
                    domEventAssertion = ts.factory.createCallExpression(this.tcb.env.referenceExternalSymbol('@angular/core', 'ÉµassertType'), [ts.factory.createTypeQueryNode(target)], [
                        ts.factory.createPropertyAccessExpression(ts.factory.createIdentifier(EVENT_PARAMETER), 'target'),
                    ]);
                }
                const propertyAccess = ts.factory.createPropertyAccessExpression(target, 'addEventListener');
                addParseSpanInfo(propertyAccess, output.keySpan);
                const handler = tcbCreateEventHandler(output, this.tcb, this.scope, 0 /* EventParamType.Infer */, domEventAssertion);
                const call = ts.factory.createCallExpression(
                /* expression */ propertyAccess, 
                /* typeArguments */ undefined, 
                /* arguments */ [ts.factory.createStringLiteral(output.name), handler]);
                addParseSpanInfo(call, output.sourceSpan);
                this.scope.addStatement(ts.factory.createExpressionStatement(call));
            }
            else {
                // If strict checking of DOM inputs is disabled, emit a handler function where the `$event`
                // parameter has an explicit `any` type.
                const handler = tcbCreateEventHandler(output, this.tcb, this.scope, 1 /* EventParamType.Any */);
                this.scope.addStatement(ts.factory.createExpressionStatement(handler));
            }
        }
        return null;
    }
}
/**
 * A `TcbOp` which generates a completion point for the component context.
 *
 * This completion point looks like `this. ;` in the TCB output, and does not produce diagnostics.
 * TypeScript autocompletion APIs can be used at this completion point (after the '.') to produce
 * autocompletion results of properties and methods from the template's component context.
 */
class TcbComponentContextCompletionOp extends TcbOp {
    scope;
    constructor(scope) {
        super();
        this.scope = scope;
    }
    optional = false;
    execute() {
        const ctx = ts.factory.createThis();
        const ctxDot = ts.factory.createPropertyAccessExpression(ctx, '');
        markIgnoreDiagnostics(ctxDot);
        addExpressionIdentifier(ctxDot, ExpressionIdentifier.COMPONENT_COMPLETION);
        this.scope.addStatement(ts.factory.createExpressionStatement(ctxDot));
        return null;
    }
}
/**
 * A `TcbOp` which renders a variable defined inside of block syntax (e.g. `@if (expr; as var) {}`).
 *
 * Executing this operation returns the identifier which can be used to refer to the variable.
 */
class TcbBlockVariableOp extends TcbOp {
    tcb;
    scope;
    initializer;
    variable;
    constructor(tcb, scope, initializer, variable) {
        super();
        this.tcb = tcb;
        this.scope = scope;
        this.initializer = initializer;
        this.variable = variable;
    }
    get optional() {
        return false;
    }
    execute() {
        const id = this.tcb.allocateId();
        addParseSpanInfo(id, this.variable.keySpan);
        const variable = tsCreateVariable(id, wrapForTypeChecker(this.initializer));
        addParseSpanInfo(variable.declarationList.declarations[0], this.variable.sourceSpan);
        this.scope.addStatement(variable);
        return id;
    }
}
/**
 * A `TcbOp` which renders a variable that is implicitly available within a block (e.g. `$count`
 * in a `@for` block).
 *
 * Executing this operation returns the identifier which can be used to refer to the variable.
 */
class TcbBlockImplicitVariableOp extends TcbOp {
    tcb;
    scope;
    type;
    variable;
    constructor(tcb, scope, type, variable) {
        super();
        this.tcb = tcb;
        this.scope = scope;
        this.type = type;
        this.variable = variable;
    }
    optional = true;
    execute() {
        const id = this.tcb.allocateId();
        addParseSpanInfo(id, this.variable.keySpan);
        const variable = tsDeclareVariable(id, this.type);
        addParseSpanInfo(variable.declarationList.declarations[0], this.variable.sourceSpan);
        this.scope.addStatement(variable);
        return id;
    }
}
/**
 * A `TcbOp` which renders an `if` template block as a TypeScript `if` statement.
 *
 * Executing this operation returns nothing.
 */
class TcbIfOp extends TcbOp {
    tcb;
    scope;
    block;
    expressionScopes = new Map();
    constructor(tcb, scope, block) {
        super();
        this.tcb = tcb;
        this.scope = scope;
        this.block = block;
    }
    get optional() {
        return false;
    }
    execute() {
        const root = this.generateBranch(0);
        root && this.scope.addStatement(root);
        return null;
    }
    generateBranch(index) {
        const branch = this.block.branches[index];
        if (!branch) {
            return undefined;
        }
        // If the expression is null, it means that it's an `else` statement.
        if (branch.expression === null) {
            const branchScope = this.getBranchScope(this.scope, branch, index);
            return ts.factory.createBlock(branchScope.render());
        }
        // We process the expression first in the parent scope, but create a scope around the block
        // that the body will inherit from. We do this, because we need to declare a separate variable
        // for the case where the expression has an alias _and_ because we need the processed
        // expression when generating the guard for the body.
        const outerScope = Scope.forNodes(this.tcb, this.scope, branch, [], null);
        outerScope.render().forEach((stmt) => this.scope.addStatement(stmt));
        this.expressionScopes.set(branch, outerScope);
        let expression = tcbExpression(branch.expression, this.tcb, this.scope);
        if (branch.expressionAlias !== null) {
            expression = ts.factory.createBinaryExpression(ts.factory.createParenthesizedExpression(expression), ts.SyntaxKind.AmpersandAmpersandToken, outerScope.resolve(branch.expressionAlias));
        }
        const bodyScope = this.getBranchScope(outerScope, branch, index);
        return ts.factory.createIfStatement(expression, ts.factory.createBlock(bodyScope.render()), this.generateBranch(index + 1));
    }
    getBranchScope(parentScope, branch, index) {
        const checkBody = this.tcb.env.config.checkControlFlowBodies;
        return Scope.forNodes(this.tcb, parentScope, null, checkBody ? branch.children : [], checkBody ? this.generateBranchGuard(index) : null);
    }
    generateBranchGuard(index) {
        let guard = null;
        // Since event listeners are inside callbacks, type narrowing doesn't apply to them anymore.
        // To recreate the behavior, we generate an expression that negates all the values of the
        // branches _before_ the current one, and then we add the current branch's expression on top.
        // For example `@if (expr === 1) {} @else if (expr === 2) {} @else if (expr === 3)`, the guard
        // for the last expression will be `!(expr === 1) && !(expr === 2) && expr === 3`.
        for (let i = 0; i <= index; i++) {
            const branch = this.block.branches[i];
            // Skip over branches without an expression.
            if (branch.expression === null) {
                continue;
            }
            // This shouldn't happen since all the state is handled
            // internally, but we have the check just in case.
            if (!this.expressionScopes.has(branch)) {
                throw new Error(`Could not determine expression scope of branch at index ${i}`);
            }
            const expressionScope = this.expressionScopes.get(branch);
            let expression;
            // We need to recreate the expression and mark it to be ignored for diagnostics,
            // because it was already checked as a part of the block's condition and we don't
            // want it to produce a duplicate diagnostic.
            expression = tcbExpression(branch.expression, this.tcb, expressionScope);
            if (branch.expressionAlias !== null) {
                expression = ts.factory.createBinaryExpression(ts.factory.createParenthesizedExpression(expression), ts.SyntaxKind.AmpersandAmpersandToken, expressionScope.resolve(branch.expressionAlias));
            }
            markIgnoreDiagnostics(expression);
            // The expressions of the preceding branches have to be negated
            // (e.g. `expr` becomes `!(expr)`) when comparing in the guard, except
            // for the branch's own expression which is preserved as is.
            const comparisonExpression = i === index
                ? expression
                : ts.factory.createPrefixUnaryExpression(ts.SyntaxKind.ExclamationToken, ts.factory.createParenthesizedExpression(expression));
            // Finally add the expression to the guard with an && operator.
            guard =
                guard === null
                    ? comparisonExpression
                    : ts.factory.createBinaryExpression(guard, ts.SyntaxKind.AmpersandAmpersandToken, comparisonExpression);
        }
        return guard;
    }
}
/**
 * A `TcbOp` which renders a `switch` block as a TypeScript `switch` statement.
 *
 * Executing this operation returns nothing.
 */
class TcbSwitchOp extends TcbOp {
    tcb;
    scope;
    block;
    constructor(tcb, scope, block) {
        super();
        this.tcb = tcb;
        this.scope = scope;
        this.block = block;
    }
    get optional() {
        return false;
    }
    execute() {
        const switchExpression = tcbExpression(this.block.expression, this.tcb, this.scope);
        const clauses = this.block.cases.map((current) => {
            const checkBody = this.tcb.env.config.checkControlFlowBodies;
            const clauseScope = Scope.forNodes(this.tcb, this.scope, null, checkBody ? current.children : [], checkBody ? this.generateGuard(current, switchExpression) : null);
            const statements = [...clauseScope.render(), ts.factory.createBreakStatement()];
            return current.expression === null
                ? ts.factory.createDefaultClause(statements)
                : ts.factory.createCaseClause(tcbExpression(current.expression, this.tcb, clauseScope), statements);
        });
        this.scope.addStatement(ts.factory.createSwitchStatement(switchExpression, ts.factory.createCaseBlock(clauses)));
        return null;
    }
    generateGuard(node, switchValue) {
        // For non-default cases, the guard needs to compare against the case value, e.g.
        // `switchExpression === caseExpression`.
        if (node.expression !== null) {
            // The expression needs to be ignored for diagnostics since it has been checked already.
            const expression = tcbExpression(node.expression, this.tcb, this.scope);
            markIgnoreDiagnostics(expression);
            return ts.factory.createBinaryExpression(switchValue, ts.SyntaxKind.EqualsEqualsEqualsToken, expression);
        }
        // To fully narrow the type in the default case, we need to generate an expression that negates
        // the values of all of the other expressions. For example:
        // @switch (expr) {
        //   @case (1) {}
        //   @case (2) {}
        //   @default {}
        // }
        // Will produce the guard `expr !== 1 && expr !== 2`.
        let guard = null;
        for (const current of this.block.cases) {
            if (current.expression === null) {
                continue;
            }
            // The expression needs to be ignored for diagnostics since it has been checked already.
            const expression = tcbExpression(current.expression, this.tcb, this.scope);
            markIgnoreDiagnostics(expression);
            const comparison = ts.factory.createBinaryExpression(switchValue, ts.SyntaxKind.ExclamationEqualsEqualsToken, expression);
            if (guard === null) {
                guard = comparison;
            }
            else {
                guard = ts.factory.createBinaryExpression(guard, ts.SyntaxKind.AmpersandAmpersandToken, comparison);
            }
        }
        return guard;
    }
}
/**
 * A `TcbOp` which renders a `for` block as a TypeScript `for...of` loop.
 *
 * Executing this operation returns nothing.
 */
class TcbForOfOp extends TcbOp {
    tcb;
    scope;
    block;
    constructor(tcb, scope, block) {
        super();
        this.tcb = tcb;
        this.scope = scope;
        this.block = block;
    }
    get optional() {
        return false;
    }
    execute() {
        const loopScope = Scope.forNodes(this.tcb, this.scope, this.block, this.tcb.env.config.checkControlFlowBodies ? this.block.children : [], null);
        const initializerId = loopScope.resolve(this.block.item);
        if (!ts.isIdentifier(initializerId)) {
            throw new Error(`Could not resolve for loop variable ${this.block.item.name} to an identifier`);
        }
        const initializer = ts.factory.createVariableDeclarationList([ts.factory.createVariableDeclaration(initializerId)], ts.NodeFlags.Const);
        addParseSpanInfo(initializer, this.block.item.keySpan);
        // It's common to have a for loop over a nullable value (e.g. produced by the `async` pipe).
        // Add a non-null expression to allow such values to be assigned.
        const expression = ts.factory.createNonNullExpression(tcbExpression(this.block.expression, this.tcb, this.scope));
        const trackTranslator = new TcbForLoopTrackTranslator(this.tcb, loopScope, this.block);
        const trackExpression = trackTranslator.translate(this.block.trackBy);
        const statements = [
            ...loopScope.render(),
            ts.factory.createExpressionStatement(trackExpression),
        ];
        this.scope.addStatement(ts.factory.createForOfStatement(undefined, initializer, expression, ts.factory.createBlock(statements)));
        return null;
    }
}
/**
 * A `TcbOp` which can be used to type check the options of an `IntersectionObserver`.
 */
class TcbIntersectionObserverOp extends TcbOp {
    tcb;
    scope;
    options;
    constructor(tcb, scope, options) {
        super();
        this.tcb = tcb;
        this.scope = scope;
        this.options = options;
    }
    optional = false;
    execute() {
        const options = tcbExpression(this.options, this.tcb, this.scope);
        const callback = ts.factory.createNonNullExpression(ts.factory.createNull());
        const expression = ts.factory.createNewExpression(ts.factory.createIdentifier('IntersectionObserver'), undefined, [callback, options]);
        this.scope.addStatement(ts.factory.createExpressionStatement(expression));
        return null;
    }
}
/**
 * Overall generation context for the type check block.
 *
 * `Context` handles operations during code generation which are global with respect to the whole
 * block. It's responsible for variable name allocation and management of any imports needed. It
 * also contains the template metadata itself.
 */
class Context {
    env;
    domSchemaChecker;
    oobRecorder;
    id;
    boundTarget;
    pipes;
    schemas;
    hostIsStandalone;
    hostPreserveWhitespaces;
    nextId = 1;
    constructor(env, domSchemaChecker, oobRecorder, id, boundTarget, pipes, schemas, hostIsStandalone, hostPreserveWhitespaces) {
        this.env = env;
        this.domSchemaChecker = domSchemaChecker;
        this.oobRecorder = oobRecorder;
        this.id = id;
        this.boundTarget = boundTarget;
        this.pipes = pipes;
        this.schemas = schemas;
        this.hostIsStandalone = hostIsStandalone;
        this.hostPreserveWhitespaces = hostPreserveWhitespaces;
    }
    /**
     * Allocate a new variable name for use within the `Context`.
     *
     * Currently this uses a monotonically increasing counter, but in the future the variable name
     * might change depending on the type of data being stored.
     */
    allocateId() {
        return ts.factory.createIdentifier(`_t${this.nextId++}`);
    }
    getPipeByName(name) {
        if (this.pipes === null || !this.pipes.has(name)) {
            return null;
        }
        return this.pipes.get(name);
    }
}
/**
 * Local scope within the type check block for a particular template.
 *
 * The top-level template and each nested `<ng-template>` have their own `Scope`, which exist in a
 * hierarchy. The structure of this hierarchy mirrors the syntactic scopes in the generated type
 * check block, where each nested template is encased in an `if` structure.
 *
 * As a template's `TcbOp`s are executed in a given `Scope`, statements are added via
 * `addStatement()`. When this processing is complete, the `Scope` can be turned into a `ts.Block`
 * via `renderToBlock()`.
 *
 * If a `TcbOp` requires the output of another, it can call `resolve()`.
 */
class Scope {
    tcb;
    parent;
    guard;
    /**
     * A queue of operations which need to be performed to generate the TCB code for this scope.
     *
     * This array can contain either a `TcbOp` which has yet to be executed, or a `ts.Expression|null`
     * representing the memoized result of executing the operation. As operations are executed, their
     * results are written into the `opQueue`, overwriting the original operation.
     *
     * If an operation is in the process of being executed, it is temporarily overwritten here with
     * `INFER_TYPE_FOR_CIRCULAR_OP_EXPR`. This way, if a cycle is encountered where an operation
     * depends transitively on its own result, the inner operation will infer the least narrow type
     * that fits instead. This has the same semantics as TypeScript itself when types are referenced
     * circularly.
     */
    opQueue = [];
    /**
     * A map of `TmplAstElement`s to the index of their `TcbElementOp` in the `opQueue`
     */
    elementOpMap = new Map();
    /**
     * A map of `TmplAstHostElement`s to the index of their `TcbHostElementOp` in the `opQueue`
     */
    hostElementOpMap = new Map();
    /**
     * A map of `TmplAstComponent`s to the index of their `TcbComponentNodeOp` in the `opQueue`
     */
    componentNodeOpMap = new Map();
    /**
     * A map of maps which tracks the index of `TcbDirectiveCtorOp`s in the `opQueue` for each
     * directive on a `TmplAstElement` or `TmplAstTemplate` node.
     */
    directiveOpMap = new Map();
    /**
     * A map of `TmplAstReference`s to the index of their `TcbReferenceOp` in the `opQueue`
     */
    referenceOpMap = new Map();
    /**
     * Map of immediately nested <ng-template>s (within this `Scope`) represented by `TmplAstTemplate`
     * nodes to the index of their `TcbTemplateContextOp`s in the `opQueue`.
     */
    templateCtxOpMap = new Map();
    /**
     * Map of variables declared on the template that created this `Scope` (represented by
     * `TmplAstVariable` nodes) to the index of their `TcbVariableOp`s in the `opQueue`, or to
     * pre-resolved variable identifiers.
     */
    varMap = new Map();
    /**
     * A map of the names of `TmplAstLetDeclaration`s to the index of their op in the `opQueue`.
     *
     * Assumes that there won't be duplicated `@let` declarations within the same scope.
     */
    letDeclOpMap = new Map();
    /**
     * Statements for this template.
     *
     * Executing the `TcbOp`s in the `opQueue` populates this array.
     */
    statements = [];
    /**
     * Gets names of the for loop context variables and their types.
     */
    static getForLoopContextVariableTypes() {
        return new Map([
            ['$first', ts.SyntaxKind.BooleanKeyword],
            ['$last', ts.SyntaxKind.BooleanKeyword],
            ['$even', ts.SyntaxKind.BooleanKeyword],
            ['$odd', ts.SyntaxKind.BooleanKeyword],
            ['$index', ts.SyntaxKind.NumberKeyword],
            ['$count', ts.SyntaxKind.NumberKeyword],
        ]);
    }
    constructor(tcb, parent = null, guard = null) {
        this.tcb = tcb;
        this.parent = parent;
        this.guard = guard;
    }
    /**
     * Constructs a `Scope` given either a `TmplAstTemplate` or a list of `TmplAstNode`s.
     *
     * @param tcb the overall context of TCB generation.
     * @param parentScope the `Scope` of the parent template (if any) or `null` if this is the root
     * `Scope`.
     * @param scopedNode Node that provides the scope around the child nodes (e.g. a
     * `TmplAstTemplate` node exposing variables to its children).
     * @param children Child nodes that should be appended to the TCB.
     * @param guard an expression that is applied to this scope for type narrowing purposes.
     */
    static forNodes(tcb, parentScope, scopedNode, children, guard) {
        const scope = new Scope(tcb, parentScope, guard);
        if (parentScope === null && tcb.env.config.enableTemplateTypeChecker) {
            // Add an autocompletion point for the component context.
            scope.opQueue.push(new TcbComponentContextCompletionOp(scope));
        }
        // If given an actual `TmplAstTemplate` instance, then process any additional information it
        // has.
        if (scopedNode instanceof o.TmplAstTemplate) {
            // The template's variable declarations need to be added as `TcbVariableOp`s.
            const varMap = new Map();
            for (const v of scopedNode.variables) {
                // Validate that variables on the `TmplAstTemplate` are only declared once.
                if (!varMap.has(v.name)) {
                    varMap.set(v.name, v);
                }
                else {
                    const firstDecl = varMap.get(v.name);
                    tcb.oobRecorder.duplicateTemplateVar(tcb.id, v, firstDecl);
                }
                Scope.registerVariable(scope, v, new TcbTemplateVariableOp(tcb, scope, scopedNode, v));
            }
        }
        else if (scopedNode instanceof o.TmplAstIfBlockBranch) {
            const { expression, expressionAlias } = scopedNode;
            if (expression !== null && expressionAlias !== null) {
                Scope.registerVariable(scope, expressionAlias, new TcbBlockVariableOp(tcb, scope, tcbExpression(expression, tcb, scope), expressionAlias));
            }
        }
        else if (scopedNode instanceof o.TmplAstForLoopBlock) {
            // Register the variable for the loop so it can be resolved by
            // children. It'll be declared once the loop is created.
            const loopInitializer = tcb.allocateId();
            addParseSpanInfo(loopInitializer, scopedNode.item.sourceSpan);
            scope.varMap.set(scopedNode.item, loopInitializer);
            const forLoopContextVariableTypes = Scope.getForLoopContextVariableTypes();
            for (const variable of scopedNode.contextVariables) {
                if (!forLoopContextVariableTypes.has(variable.value)) {
                    throw new Error(`Unrecognized for loop context variable ${variable.name}`);
                }
                const type = ts.factory.createKeywordTypeNode(forLoopContextVariableTypes.get(variable.value));
                Scope.registerVariable(scope, variable, new TcbBlockImplicitVariableOp(tcb, scope, type, variable));
            }
        }
        else if (scopedNode instanceof o.TmplAstHostElement) {
            scope.appendNode(scopedNode);
        }
        if (children !== null) {
            for (const node of children) {
                scope.appendNode(node);
            }
        }
        // Once everything is registered, we need to check if there are `@let`
        // declarations that conflict with other local symbols defined after them.
        for (const variable of scope.varMap.keys()) {
            Scope.checkConflictingLet(scope, variable);
        }
        for (const ref of scope.referenceOpMap.keys()) {
            Scope.checkConflictingLet(scope, ref);
        }
        return scope;
    }
    /** Registers a local variable with a scope. */
    static registerVariable(scope, variable, op) {
        const opIndex = scope.opQueue.push(op) - 1;
        scope.varMap.set(variable, opIndex);
    }
    /**
     * Look up a `ts.Expression` representing the value of some operation in the current `Scope`,
     * including any parent scope(s). This method always returns a mutable clone of the
     * `ts.Expression` with the comments cleared.
     *
     * @param node a `TmplAstNode` of the operation in question. The lookup performed will depend on
     * the type of this node:
     *
     * Assuming `directive` is not present, then `resolve` will return:
     *
     * * `TmplAstElement` - retrieve the expression for the element DOM node
     * * `TmplAstTemplate` - retrieve the template context variable
     * * `TmplAstVariable` - retrieve a template let- variable
     * * `TmplAstLetDeclaration` - retrieve a template `@let` declaration
     * * `TmplAstReference` - retrieve variable created for the local ref
     *
     * @param directive if present, a directive type on a `TmplAstElement` or `TmplAstTemplate` to
     * look up instead of the default for an element or template node.
     */
    resolve(node, directive) {
        // Attempt to resolve the operation locally.
        const res = this.resolveLocal(node, directive);
        if (res !== null) {
            // We want to get a clone of the resolved expression and clear the trailing comments
            // so they don't continue to appear in every place the expression is used.
            // As an example, this would otherwise produce:
            // var _t1 /**T:DIR*/ /*1,2*/ = _ctor1();
            // _t1 /**T:DIR*/ /*1,2*/.input = 'value';
            //
            // In addition, returning a clone prevents the consumer of `Scope#resolve` from
            // attaching comments at the declaration site.
            let clone;
            if (ts.isIdentifier(res)) {
                clone = ts.factory.createIdentifier(res.text);
            }
            else if (ts.isNonNullExpression(res)) {
                clone = ts.factory.createNonNullExpression(res.expression);
            }
            else {
                throw new Error(`Could not resolve ${node} to an Identifier or a NonNullExpression`);
            }
            ts.setOriginalNode(clone, res);
            clone.parent = clone.parent;
            return ts.setSyntheticTrailingComments(clone, []);
        }
        else if (this.parent !== null) {
            // Check with the parent.
            return this.parent.resolve(node, directive);
        }
        else {
            throw new Error(`Could not resolve ${node} / ${directive}`);
        }
    }
    /**
     * Add a statement to this scope.
     */
    addStatement(stmt) {
        this.statements.push(stmt);
    }
    /**
     * Get the statements.
     */
    render() {
        for (let i = 0; i < this.opQueue.length; i++) {
            // Optional statements cannot be skipped when we are generating the TCB for use
            // by the TemplateTypeChecker.
            const skipOptional = !this.tcb.env.config.enableTemplateTypeChecker;
            this.executeOp(i, skipOptional);
        }
        return this.statements;
    }
    /**
     * Returns an expression of all template guards that apply to this scope, including those of
     * parent scopes. If no guards have been applied, null is returned.
     */
    guards() {
        let parentGuards = null;
        if (this.parent !== null) {
            // Start with the guards from the parent scope, if present.
            parentGuards = this.parent.guards();
        }
        if (this.guard === null) {
            // This scope does not have a guard, so return the parent's guards as is.
            return parentGuards;
        }
        else if (parentGuards === null) {
            // There's no guards from the parent scope, so this scope's guard represents all available
            // guards.
            return this.guard;
        }
        else {
            // Both the parent scope and this scope provide a guard, so create a combination of the two.
            // It is important that the parent guard is used as left operand, given that it may provide
            // narrowing that is required for this scope's guard to be valid.
            return ts.factory.createBinaryExpression(parentGuards, ts.SyntaxKind.AmpersandAmpersandToken, this.guard);
        }
    }
    /** Returns whether a template symbol is defined locally within the current scope. */
    isLocal(node) {
        if (node instanceof o.TmplAstVariable) {
            return this.varMap.has(node);
        }
        if (node instanceof o.TmplAstLetDeclaration) {
            return this.letDeclOpMap.has(node.name);
        }
        return this.referenceOpMap.has(node);
    }
    resolveLocal(ref, directive) {
        if (ref instanceof o.TmplAstReference && this.referenceOpMap.has(ref)) {
            return this.resolveOp(this.referenceOpMap.get(ref));
        }
        else if (ref instanceof o.TmplAstLetDeclaration && this.letDeclOpMap.has(ref.name)) {
            return this.resolveOp(this.letDeclOpMap.get(ref.name).opIndex);
        }
        else if (ref instanceof o.TmplAstVariable && this.varMap.has(ref)) {
            // Resolving a context variable for this template.
            // Execute the `TcbVariableOp` associated with the `TmplAstVariable`.
            const opIndexOrNode = this.varMap.get(ref);
            return typeof opIndexOrNode === 'number' ? this.resolveOp(opIndexOrNode) : opIndexOrNode;
        }
        else if (ref instanceof o.TmplAstTemplate &&
            directive === undefined &&
            this.templateCtxOpMap.has(ref)) {
            // Resolving the context of the given sub-template.
            // Execute the `TcbTemplateContextOp` for the template.
            return this.resolveOp(this.templateCtxOpMap.get(ref));
        }
        else if ((ref instanceof o.TmplAstElement ||
            ref instanceof o.TmplAstTemplate ||
            ref instanceof o.TmplAstComponent ||
            ref instanceof o.TmplAstDirective ||
            ref instanceof o.TmplAstHostElement) &&
            directive !== undefined &&
            this.directiveOpMap.has(ref)) {
            // Resolving a directive on an element or sub-template.
            const dirMap = this.directiveOpMap.get(ref);
            return dirMap.has(directive) ? this.resolveOp(dirMap.get(directive)) : null;
        }
        else if (ref instanceof o.TmplAstElement && this.elementOpMap.has(ref)) {
            // Resolving the DOM node of an element in this template.
            return this.resolveOp(this.elementOpMap.get(ref));
        }
        else if (ref instanceof o.TmplAstComponent && this.componentNodeOpMap.has(ref)) {
            return this.resolveOp(this.componentNodeOpMap.get(ref));
        }
        else if (ref instanceof o.TmplAstHostElement && this.hostElementOpMap.has(ref)) {
            return this.resolveOp(this.hostElementOpMap.get(ref));
        }
        else {
            return null;
        }
    }
    /**
     * Like `executeOp`, but assert that the operation actually returned `ts.Expression`.
     */
    resolveOp(opIndex) {
        const res = this.executeOp(opIndex, /* skipOptional */ false);
        if (res === null) {
            throw new Error(`Error resolving operation, got null`);
        }
        return res;
    }
    /**
     * Execute a particular `TcbOp` in the `opQueue`.
     *
     * This method replaces the operation in the `opQueue` with the result of execution (once done)
     * and also protects against a circular dependency from the operation to itself by temporarily
     * setting the operation's result to a special expression.
     */
    executeOp(opIndex, skipOptional) {
        const op = this.opQueue[opIndex];
        if (!(op instanceof TcbOp)) {
            return op;
        }
        if (skipOptional && op.optional) {
            return null;
        }
        // Set the result of the operation in the queue to its circular fallback. If executing this
        // operation results in a circular dependency, this will prevent an infinite loop and allow for
        // the resolution of such cycles.
        this.opQueue[opIndex] = op.circularFallback();
        const res = op.execute();
        // Once the operation has finished executing, it's safe to cache the real result.
        this.opQueue[opIndex] = res;
        return res;
    }
    appendNode(node) {
        if (node instanceof o.TmplAstElement) {
            const opIndex = this.opQueue.push(new TcbElementOp(this.tcb, this, node)) - 1;
            this.elementOpMap.set(node, opIndex);
            if (this.tcb.env.config.controlFlowPreventingContentProjection !== 'suppress') {
                this.appendContentProjectionCheckOp(node);
            }
            this.appendDirectivesAndInputsOfElementLikeNode(node);
            this.appendOutputsOfElementLikeNode(node, node.inputs, node.outputs);
            this.appendSelectorlessDirectives(node);
            this.appendChildren(node);
            this.checkAndAppendReferencesOfNode(node);
        }
        else if (node instanceof o.TmplAstTemplate) {
            // Template children are rendered in a child scope.
            this.appendDirectivesAndInputsOfElementLikeNode(node);
            this.appendOutputsOfElementLikeNode(node, node.inputs, node.outputs);
            this.appendSelectorlessDirectives(node);
            const ctxIndex = this.opQueue.push(new TcbTemplateContextOp(this.tcb, this)) - 1;
            this.templateCtxOpMap.set(node, ctxIndex);
            if (this.tcb.env.config.checkTemplateBodies) {
                this.opQueue.push(new TcbTemplateBodyOp(this.tcb, this, node));
            }
            else if (this.tcb.env.config.alwaysCheckSchemaInTemplateBodies) {
                this.appendDeepSchemaChecks(node.children);
            }
            this.checkAndAppendReferencesOfNode(node);
        }
        else if (node instanceof o.TmplAstComponent) {
            this.appendComponentNode(node);
        }
        else if (node instanceof o.TmplAstDeferredBlock) {
            this.appendDeferredBlock(node);
        }
        else if (node instanceof o.TmplAstIfBlock) {
            this.opQueue.push(new TcbIfOp(this.tcb, this, node));
        }
        else if (node instanceof o.TmplAstSwitchBlock) {
            this.opQueue.push(new TcbSwitchOp(this.tcb, this, node));
        }
        else if (node instanceof o.TmplAstForLoopBlock) {
            this.opQueue.push(new TcbForOfOp(this.tcb, this, node));
            node.empty && this.tcb.env.config.checkControlFlowBodies && this.appendChildren(node.empty);
        }
        else if (node instanceof o.TmplAstBoundText) {
            this.opQueue.push(new TcbExpressionOp(this.tcb, this, node.value));
        }
        else if (node instanceof o.TmplAstIcu) {
            this.appendIcuExpressions(node);
        }
        else if (node instanceof o.TmplAstContent) {
            this.appendChildren(node);
        }
        else if (node instanceof o.TmplAstLetDeclaration) {
            const opIndex = this.opQueue.push(new TcbLetDeclarationOp(this.tcb, this, node)) - 1;
            if (this.isLocal(node)) {
                this.tcb.oobRecorder.conflictingDeclaration(this.tcb.id, node);
            }
            else {
                this.letDeclOpMap.set(node.name, { opIndex, node });
            }
        }
        else if (node instanceof o.TmplAstHostElement) {
            this.appendHostElement(node);
        }
    }
    appendChildren(node) {
        for (const child of node.children) {
            this.appendNode(child);
        }
    }
    checkAndAppendReferencesOfNode(node) {
        for (const ref of node.references) {
            const target = this.tcb.boundTarget.getReferenceTarget(ref);
            let ctxIndex;
            if (target === null) {
                // The reference is invalid if it doesn't have a target, so report it as an error.
                this.tcb.oobRecorder.missingReferenceTarget(this.tcb.id, ref);
                // Any usages of the invalid reference will be resolved to a variable of type any.
                ctxIndex = this.opQueue.push(new TcbInvalidReferenceOp(this.tcb, this)) - 1;
            }
            else if (target instanceof o.TmplAstTemplate || target instanceof o.TmplAstElement) {
                ctxIndex = this.opQueue.push(new TcbReferenceOp(this.tcb, this, ref, node, target)) - 1;
            }
            else {
                ctxIndex =
                    this.opQueue.push(new TcbReferenceOp(this.tcb, this, ref, node, target.directive)) - 1;
            }
            this.referenceOpMap.set(ref, ctxIndex);
        }
    }
    appendDirectivesAndInputsOfElementLikeNode(node) {
        // Collect all the inputs on the element.
        const claimedInputs = new Set();
        // Don't resolve directives when selectorless is enabled and treat all the inputs on the element
        // as unclaimed. In selectorless the inputs are defined either in component or directive nodes.
        const directives = this.tcb.boundTarget.getDirectivesOfNode(node);
        if (directives === null || directives.length === 0) {
            // If there are no directives, then all inputs are unclaimed inputs, so queue an operation
            // to add them if needed.
            if (node instanceof o.TmplAstElement) {
                this.opQueue.push(new TcbUnclaimedInputsOp(this.tcb, this, node.inputs, node, claimedInputs), new TcbDomSchemaCheckerOp(this.tcb, node, /* checkElement */ true, claimedInputs));
            }
            return;
        }
        if (node instanceof o.TmplAstElement) {
            const isDeferred = this.tcb.boundTarget.isDeferred(node);
            if (!isDeferred && directives.some((dirMeta) => dirMeta.isExplicitlyDeferred)) {
                // This node has directives/components that were defer-loaded (included into
                // `@Component.deferredImports`), but the node itself was used outside of a
                // `@defer` block, which is the error.
                this.tcb.oobRecorder.deferredComponentUsedEagerly(this.tcb.id, node);
            }
        }
        const dirMap = new Map();
        for (const dir of directives) {
            this.appendDirectiveInputs(dir, node, dirMap);
        }
        this.directiveOpMap.set(node, dirMap);
        // After expanding the directives, we might need to queue an operation to check any unclaimed
        // inputs.
        if (node instanceof o.TmplAstElement) {
            // Go through the directives and remove any inputs that it claims from `elementInputs`.
            for (const dir of directives) {
                for (const propertyName of dir.inputs.propertyNames) {
                    claimedInputs.add(propertyName);
                }
            }
            this.opQueue.push(new TcbUnclaimedInputsOp(this.tcb, this, node.inputs, node, claimedInputs));
            // If there are no directives which match this element, then it's a "plain" DOM element (or a
            // web component), and should be checked against the DOM schema. If any directives match,
            // we must assume that the element could be custom (either a component, or a directive like
            // <router-outlet>) and shouldn't validate the element name itself.
            const checkElement = directives.length === 0;
            this.opQueue.push(new TcbDomSchemaCheckerOp(this.tcb, node, checkElement, claimedInputs));
        }
    }
    appendOutputsOfElementLikeNode(node, bindings, events) {
        // Collect all the outputs on the element.
        const claimedOutputs = new Set();
        // Don't resolve directives when selectorless is enabled and treat all the outputs on the
        // element as unclaimed. In selectorless the outputs are defined either in component or
        // directive nodes.
        const directives = this.tcb.boundTarget.getDirectivesOfNode(node);
        if (directives === null || directives.length === 0) {
            // If there are no directives, then all outputs are unclaimed outputs, so queue an operation
            // to add them if needed.
            if (node instanceof o.TmplAstElement) {
                this.opQueue.push(new TcbUnclaimedOutputsOp(this.tcb, this, node, events, bindings, claimedOutputs));
            }
            return;
        }
        // Queue operations for all directives to check the relevant outputs for a directive.
        for (const dir of directives) {
            this.opQueue.push(new TcbDirectiveOutputsOp(this.tcb, this, node, bindings, events, dir));
        }
        // After expanding the directives, we might need to queue an operation to check any unclaimed
        // outputs.
        if (node instanceof o.TmplAstElement || node instanceof o.TmplAstHostElement) {
            // Go through the directives and register any outputs that it claims in `claimedOutputs`.
            for (const dir of directives) {
                for (const outputProperty of dir.outputs.propertyNames) {
                    claimedOutputs.add(outputProperty);
                }
            }
            this.opQueue.push(new TcbUnclaimedOutputsOp(this.tcb, this, node, events, bindings, claimedOutputs));
        }
    }
    appendInputsOfSelectorlessNode(node) {
        // Only resolve the directives that were brought in by this specific directive.
        const directives = this.tcb.boundTarget.getDirectivesOfNode(node);
        const claimedInputs = new Set();
        if (directives !== null && directives.length > 0) {
            const dirMap = new Map();
            for (const dir of directives) {
                this.appendDirectiveInputs(dir, node, dirMap);
                for (const propertyName of dir.inputs.propertyNames) {
                    claimedInputs.add(propertyName);
                }
            }
            this.directiveOpMap.set(node, dirMap);
        }
        // In selectorless all directive inputs have to be claimed.
        if (node instanceof o.TmplAstDirective) {
            for (const input of node.inputs) {
                if (!claimedInputs.has(input.name)) {
                    this.tcb.oobRecorder.unclaimedDirectiveBinding(this.tcb.id, node, input);
                }
            }
            for (const attr of node.attributes) {
                if (!claimedInputs.has(attr.name)) {
                    this.tcb.oobRecorder.unclaimedDirectiveBinding(this.tcb.id, node, attr);
                }
            }
        }
        else {
            const checkElement = node.tagName !== null;
            this.opQueue.push(new TcbUnclaimedInputsOp(this.tcb, this, node.inputs, node, claimedInputs), new TcbDomSchemaCheckerOp(this.tcb, node, checkElement, claimedInputs));
        }
    }
    appendOutputsOfSelectorlessNode(node) {
        // Only resolve the directives that were brought in by this specific directive.
        const directives = this.tcb.boundTarget.getDirectivesOfNode(node);
        const claimedOutputs = new Set();
        if (directives !== null && directives.length > 0) {
            for (const dir of directives) {
                this.opQueue.push(new TcbDirectiveOutputsOp(this.tcb, this, node, node.inputs, node.outputs, dir));
                for (const outputProperty of dir.outputs.propertyNames) {
                    claimedOutputs.add(outputProperty);
                }
            }
        }
        // In selectorless all directive outputs have to be claimed.
        if (node instanceof o.TmplAstDirective) {
            for (const output of node.outputs) {
                if (!claimedOutputs.has(output.name)) {
                    this.tcb.oobRecorder.unclaimedDirectiveBinding(this.tcb.id, node, output);
                }
            }
        }
        else {
            this.opQueue.push(new TcbUnclaimedOutputsOp(this.tcb, this, node, node.outputs, node.inputs, claimedOutputs));
        }
    }
    appendDirectiveInputs(dir, node, dirMap) {
        const directiveOp = this.getDirectiveOp(dir, node);
        const dirIndex = this.opQueue.push(directiveOp) - 1;
        dirMap.set(dir, dirIndex);
        this.opQueue.push(new TcbDirectiveInputsOp(this.tcb, this, node, dir));
    }
    getDirectiveOp(dir, node) {
        const dirRef = dir.ref;
        if (!dir.isGeneric) {
            // The most common case is that when a directive is not generic, we use the normal
            // `TcbNonDirectiveTypeOp`.
            return new TcbNonGenericDirectiveTypeOp(this.tcb, this, node, dir);
        }
        else if (!requiresInlineTypeCtor(dirRef.node, this.tcb.env.reflector, this.tcb.env) ||
            this.tcb.env.config.useInlineTypeConstructors) {
            // For generic directives, we use a type constructor to infer types. If a directive requires
            // an inline type constructor, then inlining must be available to use the
            // `TcbDirectiveCtorOp`. If not we, we fallback to using `any` â see below.
            return new TcbDirectiveCtorOp(this.tcb, this, node, dir);
        }
        // If inlining is not available, then we give up on inferring the generic params, and use
        // `any` type for the directive's generic parameters.
        return new TcbGenericDirectiveTypeWithAnyParamsOp(this.tcb, this, node, dir);
    }
    appendSelectorlessDirectives(node) {
        for (const directive of node.directives) {
            // Check that the directive exists.
            if (!this.tcb.boundTarget.referencedDirectiveExists(directive.name)) {
                this.tcb.oobRecorder.missingNamedTemplateDependency(this.tcb.id, directive);
                continue;
            }
            // Check that the class is a directive class.
            const directives = this.tcb.boundTarget.getDirectivesOfNode(directive);
            if (directives === null ||
                directives.length === 0 ||
                directives.some((dir) => dir.isComponent || !dir.isStandalone)) {
                this.tcb.oobRecorder.incorrectTemplateDependencyType(this.tcb.id, directive);
                continue;
            }
            this.appendInputsOfSelectorlessNode(directive);
            this.appendOutputsOfSelectorlessNode(directive);
            this.checkAndAppendReferencesOfNode(directive);
        }
    }
    appendDeepSchemaChecks(nodes) {
        for (const node of nodes) {
            if (!(node instanceof o.TmplAstElement || node instanceof o.TmplAstTemplate)) {
                continue;
            }
            if (node instanceof o.TmplAstElement) {
                const claimedInputs = new Set();
                let directives = this.tcb.boundTarget.getDirectivesOfNode(node);
                for (const dirNode of node.directives) {
                    const directiveResults = this.tcb.boundTarget.getDirectivesOfNode(dirNode);
                    if (directiveResults !== null && directiveResults.length > 0) {
                        directives ??= [];
                        directives.push(...directiveResults);
                    }
                }
                let hasDirectives;
                if (directives === null || directives.length === 0) {
                    hasDirectives = false;
                }
                else {
                    hasDirectives = true;
                    for (const dir of directives) {
                        for (const propertyName of dir.inputs.propertyNames) {
                            claimedInputs.add(propertyName);
                        }
                    }
                }
                this.opQueue.push(new TcbDomSchemaCheckerOp(this.tcb, node, !hasDirectives, claimedInputs));
            }
            this.appendDeepSchemaChecks(node.children);
        }
    }
    appendIcuExpressions(node) {
        for (const variable of Object.values(node.vars)) {
            this.opQueue.push(new TcbExpressionOp(this.tcb, this, variable.value));
        }
        for (const placeholder of Object.values(node.placeholders)) {
            if (placeholder instanceof o.TmplAstBoundText) {
                this.opQueue.push(new TcbExpressionOp(this.tcb, this, placeholder.value));
            }
        }
    }
    appendContentProjectionCheckOp(root) {
        const meta = this.tcb.boundTarget.getDirectivesOfNode(root)?.find((meta) => meta.isComponent) || null;
        if (meta !== null && meta.ngContentSelectors !== null && meta.ngContentSelectors.length > 0) {
            const selectors = meta.ngContentSelectors;
            // We don't need to generate anything for components that don't have projection
            // slots, or they only have one catch-all slot (represented by `*`).
            if (selectors.length > 1 || (selectors.length === 1 && selectors[0] !== '*')) {
                this.opQueue.push(new TcbControlFlowContentProjectionOp(this.tcb, root, selectors, meta.name));
            }
        }
    }
    appendComponentNode(node) {
        // TODO(crisbeto): should we still append the children if the component is invalid?
        // Check that the referenced class exists.
        if (!this.tcb.boundTarget.referencedDirectiveExists(node.componentName)) {
            this.tcb.oobRecorder.missingNamedTemplateDependency(this.tcb.id, node);
            return;
        }
        // Check that the class is a component.
        const directives = this.tcb.boundTarget.getDirectivesOfNode(node);
        if (directives === null ||
            directives.length === 0 ||
            directives.every((dir) => !dir.isComponent || !dir.isStandalone)) {
            this.tcb.oobRecorder.incorrectTemplateDependencyType(this.tcb.id, node);
            return;
        }
        const opIndex = this.opQueue.push(new TcbComponentNodeOp(this.tcb, this, node)) - 1;
        this.componentNodeOpMap.set(node, opIndex);
        if (this.tcb.env.config.controlFlowPreventingContentProjection !== 'suppress') {
            this.appendContentProjectionCheckOp(node);
        }
        this.appendInputsOfSelectorlessNode(node);
        this.appendOutputsOfSelectorlessNode(node);
        this.appendSelectorlessDirectives(node);
        this.appendChildren(node);
        this.checkAndAppendReferencesOfNode(node);
    }
    appendDeferredBlock(block) {
        this.appendDeferredTriggers(block, block.triggers);
        this.appendDeferredTriggers(block, block.prefetchTriggers);
        // Only the `when` hydration trigger needs to be checked.
        if (block.hydrateTriggers.when) {
            this.opQueue.push(new TcbExpressionOp(this.tcb, this, block.hydrateTriggers.when.value));
        }
        this.appendChildren(block);
        if (block.placeholder !== null) {
            this.appendChildren(block.placeholder);
        }
        if (block.loading !== null) {
            this.appendChildren(block.loading);
        }
        if (block.error !== null) {
            this.appendChildren(block.error);
        }
    }
    appendDeferredTriggers(block, triggers) {
        if (triggers.when !== undefined) {
            this.opQueue.push(new TcbExpressionOp(this.tcb, this, triggers.when.value));
        }
        if (triggers.viewport !== undefined && triggers.viewport.options !== null) {
            this.opQueue.push(new TcbIntersectionObserverOp(this.tcb, this, triggers.viewport.options));
        }
        if (triggers.hover !== undefined) {
            this.validateReferenceBasedDeferredTrigger(block, triggers.hover);
        }
        if (triggers.interaction !== undefined) {
            this.validateReferenceBasedDeferredTrigger(block, triggers.interaction);
        }
        if (triggers.viewport !== undefined) {
            this.validateReferenceBasedDeferredTrigger(block, triggers.viewport);
        }
    }
    appendHostElement(node) {
        const opIndex = this.opQueue.push(new TcbHostElementOp(this.tcb, this, node)) - 1;
        const directives = this.tcb.boundTarget.getDirectivesOfNode(node);
        if (directives !== null && directives.length > 0) {
            const directiveOpMap = new Map();
            for (const directive of directives) {
                const directiveOp = this.getDirectiveOp(directive, node);
                directiveOpMap.set(directive, this.opQueue.push(directiveOp) - 1);
            }
            this.directiveOpMap.set(node, directiveOpMap);
        }
        this.hostElementOpMap.set(node, opIndex);
        this.opQueue.push(new TcbUnclaimedInputsOp(this.tcb, this, node.bindings, node, null), new TcbDomSchemaCheckerOp(this.tcb, node, false, null));
        this.appendOutputsOfElementLikeNode(node, null, node.listeners);
    }
    validateReferenceBasedDeferredTrigger(block, trigger) {
        if (trigger.reference === null) {
            if (block.placeholder === null) {
                this.tcb.oobRecorder.deferImplicitTriggerMissingPlaceholder(this.tcb.id, trigger);
                return;
            }
            let rootNode = null;
            for (const child of block.placeholder.children) {
                // Skip over empty text nodes if the host doesn't preserve whitespaces.
                if (!this.tcb.hostPreserveWhitespaces &&
                    child instanceof o.TmplAstText &&
                    child.value.trim().length === 0) {
                    continue;
                }
                // Capture the first root node.
                if (rootNode === null) {
                    rootNode = child;
                }
                else {
                    // More than one root node is invalid. Reset it and break
                    // the loop so the assertion below can flag it.
                    rootNode = null;
                    break;
                }
            }
            if (rootNode === null || !(rootNode instanceof o.TmplAstElement)) {
                this.tcb.oobRecorder.deferImplicitTriggerInvalidPlaceholder(this.tcb.id, trigger);
            }
            return;
        }
        if (this.tcb.boundTarget.getDeferredTriggerTarget(block, trigger) === null) {
            this.tcb.oobRecorder.inaccessibleDeferredTriggerElement(this.tcb.id, trigger);
        }
    }
    /** Reports a diagnostic if there are any `@let` declarations that conflict with a node. */
    static checkConflictingLet(scope, node) {
        if (scope.letDeclOpMap.has(node.name)) {
            scope.tcb.oobRecorder.conflictingDeclaration(scope.tcb.id, scope.letDeclOpMap.get(node.name).node);
        }
    }
}
/**
 * Create the `this` parameter to the top-level TCB function, with the given generic type
 * arguments.
 */
function tcbThisParam(name, typeArguments) {
    return ts.factory.createParameterDeclaration(
    /* modifiers */ undefined, 
    /* dotDotDotToken */ undefined, 
    /* name */ 'this', 
    /* questionToken */ undefined, 
    /* type */ ts.factory.createTypeReferenceNode(name, typeArguments), 
    /* initializer */ undefined);
}
/**
 * Process an `AST` expression and convert it into a `ts.Expression`, generating references to the
 * correct identifiers in the current scope.
 */
function tcbExpression(ast, tcb, scope) {
    const translator = new TcbExpressionTranslator(tcb, scope);
    return translator.translate(ast);
}
class TcbExpressionTranslator {
    tcb;
    scope;
    constructor(tcb, scope) {
        this.tcb = tcb;
        this.scope = scope;
    }
    translate(ast) {
        // `astToTypescript` actually does the conversion. A special resolver `tcbResolve` is passed
        // which interprets specific expression nodes that interact with the `ImplicitReceiver`. These
        // nodes actually refer to identifiers within the current scope.
        return astToTypescript(ast, (ast) => this.resolve(ast), this.tcb.env.config);
    }
    /**
     * Resolve an `AST` expression within the given scope.
     *
     * Some `AST` expressions refer to top-level concepts (references, variables, the component
     * context). This method assists in resolving those.
     */
    resolve(ast) {
        if (ast instanceof o.PropertyRead &&
            ast.receiver instanceof o.ImplicitReceiver &&
            !(ast.receiver instanceof o.ThisReceiver)) {
            // Try to resolve a bound target for this expression. If no such target is available, then
            // the expression is referencing the top-level component context. In that case, `null` is
            // returned here to let it fall through resolution so it will be caught when the
            // `ImplicitReceiver` is resolved in the branch below.
            const target = this.tcb.boundTarget.getExpressionTarget(ast);
            const targetExpression = target === null ? null : this.getTargetNodeExpression(target, ast);
            if (target instanceof o.TmplAstLetDeclaration &&
                !this.isValidLetDeclarationAccess(target, ast)) {
                this.tcb.oobRecorder.letUsedBeforeDefinition(this.tcb.id, ast, target);
                // Cast the expression to `any` so we don't produce additional diagnostics.
                // We don't use `markIgnoreForDiagnostics` here, because it won't prevent duplicate
                // diagnostics for nested accesses in cases like `@let value = value.foo.bar.baz`.
                if (targetExpression !== null) {
                    return ts.factory.createAsExpression(targetExpression, ts.factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword));
                }
            }
            return targetExpression;
        }
        else if (ast instanceof o.Binary &&
            o.Binary.isAssignmentOperation(ast.operation) &&
            ast.left instanceof o.PropertyRead &&
            ast.left.receiver instanceof o.ImplicitReceiver) {
            const read = ast.left;
            const target = this.tcb.boundTarget.getExpressionTarget(read);
            if (target === null) {
                return null;
            }
            const targetExpression = this.getTargetNodeExpression(target, read);
            const expr = this.translate(ast.right);
            const result = ts.factory.createParenthesizedExpression(ts.factory.createBinaryExpression(targetExpression, ts.SyntaxKind.EqualsToken, expr));
            addParseSpanInfo(result, read.sourceSpan);
            // Ignore diagnostics from TS produced for writes to `@let` and re-report them using
            // our own infrastructure. We can't rely on the TS reporting, because it includes
            // the name of the auto-generated TCB variable name.
            if (target instanceof o.TmplAstLetDeclaration) {
                markIgnoreDiagnostics(result);
                this.tcb.oobRecorder.illegalWriteToLetDeclaration(this.tcb.id, read, target);
            }
            return result;
        }
        else if (ast instanceof o.ImplicitReceiver) {
            // AST instances representing variables and references look very similar to property reads
            // or method calls from the component context: both have the shape
            // PropertyRead(ImplicitReceiver, 'propName') or Call(ImplicitReceiver, 'methodName').
            //
            // `translate` will first try to `resolve` the outer PropertyRead/Call. If this works,
            // it's because the `BoundTarget` found an expression target for the whole expression, and
            // therefore `translate` will never attempt to `resolve` the ImplicitReceiver of that
            // PropertyRead/Call.
            //
            // Therefore if `resolve` is called on an `ImplicitReceiver`, it's because no outer
            // PropertyRead/Call resolved to a variable or reference, and therefore this is a
            // property read or method call on the component context itself.
            return ts.factory.createThis();
        }
        else if (ast instanceof o.BindingPipe) {
            const expr = this.translate(ast.exp);
            const pipeMeta = this.tcb.getPipeByName(ast.name);
            let pipe;
            if (pipeMeta === null) {
                // No pipe by that name exists in scope. Record this as an error.
                this.tcb.oobRecorder.missingPipe(this.tcb.id, ast, this.tcb.hostIsStandalone);
                // Use an 'any' value to at least allow the rest of the expression to be checked.
                pipe = getAnyExpression();
            }
            else if (pipeMeta.isExplicitlyDeferred &&
                this.tcb.boundTarget.getEagerlyUsedPipes().includes(ast.name)) {
                // This pipe was defer-loaded (included into `@Component.deferredImports`),
                // but was used outside of a `@defer` block, which is the error.
                this.tcb.oobRecorder.deferredPipeUsedEagerly(this.tcb.id, ast);
                // Use an 'any' value to at least allow the rest of the expression to be checked.
                pipe = getAnyExpression();
            }
            else {
                // Use a variable declared as the pipe's type.
                pipe = this.tcb.env.pipeInst(pipeMeta.ref);
            }
            const args = ast.args.map((arg) => this.translate(arg));
            let methodAccess = ts.factory.createPropertyAccessExpression(pipe, 'transform');
            addParseSpanInfo(methodAccess, ast.nameSpan);
            if (!this.tcb.env.config.checkTypeOfPipes) {
                methodAccess = ts.factory.createAsExpression(methodAccess, ts.factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword));
            }
            const result = ts.factory.createCallExpression(
            /* expression */ methodAccess, 
            /* typeArguments */ undefined, 
            /* argumentsArray */ [expr, ...args]);
            addParseSpanInfo(result, ast.sourceSpan);
            return result;
        }
        else if ((ast instanceof o.Call || ast instanceof o.SafeCall) &&
            (ast.receiver instanceof o.PropertyRead || ast.receiver instanceof o.SafePropertyRead)) {
            // Resolve the special `$any(expr)` syntax to insert a cast of the argument to type `any`.
            // `$any(expr)` -> `expr as any`
            if (ast.receiver.receiver instanceof o.ImplicitReceiver &&
                !(ast.receiver.receiver instanceof o.ThisReceiver) &&
                ast.receiver.name === '$any' &&
                ast.args.length === 1) {
                const expr = this.translate(ast.args[0]);
                const exprAsAny = ts.factory.createAsExpression(expr, ts.factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword));
                const result = ts.factory.createParenthesizedExpression(exprAsAny);
                addParseSpanInfo(result, ast.sourceSpan);
                return result;
            }
            // Attempt to resolve a bound target for the method, and generate the method call if a target
            // could be resolved. If no target is available, then the method is referencing the top-level
            // component context, in which case `null` is returned to let the `ImplicitReceiver` being
            // resolved to the component context.
            const target = this.tcb.boundTarget.getExpressionTarget(ast);
            if (target === null) {
                return null;
            }
            const receiver = this.getTargetNodeExpression(target, ast);
            const method = wrapForDiagnostics(receiver);
            addParseSpanInfo(method, ast.receiver.nameSpan);
            const args = ast.args.map((arg) => this.translate(arg));
            const node = ts.factory.createCallExpression(method, undefined, args);
            addParseSpanInfo(node, ast.sourceSpan);
            return node;
        }
        else {
            // This AST isn't special after all.
            return null;
        }
    }
    getTargetNodeExpression(targetNode, expressionNode) {
        const expr = this.scope.resolve(targetNode);
        addParseSpanInfo(expr, expressionNode.sourceSpan);
        return expr;
    }
    isValidLetDeclarationAccess(target, ast) {
        const targetStart = target.sourceSpan.start.offset;
        const targetEnd = target.sourceSpan.end.offset;
        const astStart = ast.sourceSpan.start;
        // We only flag local references that occur before the declaration, because embedded views
        // are updated before the child views. In practice this means that something like
        // `<ng-template [ngIf]="true">{{value}}</ng-template> @let value = 1;` is valid.
        return (targetStart < astStart && astStart > targetEnd) || !this.scope.isLocal(target);
    }
}
/**
 * Call the type constructor of a directive instance on a given template node, inferring a type for
 * the directive instance from any bound inputs.
 */
function tcbCallTypeCtor(dir, tcb, inputs) {
    const typeCtor = tcb.env.typeCtorFor(dir);
    // Construct an array of `ts.PropertyAssignment`s for each of the directive's inputs.
    const members = inputs.map((input) => {
        const propertyName = ts.factory.createStringLiteral(input.field);
        if (input.type === 'binding') {
            // For bound inputs, the property is assigned the binding expression.
            let expr = widenBinding(input.expression, tcb);
            if (input.isTwoWayBinding && tcb.env.config.allowSignalsInTwoWayBindings) {
                expr = unwrapWritableSignal(expr, tcb);
            }
            const assignment = ts.factory.createPropertyAssignment(propertyName, wrapForDiagnostics(expr));
            addParseSpanInfo(assignment, input.sourceSpan);
            return assignment;
        }
        else {
            // A type constructor is required to be called with all input properties, so any unset
            // inputs are simply assigned a value of type `any` to ignore them.
            return ts.factory.createPropertyAssignment(propertyName, getAnyExpression());
        }
    });
    // Call the `ngTypeCtor` method on the directive class, with an object literal argument created
    // from the matched inputs.
    return ts.factory.createCallExpression(
    /* expression */ typeCtor, 
    /* typeArguments */ undefined, 
    /* argumentsArray */ [ts.factory.createObjectLiteralExpression(members)]);
}
function getBoundAttributes(directive, node) {
    const boundInputs = [];
    const processAttribute = (attr) => {
        // Skip non-property bindings.
        if (attr instanceof o.TmplAstBoundAttribute &&
            attr.type !== o.BindingType.Property &&
            attr.type !== o.BindingType.TwoWay) {
            return;
        }
        // Skip the attribute if the directive does not have an input for it.
        const inputs = directive.inputs.getByBindingPropertyName(attr.name);
        if (inputs !== null) {
            boundInputs.push({
                attribute: attr,
                inputs: inputs.map((input) => {
                    return {
                        fieldName: input.classPropertyName,
                        required: input.required,
                        transformType: input.transform?.type || null,
                        isSignal: input.isSignal,
                        isTwoWayBinding: attr instanceof o.TmplAstBoundAttribute && attr.type === o.BindingType.TwoWay,
                    };
                }),
            });
        }
    };
    if (node instanceof o.TmplAstTemplate) {
        if (node.tagName === 'ng-template') {
            node.inputs.forEach(processAttribute);
            node.attributes.forEach(processAttribute);
        }
        node.templateAttrs.forEach(processAttribute);
    }
    else {
        node.inputs.forEach(processAttribute);
        node.attributes.forEach(processAttribute);
    }
    return boundInputs;
}
/**
 * Translates the given attribute binding to a `ts.Expression`.
 */
function translateInput(attr, tcb, scope) {
    if (attr instanceof o.TmplAstBoundAttribute) {
        // Produce an expression representing the value of the binding.
        return tcbExpression(attr.value, tcb, scope);
    }
    else {
        // For regular attributes with a static string value, use the represented string literal.
        return ts.factory.createStringLiteral(attr.value);
    }
}
/**
 * Potentially widens the type of `expr` according to the type-checking configuration.
 */
function widenBinding(expr, tcb) {
    if (!tcb.env.config.checkTypeOfInputBindings) {
        // If checking the type of bindings is disabled, cast the resulting expression to 'any'
        // before the assignment.
        return tsCastToAny(expr);
    }
    else if (!tcb.env.config.strictNullInputBindings) {
        if (ts.isObjectLiteralExpression(expr) || ts.isArrayLiteralExpression(expr)) {
            // Object literals and array literals should not be wrapped in non-null assertions as that
            // would cause literals to be prematurely widened, resulting in type errors when assigning
            // into a literal type.
            return expr;
        }
        else {
            // If strict null checks are disabled, erase `null` and `undefined` from the type by
            // wrapping the expression in a non-null assertion.
            return ts.factory.createNonNullExpression(expr);
        }
    }
    else {
        // No widening is requested, use the expression as is.
        return expr;
    }
}
/**
 * Wraps an expression in an `unwrapSignal` call which extracts the signal's value.
 */
function unwrapWritableSignal(expression, tcb) {
    const unwrapRef = tcb.env.referenceExternalSymbol(o.R3Identifiers.unwrapWritableSignal.moduleName, o.R3Identifiers.unwrapWritableSignal.name);
    return ts.factory.createCallExpression(unwrapRef, undefined, [expression]);
}
const EVENT_PARAMETER = '$event';
/**
 * Creates an arrow function to be used as handler function for event bindings. The handler
 * function has a single parameter `$event` and the bound event's handler `AST` represented as a
 * TypeScript expression as its body.
 *
 * When `eventType` is set to `Infer`, the `$event` parameter will not have an explicit type. This
 * allows for the created handler function to have its `$event` parameter's type inferred based on
 * how it's used, to enable strict type checking of event bindings. When set to `Any`, the `$event`
 * parameter will have an explicit `any` type, effectively disabling strict type checking of event
 * bindings. Alternatively, an explicit type can be passed for the `$event` parameter.
 */
function tcbCreateEventHandler(event, tcb, scope, eventType, assertionExpression) {
    const handler = tcbEventHandlerExpression(event.handler, tcb, scope);
    const statements = [];
    if (assertionExpression !== undefined) {
        statements.push(ts.factory.createExpressionStatement(assertionExpression));
    }
    // TODO(crisbeto): remove the `checkTwoWayBoundEvents` check in v20.
    if (event.type === o.ParsedEventType.TwoWay && tcb.env.config.checkTwoWayBoundEvents) {
        // If we're dealing with a two-way event, we create a variable initialized to the unwrapped
        // signal value of the expression and then we assign `$event` to it. Note that in most cases
        // this will already be covered by the corresponding input binding, however it allows us to
        // handle the case where the input has a wider type than the output (see #58971).
        const target = tcb.allocateId();
        const assignment = ts.factory.createBinaryExpression(target, ts.SyntaxKind.EqualsToken, ts.factory.createIdentifier(EVENT_PARAMETER));
        statements.push(tsCreateVariable(target, tcb.env.config.allowSignalsInTwoWayBindings ? unwrapWritableSignal(handler, tcb) : handler), ts.factory.createExpressionStatement(assignment));
    }
    else {
        statements.push(ts.factory.createExpressionStatement(handler));
    }
    let eventParamType;
    if (eventType === 0 /* EventParamType.Infer */) {
        eventParamType = undefined;
    }
    else if (eventType === 1 /* EventParamType.Any */) {
        eventParamType = ts.factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword);
    }
    else {
        eventParamType = eventType;
    }
    // Obtain all guards that have been applied to the scope and its parents, as they have to be
    // repeated within the handler function for their narrowing to be in effect within the handler.
    const guards = scope.guards();
    let body = ts.factory.createBlock(statements);
    if (guards !== null) {
        // Wrap the body in an `if` statement containing all guards that have to be applied.
        body = ts.factory.createBlock([ts.factory.createIfStatement(guards, body)]);
    }
    const eventParam = ts.factory.createParameterDeclaration(
    /* modifiers */ undefined, 
    /* dotDotDotToken */ undefined, 
    /* name */ EVENT_PARAMETER, 
    /* questionToken */ undefined, 
    /* type */ eventParamType);
    addExpressionIdentifier(eventParam, ExpressionIdentifier.EVENT_PARAMETER);
    // Return an arrow function instead of a function expression to preserve the `this` context.
    return ts.factory.createArrowFunction(
    /* modifiers */ undefined, 
    /* typeParameters */ undefined, 
    /* parameters */ [eventParam], 
    /* type */ ts.factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword), 
    /* equalsGreaterThanToken */ undefined, 
    /* body */ body);
}
/**
 * Similar to `tcbExpression`, this function converts the provided `AST` expression into a
 * `ts.Expression`, with special handling of the `$event` variable that can be used within event
 * bindings.
 */
function tcbEventHandlerExpression(ast, tcb, scope) {
    const translator = new TcbEventHandlerTranslator(tcb, scope);
    return translator.translate(ast);
}
function checkSplitTwoWayBinding(inputName, output, inputs, tcb) {
    const input = inputs.find((input) => input.name === inputName);
    if (input === undefined || input.sourceSpan !== output.sourceSpan) {
        return false;
    }
    // Input consumer should be a directive because it's claimed
    const inputConsumer = tcb.boundTarget.getConsumerOfBinding(input);
    const outputConsumer = tcb.boundTarget.getConsumerOfBinding(output);
    if (outputConsumer === null ||
        inputConsumer.ref === undefined ||
        outputConsumer instanceof o.TmplAstTemplate) {
        return false;
    }
    if (outputConsumer instanceof o.TmplAstElement) {
        tcb.oobRecorder.splitTwoWayBinding(tcb.id, input, output, inputConsumer.ref.node, outputConsumer);
        return true;
    }
    else if (outputConsumer.ref !== inputConsumer.ref) {
        tcb.oobRecorder.splitTwoWayBinding(tcb.id, input, output, inputConsumer.ref.node, outputConsumer.ref.node);
        return true;
    }
    return false;
}
class TcbEventHandlerTranslator extends TcbExpressionTranslator {
    resolve(ast) {
        // Recognize a property read on the implicit receiver corresponding with the event parameter
        // that is available in event bindings. Since this variable is a parameter of the handler
        // function that the converted expression becomes a child of, just create a reference to the
        // parameter by its name.
        if (ast instanceof o.PropertyRead &&
            ast.receiver instanceof o.ImplicitReceiver &&
            !(ast.receiver instanceof o.ThisReceiver) &&
            ast.name === EVENT_PARAMETER) {
            const event = ts.factory.createIdentifier(EVENT_PARAMETER);
            addParseSpanInfo(event, ast.nameSpan);
            return event;
        }
        return super.resolve(ast);
    }
    isValidLetDeclarationAccess() {
        // Event listeners are allowed to read `@let` declarations before
        // they're declared since the callback won't be executed immediately.
        return true;
    }
}
class TcbForLoopTrackTranslator extends TcbExpressionTranslator {
    block;
    allowedVariables;
    constructor(tcb, scope, block) {
        super(tcb, scope);
        this.block = block;
        // Tracking expressions are only allowed to read the `$index`,
        // the item and properties off the component instance.
        this.allowedVariables = new Set([block.item]);
        for (const variable of block.contextVariables) {
            if (variable.value === '$index') {
                this.allowedVariables.add(variable);
            }
        }
    }
    resolve(ast) {
        if (ast instanceof o.PropertyRead && ast.receiver instanceof o.ImplicitReceiver) {
            const target = this.tcb.boundTarget.getExpressionTarget(ast);
            if (target !== null &&
                (!(target instanceof o.TmplAstVariable) || !this.allowedVariables.has(target))) {
                this.tcb.oobRecorder.illegalForLoopTrackAccess(this.tcb.id, this.block, ast);
            }
        }
        return super.resolve(ast);
    }
}
// TODO(crisbeto): the logic for determining the fallback tag name of a Component node is
// still being designed. For now fall back to `ng-component`, but this will have to be
// revisited once the design is finalized.
function getComponentTagName(node) {
    return node.tagName || 'ng-component';
}

/**
 * An `Environment` representing the single type-checking file into which most (if not all) Type
 * Check Blocks (TCBs) will be generated.
 *
 * The `TypeCheckFile` hosts multiple TCBs and allows the sharing of declarations (e.g. type
 * constructors) between them. Rather than return such declarations via `getPreludeStatements()`, it
 * hoists them to the top of the generated `ts.SourceFile`.
 */
class TypeCheckFile extends Environment {
    fileName;
    nextTcbId = 1;
    tcbStatements = [];
    constructor(fileName, config, refEmitter, reflector, compilerHost) {
        super(config, new ImportManager({
            // This minimizes noticeable changes with older versions of `ImportManager`.
            forceGenerateNamespacesForNewImports: true,
            // Type check block code affects code completion and fix suggestions.
            // We want to encourage single quotes for now, like we always did.
            shouldUseSingleQuotes: () => true,
        }), refEmitter, reflector, ts.createSourceFile(compilerHost.getCanonicalFileName(fileName), '', ts.ScriptTarget.Latest, true));
        this.fileName = fileName;
    }
    addTypeCheckBlock(ref, meta, domSchemaChecker, oobRecorder, genericContextBehavior) {
        const fnId = ts.factory.createIdentifier(`_tcb${this.nextTcbId++}`);
        const fn = generateTypeCheckBlock(this, ref, fnId, meta, domSchemaChecker, oobRecorder, genericContextBehavior);
        this.tcbStatements.push(fn);
    }
    render(removeComments) {
        // NOTE: We are conditionally adding imports whenever we discover signal inputs. This has a
        // risk of changing the import graph of the TypeScript program, degrading incremental program
        // re-use due to program structure changes. For type check block files, we are ensuring an
        // import to e.g. `@angular/core` always exists to guarantee a stable graph.
        ensureTypeCheckFilePreparationImports(this);
        const importChanges = this.importManager.finalize();
        if (importChanges.updatedImports.size > 0) {
            throw new Error('AssertionError: Expected no imports to be updated for a new type check file.');
        }
        const printer = ts.createPrinter({ removeComments });
        let source = '';
        const newImports = importChanges.newImports.get(this.contextFile.fileName);
        if (newImports !== undefined) {
            source += newImports
                .map((i) => printer.printNode(ts.EmitHint.Unspecified, i, this.contextFile))
                .join('\n');
        }
        source += '\n';
        for (const stmt of this.pipeInstStatements) {
            source += printer.printNode(ts.EmitHint.Unspecified, stmt, this.contextFile) + '\n';
        }
        for (const stmt of this.typeCtorStatements) {
            source += printer.printNode(ts.EmitHint.Unspecified, stmt, this.contextFile) + '\n';
        }
        source += '\n';
        for (const stmt of this.tcbStatements) {
            source += printer.printNode(ts.EmitHint.Unspecified, stmt, this.contextFile) + '\n';
        }
        // Ensure the template type-checking file is an ES module. Otherwise, it's interpreted as some
        // kind of global namespace in TS, which forces a full re-typecheck of the user's program that
        // is somehow more expensive than the initial parse.
        source += '\nexport const IS_A_MODULE = true;\n';
        return source;
    }
    getPreludeStatements() {
        return [];
    }
}

/**
 * How a type-checking context should handle operations which would require inlining.
 */
var InliningMode;
(function (InliningMode) {
    /**
     * Use inlining operations when required.
     */
    InliningMode[InliningMode["InlineOps"] = 0] = "InlineOps";
    /**
     * Produce diagnostics if an operation would require inlining.
     */
    InliningMode[InliningMode["Error"] = 1] = "Error";
})(InliningMode || (InliningMode = {}));
/**
 * A template type checking context for a program.
 *
 * The `TypeCheckContext` allows registration of directives to be type checked.
 */
class TypeCheckContextImpl {
    config;
    compilerHost;
    refEmitter;
    reflector;
    host;
    inlining;
    perf;
    fileMap = new Map();
    constructor(config, compilerHost, refEmitter, reflector, host, inlining, perf) {
        this.config = config;
        this.compilerHost = compilerHost;
        this.refEmitter = refEmitter;
        this.reflector = reflector;
        this.host = host;
        this.inlining = inlining;
        this.perf = perf;
        if (inlining === InliningMode.Error && config.useInlineTypeConstructors) {
            // We cannot use inlining for type checking since this environment does not support it.
            throw new Error(`AssertionError: invalid inlining configuration.`);
        }
    }
    /**
     * A `Map` of `ts.SourceFile`s that the context has seen to the operations (additions of methods
     * or type-check blocks) that need to be eventually performed on that file.
     */
    opMap = new Map();
    /**
     * Tracks when an a particular class has a pending type constructor patching operation already
     * queued.
     */
    typeCtorPending = new Set();
    /**
     * Register a template to potentially be type-checked.
     *
     * Implements `TypeCheckContext.addTemplate`.
     */
    addDirective(ref, binder, schemas, templateContext, hostBindingContext, isStandalone) {
        if (!this.host.shouldCheckClass(ref.node)) {
            return;
        }
        const sourceFile = ref.node.getSourceFile();
        const fileData = this.dataForFile(sourceFile);
        const shimData = this.pendingShimForClass(ref.node);
        const id = fileData.sourceManager.getTypeCheckId(ref.node);
        const templateParsingDiagnostics = [];
        if (templateContext !== null && templateContext.parseErrors !== null) {
            templateParsingDiagnostics.push(...getTemplateDiagnostics(templateContext.parseErrors, id, templateContext.sourceMapping));
        }
        const boundTarget = binder.bind({
            template: templateContext?.nodes,
            host: hostBindingContext === null
                ? undefined
                : {
                    node: hostBindingContext.node,
                    directives: hostBindingContext.directives,
                },
        });
        if (this.inlining === InliningMode.InlineOps) {
            // Get all of the directives used in the template and record inline type constructors when
            // required.
            for (const dir of boundTarget.getUsedDirectives()) {
                const dirRef = dir.ref;
                const dirNode = dirRef.node;
                if (!dir.isGeneric || !requiresInlineTypeCtor(dirNode, this.reflector, shimData.file)) {
                    // inlining not required
                    continue;
                }
                // Add an inline type constructor operation for the directive.
                this.addInlineTypeCtor(fileData, dirNode.getSourceFile(), dirRef, {
                    fnName: 'ngTypeCtor',
                    // The constructor should have a body if the directive comes from a .ts file, but not if
                    // it comes from a .d.ts file. .d.ts declarations don't have bodies.
                    body: !dirNode.getSourceFile().isDeclarationFile,
                    fields: {
                        inputs: dir.inputs,
                        // TODO(alxhub): support queries
                        queries: dir.queries,
                    },
                    coercedInputFields: dir.coercedInputFields,
                });
            }
        }
        shimData.data.set(id, {
            template: templateContext?.nodes || null,
            boundTarget,
            templateParsingDiagnostics,
            hostElement: hostBindingContext?.node ?? null,
        });
        const usedPipes = [];
        if (templateContext !== null) {
            for (const name of boundTarget.getUsedPipes()) {
                if (templateContext.pipes.has(name)) {
                    usedPipes.push(templateContext.pipes.get(name).ref);
                }
            }
        }
        const inliningRequirement = requiresInlineTypeCheckBlock(ref, shimData.file, usedPipes, this.reflector);
        // If inlining is not supported, but is required for either the TCB or one of its directive
        // dependencies, then exit here with an error.
        if (this.inlining === InliningMode.Error &&
            inliningRequirement === TcbInliningRequirement.MustInline) {
            // This template cannot be supported because the underlying strategy does not support inlining
            // and inlining would be required.
            // Record diagnostics to indicate the issues with this template.
            shimData.oobRecorder.requiresInlineTcb(id, ref.node);
            // Checking this template would be unsupported, so don't try.
            this.perf.eventCount(exports.PerfEvent.SkipGenerateTcbNoInline);
            return;
        }
        if (templateContext !== null) {
            fileData.sourceManager.captureTemplateSource(id, templateContext.sourceMapping, templateContext.file);
        }
        if (hostBindingContext !== null) {
            fileData.sourceManager.captureHostBindingsMapping(id, hostBindingContext.sourceMapping, 
            // We only support host bindings in the same file as the directive
            // so we can get the source file from here.
            new o.ParseSourceFile(sourceFile.text, sourceFile.fileName));
        }
        const meta = {
            id,
            boundTarget,
            pipes: templateContext?.pipes || null,
            schemas,
            isStandalone,
            preserveWhitespaces: templateContext?.preserveWhitespaces ?? false,
        };
        this.perf.eventCount(exports.PerfEvent.GenerateTcb);
        if (inliningRequirement !== TcbInliningRequirement.None &&
            this.inlining === InliningMode.InlineOps) {
            // This class didn't meet the requirements for external type checking, so generate an inline
            // TCB for the class.
            this.addInlineTypeCheckBlock(fileData, shimData, ref, meta);
        }
        else if (inliningRequirement === TcbInliningRequirement.ShouldInlineForGenericBounds &&
            this.inlining === InliningMode.Error) {
            // It's suggested that this TCB should be generated inline due to the class' generic
            // bounds, but inlining is not supported by the current environment. Use a non-inline type
            // check block, but fall back to `any` generic parameters since the generic bounds can't be
            // referenced in that context. This will infer a less useful type for the class, but allow
            // for type-checking it in an environment where that would not be possible otherwise.
            shimData.file.addTypeCheckBlock(ref, meta, shimData.domSchemaChecker, shimData.oobRecorder, TcbGenericContextBehavior.FallbackToAny);
        }
        else {
            shimData.file.addTypeCheckBlock(ref, meta, shimData.domSchemaChecker, shimData.oobRecorder, TcbGenericContextBehavior.UseEmitter);
        }
    }
    /**
     * Record a type constructor for the given `node` with the given `ctorMetadata`.
     */
    addInlineTypeCtor(fileData, sf, ref, ctorMeta) {
        if (this.typeCtorPending.has(ref.node)) {
            return;
        }
        this.typeCtorPending.add(ref.node);
        // Lazily construct the operation map.
        if (!this.opMap.has(sf)) {
            this.opMap.set(sf, []);
        }
        const ops = this.opMap.get(sf);
        // Push a `TypeCtorOp` into the operation queue for the source file.
        ops.push(new TypeCtorOp(ref, this.reflector, ctorMeta));
        fileData.hasInlines = true;
    }
    /**
     * Transform a `ts.SourceFile` into a version that includes type checking code.
     *
     * If this particular `ts.SourceFile` requires changes, the text representing its new contents
     * will be returned. Otherwise, a `null` return indicates no changes were necessary.
     */
    transform(sf) {
        // If there are no operations pending for this particular file, return `null` to indicate no
        // changes.
        if (!this.opMap.has(sf)) {
            return null;
        }
        // Use a `ts.Printer` to generate source code.
        const printer = ts.createPrinter({ omitTrailingSemicolon: true });
        // Imports may need to be added to the file to support type-checking of directives
        // used in the template within it.
        const importManager = new ImportManager({
            // This minimizes noticeable changes with older versions of `ImportManager`.
            forceGenerateNamespacesForNewImports: true,
            // Type check block code affects code completion and fix suggestions.
            // We want to encourage single quotes for now, like we always did.
            shouldUseSingleQuotes: () => true,
        });
        // Execute ops.
        // Each Op has a splitPoint index into the text where it needs to be inserted.
        const updates = this.opMap
            .get(sf)
            .map((op) => {
            return {
                pos: op.splitPoint,
                text: op.execute(importManager, sf, this.refEmitter, printer),
            };
        });
        const { newImports, updatedImports } = importManager.finalize();
        // Capture new imports
        if (newImports.has(sf.fileName)) {
            newImports.get(sf.fileName).forEach((newImport) => {
                updates.push({
                    pos: 0,
                    text: printer.printNode(ts.EmitHint.Unspecified, newImport, sf),
                });
            });
        }
        // Capture updated imports
        for (const [oldBindings, newBindings] of updatedImports.entries()) {
            if (oldBindings.getSourceFile() !== sf) {
                throw new Error('Unexpected updates to unrelated source files.');
            }
            updates.push({
                pos: oldBindings.getStart(),
                deletePos: oldBindings.getEnd(),
                text: printer.printNode(ts.EmitHint.Unspecified, newBindings, sf),
            });
        }
        const result = new MagicString(sf.text, { filename: sf.fileName });
        for (const update of updates) {
            if (update.deletePos !== undefined) {
                result.remove(update.pos, update.deletePos);
            }
            result.appendLeft(update.pos, update.text);
        }
        return result.toString();
    }
    finalize() {
        // First, build the map of updates to source files.
        const updates = new Map();
        for (const originalSf of this.opMap.keys()) {
            const newText = this.transform(originalSf);
            if (newText !== null) {
                updates.set(absoluteFromSourceFile(originalSf), {
                    newText,
                    originalFile: originalSf,
                });
            }
        }
        // Then go through each input file that has pending code generation operations.
        for (const [sfPath, pendingFileData] of this.fileMap) {
            // For each input file, consider generation operations for each of its shims.
            for (const pendingShimData of pendingFileData.shimData.values()) {
                this.host.recordShimData(sfPath, {
                    genesisDiagnostics: [
                        ...pendingShimData.domSchemaChecker.diagnostics,
                        ...pendingShimData.oobRecorder.diagnostics,
                    ],
                    hasInlines: pendingFileData.hasInlines,
                    path: pendingShimData.file.fileName,
                    data: pendingShimData.data,
                });
                const sfText = pendingShimData.file.render(false /* removeComments */);
                updates.set(pendingShimData.file.fileName, {
                    newText: sfText,
                    // Shim files do not have an associated original file.
                    originalFile: null,
                });
            }
        }
        return updates;
    }
    addInlineTypeCheckBlock(fileData, shimData, ref, tcbMeta) {
        const sf = ref.node.getSourceFile();
        if (!this.opMap.has(sf)) {
            this.opMap.set(sf, []);
        }
        const ops = this.opMap.get(sf);
        ops.push(new InlineTcbOp(ref, tcbMeta, this.config, this.reflector, shimData.domSchemaChecker, shimData.oobRecorder));
        fileData.hasInlines = true;
    }
    pendingShimForClass(node) {
        const fileData = this.dataForFile(node.getSourceFile());
        const shimPath = TypeCheckShimGenerator.shimFor(absoluteFromSourceFile(node.getSourceFile()));
        if (!fileData.shimData.has(shimPath)) {
            fileData.shimData.set(shimPath, {
                domSchemaChecker: new RegistryDomSchemaChecker(fileData.sourceManager),
                oobRecorder: new OutOfBandDiagnosticRecorderImpl(fileData.sourceManager),
                file: new TypeCheckFile(shimPath, this.config, this.refEmitter, this.reflector, this.compilerHost),
                data: new Map(),
            });
        }
        return fileData.shimData.get(shimPath);
    }
    dataForFile(sf) {
        const sfPath = absoluteFromSourceFile(sf);
        if (!this.fileMap.has(sfPath)) {
            const data = {
                hasInlines: false,
                sourceManager: this.host.getSourceManager(sfPath),
                shimData: new Map(),
            };
            this.fileMap.set(sfPath, data);
        }
        return this.fileMap.get(sfPath);
    }
}
function getTemplateDiagnostics(parseErrors, templateId, sourceMapping) {
    return parseErrors.map((error) => {
        const span = error.span;
        if (span.start.offset === span.end.offset) {
            // Template errors can contain zero-length spans, if the error occurs at a single point.
            // However, TypeScript does not handle displaying a zero-length diagnostic very well, so
            // increase the ending offset by 1 for such errors, to ensure the position is shown in the
            // diagnostic.
            span.end.offset++;
        }
        return makeTemplateDiagnostic(templateId, sourceMapping, span, ts.DiagnosticCategory.Error, ngErrorCode(exports.ErrorCode.TEMPLATE_PARSE_ERROR), error.msg);
    });
}
/**
 * A type check block operation which produces inline type check code for a particular directive.
 */
class InlineTcbOp {
    ref;
    meta;
    config;
    reflector;
    domSchemaChecker;
    oobRecorder;
    constructor(ref, meta, config, reflector, domSchemaChecker, oobRecorder) {
        this.ref = ref;
        this.meta = meta;
        this.config = config;
        this.reflector = reflector;
        this.domSchemaChecker = domSchemaChecker;
        this.oobRecorder = oobRecorder;
    }
    /**
     * Type check blocks are inserted immediately after the end of the directve class.
     */
    get splitPoint() {
        return this.ref.node.end + 1;
    }
    execute(im, sf, refEmitter, printer) {
        const env = new Environment(this.config, im, refEmitter, this.reflector, sf);
        const fnName = ts.factory.createIdentifier(`_tcb_${this.ref.node.pos}`);
        // Inline TCBs should copy any generic type parameter nodes directly, as the TCB code is
        // inlined into the class in a context where that will always be legal.
        const fn = generateTypeCheckBlock(env, this.ref, fnName, this.meta, this.domSchemaChecker, this.oobRecorder, TcbGenericContextBehavior.CopyClassNodes);
        return printer.printNode(ts.EmitHint.Unspecified, fn, sf);
    }
}
/**
 * A type constructor operation which produces type constructor code for a particular directive.
 */
class TypeCtorOp {
    ref;
    reflector;
    meta;
    constructor(ref, reflector, meta) {
        this.ref = ref;
        this.reflector = reflector;
        this.meta = meta;
    }
    /**
     * Type constructor operations are inserted immediately before the end of the directive class.
     */
    get splitPoint() {
        return this.ref.node.end - 1;
    }
    execute(im, sf, refEmitter, printer) {
        const emitEnv = new ReferenceEmitEnvironment(im, refEmitter, this.reflector, sf);
        const tcb = generateInlineTypeCtor(emitEnv, this.ref.node, this.meta);
        return printer.printNode(ts.EmitHint.Unspecified, tcb, sf);
    }
}

const LF_CHAR = 10;
const CR_CHAR = 13;
const LINE_SEP_CHAR = 8232;
const PARAGRAPH_CHAR = 8233;
/** Gets the line and character for the given position from the line starts map. */
function getLineAndCharacterFromPosition(lineStartsMap, position) {
    const lineIndex = findClosestLineStartPosition(lineStartsMap, position);
    return { character: position - lineStartsMap[lineIndex], line: lineIndex };
}
/**
 * Computes the line start map of the given text. This can be used in order to
 * retrieve the line and character of a given text position index.
 */
function computeLineStartsMap(text) {
    const result = [0];
    let pos = 0;
    while (pos < text.length) {
        const char = text.charCodeAt(pos++);
        // Handles the "CRLF" line break. In that case we peek the character
        // after the "CR" and check if it is a line feed.
        if (char === CR_CHAR) {
            if (text.charCodeAt(pos) === LF_CHAR) {
                pos++;
            }
            result.push(pos);
        }
        else if (char === LF_CHAR || char === LINE_SEP_CHAR || char === PARAGRAPH_CHAR) {
            result.push(pos);
        }
    }
    result.push(pos);
    return result;
}
/** Finds the closest line start for the given position. */
function findClosestLineStartPosition(linesMap, position, low = 0, high = linesMap.length - 1) {
    while (low <= high) {
        const pivotIdx = Math.floor((low + high) / 2);
        const pivotEl = linesMap[pivotIdx];
        if (pivotEl === position) {
            return pivotIdx;
        }
        else if (position > pivotEl) {
            low = pivotIdx + 1;
        }
        else {
            high = pivotIdx - 1;
        }
    }
    // In case there was no exact match, return the closest "lower" line index. We also
    // subtract the index by one because want the index of the previous line start.
    return low - 1;
}

/**
 * Represents the source of code processed during type-checking. This information is used when
 * translating parse offsets in diagnostics back to their original line/column location.
 */
class Source {
    mapping;
    file;
    lineStarts = null;
    constructor(mapping, file) {
        this.mapping = mapping;
        this.file = file;
    }
    toParseSourceSpan(start, end) {
        const startLoc = this.toParseLocation(start);
        const endLoc = this.toParseLocation(end);
        return new o.ParseSourceSpan(startLoc, endLoc);
    }
    toParseLocation(position) {
        const lineStarts = this.acquireLineStarts();
        const { line, character } = getLineAndCharacterFromPosition(lineStarts, position);
        return new o.ParseLocation(this.file, position, line, character);
    }
    acquireLineStarts() {
        if (this.lineStarts === null) {
            this.lineStarts = computeLineStartsMap(this.file.content);
        }
        return this.lineStarts;
    }
}
/**
 * Assigns IDs for type checking and keeps track of their origins.
 *
 * Implements `TypeCheckSourceResolver` to resolve the source of a template based on these IDs.
 */
class DirectiveSourceManager {
    /**
     * This map keeps track of all template sources that have been type-checked by the id that is
     * attached to a TCB's function declaration as leading trivia. This enables translation of
     * diagnostics produced for TCB code to their source location in the template.
     */
    templateSources = new Map();
    /** Keeps track of type check IDs and the source location of their host bindings. */
    hostBindingSources = new Map();
    getTypeCheckId(node) {
        return getTypeCheckId$1(node);
    }
    captureTemplateSource(id, mapping, file) {
        this.templateSources.set(id, new Source(mapping, file));
    }
    captureHostBindingsMapping(id, mapping, file) {
        this.hostBindingSources.set(id, new Source(mapping, file));
    }
    getTemplateSourceMapping(id) {
        if (!this.templateSources.has(id)) {
            throw new Error(`Unexpected unknown type check ID: ${id}`);
        }
        return this.templateSources.get(id).mapping;
    }
    getHostBindingsMapping(id) {
        if (!this.hostBindingSources.has(id)) {
            throw new Error(`Unexpected unknown type check ID: ${id}`);
        }
        return this.hostBindingSources.get(id).mapping;
    }
    toTemplateParseSourceSpan(id, span) {
        if (!this.templateSources.has(id)) {
            return null;
        }
        const templateSource = this.templateSources.get(id);
        return templateSource.toParseSourceSpan(span.start, span.end);
    }
    toHostParseSourceSpan(id, span) {
        if (!this.hostBindingSources.has(id)) {
            return null;
        }
        const source = this.hostBindingSources.get(id);
        return source.toParseSourceSpan(span.start, span.end);
    }
}

/**
 * Generates and caches `Symbol`s for various template structures for a given component.
 *
 * The `SymbolBuilder` internally caches the `Symbol`s it creates, and must be destroyed and
 * replaced if the component's template changes.
 */
class SymbolBuilder {
    tcbPath;
    tcbIsShim;
    typeCheckBlock;
    typeCheckData;
    componentScopeReader;
    getTypeChecker;
    symbolCache = new Map();
    constructor(tcbPath, tcbIsShim, typeCheckBlock, typeCheckData, componentScopeReader, 
    // The `ts.TypeChecker` depends on the current type-checking program, and so must be requested
    // on-demand instead of cached.
    getTypeChecker) {
        this.tcbPath = tcbPath;
        this.tcbIsShim = tcbIsShim;
        this.typeCheckBlock = typeCheckBlock;
        this.typeCheckData = typeCheckData;
        this.componentScopeReader = componentScopeReader;
        this.getTypeChecker = getTypeChecker;
    }
    getSymbol(node) {
        if (this.symbolCache.has(node)) {
            return this.symbolCache.get(node);
        }
        let symbol = null;
        if (node instanceof o.TmplAstBoundAttribute || node instanceof o.TmplAstTextAttribute) {
            // TODO(atscott): input and output bindings only return the first directive match but should
            // return a list of bindings for all of them.
            symbol = this.getSymbolOfInputBinding(node);
        }
        else if (node instanceof o.TmplAstBoundEvent) {
            symbol = this.getSymbolOfBoundEvent(node);
        }
        else if (node instanceof o.TmplAstElement) {
            symbol = this.getSymbolOfElement(node);
        }
        else if (node instanceof o.TmplAstComponent) {
            symbol = this.getSymbolOfSelectorlessComponent(node);
        }
        else if (node instanceof o.TmplAstDirective) {
            symbol = this.getSymbolOfSelectorlessDirective(node);
        }
        else if (node instanceof o.TmplAstTemplate) {
            symbol = this.getSymbolOfAstTemplate(node);
        }
        else if (node instanceof o.TmplAstVariable) {
            symbol = this.getSymbolOfVariable(node);
        }
        else if (node instanceof o.TmplAstLetDeclaration) {
            symbol = this.getSymbolOfLetDeclaration(node);
        }
        else if (node instanceof o.TmplAstReference) {
            symbol = this.getSymbolOfReference(node);
        }
        else if (node instanceof o.BindingPipe) {
            symbol = this.getSymbolOfPipe(node);
        }
        else if (node instanceof o.AST) {
            symbol = this.getSymbolOfTemplateExpression(node);
        }
        else ;
        this.symbolCache.set(node, symbol);
        return symbol;
    }
    getSymbolOfAstTemplate(template) {
        const directives = this.getDirectivesOfNode(template);
        return { kind: exports.SymbolKind.Template, directives, templateNode: template };
    }
    getSymbolOfElement(element) {
        const elementSourceSpan = element.startSourceSpan ?? element.sourceSpan;
        const node = findFirstMatchingNode(this.typeCheckBlock, {
            withSpan: elementSourceSpan,
            filter: ts.isVariableDeclaration,
        });
        if (node === null) {
            return null;
        }
        const symbolFromDeclaration = this.getSymbolOfTsNode(node);
        if (symbolFromDeclaration === null || symbolFromDeclaration.tsSymbol === null) {
            return null;
        }
        const directives = this.getDirectivesOfNode(element);
        // All statements in the TCB are `Expression`s that optionally include more information.
        // An `ElementSymbol` uses the information returned for the variable declaration expression,
        // adds the directives for the element, and updates the `kind` to be `SymbolKind.Element`.
        return {
            ...symbolFromDeclaration,
            kind: exports.SymbolKind.Element,
            directives,
            templateNode: element,
        };
    }
    getSymbolOfSelectorlessComponent(node) {
        const directives = this.getDirectivesOfNode(node);
        const primaryDirective = directives.find((dir) => !dir.isHostDirective && dir.isComponent) ?? null;
        if (primaryDirective === null) {
            return null;
        }
        return {
            tsType: primaryDirective.tsType,
            tsSymbol: primaryDirective.tsSymbol,
            tcbLocation: primaryDirective.tcbLocation,
            kind: exports.SymbolKind.SelectorlessComponent,
            directives,
            templateNode: node,
        };
    }
    getSymbolOfSelectorlessDirective(node) {
        const directives = this.getDirectivesOfNode(node);
        const primaryDirective = directives.find((dir) => !dir.isHostDirective && !dir.isComponent) ?? null;
        if (primaryDirective === null) {
            return null;
        }
        return {
            tsType: primaryDirective.tsType,
            tsSymbol: primaryDirective.tsSymbol,
            tcbLocation: primaryDirective.tcbLocation,
            kind: exports.SymbolKind.SelectorlessDirective,
            directives,
            templateNode: node,
        };
    }
    getDirectivesOfNode(templateNode) {
        const elementSourceSpan = templateNode.startSourceSpan ?? templateNode.sourceSpan;
        const nodes = findAllMatchingNodes(this.typeCheckBlock, {
            withSpan: elementSourceSpan,
            filter: isDirectiveDeclaration,
        });
        const symbols = [];
        const seenDirectives = new Set();
        for (const node of nodes) {
            const symbol = this.getSymbolOfTsNode(node.parent);
            if (symbol === null ||
                !isSymbolWithValueDeclaration(symbol.tsSymbol) ||
                !ts.isClassDeclaration(symbol.tsSymbol.valueDeclaration)) {
                continue;
            }
            const declaration = symbol.tsSymbol.valueDeclaration;
            const meta = this.getDirectiveMeta(templateNode, declaration);
            // Host directives will be added as identifiers with the same offset as the host
            // which means that they'll get added twice. De-duplicate them to avoid confusion.
            if (meta !== null && !seenDirectives.has(declaration)) {
                const ref = new Reference(declaration);
                if (meta.hostDirectives !== null) {
                    this.addHostDirectiveSymbols(templateNode, meta.hostDirectives, symbols, seenDirectives);
                }
                const directiveSymbol = {
                    ...symbol,
                    ref,
                    tsSymbol: symbol.tsSymbol,
                    selector: meta.selector,
                    isComponent: meta.isComponent,
                    ngModule: this.getDirectiveModule(declaration),
                    kind: exports.SymbolKind.Directive,
                    isStructural: meta.isStructural,
                    isInScope: true,
                    isHostDirective: false,
                    tsCompletionEntryInfos: null,
                };
                symbols.push(directiveSymbol);
                seenDirectives.add(declaration);
            }
        }
        return symbols;
    }
    addHostDirectiveSymbols(host, hostDirectives, symbols, seenDirectives) {
        for (const current of hostDirectives) {
            if (!isHostDirectiveMetaForGlobalMode(current)) {
                throw new Error('Impossible state: typecheck code path in local compilation mode.');
            }
            const node = current.directive.node;
            if (!ts.isClassDeclaration(node) || seenDirectives.has(node)) {
                continue;
            }
            const symbol = this.getSymbolOfTsNode(node);
            const meta = this.getDirectiveMeta(host, node);
            if (meta !== null && symbol !== null && isSymbolWithValueDeclaration(symbol.tsSymbol)) {
                if (meta.hostDirectives !== null) {
                    this.addHostDirectiveSymbols(host, meta.hostDirectives, symbols, seenDirectives);
                }
                const directiveSymbol = {
                    ...symbol,
                    isHostDirective: true,
                    ref: current.directive,
                    tsSymbol: symbol.tsSymbol,
                    exposedInputs: current.inputs,
                    exposedOutputs: current.outputs,
                    selector: meta.selector,
                    isComponent: meta.isComponent,
                    ngModule: this.getDirectiveModule(node),
                    kind: exports.SymbolKind.Directive,
                    isStructural: meta.isStructural,
                    isInScope: true,
                    tsCompletionEntryInfos: null,
                };
                symbols.push(directiveSymbol);
                seenDirectives.add(node);
            }
        }
    }
    getDirectiveMeta(host, directiveDeclaration) {
        let directives = this.typeCheckData.boundTarget.getDirectivesOfNode(host);
        // `getDirectivesOfNode` will not return the directives intended for an element
        // on a microsyntax template, for example `<div *ngFor="let user of users;" dir>`,
        // the `dir` will be skipped, but it's needed in language service.
        if (!(host instanceof o.TmplAstDirective)) {
            const firstChild = host.children[0];
            if (firstChild instanceof o.TmplAstElement) {
                const isMicrosyntaxTemplate = host instanceof o.TmplAstTemplate &&
                    sourceSpanEqual(firstChild.sourceSpan, host.sourceSpan);
                if (isMicrosyntaxTemplate) {
                    const firstChildDirectives = this.typeCheckData.boundTarget.getDirectivesOfNode(firstChild);
                    if (firstChildDirectives !== null && directives !== null) {
                        directives = directives.concat(firstChildDirectives);
                    }
                    else {
                        directives = directives ?? firstChildDirectives;
                    }
                }
            }
        }
        if (directives === null) {
            return null;
        }
        const directive = directives.find((m) => m.ref.node === directiveDeclaration);
        if (directive) {
            return directive;
        }
        const originalFile = directiveDeclaration.getSourceFile()[NgOriginalFile];
        if (originalFile !== undefined) {
            // This is a preliminary check ahead of a more expensive search
            const hasPotentialCandidate = directives.find((m) => m.ref.node.name.text === directiveDeclaration.name?.text);
            if (hasPotentialCandidate) {
                // In case the TCB has been inlined,
                // We will look for a matching class
                // If we find one, we look for it in the directives array
                const classWithSameName = findMatchingDirective(originalFile, directiveDeclaration);
                if (classWithSameName !== null) {
                    return directives.find((m) => m.ref.node === classWithSameName) ?? null;
                }
            }
        }
        // Really nothing was found
        return null;
    }
    getDirectiveModule(declaration) {
        const scope = this.componentScopeReader.getScopeForComponent(declaration);
        if (scope === null || scope.kind !== ComponentScopeKind.NgModule) {
            return null;
        }
        return scope.ngModule;
    }
    getSymbolOfBoundEvent(eventBinding) {
        const consumer = this.typeCheckData.boundTarget.getConsumerOfBinding(eventBinding);
        if (consumer === null) {
            return null;
        }
        // Outputs in the TCB look like one of the two:
        // * _t1["outputField"].subscribe(handler);
        // * _t1.addEventListener(handler);
        // Even with strict null checks disabled, we still produce the access as a separate statement
        // so that it can be found here.
        let expectedAccess;
        if (consumer instanceof o.TmplAstTemplate || consumer instanceof o.TmplAstElement) {
            expectedAccess = 'addEventListener';
        }
        else {
            const bindingPropertyNames = consumer.outputs.getByBindingPropertyName(eventBinding.name);
            if (bindingPropertyNames === null || bindingPropertyNames.length === 0) {
                return null;
            }
            // Note that we only get the expectedAccess text from a single consumer of the binding. If
            // there are multiple consumers (not supported in the `boundTarget` API) and one of them has
            // an alias, it will not get matched here.
            expectedAccess = bindingPropertyNames[0].classPropertyName;
        }
        function filter(n) {
            if (!isAccessExpression(n)) {
                return false;
            }
            if (ts.isPropertyAccessExpression(n)) {
                return n.name.getText() === expectedAccess;
            }
            else {
                return (ts.isStringLiteral(n.argumentExpression) && n.argumentExpression.text === expectedAccess);
            }
        }
        const outputFieldAccesses = findAllMatchingNodes(this.typeCheckBlock, {
            withSpan: eventBinding.keySpan,
            filter,
        });
        const bindings = [];
        for (const outputFieldAccess of outputFieldAccesses) {
            if (consumer instanceof o.TmplAstTemplate || consumer instanceof o.TmplAstElement) {
                if (!ts.isPropertyAccessExpression(outputFieldAccess)) {
                    continue;
                }
                const addEventListener = outputFieldAccess.name;
                const tsSymbol = this.getTypeChecker().getSymbolAtLocation(addEventListener);
                const tsType = this.getTypeChecker().getTypeAtLocation(addEventListener);
                const positionInFile = this.getTcbPositionForNode(addEventListener);
                const target = this.getSymbol(consumer);
                if (target === null || tsSymbol === undefined) {
                    continue;
                }
                bindings.push({
                    kind: exports.SymbolKind.Binding,
                    tsSymbol,
                    tsType,
                    target,
                    tcbLocation: {
                        tcbPath: this.tcbPath,
                        isShimFile: this.tcbIsShim,
                        positionInFile,
                    },
                });
            }
            else {
                if (!ts.isElementAccessExpression(outputFieldAccess)) {
                    continue;
                }
                const tsSymbol = this.getTypeChecker().getSymbolAtLocation(outputFieldAccess.argumentExpression);
                if (tsSymbol === undefined) {
                    continue;
                }
                const target = this.getDirectiveSymbolForAccessExpression(outputFieldAccess, consumer);
                if (target === null) {
                    continue;
                }
                const positionInFile = this.getTcbPositionForNode(outputFieldAccess);
                const tsType = this.getTypeChecker().getTypeAtLocation(outputFieldAccess);
                bindings.push({
                    kind: exports.SymbolKind.Binding,
                    tsSymbol,
                    tsType,
                    target,
                    tcbLocation: {
                        tcbPath: this.tcbPath,
                        isShimFile: this.tcbIsShim,
                        positionInFile,
                    },
                });
            }
        }
        if (bindings.length === 0) {
            return null;
        }
        return { kind: exports.SymbolKind.Output, bindings };
    }
    getSymbolOfInputBinding(binding) {
        const consumer = this.typeCheckData.boundTarget.getConsumerOfBinding(binding);
        if (consumer === null) {
            return null;
        }
        if (consumer instanceof o.TmplAstElement || consumer instanceof o.TmplAstTemplate) {
            const host = this.getSymbol(consumer);
            return host !== null ? { kind: exports.SymbolKind.DomBinding, host } : null;
        }
        const nodes = findAllMatchingNodes(this.typeCheckBlock, {
            withSpan: binding.sourceSpan,
            filter: isAssignment,
        });
        const bindings = [];
        for (const node of nodes) {
            if (!isAccessExpression(node.left)) {
                continue;
            }
            const signalInputAssignment = unwrapSignalInputWriteTAccessor(node.left);
            let fieldAccessExpr;
            let symbolInfo = null;
            // Signal inputs need special treatment because they are generated with an extra keyed
            // access. E.g. `_t1.prop[WriteT_ACCESSOR_SYMBOL]`. Observations:
            //   - The keyed access for the write type needs to be resolved for the "input type".
            //   - The definition symbol of the input should be the input class member, and not the
            //     internal write accessor. Symbol should resolve `_t1.prop`.
            if (signalInputAssignment !== null) {
                // Note: If the field expression for the input binding refers to just an identifier,
                // then we are handling the case of a temporary variable being used for the input field.
                // This is the case with `honorAccessModifiersForInputBindings = false` and in those cases
                // we cannot resolve the owning directive, similar to how we guard above with `isAccessExpression`.
                if (ts.isIdentifier(signalInputAssignment.fieldExpr)) {
                    continue;
                }
                const fieldSymbol = this.getSymbolOfTsNode(signalInputAssignment.fieldExpr);
                const typeSymbol = this.getSymbolOfTsNode(signalInputAssignment.typeExpr);
                fieldAccessExpr = signalInputAssignment.fieldExpr;
                symbolInfo =
                    fieldSymbol === null || typeSymbol === null
                        ? null
                        : {
                            tcbLocation: fieldSymbol.tcbLocation,
                            tsSymbol: fieldSymbol.tsSymbol,
                            tsType: typeSymbol.tsType,
                        };
            }
            else {
                fieldAccessExpr = node.left;
                symbolInfo = this.getSymbolOfTsNode(node.left);
            }
            if (symbolInfo === null || symbolInfo.tsSymbol === null) {
                continue;
            }
            const target = this.getDirectiveSymbolForAccessExpression(fieldAccessExpr, consumer);
            if (target === null) {
                continue;
            }
            bindings.push({
                ...symbolInfo,
                tsSymbol: symbolInfo.tsSymbol,
                kind: exports.SymbolKind.Binding,
                target,
            });
        }
        if (bindings.length === 0) {
            return null;
        }
        return { kind: exports.SymbolKind.Input, bindings };
    }
    getDirectiveSymbolForAccessExpression(fieldAccessExpr, { isComponent, selector, isStructural }) {
        // In all cases, `_t1["index"]` or `_t1.index`, `node.expression` is _t1.
        const tsSymbol = this.getTypeChecker().getSymbolAtLocation(fieldAccessExpr.expression);
        if (tsSymbol?.declarations === undefined || tsSymbol.declarations.length === 0) {
            return null;
        }
        const [declaration] = tsSymbol.declarations;
        if (!ts.isVariableDeclaration(declaration) ||
            !hasExpressionIdentifier(
            // The expression identifier could be on the type (for regular directives) or the name
            // (for generic directives and the ctor op).
            declaration.getSourceFile(), declaration.type ?? declaration.name, ExpressionIdentifier.DIRECTIVE)) {
            return null;
        }
        const symbol = this.getSymbolOfTsNode(declaration);
        if (symbol === null ||
            !isSymbolWithValueDeclaration(symbol.tsSymbol) ||
            !ts.isClassDeclaration(symbol.tsSymbol.valueDeclaration)) {
            return null;
        }
        const ref = new Reference(symbol.tsSymbol.valueDeclaration);
        const ngModule = this.getDirectiveModule(symbol.tsSymbol.valueDeclaration);
        return {
            ref,
            kind: exports.SymbolKind.Directive,
            tsSymbol: symbol.tsSymbol,
            tsType: symbol.tsType,
            tcbLocation: symbol.tcbLocation,
            isComponent,
            isStructural,
            selector,
            ngModule,
            isHostDirective: false,
            isInScope: true, // TODO: this should always be in scope in this context, right?
            tsCompletionEntryInfos: null,
        };
    }
    getSymbolOfVariable(variable) {
        const node = findFirstMatchingNode(this.typeCheckBlock, {
            withSpan: variable.sourceSpan,
            filter: ts.isVariableDeclaration,
        });
        if (node === null) {
            return null;
        }
        let nodeValueSymbol = null;
        if (ts.isForOfStatement(node.parent.parent)) {
            nodeValueSymbol = this.getSymbolOfTsNode(node);
        }
        else if (node.initializer !== undefined) {
            nodeValueSymbol = this.getSymbolOfTsNode(node.initializer);
        }
        if (nodeValueSymbol === null) {
            return null;
        }
        return {
            tsType: nodeValueSymbol.tsType,
            tsSymbol: nodeValueSymbol.tsSymbol,
            initializerLocation: nodeValueSymbol.tcbLocation,
            kind: exports.SymbolKind.Variable,
            declaration: variable,
            localVarLocation: {
                tcbPath: this.tcbPath,
                isShimFile: this.tcbIsShim,
                positionInFile: this.getTcbPositionForNode(node.name),
            },
        };
    }
    getSymbolOfReference(ref) {
        const target = this.typeCheckData.boundTarget.getReferenceTarget(ref);
        // Find the node for the reference declaration, i.e. `var _t2 = _t1;`
        let node = findFirstMatchingNode(this.typeCheckBlock, {
            withSpan: ref.sourceSpan,
            filter: ts.isVariableDeclaration,
        });
        if (node === null || target === null || node.initializer === undefined) {
            return null;
        }
        // Get the original declaration for the references variable, with the exception of template refs
        // which are of the form var _t3 = (_t2 as any as i2.TemplateRef<any>)
        // TODO(atscott): Consider adding an `ExpressionIdentifier` to tag variable declaration
        // initializers as invalid for symbol retrieval.
        const originalDeclaration = ts.isParenthesizedExpression(node.initializer) &&
            ts.isAsExpression(node.initializer.expression)
            ? this.getTypeChecker().getSymbolAtLocation(node.name)
            : this.getTypeChecker().getSymbolAtLocation(node.initializer);
        if (originalDeclaration === undefined || originalDeclaration.valueDeclaration === undefined) {
            return null;
        }
        const symbol = this.getSymbolOfTsNode(originalDeclaration.valueDeclaration);
        if (symbol === null || symbol.tsSymbol === null) {
            return null;
        }
        const referenceVarTcbLocation = {
            tcbPath: this.tcbPath,
            isShimFile: this.tcbIsShim,
            positionInFile: this.getTcbPositionForNode(node),
        };
        if (target instanceof o.TmplAstTemplate || target instanceof o.TmplAstElement) {
            return {
                kind: exports.SymbolKind.Reference,
                tsSymbol: symbol.tsSymbol,
                tsType: symbol.tsType,
                target,
                declaration: ref,
                targetLocation: symbol.tcbLocation,
                referenceVarLocation: referenceVarTcbLocation,
            };
        }
        else {
            if (!ts.isClassDeclaration(target.directive.ref.node)) {
                return null;
            }
            return {
                kind: exports.SymbolKind.Reference,
                tsSymbol: symbol.tsSymbol,
                tsType: symbol.tsType,
                declaration: ref,
                target: target.directive.ref.node,
                targetLocation: symbol.tcbLocation,
                referenceVarLocation: referenceVarTcbLocation,
            };
        }
    }
    getSymbolOfLetDeclaration(decl) {
        const node = findFirstMatchingNode(this.typeCheckBlock, {
            withSpan: decl.sourceSpan,
            filter: ts.isVariableDeclaration,
        });
        if (node === null) {
            return null;
        }
        const nodeValueSymbol = this.getSymbolOfTsNode(node.initializer);
        if (nodeValueSymbol === null) {
            return null;
        }
        return {
            tsType: nodeValueSymbol.tsType,
            tsSymbol: nodeValueSymbol.tsSymbol,
            initializerLocation: nodeValueSymbol.tcbLocation,
            kind: exports.SymbolKind.LetDeclaration,
            declaration: decl,
            localVarLocation: {
                tcbPath: this.tcbPath,
                isShimFile: this.tcbIsShim,
                positionInFile: this.getTcbPositionForNode(node.name),
            },
        };
    }
    getSymbolOfPipe(expression) {
        const methodAccess = findFirstMatchingNode(this.typeCheckBlock, {
            withSpan: expression.nameSpan,
            filter: ts.isPropertyAccessExpression,
        });
        if (methodAccess === null) {
            return null;
        }
        const pipeVariableNode = methodAccess.expression;
        const pipeDeclaration = this.getTypeChecker().getSymbolAtLocation(pipeVariableNode);
        if (pipeDeclaration === undefined || pipeDeclaration.valueDeclaration === undefined) {
            return null;
        }
        const pipeInstance = this.getSymbolOfTsNode(pipeDeclaration.valueDeclaration);
        // The instance should never be null, nor should the symbol lack a value declaration. This
        // is because the node used to look for the `pipeInstance` symbol info is a value
        // declaration of another symbol (i.e. the `pipeDeclaration` symbol).
        if (pipeInstance === null || !isSymbolWithValueDeclaration(pipeInstance.tsSymbol)) {
            return null;
        }
        const symbolInfo = this.getSymbolOfTsNode(methodAccess);
        if (symbolInfo === null) {
            return null;
        }
        return {
            kind: exports.SymbolKind.Pipe,
            ...symbolInfo,
            classSymbol: {
                ...pipeInstance,
                tsSymbol: pipeInstance.tsSymbol,
            },
        };
    }
    getSymbolOfTemplateExpression(expression) {
        if (expression instanceof o.ASTWithSource) {
            expression = expression.ast;
        }
        const expressionTarget = this.typeCheckData.boundTarget.getExpressionTarget(expression);
        if (expressionTarget !== null) {
            return this.getSymbol(expressionTarget);
        }
        let withSpan = expression.sourceSpan;
        // The `name` part of a property write and `ASTWithName` do not have their own
        // AST so there is no way to retrieve a `Symbol` for just the `name` via a specific node.
        // Also skipping SafePropertyReads as it breaks nullish coalescing not nullable extended diagnostic
        if (expression instanceof o.Binary &&
            o.Binary.isAssignmentOperation(expression.operation) &&
            expression.left instanceof o.PropertyRead) {
            withSpan = expression.left.nameSpan;
        }
        else if (expression instanceof o.ASTWithName && !(expression instanceof o.SafePropertyRead)) {
            withSpan = expression.nameSpan;
        }
        let node = null;
        // Property reads in templates usually map to a `PropertyAccessExpression`
        // (e.g. `ctx.foo`) so try looking for one first.
        if (expression instanceof o.PropertyRead) {
            node = findFirstMatchingNode(this.typeCheckBlock, {
                withSpan,
                filter: ts.isPropertyAccessExpression,
            });
        }
        // Otherwise fall back to searching for any AST node.
        if (node === null) {
            node = findFirstMatchingNode(this.typeCheckBlock, { withSpan, filter: anyNodeFilter });
        }
        if (node === null) {
            return null;
        }
        while (ts.isParenthesizedExpression(node)) {
            node = node.expression;
        }
        // - If we have safe property read ("a?.b") we want to get the Symbol for b, the `whenTrue`
        // expression.
        // - If our expression is a pipe binding ("a | test:b:c"), we want the Symbol for the
        // `transform` on the pipe.
        // - Otherwise, we retrieve the symbol for the node itself with no special considerations
        if (expression instanceof o.SafePropertyRead && ts.isConditionalExpression(node)) {
            const whenTrueSymbol = this.getSymbolOfTsNode(node.whenTrue);
            if (whenTrueSymbol === null) {
                return null;
            }
            return {
                ...whenTrueSymbol,
                kind: exports.SymbolKind.Expression,
                // Rather than using the type of only the `whenTrue` part of the expression, we should
                // still get the type of the whole conditional expression to include `|undefined`.
                tsType: this.getTypeChecker().getTypeAtLocation(node),
            };
        }
        else {
            const symbolInfo = this.getSymbolOfTsNode(node);
            return symbolInfo === null ? null : { ...symbolInfo, kind: exports.SymbolKind.Expression };
        }
    }
    getSymbolOfTsNode(node) {
        while (ts.isParenthesizedExpression(node)) {
            node = node.expression;
        }
        let tsSymbol;
        if (ts.isPropertyAccessExpression(node)) {
            tsSymbol = this.getTypeChecker().getSymbolAtLocation(node.name);
        }
        else if (ts.isCallExpression(node)) {
            tsSymbol = this.getTypeChecker().getSymbolAtLocation(node.expression);
        }
        else {
            tsSymbol = this.getTypeChecker().getSymbolAtLocation(node);
        }
        const positionInFile = this.getTcbPositionForNode(node);
        const type = this.getTypeChecker().getTypeAtLocation(node);
        return {
            // If we could not find a symbol, fall back to the symbol on the type for the node.
            // Some nodes won't have a "symbol at location" but will have a symbol for the type.
            // Examples of this would be literals and `document.createElement('div')`.
            tsSymbol: tsSymbol ?? type.symbol ?? null,
            tsType: type,
            tcbLocation: {
                tcbPath: this.tcbPath,
                isShimFile: this.tcbIsShim,
                positionInFile,
            },
        };
    }
    getTcbPositionForNode(node) {
        if (ts.isTypeReferenceNode(node)) {
            return this.getTcbPositionForNode(node.typeName);
        }
        else if (ts.isQualifiedName(node)) {
            return node.right.getStart();
        }
        else if (ts.isPropertyAccessExpression(node)) {
            return node.name.getStart();
        }
        else if (ts.isElementAccessExpression(node)) {
            return node.argumentExpression.getStart();
        }
        else {
            return node.getStart();
        }
    }
}
/** Filter predicate function that matches any AST node. */
function anyNodeFilter(n) {
    return true;
}
function sourceSpanEqual(a, b) {
    return a.start.offset === b.start.offset && a.end.offset === b.end.offset;
}
function unwrapSignalInputWriteTAccessor(expr) {
    // e.g. `_t2.inputA[i2.ÉµINPUT_SIGNAL_BRAND_WRITE_TYPE]`
    // 1. Assert that we are dealing with an element access expression.
    // 2. Assert that we are dealing with a signal brand symbol access in the argument expression.
    if (!ts.isElementAccessExpression(expr) ||
        !ts.isPropertyAccessExpression(expr.argumentExpression)) {
        return null;
    }
    // Assert that the property access in the element access is a simple identifier and
    // refers to `ÉµINPUT_SIGNAL_BRAND_WRITE_TYPE`.
    if (!ts.isIdentifier(expr.argumentExpression.name) ||
        expr.argumentExpression.name.text !== o.R3Identifiers.InputSignalBrandWriteType.name) {
        return null;
    }
    // Assert that the expression is either:
    //   - `_t2.inputA[ÉµINPUT_SIGNAL_BRAND_WRITE_TYPE]` or (common case)
    //   - or `_t2['input-A'][ÉµINPUT_SIGNAL_BRAND_WRITE_TYPE]` (non-identifier input field names)
    //   - or `_dirInput[ÉµINPUT_SIGNAL_BRAND_WRITE_TYPE` (honorAccessModifiersForInputBindings=false)
    // This is checked for type safety and to catch unexpected cases.
    if (!ts.isPropertyAccessExpression(expr.expression) &&
        !ts.isElementAccessExpression(expr.expression) &&
        !ts.isIdentifier(expr.expression)) {
        throw new Error('Unexpected expression for signal input write type.');
    }
    return {
        fieldExpr: expr.expression,
        typeExpr: expr,
    };
}
/**
 * Looks for a class declaration in the original source file that matches a given directive
 * from the type check source file.
 *
 * @param originalSourceFile The original source where the runtime code resides
 * @param directiveDeclarationInTypeCheckSourceFile The directive from the type check source file
 */
function findMatchingDirective(originalSourceFile, directiveDeclarationInTypeCheckSourceFile) {
    const className = directiveDeclarationInTypeCheckSourceFile.name?.text ?? '';
    // We build an index of the class declarations with the same name
    // To then compare the indexes to confirm we found the right class declaration
    const ogClasses = collectClassesWithName(originalSourceFile, className);
    const typecheckClasses = collectClassesWithName(directiveDeclarationInTypeCheckSourceFile.getSourceFile(), className);
    return ogClasses[typecheckClasses.indexOf(directiveDeclarationInTypeCheckSourceFile)] ?? null;
}
/**
 * Builds a list of class declarations of a given name
 * Is used as a index based reference to compare class declarations
 * between the typecheck source file and the original source file
 */
function collectClassesWithName(sourceFile, className) {
    const classes = [];
    function visit(node) {
        if (ts.isClassDeclaration(node) && node.name?.text === className) {
            classes.push(node);
        }
        ts.forEachChild(node, visit);
    }
    sourceFile.forEachChild(visit);
    return classes;
}

const REGISTRY = new o.DomElementSchemaRegistry();
/**
 * Primary template type-checking engine, which performs type-checking using a
 * `TypeCheckingProgramStrategy` for type-checking program maintenance, and the
 * `ProgramTypeCheckAdapter` for generation of template type-checking code.
 */
class TemplateTypeCheckerImpl {
    originalProgram;
    programDriver;
    typeCheckAdapter;
    config;
    refEmitter;
    reflector;
    compilerHost;
    priorBuild;
    metaReader;
    localMetaReader;
    ngModuleIndex;
    componentScopeReader;
    typeCheckScopeRegistry;
    perf;
    state = new Map();
    /**
     * Stores the `CompletionEngine` which powers autocompletion for each component class.
     *
     * Must be invalidated whenever the component's template or the `ts.Program` changes. Invalidation
     * on template changes is performed within this `TemplateTypeCheckerImpl` instance. When the
     * `ts.Program` changes, the `TemplateTypeCheckerImpl` as a whole is destroyed and replaced.
     */
    completionCache = new Map();
    /**
     * Stores the `SymbolBuilder` which creates symbols for each component class.
     *
     * Must be invalidated whenever the component's template or the `ts.Program` changes. Invalidation
     * on template changes is performed within this `TemplateTypeCheckerImpl` instance. When the
     * `ts.Program` changes, the `TemplateTypeCheckerImpl` as a whole is destroyed and replaced.
     */
    symbolBuilderCache = new Map();
    /**
     * Stores directives and pipes that are in scope for each component.
     *
     * Unlike other caches, the scope of a component is not affected by its template. It will be
     * destroyed when the `ts.Program` changes and the `TemplateTypeCheckerImpl` as a whole is
     * destroyed and replaced.
     */
    scopeCache = new Map();
    /**
     * Stores potential element tags for each component (a union of DOM tags as well as directive
     * tags).
     *
     * Unlike other caches, the scope of a component is not affected by its template. It will be
     * destroyed when the `ts.Program` changes and the `TemplateTypeCheckerImpl` as a whole is
     * destroyed and replaced.
     */
    elementTagCache = new Map();
    isComplete = false;
    priorResultsAdopted = false;
    constructor(originalProgram, programDriver, typeCheckAdapter, config, refEmitter, reflector, compilerHost, priorBuild, metaReader, localMetaReader, ngModuleIndex, componentScopeReader, typeCheckScopeRegistry, perf) {
        this.originalProgram = originalProgram;
        this.programDriver = programDriver;
        this.typeCheckAdapter = typeCheckAdapter;
        this.config = config;
        this.refEmitter = refEmitter;
        this.reflector = reflector;
        this.compilerHost = compilerHost;
        this.priorBuild = priorBuild;
        this.metaReader = metaReader;
        this.localMetaReader = localMetaReader;
        this.ngModuleIndex = ngModuleIndex;
        this.componentScopeReader = componentScopeReader;
        this.typeCheckScopeRegistry = typeCheckScopeRegistry;
        this.perf = perf;
    }
    getTemplate(component, optimizeFor) {
        const { data } = this.getLatestComponentState(component, optimizeFor);
        return data?.template ?? null;
    }
    getHostElement(directive, optimizeFor) {
        const { data } = this.getLatestComponentState(directive, optimizeFor);
        return data?.hostElement ?? null;
    }
    getDirectivesOfNode(component, node) {
        return (this.getLatestComponentState(component).data?.boundTarget.getDirectivesOfNode(node) ?? null);
    }
    getUsedDirectives(component) {
        return this.getLatestComponentState(component).data?.boundTarget.getUsedDirectives() ?? null;
    }
    getUsedPipes(component) {
        return this.getLatestComponentState(component).data?.boundTarget.getUsedPipes() ?? null;
    }
    getLatestComponentState(component, optimizeFor = exports.OptimizeFor.SingleFile) {
        switch (optimizeFor) {
            case exports.OptimizeFor.WholeProgram:
                this.ensureAllShimsForAllFiles();
                break;
            case exports.OptimizeFor.SingleFile:
                this.ensureShimForComponent(component);
                break;
        }
        const sf = component.getSourceFile();
        const sfPath = absoluteFromSourceFile(sf);
        const shimPath = TypeCheckShimGenerator.shimFor(sfPath);
        const fileRecord = this.getFileData(sfPath);
        if (!fileRecord.shimData.has(shimPath)) {
            return { data: null, tcb: null, tcbPath: shimPath, tcbIsShim: true };
        }
        const id = fileRecord.sourceManager.getTypeCheckId(component);
        const shimRecord = fileRecord.shimData.get(shimPath);
        const program = this.programDriver.getProgram();
        const shimSf = getSourceFileOrNull(program, shimPath);
        if (shimSf === null || !fileRecord.shimData.has(shimPath)) {
            throw new Error(`Error: no shim file in program: ${shimPath}`);
        }
        let tcb = findTypeCheckBlock(shimSf, id, /*isDiagnosticsRequest*/ false);
        let tcbPath = shimPath;
        if (tcb === null) {
            // Try for an inline block.
            const inlineSf = getSourceFileOrError(program, sfPath);
            tcb = findTypeCheckBlock(inlineSf, id, /*isDiagnosticsRequest*/ false);
            if (tcb !== null) {
                tcbPath = sfPath;
            }
        }
        let data = null;
        if (shimRecord.data.has(id)) {
            data = shimRecord.data.get(id);
        }
        return { data, tcb, tcbPath, tcbIsShim: tcbPath === shimPath };
    }
    isTrackedTypeCheckFile(filePath) {
        return this.getFileAndShimRecordsForPath(filePath) !== null;
    }
    getFileRecordForTcbLocation({ tcbPath, isShimFile, }) {
        if (!isShimFile) {
            // The location is not within a shim file but corresponds with an inline TCB in an original
            // source file; we can obtain the record directly by its path.
            if (this.state.has(tcbPath)) {
                return this.state.get(tcbPath);
            }
            else {
                return null;
            }
        }
        // The location is within a type-checking shim file; find the type-checking data that owns this
        // shim path.
        const records = this.getFileAndShimRecordsForPath(tcbPath);
        if (records !== null) {
            return records.fileRecord;
        }
        else {
            return null;
        }
    }
    getFileAndShimRecordsForPath(shimPath) {
        for (const fileRecord of this.state.values()) {
            if (fileRecord.shimData.has(shimPath)) {
                return { fileRecord, shimRecord: fileRecord.shimData.get(shimPath) };
            }
        }
        return null;
    }
    getSourceMappingAtTcbLocation(tcbLocation) {
        const fileRecord = this.getFileRecordForTcbLocation(tcbLocation);
        if (fileRecord === null) {
            return null;
        }
        const shimSf = this.programDriver.getProgram().getSourceFile(tcbLocation.tcbPath);
        if (shimSf === undefined) {
            return null;
        }
        return getSourceMapping(shimSf, tcbLocation.positionInFile, fileRecord.sourceManager, 
        /*isDiagnosticsRequest*/ false);
    }
    generateAllTypeCheckBlocks() {
        this.ensureAllShimsForAllFiles();
    }
    /**
     * Retrieve type-checking and template parse diagnostics from the given `ts.SourceFile` using the
     * most recent type-checking program.
     */
    getDiagnosticsForFile(sf, optimizeFor) {
        switch (optimizeFor) {
            case exports.OptimizeFor.WholeProgram:
                this.ensureAllShimsForAllFiles();
                break;
            case exports.OptimizeFor.SingleFile:
                this.ensureAllShimsForOneFile(sf);
                break;
        }
        return this.perf.inPhase(exports.PerfPhase.TtcDiagnostics, () => {
            const sfPath = absoluteFromSourceFile(sf);
            const fileRecord = this.state.get(sfPath);
            const typeCheckProgram = this.programDriver.getProgram();
            const diagnostics = [];
            if (fileRecord.hasInlines) {
                const inlineSf = getSourceFileOrError(typeCheckProgram, sfPath);
                diagnostics.push(...typeCheckProgram
                    .getSemanticDiagnostics(inlineSf)
                    .map((diag) => convertDiagnostic(diag, fileRecord.sourceManager)));
            }
            for (const [shimPath, shimRecord] of fileRecord.shimData) {
                const shimSf = getSourceFileOrError(typeCheckProgram, shimPath);
                diagnostics.push(...typeCheckProgram
                    .getSemanticDiagnostics(shimSf)
                    .map((diag) => convertDiagnostic(diag, fileRecord.sourceManager)));
                diagnostics.push(...shimRecord.genesisDiagnostics);
                for (const templateData of shimRecord.data.values()) {
                    diagnostics.push(...templateData.templateParsingDiagnostics);
                }
            }
            return diagnostics.filter((diag) => diag !== null);
        });
    }
    getSuggestionDiagnosticsForFile(sf, tsLs, optimizeFor) {
        switch (optimizeFor) {
            case exports.OptimizeFor.WholeProgram:
                this.ensureAllShimsForAllFiles();
                break;
            case exports.OptimizeFor.SingleFile:
                this.ensureAllShimsForOneFile(sf);
                break;
        }
        return this.perf.inPhase(exports.PerfPhase.TtcSuggestionDiagnostics, () => {
            const sfPath = absoluteFromSourceFile(sf);
            const fileRecord = this.state.get(sfPath);
            const diagnostics = [];
            const program = this.programDriver.getProgram();
            if (fileRecord.hasInlines) {
                diagnostics.push(...getDeprecatedSuggestionDiagnostics(tsLs, program, sfPath, fileRecord, this));
            }
            for (const [shimPath] of fileRecord.shimData) {
                diagnostics.push(...getDeprecatedSuggestionDiagnostics(tsLs, program, shimPath, fileRecord, this));
            }
            return diagnostics.filter((diag) => diag !== null);
        });
    }
    getDiagnosticsForComponent(component) {
        this.ensureShimForComponent(component);
        return this.perf.inPhase(exports.PerfPhase.TtcDiagnostics, () => {
            const sf = component.getSourceFile();
            const sfPath = absoluteFromSourceFile(sf);
            const shimPath = TypeCheckShimGenerator.shimFor(sfPath);
            const fileRecord = this.getFileData(sfPath);
            if (!fileRecord.shimData.has(shimPath)) {
                return [];
            }
            const id = fileRecord.sourceManager.getTypeCheckId(component);
            const shimRecord = fileRecord.shimData.get(shimPath);
            const typeCheckProgram = this.programDriver.getProgram();
            const diagnostics = [];
            if (shimRecord.hasInlines) {
                const inlineSf = getSourceFileOrError(typeCheckProgram, sfPath);
                diagnostics.push(...typeCheckProgram
                    .getSemanticDiagnostics(inlineSf)
                    .map((diag) => convertDiagnostic(diag, fileRecord.sourceManager)));
            }
            const shimSf = getSourceFileOrError(typeCheckProgram, shimPath);
            diagnostics.push(...typeCheckProgram
                .getSemanticDiagnostics(shimSf)
                .map((diag) => convertDiagnostic(diag, fileRecord.sourceManager)));
            diagnostics.push(...shimRecord.genesisDiagnostics);
            for (const templateData of shimRecord.data.values()) {
                diagnostics.push(...templateData.templateParsingDiagnostics);
            }
            return diagnostics.filter((diag) => diag !== null && diag.typeCheckId === id);
        });
    }
    getSuggestionDiagnosticsForComponent(component, tsLs) {
        this.ensureShimForComponent(component);
        return this.perf.inPhase(exports.PerfPhase.TtcSuggestionDiagnostics, () => {
            const sf = component.getSourceFile();
            const sfPath = absoluteFromSourceFile(sf);
            const shimPath = TypeCheckShimGenerator.shimFor(sfPath);
            const fileRecord = this.getFileData(sfPath);
            if (!fileRecord.shimData.has(shimPath)) {
                return [];
            }
            const templateId = fileRecord.sourceManager.getTypeCheckId(component);
            const shimRecord = fileRecord.shimData.get(shimPath);
            const diagnostics = [];
            const program = this.programDriver.getProgram();
            if (shimRecord.hasInlines) {
                diagnostics.push(...getDeprecatedSuggestionDiagnostics(tsLs, program, sfPath, fileRecord, this));
            }
            diagnostics.push(...getDeprecatedSuggestionDiagnostics(tsLs, program, shimPath, fileRecord, this));
            return diagnostics.filter((diag) => diag !== null && diag.typeCheckId === templateId);
        });
    }
    getTypeCheckBlock(component) {
        return this.getLatestComponentState(component).tcb;
    }
    getGlobalCompletions(context, component, node) {
        const engine = this.getOrCreateCompletionEngine(component);
        if (engine === null) {
            return null;
        }
        return this.perf.inPhase(exports.PerfPhase.TtcAutocompletion, () => engine.getGlobalCompletions(context, node));
    }
    getExpressionCompletionLocation(ast, component) {
        const engine = this.getOrCreateCompletionEngine(component);
        if (engine === null) {
            return null;
        }
        return this.perf.inPhase(exports.PerfPhase.TtcAutocompletion, () => engine.getExpressionCompletionLocation(ast));
    }
    getLiteralCompletionLocation(node, component) {
        const engine = this.getOrCreateCompletionEngine(component);
        if (engine === null) {
            return null;
        }
        return this.perf.inPhase(exports.PerfPhase.TtcAutocompletion, () => engine.getLiteralCompletionLocation(node));
    }
    invalidateClass(clazz) {
        this.completionCache.delete(clazz);
        this.symbolBuilderCache.delete(clazz);
        this.scopeCache.delete(clazz);
        this.elementTagCache.delete(clazz);
        const sf = clazz.getSourceFile();
        const sfPath = absoluteFromSourceFile(sf);
        const shimPath = TypeCheckShimGenerator.shimFor(sfPath);
        const fileData = this.getFileData(sfPath);
        fileData.sourceManager.getTypeCheckId(clazz);
        fileData.shimData.delete(shimPath);
        fileData.isComplete = false;
        this.isComplete = false;
    }
    getExpressionTarget(expression, clazz) {
        return (this.getLatestComponentState(clazz).data?.boundTarget.getExpressionTarget(expression) ?? null);
    }
    makeTemplateDiagnostic(clazz, sourceSpan, category, errorCode, message, relatedInformation) {
        const sfPath = absoluteFromSourceFile(clazz.getSourceFile());
        const fileRecord = this.state.get(sfPath);
        const id = fileRecord.sourceManager.getTypeCheckId(clazz);
        const mapping = fileRecord.sourceManager.getTemplateSourceMapping(id);
        return {
            ...makeTemplateDiagnostic(id, mapping, sourceSpan, category, ngErrorCode(errorCode), message, relatedInformation),
            __ngCode: errorCode,
        };
    }
    getOrCreateCompletionEngine(component) {
        if (this.completionCache.has(component)) {
            return this.completionCache.get(component);
        }
        const { tcb, data, tcbPath, tcbIsShim } = this.getLatestComponentState(component);
        if (tcb === null || data === null) {
            return null;
        }
        const engine = new CompletionEngine(tcb, data, tcbPath, tcbIsShim);
        this.completionCache.set(component, engine);
        return engine;
    }
    maybeAdoptPriorResults() {
        if (this.priorResultsAdopted) {
            return;
        }
        for (const sf of this.originalProgram.getSourceFiles()) {
            if (sf.isDeclarationFile || isShim(sf)) {
                continue;
            }
            const sfPath = absoluteFromSourceFile(sf);
            if (this.state.has(sfPath)) {
                const existingResults = this.state.get(sfPath);
                if (existingResults.isComplete) {
                    // All data for this file has already been generated, so no need to adopt anything.
                    continue;
                }
            }
            const previousResults = this.priorBuild.priorTypeCheckingResultsFor(sf);
            if (previousResults === null || !previousResults.isComplete) {
                continue;
            }
            this.perf.eventCount(exports.PerfEvent.ReuseTypeCheckFile);
            this.state.set(sfPath, previousResults);
        }
        this.priorResultsAdopted = true;
    }
    ensureAllShimsForAllFiles() {
        if (this.isComplete) {
            return;
        }
        this.maybeAdoptPriorResults();
        this.perf.inPhase(exports.PerfPhase.TcbGeneration, () => {
            const host = new WholeProgramTypeCheckingHost(this);
            const ctx = this.newContext(host);
            for (const sf of this.originalProgram.getSourceFiles()) {
                if (sf.isDeclarationFile || isShim(sf)) {
                    continue;
                }
                const sfPath = absoluteFromSourceFile(sf);
                const fileData = this.getFileData(sfPath);
                if (fileData.isComplete) {
                    continue;
                }
                this.typeCheckAdapter.typeCheck(sf, ctx);
                fileData.isComplete = true;
            }
            this.updateFromContext(ctx);
            this.isComplete = true;
        });
    }
    ensureAllShimsForOneFile(sf) {
        this.maybeAdoptPriorResults();
        this.perf.inPhase(exports.PerfPhase.TcbGeneration, () => {
            const sfPath = absoluteFromSourceFile(sf);
            const fileData = this.getFileData(sfPath);
            if (fileData.isComplete) {
                // All data for this file is present and accounted for already.
                return;
            }
            const host = new SingleFileTypeCheckingHost(sfPath, fileData, this);
            const ctx = this.newContext(host);
            this.typeCheckAdapter.typeCheck(sf, ctx);
            fileData.isComplete = true;
            this.updateFromContext(ctx);
        });
    }
    ensureShimForComponent(component) {
        this.maybeAdoptPriorResults();
        const sf = component.getSourceFile();
        const sfPath = absoluteFromSourceFile(sf);
        const shimPath = TypeCheckShimGenerator.shimFor(sfPath);
        const fileData = this.getFileData(sfPath);
        if (fileData.shimData.has(shimPath)) {
            // All data for this component is available.
            return;
        }
        const host = new SingleShimTypeCheckingHost(sfPath, fileData, this, shimPath);
        const ctx = this.newContext(host);
        this.typeCheckAdapter.typeCheck(sf, ctx);
        this.updateFromContext(ctx);
    }
    newContext(host) {
        const inlining = this.programDriver.supportsInlineOperations
            ? InliningMode.InlineOps
            : InliningMode.Error;
        return new TypeCheckContextImpl(this.config, this.compilerHost, this.refEmitter, this.reflector, host, inlining, this.perf);
    }
    /**
     * Remove any shim data that depends on inline operations applied to the type-checking program.
     *
     * This can be useful if new inlines need to be applied, and it's not possible to guarantee that
     * they won't overwrite or corrupt existing inlines that are used by such shims.
     */
    clearAllShimDataUsingInlines() {
        for (const fileData of this.state.values()) {
            if (!fileData.hasInlines) {
                continue;
            }
            for (const [shimFile, shimData] of fileData.shimData.entries()) {
                if (shimData.hasInlines) {
                    fileData.shimData.delete(shimFile);
                }
            }
            fileData.hasInlines = false;
            fileData.isComplete = false;
            this.isComplete = false;
        }
    }
    updateFromContext(ctx) {
        const updates = ctx.finalize();
        return this.perf.inPhase(exports.PerfPhase.TcbUpdateProgram, () => {
            if (updates.size > 0) {
                this.perf.eventCount(exports.PerfEvent.UpdateTypeCheckProgram);
            }
            this.programDriver.updateFiles(updates, exports.UpdateMode.Incremental);
            this.priorBuild.recordSuccessfulTypeCheck(this.state);
            this.perf.memory(exports.PerfCheckpoint.TtcUpdateProgram);
        });
    }
    getFileData(path) {
        if (!this.state.has(path)) {
            this.state.set(path, {
                hasInlines: false,
                sourceManager: new DirectiveSourceManager(),
                isComplete: false,
                shimData: new Map(),
            });
        }
        return this.state.get(path);
    }
    getSymbolOfNode(node, component) {
        const builder = this.getOrCreateSymbolBuilder(component);
        if (builder === null) {
            return null;
        }
        return this.perf.inPhase(exports.PerfPhase.TtcSymbol, () => builder.getSymbol(node));
    }
    getOrCreateSymbolBuilder(component) {
        if (this.symbolBuilderCache.has(component)) {
            return this.symbolBuilderCache.get(component);
        }
        const { tcb, data, tcbPath, tcbIsShim } = this.getLatestComponentState(component);
        if (tcb === null || data === null) {
            return null;
        }
        const builder = new SymbolBuilder(tcbPath, tcbIsShim, tcb, data, this.componentScopeReader, () => this.programDriver.getProgram().getTypeChecker());
        this.symbolBuilderCache.set(component, builder);
        return builder;
    }
    getGlobalTsContext(component) {
        const engine = this.getOrCreateCompletionEngine(component);
        if (engine === null) {
            return null;
        }
        return engine.getGlobalTsContext();
    }
    getPotentialTemplateDirectives(component, tsLs, options) {
        const scope = this.getComponentScope(component);
        // Don't resolve directives for selectorless components since they're already in the file.
        if (scope?.kind === ComponentScopeKind.Selectorless) {
            return [];
        }
        const resultingDirectives = new Map();
        const directivesInScope = this.getTemplateDirectiveInScope(component);
        const directiveInGlobal = this.getElementsInGlobal(component, tsLs, options);
        for (const directive of [...directivesInScope, ...directiveInGlobal]) {
            if (resultingDirectives.has(directive.ref.node)) {
                continue;
            }
            resultingDirectives.set(directive.ref.node, directive);
        }
        return Array.from(resultingDirectives.values());
    }
    getPotentialPipes(component) {
        const scope = this.getComponentScope(component);
        // Don't resolve pipes for selectorless components since they're already in the file.
        if (scope?.kind === ComponentScopeKind.Selectorless) {
            return [];
        }
        // Very similar to the above `getPotentialTemplateDirectives`, but on pipes.
        const typeChecker = this.programDriver.getProgram().getTypeChecker();
        const resultingPipes = new Map();
        if (scope !== null) {
            const inScopePipes = this.getScopeData(component, scope)?.pipes ?? [];
            for (const p of inScopePipes) {
                resultingPipes.set(p.ref.node, p);
            }
        }
        for (const pipeClass of this.localMetaReader.getKnown(MetaKind.Pipe)) {
            const pipeMeta = this.metaReader.getPipeMetadata(new Reference(pipeClass));
            if (pipeMeta === null)
                continue;
            if (resultingPipes.has(pipeClass))
                continue;
            const withScope = this.scopeDataOfPipeMeta(typeChecker, pipeMeta);
            if (withScope === null)
                continue;
            resultingPipes.set(pipeClass, { ...withScope, isInScope: false });
        }
        return Array.from(resultingPipes.values());
    }
    getDirectiveMetadata(dir) {
        if (!isNamedClassDeclaration(dir)) {
            return null;
        }
        return this.typeCheckScopeRegistry.getTypeCheckDirectiveMetadata(new Reference(dir));
    }
    getNgModuleMetadata(module) {
        if (!isNamedClassDeclaration(module)) {
            return null;
        }
        return this.metaReader.getNgModuleMetadata(new Reference(module));
    }
    getPipeMetadata(pipe) {
        if (!isNamedClassDeclaration(pipe)) {
            return null;
        }
        return this.metaReader.getPipeMetadata(new Reference(pipe));
    }
    getTemplateDirectiveInScope(component) {
        const resultingDirectives = new Map();
        const scope = this.getComponentScope(component);
        // Don't resolve directives for selectorless components since they're already in the file.
        if (scope?.kind === ComponentScopeKind.Selectorless) {
            return [];
        }
        if (scope !== null) {
            const inScopeDirectives = this.getScopeData(component, scope)?.directives ?? [];
            // First, all in scope directives can be used.
            for (const d of inScopeDirectives) {
                resultingDirectives.set(d.ref.node, d);
            }
        }
        const typeChecker = this.programDriver.getProgram().getTypeChecker();
        const currentComponentFileName = component.getSourceFile().fileName;
        // Any additional directives found from the global registry can be used, only includes the directives includes in the current
        // component file.
        //
        // This means only the inputs in the decorator are needed to be updated, no need to update the import statement.
        for (const directiveClass of this.localMetaReader.getKnown(MetaKind.Directive)) {
            if (directiveClass.getSourceFile().fileName !== currentComponentFileName) {
                continue;
            }
            const directiveMeta = this.metaReader.getDirectiveMetadata(new Reference(directiveClass));
            if (directiveMeta === null)
                continue;
            if (resultingDirectives.has(directiveClass))
                continue;
            const withScope = this.scopeDataOfDirectiveMeta(typeChecker, directiveMeta);
            if (withScope === null)
                continue;
            resultingDirectives.set(directiveClass, { ...withScope, isInScope: false });
        }
        return Array.from(resultingDirectives.values());
    }
    getDirectiveScopeData(component, isInScope, tsCompletionEntryInfo) {
        const typeChecker = this.programDriver.getProgram().getTypeChecker();
        if (!isNamedClassDeclaration(component)) {
            return null;
        }
        const directiveMeta = this.metaReader.getDirectiveMetadata(new Reference(component));
        if (directiveMeta === null) {
            return null;
        }
        const withScope = this.scopeDataOfDirectiveMeta(typeChecker, directiveMeta);
        if (withScope === null) {
            return null;
        }
        return {
            ...withScope,
            isInScope,
            /**
             * The Angular LS only supports displaying one directive at a time when
             * providing the completion item, even if it's exported by multiple modules.
             */
            tsCompletionEntryInfos: tsCompletionEntryInfo !== null ? [tsCompletionEntryInfo] : null,
        };
    }
    getElementsInFileScope(component) {
        const tagMap = new Map();
        const potentialDirectives = this.getTemplateDirectiveInScope(component);
        for (const directive of potentialDirectives) {
            if (directive.selector === null) {
                continue;
            }
            for (const selector of o.CssSelector.parse(directive.selector)) {
                if (selector.element === null || tagMap.has(selector.element)) {
                    // Skip this directive if it doesn't match an element tag, or if another directive has
                    // already been included with the same element name.
                    continue;
                }
                tagMap.set(selector.element, directive);
            }
        }
        return tagMap;
    }
    getElementsInGlobal(component, tsLs, options) {
        // Add the additional directives from the global registry, which are not in scope and in different file with the current
        // component file.
        //
        // This means the inputs and the import statement in the decorator are needed to be updated.
        const tsContext = this.getGlobalTsContext(component);
        if (tsContext === null) {
            return [];
        }
        if (!options.includeExternalModule) {
            return [];
        }
        const entries = tsLs.getCompletionsAtPosition(tsContext.tcbPath, tsContext.positionInFile, {
            includeSymbol: true,
            includeCompletionsForModuleExports: true,
        })?.entries;
        const typeChecker = this.programDriver.getProgram().getTypeChecker();
        const resultingDirectives = new Map();
        const currentComponentFileName = component.getSourceFile().fileName;
        for (const { symbol, data } of entries ?? []) {
            const symbolFileName = symbol?.declarations?.[0]?.getSourceFile().fileName;
            const symbolName = symbol?.name;
            if (symbolFileName === undefined || symbolName === undefined) {
                continue;
            }
            if (symbolFileName === currentComponentFileName) {
                continue;
            }
            const decl = getClassDeclFromSymbol(symbol, typeChecker);
            if (decl === null) {
                continue;
            }
            const directiveDecls = [];
            const ref = new Reference(decl);
            const directiveMeta = this.metaReader.getDirectiveMetadata(ref);
            if (directiveMeta?.isStandalone) {
                directiveDecls.push({
                    meta: directiveMeta,
                    ref,
                });
            }
            else {
                const directiveDeclsForNgModule = this.getDirectiveDeclsForNgModule(ref);
                directiveDecls.push(...directiveDeclsForNgModule);
            }
            for (const directiveDecl of directiveDecls) {
                const cachedCompletionEntryInfos = resultingDirectives.get(directiveDecl.ref.node)?.tsCompletionEntryInfos ?? [];
                appendOrReplaceTsEntryInfo(cachedCompletionEntryInfos, {
                    tsCompletionEntryData: data,
                    tsCompletionEntrySymbolFileName: symbolFileName,
                    tsCompletionEntrySymbolName: symbolName,
                }, this.programDriver.getProgram());
                if (resultingDirectives.has(directiveDecl.ref.node)) {
                    const directiveInfo = resultingDirectives.get(directiveDecl.ref.node);
                    resultingDirectives.set(directiveDecl.ref.node, {
                        ...directiveInfo,
                        tsCompletionEntryInfos: cachedCompletionEntryInfos,
                    });
                    continue;
                }
                const withScope = this.scopeDataOfDirectiveMeta(typeChecker, directiveDecl.meta);
                if (withScope === null) {
                    continue;
                }
                resultingDirectives.set(directiveDecl.ref.node, {
                    ...withScope,
                    isInScope: false,
                    tsCompletionEntryInfos: cachedCompletionEntryInfos,
                });
            }
        }
        return Array.from(resultingDirectives.values());
    }
    /**
     * If the NgModule exports a new module, we need to recursively get its directives.
     */
    getDirectiveDeclsForNgModule(ref) {
        const ngModuleMeta = this.metaReader.getNgModuleMetadata(ref);
        if (ngModuleMeta === null) {
            return [];
        }
        const directiveDecls = [];
        for (const moduleExports of ngModuleMeta.exports) {
            const directiveMeta = this.metaReader.getDirectiveMetadata(moduleExports);
            if (directiveMeta !== null) {
                directiveDecls.push({
                    meta: directiveMeta,
                    ref: moduleExports,
                });
            }
            else {
                const ngModuleMeta = this.metaReader.getNgModuleMetadata(moduleExports);
                if (ngModuleMeta === null) {
                    continue;
                }
                // If the export is an NgModule, we need to recursively get its directives.
                const nestedDirectiveDecls = this.getDirectiveDeclsForNgModule(moduleExports);
                directiveDecls.push(...nestedDirectiveDecls);
            }
        }
        return directiveDecls;
    }
    getPotentialElementTags(component, tsLs, options) {
        if (this.elementTagCache.has(component)) {
            return this.elementTagCache.get(component);
        }
        const tagMap = new Map();
        for (const tag of REGISTRY.allKnownElementNames()) {
            tagMap.set(tag, null);
        }
        const potentialDirectives = this.getPotentialTemplateDirectives(component, tsLs, options);
        for (const directive of potentialDirectives) {
            if (directive.selector === null) {
                continue;
            }
            for (const selector of o.CssSelector.parse(directive.selector)) {
                if (selector.element === null || tagMap.has(selector.element)) {
                    // Skip this directive if it doesn't match an element tag, or if another directive has
                    // already been included with the same element name.
                    continue;
                }
                tagMap.set(selector.element, directive);
            }
        }
        this.elementTagCache.set(component, tagMap);
        return tagMap;
    }
    getPotentialDomBindings(tagName) {
        const attributes = REGISTRY.allKnownAttributesOfElement(tagName);
        return attributes.map((attribute) => ({
            attribute,
            property: REGISTRY.getMappedPropName(attribute),
        }));
    }
    getPotentialDomEvents(tagName) {
        return REGISTRY.allKnownEventsOfElement(tagName);
    }
    getPrimaryAngularDecorator(target) {
        this.ensureAllShimsForOneFile(target.getSourceFile());
        if (!isNamedClassDeclaration(target)) {
            return null;
        }
        const ref = new Reference(target);
        const dirMeta = this.metaReader.getDirectiveMetadata(ref);
        if (dirMeta !== null) {
            return dirMeta.decorator;
        }
        const pipeMeta = this.metaReader.getPipeMetadata(ref);
        if (pipeMeta !== null) {
            return pipeMeta.decorator;
        }
        const ngModuleMeta = this.metaReader.getNgModuleMetadata(ref);
        if (ngModuleMeta !== null) {
            return ngModuleMeta.decorator;
        }
        return null;
    }
    getOwningNgModule(component) {
        if (!isNamedClassDeclaration(component)) {
            return null;
        }
        const dirMeta = this.metaReader.getDirectiveMetadata(new Reference(component));
        if (dirMeta !== null && dirMeta.isStandalone) {
            return null;
        }
        const scope = this.componentScopeReader.getScopeForComponent(component);
        if (scope === null ||
            scope.kind !== ComponentScopeKind.NgModule ||
            !isNamedClassDeclaration(scope.ngModule)) {
            return null;
        }
        return scope.ngModule;
    }
    emit(kind, refTo, inContext) {
        const emittedRef = this.refEmitter.emit(refTo, inContext.getSourceFile());
        if (emittedRef.kind === exports.ReferenceEmitKind.Failed) {
            return null;
        }
        const emitted = emittedRef.expression;
        if (emitted instanceof o.WrappedNodeExpr) {
            if (refTo.node === inContext) {
                // Suppress self-imports since components do not have to import themselves.
                return null;
            }
            let isForwardReference = false;
            if (emitted.node.getStart() > inContext.getStart()) {
                const declaration = this.programDriver
                    .getProgram()
                    .getTypeChecker()
                    .getTypeAtLocation(emitted.node)
                    .getSymbol()?.declarations?.[0];
                if (declaration && declaration.getSourceFile() === inContext.getSourceFile()) {
                    isForwardReference = true;
                }
            }
            // An appropriate identifier is already in scope.
            return { kind, symbolName: emitted.node.text, isForwardReference };
        }
        else if (emitted instanceof o.ExternalExpr &&
            emitted.value.moduleName !== null &&
            emitted.value.name !== null) {
            return {
                kind,
                moduleSpecifier: emitted.value.moduleName,
                symbolName: emitted.value.name,
                isForwardReference: false,
            };
        }
        return null;
    }
    getPotentialImportsFor(toImport, inContext, importMode, potentialDirectiveModuleSpecifierResolver) {
        const imports = [];
        const meta = this.metaReader.getDirectiveMetadata(toImport) ?? this.metaReader.getPipeMetadata(toImport);
        if (meta === null) {
            return imports;
        }
        /**
         * When providing completion items, the Angular Language Service only supports displaying
         * one directive at a time. If a directive is exported by two different modules,
         * the Language Service will select the first module. To ensure the most appropriate directive
         * is shown, move the likely one to the top of the import list.
         *
         * When providing the code action for the directive. All the imports will show for the developer to choose.
         */
        let highestImportPriority = -1;
        const collectImports = (emit, moduleSpecifierDetail) => {
            if (emit === null) {
                return;
            }
            imports.push({
                ...emit,
                moduleSpecifier: moduleSpecifierDetail?.moduleSpecifier ?? emit.moduleSpecifier,
                symbolName: moduleSpecifierDetail?.exportName ?? emit.symbolName,
            });
            if (moduleSpecifierDetail !== null && highestImportPriority === -1) {
                highestImportPriority = imports.length - 1;
            }
        };
        if (meta.isStandalone || importMode === exports.PotentialImportMode.ForceDirect) {
            const emitted = this.emit(exports.PotentialImportKind.Standalone, toImport, inContext);
            const moduleSpecifierDetail = potentialDirectiveModuleSpecifierResolver?.resolve(toImport, inContext) ?? null;
            collectImports(emitted, moduleSpecifierDetail);
        }
        const exportingNgModules = this.ngModuleIndex.getNgModulesExporting(meta.ref.node);
        if (exportingNgModules !== null) {
            for (const exporter of exportingNgModules) {
                const emittedRef = this.emit(exports.PotentialImportKind.NgModule, exporter, inContext);
                const moduleSpecifierDetail = potentialDirectiveModuleSpecifierResolver?.resolve(exporter, inContext) ?? null;
                collectImports(emittedRef, moduleSpecifierDetail);
            }
        }
        // move the import with module specifier from the tsLs to top in the imports array
        if (highestImportPriority > 0) {
            const highImport = imports.splice(highestImportPriority, 1)[0];
            imports.unshift(highImport);
        }
        return imports;
    }
    getComponentScope(component) {
        if (!isNamedClassDeclaration(component)) {
            throw new Error(`AssertionError: components must have names`);
        }
        return this.componentScopeReader.getScopeForComponent(component);
    }
    getScopeData(component, scope) {
        if (this.scopeCache.has(component)) {
            return this.scopeCache.get(component);
        }
        const dependencies = scope.kind === ComponentScopeKind.NgModule
            ? scope.compilation.dependencies
            : scope.dependencies;
        const data = {
            directives: [],
            pipes: [],
            isPoisoned: scope.kind === ComponentScopeKind.NgModule
                ? scope.compilation.isPoisoned
                : scope.isPoisoned,
        };
        const typeChecker = this.programDriver.getProgram().getTypeChecker();
        for (const dep of dependencies) {
            if (dep.kind === MetaKind.Directive) {
                const dirScope = this.scopeDataOfDirectiveMeta(typeChecker, dep);
                if (dirScope === null)
                    continue;
                data.directives.push({ ...dirScope, isInScope: true });
            }
            else if (dep.kind === MetaKind.Pipe) {
                const pipeScope = this.scopeDataOfPipeMeta(typeChecker, dep);
                if (pipeScope === null)
                    continue;
                data.pipes.push({ ...pipeScope, isInScope: true });
            }
        }
        this.scopeCache.set(component, data);
        return data;
    }
    scopeDataOfDirectiveMeta(typeChecker, dep) {
        if (dep.selector === null) {
            // Skip this directive, it can't be added to a template anyway.
            return null;
        }
        const tsSymbol = typeChecker.getSymbolAtLocation(dep.ref.node.name);
        if (!isSymbolWithValueDeclaration(tsSymbol)) {
            return null;
        }
        let ngModule = null;
        const moduleScopeOfDir = this.componentScopeReader.getScopeForComponent(dep.ref.node);
        if (moduleScopeOfDir !== null && moduleScopeOfDir.kind === ComponentScopeKind.NgModule) {
            ngModule = moduleScopeOfDir.ngModule;
        }
        return {
            ref: dep.ref,
            isComponent: dep.isComponent,
            isStructural: dep.isStructural,
            selector: dep.selector,
            tsSymbol,
            ngModule,
            tsCompletionEntryInfos: null,
        };
    }
    scopeDataOfPipeMeta(typeChecker, dep) {
        const tsSymbol = typeChecker.getSymbolAtLocation(dep.ref.node.name);
        if (tsSymbol === undefined) {
            return null;
        }
        return {
            ref: dep.ref,
            name: dep.name,
            tsSymbol,
            tsCompletionEntryInfos: null,
        };
    }
}
function convertDiagnostic(diag, sourceResolver) {
    if (!shouldReportDiagnostic(diag)) {
        return null;
    }
    return translateDiagnostic(diag, sourceResolver);
}
/**
 * Drives a `TypeCheckContext` to generate type-checking code for every component in the program.
 */
class WholeProgramTypeCheckingHost {
    impl;
    constructor(impl) {
        this.impl = impl;
    }
    getSourceManager(sfPath) {
        return this.impl.getFileData(sfPath).sourceManager;
    }
    shouldCheckClass(node) {
        const sfPath = absoluteFromSourceFile(node.getSourceFile());
        const shimPath = TypeCheckShimGenerator.shimFor(sfPath);
        const fileData = this.impl.getFileData(sfPath);
        // The component needs to be checked unless the shim which would contain it already exists.
        return !fileData.shimData.has(shimPath);
    }
    recordShimData(sfPath, data) {
        const fileData = this.impl.getFileData(sfPath);
        fileData.shimData.set(data.path, data);
        if (data.hasInlines) {
            fileData.hasInlines = true;
        }
    }
    recordComplete(sfPath) {
        this.impl.getFileData(sfPath).isComplete = true;
    }
}
/**
 * Drives a `TypeCheckContext` to generate type-checking code efficiently for a single input file.
 */
class SingleFileTypeCheckingHost {
    sfPath;
    fileData;
    impl;
    seenInlines = false;
    constructor(sfPath, fileData, impl) {
        this.sfPath = sfPath;
        this.fileData = fileData;
        this.impl = impl;
    }
    assertPath(sfPath) {
        if (this.sfPath !== sfPath) {
            throw new Error(`AssertionError: querying TypeCheckingHost outside of assigned file`);
        }
    }
    getSourceManager(sfPath) {
        this.assertPath(sfPath);
        return this.fileData.sourceManager;
    }
    shouldCheckClass(node) {
        if (this.sfPath !== absoluteFromSourceFile(node.getSourceFile())) {
            return false;
        }
        const shimPath = TypeCheckShimGenerator.shimFor(this.sfPath);
        // Only need to generate a TCB for the class if no shim exists for it currently.
        return !this.fileData.shimData.has(shimPath);
    }
    recordShimData(sfPath, data) {
        this.assertPath(sfPath);
        // Previous type-checking state may have required the use of inlines (assuming they were
        // supported). If the current operation also requires inlines, this presents a problem:
        // generating new inlines may invalidate any old inlines that old state depends on.
        //
        // Rather than resolve this issue by tracking specific dependencies on inlines, if the new state
        // relies on inlines, any old state that relied on them is simply cleared. This happens when the
        // first new state that uses inlines is encountered.
        if (data.hasInlines && !this.seenInlines) {
            this.impl.clearAllShimDataUsingInlines();
            this.seenInlines = true;
        }
        this.fileData.shimData.set(data.path, data);
        if (data.hasInlines) {
            this.fileData.hasInlines = true;
        }
    }
    recordComplete(sfPath) {
        this.assertPath(sfPath);
        this.fileData.isComplete = true;
    }
}
/**
 * Drives a `TypeCheckContext` to generate type-checking code efficiently for only those components
 * which map to a single shim of a single input file.
 */
class SingleShimTypeCheckingHost extends SingleFileTypeCheckingHost {
    shimPath;
    constructor(sfPath, fileData, impl, shimPath) {
        super(sfPath, fileData, impl);
        this.shimPath = shimPath;
    }
    shouldCheckNode(node) {
        if (this.sfPath !== absoluteFromSourceFile(node.getSourceFile())) {
            return false;
        }
        // Only generate a TCB for the component if it maps to the requested shim file.
        const shimPath = TypeCheckShimGenerator.shimFor(this.sfPath);
        if (shimPath !== this.shimPath) {
            return false;
        }
        // Only need to generate a TCB for the class if no shim exists for it currently.
        return !this.fileData.shimData.has(shimPath);
    }
}
function getClassDeclFromSymbol(symbol, checker) {
    const tsDecl = symbol?.getDeclarations();
    if (tsDecl === undefined) {
        return null;
    }
    let decl = tsDecl.length > 0 ? tsDecl[0] : undefined;
    if (decl === undefined) {
        return null;
    }
    if (ts.isExportAssignment(decl)) {
        const symbol = checker.getTypeAtLocation(decl.expression).getSymbol();
        return getClassDeclFromSymbol(symbol, checker);
    }
    if (ts.isExportSpecifier(decl)) {
        const symbol = checker.getTypeAtLocation(decl).getSymbol();
        return getClassDeclFromSymbol(symbol, checker);
    }
    if (isNamedClassDeclaration(decl)) {
        return decl;
    }
    return null;
}
/**
 * Returns the diagnostics that report deprecated symbols in the given TypeScript language service.
 *
 * There are two logins here:
 *
 * 1. For input properties, function calls, and so on, the diagnostics reported in the TypeScript
 *    Language Service can be directly transformed into template diagnostics.
 * 2. For the element tag deprecation, we need to manually connect the TCB node to the template node
 *    and generate the template diagnostics.
 */
function getDeprecatedSuggestionDiagnostics(tsLs, program, path, fileRecord, templateTypeChecker) {
    const sourceFile = program.getSourceFile(path);
    if (sourceFile === undefined) {
        return [];
    }
    const tsDiags = tsLs.getSuggestionDiagnostics(path).filter(isDeprecatedDiagnostics);
    const commonTemplateDiags = tsDiags.map((diag) => {
        return convertDiagnostic(diag, fileRecord.sourceManager);
    });
    const elementTagDiags = getTheElementTagDeprecatedSuggestionDiagnostics(path, program, fileRecord, tsDiags, templateTypeChecker);
    return [...commonTemplateDiags, ...elementTagDiags];
}
/**
 * Connect the TCB node to the template node and generate the template diagnostics.
 *
 * How to generate the template diagnostics:
 *
 * 1. For each diagnostic, find the TCB node that is reported.
 * 2. Build a map called `nodeToDiag` that the key is the type node and value is the diagnostic.
 *    For example:
 *    ```
 *    var _t1 = null! as TestDir;
 *                       ^^^^^^^------ This is diagnostic node that is reported by the ts.
 *    ```
 *    The key is the class component of TestDir.
 * 3. Find the all directive nodes in the TCB.
 *    For example:
 *    In the above example, the directive node is `_t1`, get the type of `_t1` which is the
 *    class component of `TestDir`. Check if there is a diagnostic in the `nodeToDiag` map
 *    that matches the class component of `TestDir`.
 *    If there is a match, it means that the diagnostic is reported for the directive node
 * 4. Generate the template diagnostic and return the template diagnostics.
 */
function getTheElementTagDeprecatedSuggestionDiagnostics(shimPath, program, fileRecord, diags, templateTypeChecker) {
    const sourceFile = program.getSourceFile(shimPath);
    if (sourceFile === undefined) {
        return [];
    }
    const typeChecker = program.getTypeChecker();
    const nodeToDiag = new Map();
    for (const tsDiag of diags) {
        const diagNode = getTokenAtPosition(sourceFile, tsDiag.start);
        const nodeType = typeChecker.getTypeAtLocation(diagNode);
        const nodeSymbolDeclarations = nodeType.getSymbol()?.declarations;
        const decl = nodeSymbolDeclarations !== undefined && nodeSymbolDeclarations.length > 0
            ? nodeSymbolDeclarations[0]
            : undefined;
        if (decl === undefined || !ts.isClassDeclaration(decl)) {
            continue;
        }
        const directiveForDiagnostic = templateTypeChecker.getDirectiveMetadata(decl);
        // For now, we only report deprecations for components. This is because
        // directive spans apply to the entire element, so it would cause the deprecation to
        // appear as a deprecation for the element rather than whatever the selector (likely an attribute)
        // is for the directive. Technically components have this issue as well but nearly
        // all component selectors are element selectors.
        if (directiveForDiagnostic === null || !directiveForDiagnostic.isComponent) {
            continue;
        }
        nodeToDiag.set(decl, tsDiag);
    }
    const directiveNodesInTcb = findAllMatchingNodes(sourceFile, {
        filter: isDirectiveDeclaration,
    });
    const templateDiagnostics = [];
    for (const directive of directiveNodesInTcb) {
        const directiveType = typeChecker.getTypeAtLocation(directive);
        const directiveSymbolDeclarations = directiveType.getSymbol()?.declarations;
        const decl = directiveSymbolDeclarations !== undefined && directiveSymbolDeclarations.length > 0
            ? directiveSymbolDeclarations[0]
            : undefined;
        if (decl === undefined) {
            continue;
        }
        if (!ts.isClassDeclaration(decl)) {
            continue;
        }
        const diagnostic = nodeToDiag.get(decl);
        if (diagnostic === undefined) {
            continue;
        }
        const fullMapping = getSourceMapping(diagnostic.file, directive.getStart(), fileRecord.sourceManager, 
        /**
         * Don't set to true, the deprecated diagnostics will be ignored if this is a diagnostics request.
         * Only the deprecated diagnostics will be reported here.
         */
        // For example:
        // var _t2 /*T:DIR*/ /*87,104*/ = _ctor1({ "name": ("") /*96,103*/ }) /*D:ignore*/;
        // At the end of the statement, there is a comment `/*D:ignore*/` which means that this diagnostic
        // should be ignored in diagnostics request.
        /*isDiagnosticsRequest*/ false);
        if (fullMapping === null) {
            continue;
        }
        const { sourceLocation, sourceMapping: templateSourceMapping, span } = fullMapping;
        const templateDiagnostic = makeTemplateDiagnostic(sourceLocation.id, templateSourceMapping, span, diagnostic.category, diagnostic.code, diagnostic.messageText, undefined, diagnostic.reportsDeprecated !== undefined
            ? {
                reportsDeprecated: diagnostic.reportsDeprecated,
                relatedMessages: diagnostic.relatedInformation,
            }
            : undefined);
        templateDiagnostics.push(templateDiagnostic);
    }
    return templateDiagnostics;
}
function isDeprecatedDiagnostics(diag) {
    return diag.reportsDeprecated !== undefined;
}
/**
 * Append the ts completion entry into the array only when the new entry's directive
 * doesn't exist in the array.
 *
 * If the new entry's directive already exists, and the entry's symbol is the alias of
 * the existing entry, the new entry will replace the existing entry.
 *
 */
function appendOrReplaceTsEntryInfo(tsEntryInfos, newTsEntryInfo, program) {
    const typeChecker = program.getTypeChecker();
    const newTsEntryInfoSymbol = getSymbolFromTsEntryInfo(newTsEntryInfo, program);
    if (newTsEntryInfoSymbol === null) {
        return;
    }
    // Find the index of the first entry that has a matching type.
    const matchedEntryIndex = tsEntryInfos.findIndex((currentTsEntryInfo) => {
        const currentTsEntrySymbol = getSymbolFromTsEntryInfo(currentTsEntryInfo, program);
        if (currentTsEntrySymbol === null) {
            return false;
        }
        return isSymbolTypeMatch(currentTsEntrySymbol, newTsEntryInfoSymbol, typeChecker);
    });
    if (matchedEntryIndex === -1) {
        // No entry with a matching type was found, so append the new entry.
        tsEntryInfos.push(newTsEntryInfo);
        return;
    }
    // An entry with a matching type was found at matchedEntryIndex.
    const matchedEntry = tsEntryInfos[matchedEntryIndex];
    const matchedEntrySymbol = getSymbolFromTsEntryInfo(matchedEntry, program);
    if (matchedEntrySymbol === null) {
        // Should not happen based on the findIndex condition, but check defensively.
        return;
    }
    // Check if the `matchedEntrySymbol` is an alias of the `newTsEntryInfoSymbol`.
    if (isSymbolAliasOf(matchedEntrySymbol, newTsEntryInfoSymbol, typeChecker)) {
        // The first type-matching entry is an alias, so replace it.
        tsEntryInfos[matchedEntryIndex] = newTsEntryInfo;
        return;
    }
    // The new entry's symbol is an alias of the existing entry's symbol.
    // In this case, we prefer to keep the existing entry that was found first
    // and do not replace it.
    return;
}
function getSymbolFromTsEntryInfo(tsInfo, program) {
    const typeChecker = program.getTypeChecker();
    const sf = program.getSourceFile(tsInfo.tsCompletionEntrySymbolFileName);
    if (sf === undefined) {
        return null;
    }
    const sfSymbol = typeChecker.getSymbolAtLocation(sf);
    if (sfSymbol === undefined) {
        return null;
    }
    return (typeChecker.tryGetMemberInModuleExports(tsInfo.tsCompletionEntrySymbolName, sfSymbol) ?? null);
}
function getFirstTypeDeclarationOfSymbol(symbol, typeChecker) {
    const type = typeChecker.getTypeOfSymbol(symbol);
    return type.getSymbol()?.declarations?.[0];
}
/**
 * Check if the two symbols come from the same type node. For example:
 *
 * The `NewBarComponent`'s type node is the `BarComponent`.
 *
 * ```
 * // a.ts
 * export class BarComponent
 *
 * // b.ts
 * import {BarComponent} from "./a"
 * const NewBarComponent = BarComponent;
 * export {NewBarComponent}
 * ```
 */
function isSymbolTypeMatch(first, last, typeChecker) {
    const firstTypeNode = getFirstTypeDeclarationOfSymbol(first, typeChecker);
    const lastTypeNode = getFirstTypeDeclarationOfSymbol(last, typeChecker);
    return firstTypeNode === lastTypeNode && firstTypeNode !== undefined;
}

const FIELD_DECORATORS = [
    'Input',
    'Output',
    'ViewChild',
    'ViewChildren',
    'ContentChild',
    'ContentChildren',
    'HostBinding',
    'HostListener',
];
const LIFECYCLE_HOOKS = new Set([
    'ngOnChanges',
    'ngOnInit',
    'ngOnDestroy',
    'ngDoCheck',
    'ngAfterViewInit',
    'ngAfterViewChecked',
    'ngAfterContentInit',
    'ngAfterContentChecked',
]);
class DirectiveDecoratorHandler {
    reflector;
    evaluator;
    metaRegistry;
    scopeRegistry;
    metaReader;
    injectableRegistry;
    refEmitter;
    referencesRegistry;
    isCore;
    strictCtorDeps;
    semanticDepGraphUpdater;
    annotateForClosureCompiler;
    perf;
    importTracker;
    includeClassMetadata;
    typeCheckScopeRegistry;
    compilationMode;
    jitDeclarationRegistry;
    resourceRegistry;
    strictStandalone;
    implicitStandaloneValue;
    usePoisonedData;
    typeCheckHostBindings;
    emitDeclarationOnly;
    constructor(reflector, evaluator, metaRegistry, scopeRegistry, metaReader, injectableRegistry, refEmitter, referencesRegistry, isCore, strictCtorDeps, semanticDepGraphUpdater, annotateForClosureCompiler, perf, importTracker, includeClassMetadata, typeCheckScopeRegistry, compilationMode, jitDeclarationRegistry, resourceRegistry, strictStandalone, implicitStandaloneValue, usePoisonedData, typeCheckHostBindings, emitDeclarationOnly) {
        this.reflector = reflector;
        this.evaluator = evaluator;
        this.metaRegistry = metaRegistry;
        this.scopeRegistry = scopeRegistry;
        this.metaReader = metaReader;
        this.injectableRegistry = injectableRegistry;
        this.refEmitter = refEmitter;
        this.referencesRegistry = referencesRegistry;
        this.isCore = isCore;
        this.strictCtorDeps = strictCtorDeps;
        this.semanticDepGraphUpdater = semanticDepGraphUpdater;
        this.annotateForClosureCompiler = annotateForClosureCompiler;
        this.perf = perf;
        this.importTracker = importTracker;
        this.includeClassMetadata = includeClassMetadata;
        this.typeCheckScopeRegistry = typeCheckScopeRegistry;
        this.compilationMode = compilationMode;
        this.jitDeclarationRegistry = jitDeclarationRegistry;
        this.resourceRegistry = resourceRegistry;
        this.strictStandalone = strictStandalone;
        this.implicitStandaloneValue = implicitStandaloneValue;
        this.usePoisonedData = usePoisonedData;
        this.typeCheckHostBindings = typeCheckHostBindings;
        this.emitDeclarationOnly = emitDeclarationOnly;
        this.undecoratedMetadataExtractor = getDirectiveUndecoratedMetadataExtractor(reflector, importTracker);
    }
    precedence = HandlerPrecedence.PRIMARY;
    name = 'DirectiveDecoratorHandler';
    undecoratedMetadataExtractor;
    detect(node, decorators) {
        // If a class is undecorated but uses Angular features, we detect it as an
        // abstract directive. This is an unsupported pattern as of v10, but we want
        // to still detect these patterns so that we can report diagnostics.
        if (!decorators) {
            const angularField = this.findClassFieldWithAngularFeatures(node);
            return angularField
                ? { trigger: angularField.node, decorator: null, metadata: null }
                : undefined;
        }
        else {
            const decorator = findAngularDecorator(decorators, 'Directive', this.isCore);
            return decorator ? { trigger: decorator.node, decorator, metadata: decorator } : undefined;
        }
    }
    analyze(node, decorator) {
        // Skip processing of the class declaration if compilation of undecorated classes
        // with Angular features is disabled. Previously in ngtsc, such classes have always
        // been processed, but we want to enforce a consistent decorator mental model.
        // See: https://v9.angular.io/guide/migration-undecorated-classes.
        if (decorator === null) {
            // If compiling @angular/core, skip the diagnostic as core occasionally hand-writes
            // definitions.
            if (this.isCore) {
                return {};
            }
            return { diagnostics: [getUndecoratedClassWithAngularFeaturesDiagnostic(node)] };
        }
        this.perf.eventCount(exports.PerfEvent.AnalyzeDirective);
        const directiveResult = extractDirectiveMetadata(node, decorator, this.reflector, this.importTracker, this.evaluator, this.refEmitter, this.referencesRegistry, this.isCore, this.annotateForClosureCompiler, this.compilationMode, 
        /* defaultSelector */ null, this.strictStandalone, this.implicitStandaloneValue, this.emitDeclarationOnly);
        // `extractDirectiveMetadata` returns `jitForced = true` when the `@Directive` has
        // set `jit: true`. In this case, compilation of the decorator is skipped. Returning
        // an empty object signifies that no analysis was produced.
        if (directiveResult.jitForced) {
            this.jitDeclarationRegistry.jitDeclarations.add(node);
            return {};
        }
        const analysis = directiveResult.metadata;
        let providersRequiringFactory = null;
        if (directiveResult !== undefined && directiveResult.decorator.has('providers')) {
            providersRequiringFactory = resolveProvidersRequiringFactory(directiveResult.decorator.get('providers'), this.reflector, this.evaluator);
        }
        return {
            analysis: {
                inputs: directiveResult.inputs,
                inputFieldNamesFromMetadataArray: directiveResult.inputFieldNamesFromMetadataArray,
                outputs: directiveResult.outputs,
                meta: analysis,
                hostDirectives: directiveResult.hostDirectives,
                rawHostDirectives: directiveResult.rawHostDirectives,
                classMetadata: this.includeClassMetadata
                    ? extractClassMetadata(node, this.reflector, this.isCore, this.annotateForClosureCompiler, undefined, this.undecoratedMetadataExtractor)
                    : null,
                baseClass: readBaseClass$1(node, this.reflector, this.evaluator),
                typeCheckMeta: extractDirectiveTypeCheckMeta(node, directiveResult.inputs, this.reflector),
                providersRequiringFactory,
                isPoisoned: false,
                isStructural: directiveResult.isStructural,
                decorator: decorator?.node ?? null,
                hostBindingNodes: directiveResult.hostBindingNodes,
                resources: {
                    template: null,
                    styles: null,
                    hostBindings: extractHostBindingResources(directiveResult.hostBindingNodes),
                },
            },
        };
    }
    symbol(node, analysis) {
        const typeParameters = extractSemanticTypeParameters(node);
        return new DirectiveSymbol(node, analysis.meta.selector, analysis.inputs, analysis.outputs, analysis.meta.exportAs, analysis.typeCheckMeta, typeParameters);
    }
    register(node, analysis) {
        // Register this directive's information with the `MetadataRegistry`. This ensures that
        // the information about the directive is available during the compile() phase.
        const ref = new Reference(node);
        this.metaRegistry.registerDirectiveMetadata({
            kind: MetaKind.Directive,
            matchSource: MatchSource.Selector,
            ref,
            name: node.name.text,
            selector: analysis.meta.selector,
            exportAs: analysis.meta.exportAs,
            inputs: analysis.inputs,
            inputFieldNamesFromMetadataArray: analysis.inputFieldNamesFromMetadataArray,
            outputs: analysis.outputs,
            queries: analysis.meta.queries.map((query) => query.propertyName),
            isComponent: false,
            baseClass: analysis.baseClass,
            hostDirectives: analysis.hostDirectives,
            ...analysis.typeCheckMeta,
            isPoisoned: analysis.isPoisoned,
            isStructural: analysis.isStructural,
            animationTriggerNames: null,
            isStandalone: analysis.meta.isStandalone,
            isSignal: analysis.meta.isSignal,
            imports: null,
            rawImports: null,
            deferredImports: null,
            schemas: null,
            ngContentSelectors: null,
            decorator: analysis.decorator,
            preserveWhitespaces: false,
            // Directives analyzed within our own compilation are not _assumed_ to export providers.
            // Instead, we statically analyze their imports to make a direct determination.
            assumedToExportProviders: false,
            isExplicitlyDeferred: false,
            selectorlessEnabled: false,
            localReferencedSymbols: null,
        });
        this.resourceRegistry.registerResources(analysis.resources, node);
        this.injectableRegistry.registerInjectable(node, {
            ctorDeps: analysis.meta.deps,
        });
    }
    typeCheck(ctx, node, meta) {
        // Currently type checking in directives is only supported for host bindings
        // so we can skip everything below if type checking is disabled.
        if (!this.typeCheckHostBindings) {
            return;
        }
        if (!ts.isClassDeclaration(node) || (meta.isPoisoned && !this.usePoisonedData)) {
            return;
        }
        const ref = new Reference(node);
        const scope = this.typeCheckScopeRegistry.getTypeCheckScope(ref);
        if (scope.isPoisoned && !this.usePoisonedData) {
            // Don't type-check components that had errors in their scopes, unless requested.
            return;
        }
        const hostElement = createHostElement('directive', meta.meta.selector, node, meta.hostBindingNodes.literal, meta.hostBindingNodes.bindingDecorators, meta.hostBindingNodes.listenerDecorators);
        if (hostElement !== null && scope.directivesOnHost !== null) {
            const binder = new o.R3TargetBinder(scope.matcher);
            const hostBindingsContext = {
                node: hostElement,
                directives: scope.directivesOnHost,
                sourceMapping: { type: 'direct', node },
            };
            ctx.addDirective(ref, binder, scope.schemas, null, hostBindingsContext, meta.meta.isStandalone);
        }
    }
    resolve(node, analysis, symbol) {
        if (this.compilationMode === exports.CompilationMode.LOCAL) {
            return {};
        }
        if (this.semanticDepGraphUpdater !== null && analysis.baseClass instanceof Reference) {
            symbol.baseClass = this.semanticDepGraphUpdater.getSymbol(analysis.baseClass.node);
        }
        const diagnostics = [];
        if (analysis.providersRequiringFactory !== null &&
            analysis.meta.providers instanceof o.WrappedNodeExpr) {
            const providerDiagnostics = getProviderDiagnostics(analysis.providersRequiringFactory, analysis.meta.providers.node, this.injectableRegistry);
            diagnostics.push(...providerDiagnostics);
        }
        const directiveDiagnostics = getDirectiveDiagnostics(node, this.injectableRegistry, this.evaluator, this.reflector, this.scopeRegistry, this.strictCtorDeps, 'Directive');
        if (directiveDiagnostics !== null) {
            diagnostics.push(...directiveDiagnostics);
        }
        const hostDirectivesDiagnotics = analysis.hostDirectives && analysis.rawHostDirectives
            ? validateHostDirectives(analysis.rawHostDirectives, analysis.hostDirectives, this.metaReader)
            : null;
        if (hostDirectivesDiagnotics !== null) {
            diagnostics.push(...hostDirectivesDiagnotics);
        }
        if (diagnostics.length > 0) {
            return { diagnostics };
        }
        // Note: we need to produce *some* sort of the data in order
        // for the host binding diagnostics to be surfaced.
        return { data: {} };
    }
    compileFull(node, analysis, resolution, pool) {
        const fac = compileNgFactoryDefField(toFactoryMetadata(analysis.meta, o.FactoryTarget.Directive));
        const def = o.compileDirectiveFromMetadata(analysis.meta, pool, o.makeBindingParser());
        const inputTransformFields = compileInputTransformFields(analysis.inputs);
        const classMetadata = analysis.classMetadata !== null
            ? o.compileClassMetadata(analysis.classMetadata).toStmt()
            : null;
        return compileResults(fac, def, classMetadata, 'Éµdir', inputTransformFields, null /* deferrableImports */);
    }
    compilePartial(node, analysis, resolution) {
        const fac = compileDeclareFactory(toFactoryMetadata(analysis.meta, o.FactoryTarget.Directive));
        const def = o.compileDeclareDirectiveFromMetadata(analysis.meta);
        const inputTransformFields = compileInputTransformFields(analysis.inputs);
        const classMetadata = analysis.classMetadata !== null
            ? o.compileDeclareClassMetadata(analysis.classMetadata).toStmt()
            : null;
        return compileResults(fac, def, classMetadata, 'Éµdir', inputTransformFields, null /* deferrableImports */);
    }
    compileLocal(node, analysis, resolution, pool) {
        const fac = compileNgFactoryDefField(toFactoryMetadata(analysis.meta, o.FactoryTarget.Directive));
        const def = o.compileDirectiveFromMetadata(analysis.meta, pool, o.makeBindingParser());
        const inputTransformFields = compileInputTransformFields(analysis.inputs);
        const classMetadata = analysis.classMetadata !== null
            ? o.compileClassMetadata(analysis.classMetadata).toStmt()
            : null;
        return compileResults(fac, def, classMetadata, 'Éµdir', inputTransformFields, null /* deferrableImports */);
    }
    /**
     * Checks if a given class uses Angular features and returns the TypeScript node
     * that indicated the usage. Classes are considered using Angular features if they
     * contain class members that are either decorated with a known Angular decorator,
     * or if they correspond to a known Angular lifecycle hook.
     */
    findClassFieldWithAngularFeatures(node) {
        return this.reflector.getMembersOfClass(node).find((member) => {
            if (!member.isStatic &&
                member.kind === ClassMemberKind.Method &&
                LIFECYCLE_HOOKS.has(member.name)) {
                return true;
            }
            if (member.decorators) {
                return member.decorators.some((decorator) => FIELD_DECORATORS.some((decoratorName) => isAngularDecorator$2(decorator, decoratorName, this.isCore)));
            }
            return false;
        });
    }
}

/**
 * Creates a foreign function resolver to detect a `ModuleWithProviders<T>` type in a return type
 * position of a function or method declaration. A `SyntheticValue` is produced if such a return
 * type is recognized.
 *
 * @param reflector The reflection host to use for analyzing the syntax.
 * @param isCore Whether the @angular/core package is being compiled.
 */
function createModuleWithProvidersResolver(reflector, isCore) {
    /**
     * Retrieve an `NgModule` identifier (T) from the specified `type`, if it is of the form:
     * `ModuleWithProviders<T>`
     * @param type The type to reflect on.
     * @returns the identifier of the NgModule type if found, or null otherwise.
     */
    function _reflectModuleFromTypeParam(type, node) {
        // Examine the type of the function to see if it's a ModuleWithProviders reference.
        if (!ts.isTypeReferenceNode(type)) {
            return null;
        }
        const typeName = (type &&
            ((ts.isIdentifier(type.typeName) && type.typeName) ||
                (ts.isQualifiedName(type.typeName) && type.typeName.right))) ||
            null;
        if (typeName === null) {
            return null;
        }
        // Look at the type itself to see where it comes from.
        const id = reflector.getImportOfIdentifier(typeName);
        // If it's not named ModuleWithProviders, bail.
        if (id === null || id.name !== 'ModuleWithProviders') {
            return null;
        }
        // If it's not from @angular/core, bail.
        if (!isCore && id.from !== '@angular/core') {
            return null;
        }
        // If there's no type parameter specified, bail.
        if (type.typeArguments === undefined || type.typeArguments.length !== 1) {
            const parent = ts.isMethodDeclaration(node) && ts.isClassDeclaration(node.parent) ? node.parent : null;
            const symbolName = (parent && parent.name ? parent.name.getText() + '.' : '') +
                (node.name ? node.name.getText() : 'anonymous');
            throw new FatalDiagnosticError(exports.ErrorCode.NGMODULE_MODULE_WITH_PROVIDERS_MISSING_GENERIC, type, `${symbolName} returns a ModuleWithProviders type without a generic type argument. ` +
                `Please add a generic type argument to the ModuleWithProviders type. If this ` +
                `occurrence is in library code you don't control, please contact the library authors.`);
        }
        const arg = type.typeArguments[0];
        return typeNodeToValueExpr(arg);
    }
    /**
     * Retrieve an `NgModule` identifier (T) from the specified `type`, if it is of the form:
     * `A|B|{ngModule: T}|C`.
     * @param type The type to reflect on.
     * @returns the identifier of the NgModule type if found, or null otherwise.
     */
    function _reflectModuleFromLiteralType(type) {
        if (!ts.isIntersectionTypeNode(type)) {
            return null;
        }
        for (const t of type.types) {
            if (ts.isTypeLiteralNode(t)) {
                for (const m of t.members) {
                    const ngModuleType = (ts.isPropertySignature(m) &&
                        ts.isIdentifier(m.name) &&
                        m.name.text === 'ngModule' &&
                        m.type) ||
                        null;
                    let ngModuleExpression = null;
                    // Handle `: typeof X` or `: X` cases.
                    if (ngModuleType !== null && ts.isTypeQueryNode(ngModuleType)) {
                        ngModuleExpression = entityNameToValue(ngModuleType.exprName);
                    }
                    else if (ngModuleType !== null) {
                        ngModuleExpression = typeNodeToValueExpr(ngModuleType);
                    }
                    if (ngModuleExpression) {
                        return ngModuleExpression;
                    }
                }
            }
        }
        return null;
    }
    return (fn, callExpr, resolve, unresolvable) => {
        const rawType = fn.node.type;
        if (rawType === undefined) {
            return unresolvable;
        }
        const type = _reflectModuleFromTypeParam(rawType, fn.node) ?? _reflectModuleFromLiteralType(rawType);
        if (type === null) {
            return unresolvable;
        }
        const ngModule = resolve(type);
        if (!(ngModule instanceof Reference) || !isNamedClassDeclaration(ngModule.node)) {
            return unresolvable;
        }
        return new SyntheticValue({
            ngModule: ngModule,
            mwpCall: callExpr,
        });
    };
}
function isResolvedModuleWithProviders(sv) {
    return (typeof sv.value === 'object' &&
        sv.value != null &&
        sv.value.hasOwnProperty('ngModule') &&
        sv.value.hasOwnProperty('mwpCall'));
}

/**
 * Represents an Angular NgModule.
 */
class NgModuleSymbol extends SemanticSymbol {
    hasProviders;
    remotelyScopedComponents = [];
    /**
     * `SemanticSymbol`s of the transitive imports of this NgModule which came from imported
     * standalone components.
     *
     * Standalone components are excluded/included in the `InjectorDef` emit output of the NgModule
     * based on whether the compiler can prove that their transitive imports may contain exported
     * providers, so a change in this set of symbols may affect the compilation output of this
     * NgModule.
     */
    transitiveImportsFromStandaloneComponents = new Set();
    constructor(decl, hasProviders) {
        super(decl);
        this.hasProviders = hasProviders;
    }
    isPublicApiAffected(previousSymbol) {
        if (!(previousSymbol instanceof NgModuleSymbol)) {
            return true;
        }
        // Changes in the provider status of this NgModule affect downstream dependencies, which may
        // consider provider status in their own emits.
        if (previousSymbol.hasProviders !== this.hasProviders) {
            return true;
        }
        return false;
    }
    isEmitAffected(previousSymbol) {
        if (!(previousSymbol instanceof NgModuleSymbol)) {
            return true;
        }
        // compare our remotelyScopedComponents to the previous symbol
        if (previousSymbol.remotelyScopedComponents.length !== this.remotelyScopedComponents.length) {
            return true;
        }
        for (const currEntry of this.remotelyScopedComponents) {
            const prevEntry = previousSymbol.remotelyScopedComponents.find((prevEntry) => {
                return isSymbolEqual(prevEntry.component, currEntry.component);
            });
            if (prevEntry === undefined) {
                // No previous entry was found, which means that this component became remotely scoped and
                // hence this NgModule needs to be re-emitted.
                return true;
            }
            if (!isArrayEqual(currEntry.usedDirectives, prevEntry.usedDirectives, isReferenceEqual)) {
                // The list of used directives or their order has changed. Since this NgModule emits
                // references to the list of used directives, it should be re-emitted to update this list.
                // Note: the NgModule does not have to be re-emitted when any of the directives has had
                // their public API changed, as the NgModule only emits a reference to the symbol by its
                // name. Therefore, testing for symbol equality is sufficient.
                return true;
            }
            if (!isArrayEqual(currEntry.usedPipes, prevEntry.usedPipes, isReferenceEqual)) {
                return true;
            }
        }
        if (previousSymbol.transitiveImportsFromStandaloneComponents.size !==
            this.transitiveImportsFromStandaloneComponents.size) {
            return true;
        }
        const previousImports = Array.from(previousSymbol.transitiveImportsFromStandaloneComponents);
        for (const transitiveImport of this.transitiveImportsFromStandaloneComponents) {
            const prevEntry = previousImports.find((prevEntry) => isSymbolEqual(prevEntry, transitiveImport));
            if (prevEntry === undefined) {
                return true;
            }
            if (transitiveImport.isPublicApiAffected(prevEntry)) {
                return true;
            }
        }
        return false;
    }
    isTypeCheckApiAffected(previousSymbol) {
        if (!(previousSymbol instanceof NgModuleSymbol)) {
            return true;
        }
        return false;
    }
    addRemotelyScopedComponent(component, usedDirectives, usedPipes) {
        this.remotelyScopedComponents.push({ component, usedDirectives, usedPipes });
    }
    addTransitiveImportFromStandaloneComponent(importedSymbol) {
        this.transitiveImportsFromStandaloneComponents.add(importedSymbol);
    }
}
/**
 * Compiles @NgModule annotations to ngModuleDef fields.
 */
class NgModuleDecoratorHandler {
    reflector;
    evaluator;
    metaReader;
    metaRegistry;
    scopeRegistry;
    referencesRegistry;
    exportedProviderStatusResolver;
    semanticDepGraphUpdater;
    isCore;
    refEmitter;
    annotateForClosureCompiler;
    onlyPublishPublicTypings;
    injectableRegistry;
    perf;
    includeClassMetadata;
    includeSelectorScope;
    compilationMode;
    localCompilationExtraImportsTracker;
    jitDeclarationRegistry;
    emitDeclarationOnly;
    constructor(reflector, evaluator, metaReader, metaRegistry, scopeRegistry, referencesRegistry, exportedProviderStatusResolver, semanticDepGraphUpdater, isCore, refEmitter, annotateForClosureCompiler, onlyPublishPublicTypings, injectableRegistry, perf, includeClassMetadata, includeSelectorScope, compilationMode, localCompilationExtraImportsTracker, jitDeclarationRegistry, emitDeclarationOnly) {
        this.reflector = reflector;
        this.evaluator = evaluator;
        this.metaReader = metaReader;
        this.metaRegistry = metaRegistry;
        this.scopeRegistry = scopeRegistry;
        this.referencesRegistry = referencesRegistry;
        this.exportedProviderStatusResolver = exportedProviderStatusResolver;
        this.semanticDepGraphUpdater = semanticDepGraphUpdater;
        this.isCore = isCore;
        this.refEmitter = refEmitter;
        this.annotateForClosureCompiler = annotateForClosureCompiler;
        this.onlyPublishPublicTypings = onlyPublishPublicTypings;
        this.injectableRegistry = injectableRegistry;
        this.perf = perf;
        this.includeClassMetadata = includeClassMetadata;
        this.includeSelectorScope = includeSelectorScope;
        this.compilationMode = compilationMode;
        this.localCompilationExtraImportsTracker = localCompilationExtraImportsTracker;
        this.jitDeclarationRegistry = jitDeclarationRegistry;
        this.emitDeclarationOnly = emitDeclarationOnly;
    }
    precedence = HandlerPrecedence.PRIMARY;
    name = 'NgModuleDecoratorHandler';
    detect(node, decorators) {
        if (!decorators) {
            return undefined;
        }
        const decorator = findAngularDecorator(decorators, 'NgModule', this.isCore);
        if (decorator !== undefined) {
            return {
                trigger: decorator.node,
                decorator: decorator,
                metadata: decorator,
            };
        }
        else {
            return undefined;
        }
    }
    analyze(node, decorator) {
        this.perf.eventCount(exports.PerfEvent.AnalyzeNgModule);
        const name = node.name.text;
        if (decorator.args === null || decorator.args.length > 1) {
            throw new FatalDiagnosticError(exports.ErrorCode.DECORATOR_ARITY_WRONG, decorator.node, `Incorrect number of arguments to @NgModule decorator`);
        }
        // @NgModule can be invoked without arguments. In case it is, pretend as if a blank object
        // literal was specified. This simplifies the code below.
        const meta = decorator.args.length === 1
            ? unwrapExpression(decorator.args[0])
            : ts.factory.createObjectLiteralExpression([]);
        if (!ts.isObjectLiteralExpression(meta)) {
            throw new FatalDiagnosticError(exports.ErrorCode.DECORATOR_ARG_NOT_LITERAL, meta, '@NgModule argument must be an object literal');
        }
        const ngModule = reflectObjectLiteral(meta);
        if (ngModule.has('jit')) {
            this.jitDeclarationRegistry.jitDeclarations.add(node);
            // The only allowed value is true, so there's no need to expand further.
            return {};
        }
        const forwardRefResolver = createForwardRefResolver(this.isCore);
        const moduleResolvers = combineResolvers([
            createModuleWithProvidersResolver(this.reflector, this.isCore),
            forwardRefResolver,
        ]);
        const allowUnresolvedReferences = this.compilationMode === exports.CompilationMode.LOCAL && !this.emitDeclarationOnly;
        const diagnostics = [];
        // Resolving declarations
        let declarationRefs = [];
        const rawDeclarations = ngModule.get('declarations') ?? null;
        if (rawDeclarations !== null) {
            const declarationMeta = this.evaluator.evaluate(rawDeclarations, forwardRefResolver);
            declarationRefs = this.resolveTypeList(rawDeclarations, declarationMeta, name, 'declarations', 0, allowUnresolvedReferences).references;
            // Look through the declarations to make sure they're all a part of the current compilation.
            for (const ref of declarationRefs) {
                if (ref.node.getSourceFile().isDeclarationFile) {
                    const errorNode = ref.getOriginForDiagnostics(rawDeclarations);
                    diagnostics.push(makeDiagnostic(exports.ErrorCode.NGMODULE_INVALID_DECLARATION, errorNode, `Cannot declare '${ref.node.name.text}' in an NgModule as it's not a part of the current compilation.`, [makeRelatedInformation(ref.node.name, `'${ref.node.name.text}' is declared here.`)]));
                }
            }
        }
        if (diagnostics.length > 0) {
            return { diagnostics };
        }
        // Resolving imports
        let importRefs = [];
        let rawImports = ngModule.get('imports') ?? null;
        if (rawImports !== null) {
            const importsMeta = this.evaluator.evaluate(rawImports, moduleResolvers);
            const result = this.resolveTypeList(rawImports, importsMeta, name, 'imports', 0, allowUnresolvedReferences);
            if (this.compilationMode === exports.CompilationMode.LOCAL &&
                this.localCompilationExtraImportsTracker !== null) {
                // For generating extra imports in local mode, the NgModule imports that are from external
                // files (i.e., outside of the compilation unit) are to be added to all the files in the
                // compilation unit. This is because any external component that is a dependency of some
                // component in the compilation unit must be imported by one of these NgModule's external
                // imports (or the external component cannot be a dependency of that internal component).
                // This approach can be further optimized by adding these NgModule external imports to a
                // subset of files in the compilation unit and not all. See comments in {@link
                // LocalCompilationExtraImportsTracker} and {@link
                // LocalCompilationExtraImportsTracker#addGlobalImportFromIdentifier} for more details.
                for (const d of result.dynamicValues) {
                    this.localCompilationExtraImportsTracker.addGlobalImportFromIdentifier(d.node);
                }
            }
            importRefs = result.references;
        }
        // Resolving exports
        let exportRefs = [];
        const rawExports = ngModule.get('exports') ?? null;
        if (rawExports !== null) {
            const exportsMeta = this.evaluator.evaluate(rawExports, moduleResolvers);
            exportRefs = this.resolveTypeList(rawExports, exportsMeta, name, 'exports', 0, allowUnresolvedReferences).references;
            this.referencesRegistry.add(node, ...exportRefs);
        }
        // Resolving bootstrap
        let bootstrapRefs = [];
        const rawBootstrap = ngModule.get('bootstrap') ?? null;
        if (!allowUnresolvedReferences && rawBootstrap !== null) {
            const bootstrapMeta = this.evaluator.evaluate(rawBootstrap, forwardRefResolver);
            bootstrapRefs = this.resolveTypeList(rawBootstrap, bootstrapMeta, name, 'bootstrap', 0, 
            /* allowUnresolvedReferences */ false).references;
            // Verify that the `@NgModule.bootstrap` list doesn't have Standalone Components.
            for (const ref of bootstrapRefs) {
                const dirMeta = this.metaReader.getDirectiveMetadata(ref);
                if (dirMeta?.isStandalone) {
                    diagnostics.push(makeStandaloneBootstrapDiagnostic(node, ref, rawBootstrap));
                }
            }
        }
        let schemas;
        try {
            schemas =
                this.compilationMode !== exports.CompilationMode.LOCAL && ngModule.has('schemas')
                    ? extractSchemas(ngModule.get('schemas'), this.evaluator, 'NgModule')
                    : [];
        }
        catch (e) {
            if (e instanceof FatalDiagnosticError) {
                diagnostics.push(e.toDiagnostic());
                // Use an empty schema array if schema extract fails.
                // A build will still fail in this case. However, for the language service,
                // this allows the module to exist in the compiler registry and prevents
                // cascading diagnostics within an IDE due to "missing" components. The
                // originating schema related errors will still be reported in the IDE.
                schemas = [];
            }
            else {
                throw e;
            }
        }
        let id = null;
        if (ngModule.has('id')) {
            const idExpr = ngModule.get('id');
            if (!isModuleIdExpression(idExpr)) {
                id = new o.WrappedNodeExpr(idExpr);
            }
            else {
                const diag = makeDiagnostic(exports.ErrorCode.WARN_NGMODULE_ID_UNNECESSARY, idExpr, `Using 'module.id' for NgModule.id is a common anti-pattern that is ignored by the Angular compiler.`);
                diag.category = ts.DiagnosticCategory.Warning;
                diagnostics.push(diag);
            }
        }
        const valueContext = node.getSourceFile();
        const exportedNodes = new Set(exportRefs.map((ref) => ref.node));
        const declarations = [];
        const exportedDeclarations = [];
        const bootstrap = bootstrapRefs.map((bootstrap) => this._toR3Reference(bootstrap.getOriginForDiagnostics(meta, node.name), bootstrap, valueContext));
        for (const ref of declarationRefs) {
            const decl = this._toR3Reference(ref.getOriginForDiagnostics(meta, node.name), ref, valueContext);
            declarations.push(decl);
            if (exportedNodes.has(ref.node)) {
                exportedDeclarations.push(decl.type);
            }
        }
        const imports = importRefs.map((imp) => this._toR3Reference(imp.getOriginForDiagnostics(meta, node.name), imp, valueContext));
        const exports$1 = exportRefs.map((exp) => this._toR3Reference(exp.getOriginForDiagnostics(meta, node.name), exp, valueContext));
        const isForwardReference = (ref) => isExpressionForwardReference(ref.value, node.name, valueContext);
        const containsForwardDecls = bootstrap.some(isForwardReference) ||
            declarations.some(isForwardReference) ||
            imports.some(isForwardReference) ||
            exports$1.some(isForwardReference);
        const type = wrapTypeReference(this.reflector, node);
        let ngModuleMetadata;
        if (allowUnresolvedReferences) {
            ngModuleMetadata = {
                kind: o.R3NgModuleMetadataKind.Local,
                type,
                bootstrapExpression: rawBootstrap ? new o.WrappedNodeExpr(rawBootstrap) : null,
                declarationsExpression: rawDeclarations ? new o.WrappedNodeExpr(rawDeclarations) : null,
                exportsExpression: rawExports ? new o.WrappedNodeExpr(rawExports) : null,
                importsExpression: rawImports ? new o.WrappedNodeExpr(rawImports) : null,
                id,
                // Use `ÉµÉµsetNgModuleScope` to patch selector scopes onto the generated definition in a
                // tree-shakeable way.
                selectorScopeMode: o.R3SelectorScopeMode.SideEffect,
                // TODO: to be implemented as a part of FW-1004.
                schemas: [],
            };
        }
        else {
            ngModuleMetadata = {
                kind: o.R3NgModuleMetadataKind.Global,
                type,
                bootstrap,
                declarations,
                publicDeclarationTypes: this.onlyPublishPublicTypings ? exportedDeclarations : null,
                exports: exports$1,
                imports,
                // Imported types are generally private, so include them unless restricting the .d.ts emit
                // to only public types.
                includeImportTypes: !this.onlyPublishPublicTypings,
                containsForwardDecls,
                id,
                // Use `ÉµÉµsetNgModuleScope` to patch selector scopes onto the generated definition in a
                // tree-shakeable way.
                selectorScopeMode: this.includeSelectorScope
                    ? o.R3SelectorScopeMode.SideEffect
                    : o.R3SelectorScopeMode.Omit,
                // TODO: to be implemented as a part of FW-1004.
                schemas: [],
            };
        }
        const rawProviders = ngModule.has('providers') ? ngModule.get('providers') : null;
        let wrappedProviders = null;
        // In most cases the providers will be an array literal. Check if it has any elements
        // and don't include the providers if it doesn't which saves us a few bytes.
        if (rawProviders !== null &&
            (!ts.isArrayLiteralExpression(rawProviders) || rawProviders.elements.length > 0)) {
            wrappedProviders = new o.WrappedNodeExpr(this.annotateForClosureCompiler
                ? wrapFunctionExpressionsInParens(rawProviders)
                : rawProviders);
        }
        const topLevelImports = [];
        if (!allowUnresolvedReferences && ngModule.has('imports')) {
            const rawImports = unwrapExpression(ngModule.get('imports'));
            let topLevelExpressions = [];
            if (ts.isArrayLiteralExpression(rawImports)) {
                for (const element of rawImports.elements) {
                    if (ts.isSpreadElement(element)) {
                        // Because `imports` allows nested arrays anyway, a spread expression (`...foo`) can be
                        // treated the same as a direct reference to `foo`.
                        topLevelExpressions.push(element.expression);
                        continue;
                    }
                    topLevelExpressions.push(element);
                }
            }
            else {
                // Treat the whole `imports` expression as top-level.
                topLevelExpressions.push(rawImports);
            }
            let absoluteIndex = 0;
            for (const importExpr of topLevelExpressions) {
                const resolved = this.evaluator.evaluate(importExpr, moduleResolvers);
                const { references, hasModuleWithProviders } = this.resolveTypeList(importExpr, [resolved], node.name.text, 'imports', absoluteIndex, 
                /* allowUnresolvedReferences */ false);
                absoluteIndex += references.length;
                topLevelImports.push({
                    expression: importExpr,
                    resolvedReferences: references,
                    hasModuleWithProviders,
                });
            }
        }
        const injectorMetadata = {
            name,
            type,
            providers: wrappedProviders,
            imports: [],
        };
        if (allowUnresolvedReferences) {
            // Adding NgModule's raw imports/exports to the injector's imports field in local compilation
            // mode.
            for (const exp of [rawImports, rawExports]) {
                if (exp === null) {
                    continue;
                }
                if (ts.isArrayLiteralExpression(exp)) {
                    // If array expression then add it entry-by-entry to the injector imports
                    if (exp.elements) {
                        injectorMetadata.imports.push(...exp.elements.map((n) => new o.WrappedNodeExpr(n)));
                    }
                }
                else {
                    // if not array expression then add it as is to the injector's imports field.
                    injectorMetadata.imports.push(new o.WrappedNodeExpr(exp));
                }
            }
        }
        const factoryMetadata = {
            name,
            type,
            typeArgumentCount: 0,
            deps: getValidConstructorDependencies(node, this.reflector, this.isCore),
            target: o.FactoryTarget.NgModule,
        };
        // Remote scoping is used when adding imports to a component file would create a cycle. In such
        // circumstances the component scope is monkey-patched from the NgModule file instead.
        //
        // However, if the NgModule itself has a cycle with the desired component/directive
        // reference(s), then we need to be careful. This can happen for example if an NgModule imports
        // a standalone component and the component also imports the NgModule.
        //
        // In this case, it'd be tempting to rely on the compiler's cycle detector to automatically put
        // such circular references behind a function/closure. This requires global knowledge of the
        // import graph though, and we don't want to depend on such techniques for new APIs like
        // standalone components.
        //
        // Instead, we look for `forwardRef`s in the NgModule dependencies - an explicit signal from the
        // user that a reference may not be defined until a circular import is resolved. If an NgModule
        // contains forward-referenced declarations or imports, we assume that remotely scoped
        // components should also guard against cycles using a closure-wrapped scope.
        //
        // The actual detection here is done heuristically. The compiler doesn't actually know whether
        // any given `Reference` came from a `forwardRef`, but it does know when a `Reference` came from
        // a `ForeignFunctionResolver` _like_ the `forwardRef` resolver. So we know when it's safe to
        // not use a closure, and will use one just in case otherwise.
        const remoteScopesMayRequireCycleProtection = declarationRefs.some(isSyntheticReference) || importRefs.some(isSyntheticReference);
        return {
            diagnostics: diagnostics.length > 0 ? diagnostics : undefined,
            analysis: {
                id,
                schemas,
                mod: ngModuleMetadata,
                inj: injectorMetadata,
                fac: factoryMetadata,
                declarations: declarationRefs,
                rawDeclarations,
                imports: topLevelImports,
                rawImports,
                importRefs,
                exports: exportRefs,
                rawExports,
                providers: rawProviders,
                providersRequiringFactory: rawProviders
                    ? resolveProvidersRequiringFactory(rawProviders, this.reflector, this.evaluator)
                    : null,
                classMetadata: this.includeClassMetadata
                    ? extractClassMetadata(node, this.reflector, this.isCore, this.annotateForClosureCompiler)
                    : null,
                factorySymbolName: node.name.text,
                remoteScopesMayRequireCycleProtection,
                decorator: decorator?.node ?? null,
            },
        };
    }
    symbol(node, analysis) {
        return new NgModuleSymbol(node, analysis.providers !== null);
    }
    register(node, analysis) {
        // Register this module's information with the LocalModuleScopeRegistry. This ensures that
        // during the compile() phase, the module's metadata is available for selector scope
        // computation.
        this.metaRegistry.registerNgModuleMetadata({
            kind: MetaKind.NgModule,
            ref: new Reference(node),
            schemas: analysis.schemas,
            declarations: analysis.declarations,
            imports: analysis.importRefs,
            exports: analysis.exports,
            rawDeclarations: analysis.rawDeclarations,
            rawImports: analysis.rawImports,
            rawExports: analysis.rawExports,
            decorator: analysis.decorator,
            mayDeclareProviders: analysis.providers !== null,
            isPoisoned: false,
        });
        this.injectableRegistry.registerInjectable(node, {
            ctorDeps: analysis.fac.deps,
        });
    }
    resolve(node, analysis) {
        if (this.compilationMode === exports.CompilationMode.LOCAL) {
            return {};
        }
        const scope = this.scopeRegistry.getScopeOfModule(node);
        const diagnostics = [];
        const scopeDiagnostics = this.scopeRegistry.getDiagnosticsOfModule(node);
        if (scopeDiagnostics !== null) {
            diagnostics.push(...scopeDiagnostics);
        }
        if (analysis.providersRequiringFactory !== null) {
            const providerDiagnostics = getProviderDiagnostics(analysis.providersRequiringFactory, analysis.providers, this.injectableRegistry);
            diagnostics.push(...providerDiagnostics);
        }
        const data = {
            injectorImports: [],
        };
        // Add all top-level imports from the `imports` field to the injector imports.
        for (const topLevelImport of analysis.imports) {
            if (topLevelImport.hasModuleWithProviders) {
                // We have no choice but to emit expressions which contain MWPs, as we cannot filter on
                // individual references.
                data.injectorImports.push(new o.WrappedNodeExpr(topLevelImport.expression));
                continue;
            }
            const refsToEmit = [];
            let symbol = null;
            if (this.semanticDepGraphUpdater !== null) {
                const sym = this.semanticDepGraphUpdater.getSymbol(node);
                if (sym instanceof NgModuleSymbol) {
                    symbol = sym;
                }
            }
            for (const ref of topLevelImport.resolvedReferences) {
                const dirMeta = this.metaReader.getDirectiveMetadata(ref);
                if (dirMeta !== null) {
                    if (!dirMeta.isComponent) {
                        // Skip emit of directives in imports - directives can't carry providers.
                        continue;
                    }
                    // Check whether this component has providers.
                    const mayExportProviders = this.exportedProviderStatusResolver.mayExportProviders(dirMeta.ref, (importRef) => {
                        // We need to keep track of which transitive imports were used to decide
                        // `mayExportProviders`, since if those change in a future compilation this
                        // NgModule will need to be re-emitted.
                        if (symbol !== null && this.semanticDepGraphUpdater !== null) {
                            const importSymbol = this.semanticDepGraphUpdater.getSymbol(importRef.node);
                            symbol.addTransitiveImportFromStandaloneComponent(importSymbol);
                        }
                    });
                    if (!mayExportProviders) {
                        // Skip emit of components that don't carry providers.
                        continue;
                    }
                }
                const pipeMeta = dirMeta === null ? this.metaReader.getPipeMetadata(ref) : null;
                if (pipeMeta !== null) {
                    // Skip emit of pipes in imports - pipes can't carry providers.
                    continue;
                }
                refsToEmit.push(ref);
            }
            if (refsToEmit.length === topLevelImport.resolvedReferences.length) {
                // All references within this top-level import should be emitted, so just use the user's
                // expression.
                data.injectorImports.push(new o.WrappedNodeExpr(topLevelImport.expression));
            }
            else {
                // Some references have been filtered out. Emit references to individual classes.
                const context = node.getSourceFile();
                for (const ref of refsToEmit) {
                    const emittedRef = this.refEmitter.emit(ref, context);
                    assertSuccessfulReferenceEmit(emittedRef, topLevelImport.expression, 'class');
                    data.injectorImports.push(emittedRef.expression);
                }
            }
        }
        if (scope !== null && !scope.compilation.isPoisoned) {
            // Using the scope information, extend the injector's imports using the modules that are
            // specified as module exports.
            const context = getSourceFile(node);
            for (const exportRef of analysis.exports) {
                if (isNgModule(exportRef.node, scope.compilation)) {
                    const type = this.refEmitter.emit(exportRef, context);
                    assertSuccessfulReferenceEmit(type, node, 'NgModule');
                    data.injectorImports.push(type.expression);
                }
            }
            for (const decl of analysis.declarations) {
                const dirMeta = this.metaReader.getDirectiveMetadata(decl);
                if (dirMeta !== null) {
                    const refType = dirMeta.isComponent ? 'Component' : 'Directive';
                    if (dirMeta.selector === null) {
                        throw new FatalDiagnosticError(exports.ErrorCode.DIRECTIVE_MISSING_SELECTOR, decl.node, `${refType} ${decl.node.name.text} has no selector, please add it!`);
                    }
                    continue;
                }
            }
        }
        if (diagnostics.length > 0) {
            return { diagnostics };
        }
        if (scope === null ||
            scope.compilation.isPoisoned ||
            scope.exported.isPoisoned ||
            scope.reexports === null) {
            return { data };
        }
        else {
            return {
                data,
                reexports: scope.reexports,
            };
        }
    }
    compileFull(node, { inj, mod, fac, classMetadata, declarations, remoteScopesMayRequireCycleProtection, }, { injectorImports }) {
        const factoryFn = compileNgFactoryDefField(fac);
        const ngInjectorDef = o.compileInjector({
            ...inj,
            imports: injectorImports,
        });
        const ngModuleDef = o.compileNgModule(mod);
        const statements = ngModuleDef.statements;
        const metadata = classMetadata !== null ? o.compileClassMetadata(classMetadata) : null;
        this.insertMetadataStatement(statements, metadata);
        this.appendRemoteScopingStatements(statements, node, declarations, remoteScopesMayRequireCycleProtection);
        return this.compileNgModule(factoryFn, ngInjectorDef, ngModuleDef);
    }
    compilePartial(node, { inj, fac, mod, classMetadata }, { injectorImports }) {
        const factoryFn = compileDeclareFactory(fac);
        const injectorDef = o.compileDeclareInjectorFromMetadata({
            ...inj,
            imports: injectorImports,
        });
        const ngModuleDef = o.compileDeclareNgModuleFromMetadata(mod);
        const metadata = classMetadata !== null ? o.compileDeclareClassMetadata(classMetadata) : null;
        this.insertMetadataStatement(ngModuleDef.statements, metadata);
        // NOTE: no remote scoping required as this is banned in partial compilation.
        return this.compileNgModule(factoryFn, injectorDef, ngModuleDef);
    }
    compileLocal(node, { inj, mod, fac, classMetadata, declarations, remoteScopesMayRequireCycleProtection, }) {
        const factoryFn = compileNgFactoryDefField(fac);
        const ngInjectorDef = o.compileInjector({
            ...inj,
        });
        const ngModuleDef = o.compileNgModule(mod);
        const statements = ngModuleDef.statements;
        const metadata = classMetadata !== null ? o.compileClassMetadata(classMetadata) : null;
        this.insertMetadataStatement(statements, metadata);
        this.appendRemoteScopingStatements(statements, node, declarations, remoteScopesMayRequireCycleProtection);
        return this.compileNgModule(factoryFn, ngInjectorDef, ngModuleDef);
    }
    /**
     * Add class metadata statements, if provided, to the `ngModuleStatements`.
     */
    insertMetadataStatement(ngModuleStatements, metadata) {
        if (metadata !== null) {
            ngModuleStatements.unshift(metadata.toStmt());
        }
    }
    /**
     * Add remote scoping statements, as needed, to the `ngModuleStatements`.
     */
    appendRemoteScopingStatements(ngModuleStatements, node, declarations, remoteScopesMayRequireCycleProtection) {
        // Local compilation mode generates its own runtimes to compute the dependencies. So there no
        // need to add remote scope statements (which also conflicts with local compilation runtimes)
        if (this.compilationMode === exports.CompilationMode.LOCAL) {
            return;
        }
        const context = getSourceFile(node);
        for (const decl of declarations) {
            const remoteScope = this.scopeRegistry.getRemoteScope(decl.node);
            if (remoteScope !== null) {
                const directives = remoteScope.directives.map((directive) => {
                    const type = this.refEmitter.emit(directive, context);
                    assertSuccessfulReferenceEmit(type, node, 'directive');
                    return type.expression;
                });
                const pipes = remoteScope.pipes.map((pipe) => {
                    const type = this.refEmitter.emit(pipe, context);
                    assertSuccessfulReferenceEmit(type, node, 'pipe');
                    return type.expression;
                });
                const directiveArray = new o.LiteralArrayExpr(directives);
                const pipesArray = new o.LiteralArrayExpr(pipes);
                const directiveExpr = remoteScopesMayRequireCycleProtection && directives.length > 0
                    ? new o.FunctionExpr([], [new o.ReturnStatement(directiveArray)])
                    : directiveArray;
                const pipesExpr = remoteScopesMayRequireCycleProtection && pipes.length > 0
                    ? new o.FunctionExpr([], [new o.ReturnStatement(pipesArray)])
                    : pipesArray;
                const componentType = this.refEmitter.emit(decl, context);
                assertSuccessfulReferenceEmit(componentType, node, 'component');
                const declExpr = componentType.expression;
                const setComponentScope = new o.ExternalExpr(o.R3Identifiers.setComponentScope);
                const callExpr = new o.InvokeFunctionExpr(setComponentScope, [
                    declExpr,
                    directiveExpr,
                    pipesExpr,
                ]);
                ngModuleStatements.push(callExpr.toStmt());
            }
        }
    }
    compileNgModule(factoryFn, injectorDef, ngModuleDef) {
        const res = [
            factoryFn,
            {
                name: 'Éµmod',
                initializer: ngModuleDef.expression,
                statements: ngModuleDef.statements,
                type: ngModuleDef.type,
                deferrableImports: null,
            },
            {
                name: 'Éµinj',
                initializer: injectorDef.expression,
                statements: injectorDef.statements,
                type: injectorDef.type,
                deferrableImports: null,
            },
        ];
        return res;
    }
    _toR3Reference(origin, valueRef, valueContext) {
        if (valueRef.hasOwningModuleGuess) {
            return toR3Reference(origin, valueRef, valueContext, this.refEmitter);
        }
        else {
            return toR3Reference(origin, valueRef, valueContext, this.refEmitter);
        }
    }
    // Verify that a "Declaration" reference is a `ClassDeclaration` reference.
    isClassDeclarationReference(ref) {
        return this.reflector.isClass(ref.node);
    }
    /**
     * Compute a list of `Reference`s from a resolved metadata value.
     */
    resolveTypeList(expr, resolvedList, className, arrayName, absoluteIndex, allowUnresolvedReferences) {
        let hasModuleWithProviders = false;
        const refList = [];
        const dynamicValueSet = new Set();
        if (!Array.isArray(resolvedList)) {
            if (allowUnresolvedReferences) {
                return {
                    references: [],
                    hasModuleWithProviders: false,
                    dynamicValues: [],
                };
            }
            throw createValueHasWrongTypeError(expr, resolvedList, `Expected array when reading the NgModule.${arrayName} of ${className}`);
        }
        for (let idx = 0; idx < resolvedList.length; idx++) {
            let entry = resolvedList[idx];
            // Unwrap ModuleWithProviders for modules that are locally declared (and thus static
            // resolution was able to descend into the function and return an object literal, a Map).
            if (entry instanceof SyntheticValue && isResolvedModuleWithProviders(entry)) {
                entry = entry.value.ngModule;
                hasModuleWithProviders = true;
            }
            else if (entry instanceof Map && entry.has('ngModule')) {
                entry = entry.get('ngModule');
                hasModuleWithProviders = true;
            }
            if (Array.isArray(entry)) {
                // Recurse into nested arrays.
                const recursiveResult = this.resolveTypeList(expr, entry, className, arrayName, absoluteIndex, allowUnresolvedReferences);
                refList.push(...recursiveResult.references);
                for (const d of recursiveResult.dynamicValues) {
                    dynamicValueSet.add(d);
                }
                absoluteIndex += recursiveResult.references.length;
                hasModuleWithProviders = hasModuleWithProviders || recursiveResult.hasModuleWithProviders;
            }
            else if (entry instanceof Reference) {
                if (!this.isClassDeclarationReference(entry)) {
                    throw createValueHasWrongTypeError(entry.node, entry, `Value at position ${absoluteIndex} in the NgModule.${arrayName} of ${className} is not a class`);
                }
                refList.push(entry);
                absoluteIndex += 1;
            }
            else if (entry instanceof DynamicValue && allowUnresolvedReferences) {
                dynamicValueSet.add(entry);
                continue;
            }
            else if (this.emitDeclarationOnly &&
                entry instanceof DynamicValue &&
                entry.isFromUnknownIdentifier()) {
                throw createValueHasWrongTypeError(entry.node, entry, `Value at position ${absoluteIndex} in the NgModule.${arrayName} of ${className} is an external reference. ` +
                    'External references in @NgModule declarations are not supported in experimental declaration-only emission mode');
            }
            else {
                // TODO(alxhub): Produce a better diagnostic here - the array index may be an inner array.
                throw createValueHasWrongTypeError(expr, entry, `Value at position ${absoluteIndex} in the NgModule.${arrayName} of ${className} is not a reference`);
            }
        }
        return {
            references: refList,
            hasModuleWithProviders,
            dynamicValues: [...dynamicValueSet],
        };
    }
}
function isNgModule(node, compilation) {
    return !compilation.dependencies.some((dep) => dep.ref.node === node);
}
/**
 * Checks whether the given `ts.Expression` is the expression `module.id`.
 */
function isModuleIdExpression(expr) {
    return (ts.isPropertyAccessExpression(expr) &&
        ts.isIdentifier(expr.expression) &&
        expr.expression.text === 'module' &&
        expr.name.text === 'id');
}
/**
 * Helper method to produce a diagnostics for a situation when a standalone component
 * is referenced in the `@NgModule.bootstrap` array.
 */
function makeStandaloneBootstrapDiagnostic(ngModuleClass, bootstrappedClassRef, rawBootstrapExpr) {
    const componentClassName = bootstrappedClassRef.node.name.text;
    // Note: this error message should be aligned with the one produced by JIT.
    const message = //
     `The \`${componentClassName}\` class is a standalone component, which can ` +
        `not be used in the \`@NgModule.bootstrap\` array. Use the \`bootstrapApplication\` ` +
        `function for bootstrap instead.`;
    const relatedInformation = [
        makeRelatedInformation(ngModuleClass, `The 'bootstrap' array is present on this NgModule.`),
    ];
    return makeDiagnostic(exports.ErrorCode.NGMODULE_BOOTSTRAP_IS_STANDALONE, getDiagnosticNode(bootstrappedClassRef, rawBootstrapExpr), message, relatedInformation);
}
function isSyntheticReference(ref) {
    return ref.synthetic;
}

/**
 * Generate a diagnostic related information object that describes a potential cyclic import path.
 */
function makeCyclicImportInfo(ref, type, cycle) {
    const name = ref.debugName || '(unknown)';
    const path = cycle
        .getPath()
        .map((sf) => sf.fileName)
        .join(' -> ');
    const message = `The ${type} '${name}' is used in the template but importing it would create a cycle: `;
    return makeRelatedInformation(ref.node, message + path);
}
/**
 * Checks whether a selector is a valid custom element tag name.
 * Based loosely on https://github.com/sindresorhus/validate-element-name.
 */
function checkCustomElementSelectorForErrors(selector) {
    // Avoid flagging components with an attribute or class selector. This isn't bulletproof since it
    // won't catch cases like `foo[]bar`, but we don't need it to be. This is mainly to avoid flagging
    // something like `foo-bar[baz]` incorrectly.
    if (selector.includes('.') || (selector.includes('[') && selector.includes(']'))) {
        return null;
    }
    if (!/^[a-z]/.test(selector)) {
        return 'Selector of a ShadowDom-encapsulated component must start with a lower case letter.';
    }
    if (/[A-Z]/.test(selector)) {
        return 'Selector of a ShadowDom-encapsulated component must all be in lower case.';
    }
    if (!selector.includes('-')) {
        return 'Selector of a component that uses ViewEncapsulation.ShadowDom must contain a hyphen.';
    }
    return null;
}

/** Determines the node to use for debugging purposes for the given TemplateDeclaration. */
function getTemplateDeclarationNodeForError(declaration) {
    return declaration.isInline ? declaration.expression : declaration.templateUrlExpression;
}
function extractTemplate(node, template, evaluator, depTracker, resourceLoader, options, compilationMode) {
    if (template.isInline) {
        let sourceStr;
        let sourceParseRange = null;
        let templateContent;
        let sourceMapping;
        let escapedString = false;
        let sourceMapUrl;
        // We only support SourceMaps for inline templates that are simple string literals.
        if (ts.isStringLiteral(template.expression) ||
            ts.isNoSubstitutionTemplateLiteral(template.expression)) {
            // the start and end of the `templateExpr` node includes the quotation marks, which we must
            // strip
            sourceParseRange = getTemplateRange(template.expression);
            sourceStr = template.expression.getSourceFile().text;
            templateContent = template.expression.text;
            escapedString = true;
            sourceMapping = {
                type: 'direct',
                node: template.expression,
            };
            sourceMapUrl = template.resolvedTemplateUrl;
        }
        else {
            const resolvedTemplate = evaluator.evaluate(template.expression);
            // The identifier used for @Component.template cannot be resolved in local compilation mode. An error specific to this situation is generated.
            assertLocalCompilationUnresolvedConst(compilationMode, resolvedTemplate, template.expression, 'Unresolved identifier found for @Component.template field! ' +
                'Did you import this identifier from a file outside of the compilation unit? ' +
                'This is not allowed when Angular compiler runs in local mode. ' +
                'Possible solutions: 1) Move the declaration into a file within the ' +
                'compilation unit, 2) Inline the template, 3) Move the template into ' +
                'a separate .html file and include it using @Component.templateUrl');
            if (typeof resolvedTemplate !== 'string') {
                throw createValueHasWrongTypeError(template.expression, resolvedTemplate, 'template must be a string');
            }
            // We do not parse the template directly from the source file using a lexer range, so
            // the template source and content are set to the statically resolved template.
            sourceStr = resolvedTemplate;
            templateContent = resolvedTemplate;
            sourceMapping = {
                type: 'indirect',
                node: template.expression,
                componentClass: node,
                template: templateContent,
            };
            // Indirect templates cannot be mapped to a particular byte range of any input file, since
            // they're computed by expressions that may span many files. Don't attempt to map them back
            // to a given file.
            sourceMapUrl = null;
        }
        return {
            ...parseExtractedTemplate(template, sourceStr, sourceParseRange, escapedString, sourceMapUrl, options),
            content: templateContent,
            sourceMapping,
            declaration: template,
        };
    }
    else {
        const templateContent = resourceLoader.load(template.resolvedTemplateUrl);
        if (depTracker !== null) {
            depTracker.addResourceDependency(node.getSourceFile(), absoluteFrom(template.resolvedTemplateUrl));
        }
        return {
            ...parseExtractedTemplate(template, 
            /* sourceStr */ templateContent, 
            /* sourceParseRange */ null, 
            /* escapedString */ false, 
            /* sourceMapUrl */ template.resolvedTemplateUrl, options),
            content: templateContent,
            sourceMapping: {
                type: 'external',
                componentClass: node,
                node: template.templateUrlExpression,
                template: templateContent,
                templateUrl: template.resolvedTemplateUrl,
            },
            declaration: template,
        };
    }
}
function createEmptyTemplate(componentClass, component, containingFile) {
    const templateUrl = component.get('templateUrl');
    const template = component.get('template');
    return {
        content: '',
        diagNodes: [],
        nodes: [],
        errors: null,
        styles: [],
        styleUrls: [],
        ngContentSelectors: [],
        file: new o.ParseSourceFile('', ''),
        sourceMapping: templateUrl
            ? { type: 'direct', node: template }
            : {
                type: 'external',
                componentClass,
                node: templateUrl,
                template: '',
                templateUrl: 'missing.ng.html',
            },
        declaration: templateUrl
            ? {
                isInline: false,
                preserveWhitespaces: false,
                templateUrlExpression: templateUrl,
                templateUrl: 'missing.ng.html',
                resolvedTemplateUrl: '/missing.ng.html',
            }
            : {
                isInline: true,
                preserveWhitespaces: false,
                expression: template,
                templateUrl: containingFile,
                resolvedTemplateUrl: containingFile,
            },
    };
}
function parseExtractedTemplate(template, sourceStr, sourceParseRange, escapedString, sourceMapUrl, options) {
    // We always normalize line endings if the template has been escaped (i.e. is inline).
    const i18nNormalizeLineEndingsInICUs = escapedString || options.i18nNormalizeLineEndingsInICUs;
    const commonParseOptions = {
        range: sourceParseRange ?? undefined,
        enableI18nLegacyMessageIdFormat: options.enableI18nLegacyMessageIdFormat,
        i18nNormalizeLineEndingsInICUs,
        alwaysAttemptHtmlToR3AstConversion: options.usePoisonedData,
        escapedString,
        enableBlockSyntax: options.enableBlockSyntax,
        enableLetSyntax: options.enableLetSyntax,
        enableSelectorless: options.enableSelectorless,
    };
    const parsedTemplate = o.parseTemplate(sourceStr, sourceMapUrl ?? '', {
        ...commonParseOptions,
        preserveWhitespaces: template.preserveWhitespaces,
        preserveSignificantWhitespace: options.preserveSignificantWhitespace,
    });
    // Unfortunately, the primary parse of the template above may not contain accurate source map
    // information. If used directly, it would result in incorrect code locations in template
    // errors, etc. There are three main problems:
    //
    // 1. `preserveWhitespaces: false` or `preserveSignificantWhitespace: false` annihilates the
    //    correctness of template source mapping, as the whitespace transformation changes the
    //    contents of HTML text nodes before they're parsed into Angular expressions.
    // 2. `preserveLineEndings: false` causes growing misalignments in templates that use '\r\n'
    //    line endings, by normalizing them to '\n'.
    // 3. By default, the template parser strips leading trivia characters (like spaces, tabs, and
    //    newlines). This also destroys source mapping information.
    //
    // In order to guarantee the correctness of diagnostics, templates are parsed a second time
    // with the above options set to preserve source mappings.
    const { nodes: diagNodes } = o.parseTemplate(sourceStr, sourceMapUrl ?? '', {
        ...commonParseOptions,
        preserveWhitespaces: true,
        preserveLineEndings: true,
        preserveSignificantWhitespace: true,
        leadingTriviaChars: [],
    });
    return {
        ...parsedTemplate,
        diagNodes,
        file: new o.ParseSourceFile(sourceStr, sourceMapUrl ?? ''),
    };
}
function parseTemplateDeclaration(node, decorator, component, containingFile, evaluator, depTracker, resourceLoader, defaultPreserveWhitespaces) {
    let preserveWhitespaces = defaultPreserveWhitespaces;
    if (component.has('preserveWhitespaces')) {
        const expr = component.get('preserveWhitespaces');
        const value = evaluator.evaluate(expr);
        if (typeof value !== 'boolean') {
            throw createValueHasWrongTypeError(expr, value, 'preserveWhitespaces must be a boolean');
        }
        preserveWhitespaces = value;
    }
    if (component.has('interpolation')) {
        const expr = component.get('interpolation');
        const value = evaluator.evaluate(expr);
        if (!Array.isArray(value) ||
            value.length !== 2 ||
            !value.every((element) => typeof element === 'string')) {
            throw createValueHasWrongTypeError(expr, value, 'interpolation must be an array with 2 elements of string type');
        }
    }
    if (component.has('templateUrl')) {
        const templateUrlExpr = component.get('templateUrl');
        const templateUrl = evaluator.evaluate(templateUrlExpr);
        if (typeof templateUrl !== 'string') {
            throw createValueHasWrongTypeError(templateUrlExpr, templateUrl, 'templateUrl must be a string');
        }
        try {
            const resourceUrl = resourceLoader.resolve(templateUrl, containingFile);
            return {
                isInline: false,
                preserveWhitespaces,
                templateUrl,
                templateUrlExpression: templateUrlExpr,
                resolvedTemplateUrl: resourceUrl,
            };
        }
        catch (e) {
            if (depTracker !== null) {
                // The analysis of this file cannot be re-used if the template URL could
                // not be resolved. Future builds should re-analyze and re-attempt resolution.
                depTracker.recordDependencyAnalysisFailure(node.getSourceFile());
            }
            throw makeResourceNotFoundError(templateUrl, templateUrlExpr, 0 /* ResourceTypeForDiagnostics.Template */);
        }
    }
    else if (component.has('template')) {
        return {
            isInline: true,
            preserveWhitespaces,
            expression: component.get('template'),
            templateUrl: containingFile,
            resolvedTemplateUrl: containingFile,
        };
    }
    else {
        throw new FatalDiagnosticError(exports.ErrorCode.COMPONENT_MISSING_TEMPLATE, decorator.node, 'component is missing a template');
    }
}
function preloadAndParseTemplate(evaluator, resourceLoader, depTracker, preanalyzeTemplateCache, node, decorator, component, containingFile, defaultPreserveWhitespaces, options, compilationMode) {
    if (component.has('templateUrl')) {
        // Extract the templateUrl and preload it.
        const templateUrlExpr = component.get('templateUrl');
        const templateUrl = evaluator.evaluate(templateUrlExpr);
        if (typeof templateUrl !== 'string') {
            throw createValueHasWrongTypeError(templateUrlExpr, templateUrl, 'templateUrl must be a string');
        }
        try {
            const resourceUrl = resourceLoader.resolve(templateUrl, containingFile);
            const templatePromise = resourceLoader.preload(resourceUrl, {
                type: 'template',
                containingFile,
                className: node.name.text,
            });
            // If the preload worked, then actually load and parse the template, and wait for any
            // style URLs to resolve.
            if (templatePromise !== undefined) {
                return templatePromise.then(() => {
                    const templateDecl = parseTemplateDeclaration(node, decorator, component, containingFile, evaluator, depTracker, resourceLoader, defaultPreserveWhitespaces);
                    const template = extractTemplate(node, templateDecl, evaluator, depTracker, resourceLoader, options, compilationMode);
                    preanalyzeTemplateCache.set(node, template);
                    return template;
                });
            }
            else {
                return Promise.resolve(null);
            }
        }
        catch (e) {
            if (depTracker !== null) {
                // The analysis of this file cannot be re-used if the template URL could
                // not be resolved. Future builds should re-analyze and re-attempt resolution.
                depTracker.recordDependencyAnalysisFailure(node.getSourceFile());
            }
            throw makeResourceNotFoundError(templateUrl, templateUrlExpr, 0 /* ResourceTypeForDiagnostics.Template */);
        }
    }
    else {
        const templateDecl = parseTemplateDeclaration(node, decorator, component, containingFile, evaluator, depTracker, resourceLoader, defaultPreserveWhitespaces);
        const template = extractTemplate(node, templateDecl, evaluator, depTracker, resourceLoader, options, compilationMode);
        preanalyzeTemplateCache.set(node, template);
        return Promise.resolve(template);
    }
}
function getTemplateRange(templateExpr) {
    const startPos = templateExpr.getStart() + 1;
    const { line, character } = ts.getLineAndCharacterOfPosition(templateExpr.getSourceFile(), startPos);
    return {
        startPos,
        startLine: line,
        startCol: character,
        endPos: templateExpr.getEnd() - 1,
    };
}
function makeResourceNotFoundError(file, nodeForError, resourceType) {
    let errorText;
    switch (resourceType) {
        case 0 /* ResourceTypeForDiagnostics.Template */:
            errorText = `Could not find template file '${file}'.`;
            break;
        case 1 /* ResourceTypeForDiagnostics.StylesheetFromTemplate */:
            errorText = `Could not find stylesheet file '${file}' linked from the template.`;
            break;
        case 2 /* ResourceTypeForDiagnostics.StylesheetFromDecorator */:
            errorText = `Could not find stylesheet file '${file}'.`;
            break;
    }
    return new FatalDiagnosticError(exports.ErrorCode.COMPONENT_RESOURCE_NOT_FOUND, nodeForError, errorText);
}
/**
 * Transforms the given decorator to inline external resources. i.e. if the decorator
 * resolves to `@Component`, the `templateUrl` and `styleUrls` metadata fields will be
 * transformed to their semantically-equivalent inline variants.
 *
 * This method is used for serializing decorators into the class metadata. The emitted
 * class metadata should not refer to external resources as this would be inconsistent
 * with the component definitions/declarations which already inline external resources.
 *
 * Additionally, the references to external resources would require libraries to ship
 * external resources exclusively for the class metadata.
 */
function transformDecoratorResources(dec, component, styles, template) {
    if (dec.name !== 'Component') {
        return dec;
    }
    // If no external resources are referenced, preserve the original decorator
    // for the best source map experience when the decorator is emitted in TS.
    if (!component.has('templateUrl') &&
        !component.has('styleUrls') &&
        !component.has('styleUrl') &&
        !component.has('styles')) {
        return dec;
    }
    const metadata = new Map(component);
    // Set the `template` property if the `templateUrl` property is set.
    if (metadata.has('templateUrl')) {
        metadata.delete('templateUrl');
        metadata.set('template', ts.factory.createStringLiteral(template.content));
    }
    if (metadata.has('styleUrls') || metadata.has('styleUrl') || metadata.has('styles')) {
        metadata.delete('styles');
        metadata.delete('styleUrls');
        metadata.delete('styleUrl');
        if (styles.length > 0) {
            const styleNodes = styles.reduce((result, style) => {
                if (style.trim().length > 0) {
                    result.push(ts.factory.createStringLiteral(style));
                }
                return result;
            }, []);
            if (styleNodes.length > 0) {
                metadata.set('styles', ts.factory.createArrayLiteralExpression(styleNodes));
            }
        }
    }
    // Convert the metadata to TypeScript AST object literal element nodes.
    const newMetadataFields = [];
    for (const [name, value] of metadata.entries()) {
        newMetadataFields.push(ts.factory.createPropertyAssignment(name, value));
    }
    // Return the original decorator with the overridden metadata argument.
    return { ...dec, args: [ts.factory.createObjectLiteralExpression(newMetadataFields)] };
}
function extractComponentStyleUrls(evaluator, component) {
    const styleUrlsExpr = component.get('styleUrls');
    const styleUrlExpr = component.get('styleUrl');
    if (styleUrlsExpr !== undefined && styleUrlExpr !== undefined) {
        throw new FatalDiagnosticError(exports.ErrorCode.COMPONENT_INVALID_STYLE_URLS, styleUrlExpr, '@Component cannot define both `styleUrl` and `styleUrls`. ' +
            'Use `styleUrl` if the component has one stylesheet, or `styleUrls` if it has multiple');
    }
    if (styleUrlsExpr !== undefined) {
        return extractStyleUrlsFromExpression(evaluator, component.get('styleUrls'));
    }
    if (styleUrlExpr !== undefined) {
        const styleUrl = evaluator.evaluate(styleUrlExpr);
        if (typeof styleUrl !== 'string') {
            throw createValueHasWrongTypeError(styleUrlExpr, styleUrl, 'styleUrl must be a string');
        }
        return [
            {
                url: styleUrl,
                source: 2 /* ResourceTypeForDiagnostics.StylesheetFromDecorator */,
                expression: styleUrlExpr,
            },
        ];
    }
    return [];
}
function extractStyleUrlsFromExpression(evaluator, styleUrlsExpr) {
    const styleUrls = [];
    if (ts.isArrayLiteralExpression(styleUrlsExpr)) {
        for (const styleUrlExpr of styleUrlsExpr.elements) {
            if (ts.isSpreadElement(styleUrlExpr)) {
                styleUrls.push(...extractStyleUrlsFromExpression(evaluator, styleUrlExpr.expression));
            }
            else {
                const styleUrl = evaluator.evaluate(styleUrlExpr);
                if (typeof styleUrl !== 'string') {
                    throw createValueHasWrongTypeError(styleUrlExpr, styleUrl, 'styleUrl must be a string');
                }
                styleUrls.push({
                    url: styleUrl,
                    source: 2 /* ResourceTypeForDiagnostics.StylesheetFromDecorator */,
                    expression: styleUrlExpr,
                });
            }
        }
    }
    else {
        const evaluatedStyleUrls = evaluator.evaluate(styleUrlsExpr);
        if (!isStringArray(evaluatedStyleUrls)) {
            throw createValueHasWrongTypeError(styleUrlsExpr, evaluatedStyleUrls, 'styleUrls must be an array of strings');
        }
        for (const styleUrl of evaluatedStyleUrls) {
            styleUrls.push({
                url: styleUrl,
                source: 2 /* ResourceTypeForDiagnostics.StylesheetFromDecorator */,
                expression: styleUrlsExpr,
            });
        }
    }
    return styleUrls;
}
function extractInlineStyleResources(component) {
    const styles = new Set();
    function stringLiteralElements(array) {
        return array.elements.filter((e) => ts.isStringLiteralLike(e));
    }
    const stylesExpr = component.get('styles');
    if (stylesExpr !== undefined) {
        if (ts.isArrayLiteralExpression(stylesExpr)) {
            for (const expression of stringLiteralElements(stylesExpr)) {
                styles.add({ path: null, node: expression });
            }
        }
        else if (ts.isStringLiteralLike(stylesExpr)) {
            styles.add({ path: null, node: stylesExpr });
        }
    }
    return styles;
}
function _extractTemplateStyleUrls(template) {
    if (template.styleUrls === null) {
        return [];
    }
    const expression = getTemplateDeclarationNodeForError(template.declaration);
    return template.styleUrls.map((url) => ({
        url,
        source: 1 /* ResourceTypeForDiagnostics.StylesheetFromTemplate */,
        expression,
    }));
}

/**
 * Represents an Angular component.
 */
class ComponentSymbol extends DirectiveSymbol {
    usedDirectives = [];
    usedPipes = [];
    isRemotelyScoped = false;
    isEmitAffected(previousSymbol, publicApiAffected) {
        if (!(previousSymbol instanceof ComponentSymbol)) {
            return true;
        }
        // Create an equality function that considers symbols equal if they represent the same
        // declaration, but only if the symbol in the current compilation does not have its public API
        // affected.
        const isSymbolUnaffected = (current, previous) => isReferenceEqual(current, previous) && !publicApiAffected.has(current.symbol);
        // The emit of a component is affected if either of the following is true:
        //  1. The component used to be remotely scoped but no longer is, or vice versa.
        //  2. The list of used directives has changed or any of those directives have had their public
        //     API changed. If the used directives have been reordered but not otherwise affected then
        //     the component must still be re-emitted, as this may affect directive instantiation order.
        //  3. The list of used pipes has changed, or any of those pipes have had their public API
        //     changed.
        return (this.isRemotelyScoped !== previousSymbol.isRemotelyScoped ||
            !isArrayEqual(this.usedDirectives, previousSymbol.usedDirectives, isSymbolUnaffected) ||
            !isArrayEqual(this.usedPipes, previousSymbol.usedPipes, isSymbolUnaffected));
    }
    isTypeCheckBlockAffected(previousSymbol, typeCheckApiAffected) {
        if (!(previousSymbol instanceof ComponentSymbol)) {
            return true;
        }
        // To verify that a used directive is not affected we need to verify that its full inheritance
        // chain is not present in `typeCheckApiAffected`.
        const isInheritanceChainAffected = (symbol) => {
            let currentSymbol = symbol;
            while (currentSymbol instanceof DirectiveSymbol) {
                if (typeCheckApiAffected.has(currentSymbol)) {
                    return true;
                }
                currentSymbol = currentSymbol.baseClass;
            }
            return false;
        };
        // Create an equality function that considers directives equal if they represent the same
        // declaration and if the symbol and all symbols it inherits from in the current compilation
        // do not have their type-check API affected.
        const isDirectiveUnaffected = (current, previous) => isReferenceEqual(current, previous) && !isInheritanceChainAffected(current.symbol);
        // Create an equality function that considers pipes equal if they represent the same
        // declaration and if the symbol in the current compilation does not have its type-check
        // API affected.
        const isPipeUnaffected = (current, previous) => isReferenceEqual(current, previous) && !typeCheckApiAffected.has(current.symbol);
        // The emit of a type-check block of a component is affected if either of the following is true:
        //  1. The list of used directives has changed or any of those directives have had their
        //     type-check API changed.
        //  2. The list of used pipes has changed, or any of those pipes have had their type-check API
        //     changed.
        return (!isArrayEqual(this.usedDirectives, previousSymbol.usedDirectives, isDirectiveUnaffected) ||
            !isArrayEqual(this.usedPipes, previousSymbol.usedPipes, isPipeUnaffected));
    }
}

/**
 * Collect the animation names from the static evaluation result.
 * @param value the static evaluation result of the animations
 * @param legacyAnimationTriggerNames the animation names collected and whether some names could not be
 *     statically evaluated.
 */
function collectLegacyAnimationNames(value, legacyAnimationTriggerNames) {
    if (value instanceof Map) {
        const name = value.get('name');
        if (typeof name === 'string') {
            legacyAnimationTriggerNames.staticTriggerNames.push(name);
        }
        else {
            legacyAnimationTriggerNames.includesDynamicAnimations = true;
        }
    }
    else if (Array.isArray(value)) {
        for (const resolvedValue of value) {
            collectLegacyAnimationNames(resolvedValue, legacyAnimationTriggerNames);
        }
    }
    else {
        legacyAnimationTriggerNames.includesDynamicAnimations = true;
    }
}
function isLegacyAngularAnimationsReference(reference, symbolName) {
    return (reference.ownedByModuleGuess === '@angular/animations' && reference.debugName === symbolName);
}
const legacyAnimationTriggerResolver = (fn, node, resolve, unresolvable) => {
    const animationTriggerMethodName = 'trigger';
    if (!isLegacyAngularAnimationsReference(fn, animationTriggerMethodName)) {
        return unresolvable;
    }
    const triggerNameExpression = node.arguments[0];
    if (!triggerNameExpression) {
        return unresolvable;
    }
    const res = new Map();
    res.set('name', resolve(triggerNameExpression));
    return res;
};
function validateAndFlattenComponentImports(imports, expr, isDeferred) {
    const flattened = [];
    const errorMessage = isDeferred
        ? `'deferredImports' must be an array of components, directives, or pipes.`
        : `'imports' must be an array of components, directives, pipes, or NgModules.`;
    if (!Array.isArray(imports)) {
        const error = createValueHasWrongTypeError(expr, imports, errorMessage).toDiagnostic();
        return {
            imports: [],
            diagnostics: [error],
        };
    }
    const diagnostics = [];
    for (let i = 0; i < imports.length; i++) {
        const ref = imports[i];
        if (Array.isArray(ref)) {
            const { imports: childImports, diagnostics: childDiagnostics } = validateAndFlattenComponentImports(ref, expr, isDeferred);
            flattened.push(...childImports);
            diagnostics.push(...childDiagnostics);
        }
        else if (ref instanceof Reference) {
            if (isNamedClassDeclaration(ref.node)) {
                flattened.push(ref);
            }
            else {
                diagnostics.push(createValueHasWrongTypeError(ref.getOriginForDiagnostics(expr), ref, errorMessage).toDiagnostic());
            }
        }
        else if (isLikelyModuleWithProviders(ref)) {
            let origin = expr;
            if (ref instanceof SyntheticValue) {
                // The `ModuleWithProviders` type originated from a foreign function declaration, in which
                // case the original foreign call is available which is used to get a more accurate origin
                // node that points at the specific call expression.
                origin = getOriginNodeForDiagnostics(ref.value.mwpCall, expr);
            }
            diagnostics.push(makeDiagnostic(exports.ErrorCode.COMPONENT_UNKNOWN_IMPORT, origin, `Component imports contains a ModuleWithProviders value, likely the result of a 'Module.forRoot()'-style call. ` +
                `These calls are not used to configure components and are not valid in standalone component imports - ` +
                `consider importing them in the application bootstrap instead.`));
        }
        else {
            let diagnosticNode;
            let diagnosticValue;
            if (ref instanceof DynamicValue) {
                diagnosticNode = ref.node;
                diagnosticValue = ref;
            }
            else if (ts.isArrayLiteralExpression(expr) &&
                expr.elements.length === imports.length &&
                !expr.elements.some(ts.isSpreadAssignment) &&
                !imports.some(Array.isArray)) {
                // Reporting a diagnostic on the entire array can be noisy, especially if the user has a
                // large array. The most common case is that the array will be static so we can reliably
                // trace back a `ResolvedValue` back to its node using its index. This allows us to report
                // the exact node that caused the issue.
                diagnosticNode = expr.elements[i];
                diagnosticValue = ref;
            }
            else {
                diagnosticNode = expr;
                diagnosticValue = imports;
            }
            diagnostics.push(createValueHasWrongTypeError(diagnosticNode, diagnosticValue, errorMessage).toDiagnostic());
        }
    }
    return { imports: flattened, diagnostics };
}
/**
 * Inspects `value` to determine if it resembles a `ModuleWithProviders` value. This is an
 * approximation only suitable for error reporting as any resolved object with an `ngModule`
 * key is considered a `ModuleWithProviders`.
 */
function isLikelyModuleWithProviders(value) {
    if (value instanceof SyntheticValue && isResolvedModuleWithProviders(value)) {
        // This is a `ModuleWithProviders` as extracted from a foreign function call.
        return true;
    }
    if (value instanceof Map && value.has('ngModule')) {
        // A resolved `Map` with `ngModule` property would have been extracted from locally declared
        // functions that return a `ModuleWithProviders` object.
        return true;
    }
    return false;
}

/*!
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.dev/license
 */
/**
 * Determines the file-level dependencies that the HMR initializer needs to capture and pass along.
 * @param sourceFile File in which the file is being compiled.
 * @param definition Compiled component definition.
 * @param factory Compiled component factory.
 * @param deferBlockMetadata Metadata about the defer blocks in the component.
 * @param classMetadata Compiled `setClassMetadata` expression, if any.
 * @param debugInfo Compiled `setClassDebugInfo` expression, if any.
 */
function extractHmrDependencies(node, definition, factory, deferBlockMetadata, classMetadata, debugInfo, reflection, evaluator) {
    const name = ts.isClassDeclaration(node) && node.name ? node.name.text : null;
    const visitor = new PotentialTopLevelReadsVisitor();
    const sourceFile = ts.getOriginalNode(node).getSourceFile();
    // Visit all of the compiled expressions to look for potential
    // local references that would have to be retained.
    definition.expression.visitExpression(visitor, null);
    definition.statements.forEach((statement) => statement.visitStatement(visitor, null));
    factory.initializer?.visitExpression(visitor, null);
    factory.statements.forEach((statement) => statement.visitStatement(visitor, null));
    classMetadata?.visitStatement(visitor, null);
    debugInfo?.visitStatement(visitor, null);
    if (deferBlockMetadata.mode === 0 /* DeferBlockDepsEmitMode.PerBlock */) {
        deferBlockMetadata.blocks.forEach((loader) => loader?.visitExpression(visitor, null));
    }
    else {
        deferBlockMetadata.dependenciesFn?.visitExpression(visitor, null);
    }
    // Filter out only the references to defined top-level symbols. This allows us to ignore local
    // variables inside of functions. Note that we filter out the class name since it is always
    // defined and it saves us having to repeat this logic wherever the locals are consumed.
    const availableTopLevel = getTopLevelDeclarationNames(sourceFile);
    const local = [];
    const seenLocals = new Set();
    for (const readNode of visitor.allReads) {
        const readName = readNode instanceof o.outputAst.ReadVarExpr ? readNode.name : readNode.text;
        if (readName !== name && !seenLocals.has(readName) && availableTopLevel.has(readName)) {
            const runtimeRepresentation = getRuntimeRepresentation(readNode, reflection, evaluator);
            if (runtimeRepresentation === null) {
                return null;
            }
            local.push({ name: readName, runtimeRepresentation });
            seenLocals.add(readName);
        }
    }
    return {
        local,
        external: Array.from(visitor.namespaceReads, (name, index) => ({
            moduleName: name,
            assignedName: `Éµhmr${index}`,
        })),
    };
}
/**
 * Gets a node that can be used to represent an identifier in the HMR replacement code at runtime.
 */
function getRuntimeRepresentation(node, reflection, evaluator) {
    if (node instanceof o.outputAst.ReadVarExpr) {
        return o.outputAst.variable(node.name);
    }
    // Const enums can't be passed by reference, because their values are inlined.
    // Pass in an object literal with all of the values instead.
    if (isConstEnumReference(node, reflection)) {
        const evaluated = evaluator.evaluate(node);
        if (evaluated instanceof Map) {
            const members = [];
            for (const [name, value] of evaluated.entries()) {
                if (value instanceof EnumValue &&
                    (value.resolved == null ||
                        typeof value.resolved === 'string' ||
                        typeof value.resolved === 'boolean' ||
                        typeof value.resolved === 'number')) {
                    members.push({
                        key: name,
                        quoted: false,
                        value: o.outputAst.literal(value.resolved),
                    });
                }
                else {
                    // TS is pretty restrictive about what values can be in a const enum so our evaluator
                    // should be able to handle them, however if we happen to hit such a case, we return null
                    // so the HMR update can be invalidated.
                    return null;
                }
            }
            return o.outputAst.literalMap(members);
        }
    }
    return o.outputAst.variable(node.text);
}
/**
 * Gets the names of all top-level declarations within the file (imports, declared classes etc).
 * @param sourceFile File in which to search for locals.
 */
function getTopLevelDeclarationNames(sourceFile) {
    const results = new Set();
    // Only look through the top-level statements.
    for (const node of sourceFile.statements) {
        // Class, function and const enum declarations need to be captured since they correspond
        // to runtime code. Intentionally excludes interfaces and type declarations.
        if (ts.isClassDeclaration(node) ||
            ts.isFunctionDeclaration(node) ||
            ts.isEnumDeclaration(node)) {
            if (node.name) {
                results.add(node.name.text);
            }
            continue;
        }
        // Variable declarations.
        if (ts.isVariableStatement(node)) {
            for (const decl of node.declarationList.declarations) {
                trackBindingName(decl.name, results);
            }
            continue;
        }
        // Import declarations.
        if (ts.isImportDeclaration(node) && node.importClause) {
            const importClause = node.importClause;
            // Skip over type-only imports since they won't be emitted to JS.
            if (importClause.isTypeOnly) {
                continue;
            }
            // import foo from 'foo'
            if (importClause.name) {
                results.add(importClause.name.text);
            }
            if (importClause.namedBindings) {
                const namedBindings = importClause.namedBindings;
                if (ts.isNamespaceImport(namedBindings)) {
                    // import * as foo from 'foo';
                    results.add(namedBindings.name.text);
                }
                else {
                    // import {foo} from 'foo';
                    namedBindings.elements.forEach((el) => {
                        if (!el.isTypeOnly) {
                            results.add(el.name.text);
                        }
                    });
                }
            }
            continue;
        }
    }
    return results;
}
/**
 * Adds all the variables declared through a `ts.BindingName` to a set of results.
 * @param node Node from which to start searching for variables.
 * @param results Set to which to add the matches.
 */
function trackBindingName(node, results) {
    if (ts.isIdentifier(node)) {
        results.add(node.text);
    }
    else {
        for (const el of node.elements) {
            if (!ts.isOmittedExpression(el)) {
                trackBindingName(el.name, results);
            }
        }
    }
}
/**
 * Visitor that will traverse an AST looking for potential top-level variable reads.
 * The reads are "potential", because the visitor doesn't account for local variables
 * inside functions.
 */
class PotentialTopLevelReadsVisitor extends o.outputAst.RecursiveAstVisitor {
    allReads = new Set();
    namespaceReads = new Set();
    visitExternalExpr(ast, context) {
        if (ast.value.moduleName !== null) {
            this.namespaceReads.add(ast.value.moduleName);
        }
        super.visitExternalExpr(ast, context);
    }
    visitReadVarExpr(ast, context) {
        this.allReads.add(ast);
        super.visitReadVarExpr(ast, context);
    }
    visitWrappedNodeExpr(ast, context) {
        if (this.isTypeScriptNode(ast.node)) {
            this.addAllTopLevelIdentifiers(ast.node);
        }
        super.visitWrappedNodeExpr(ast, context);
    }
    /**
     * Traverses a TypeScript AST and tracks all the top-level reads.
     * @param node Node from which to start the traversal.
     */
    addAllTopLevelIdentifiers = (node) => {
        if (ts.isIdentifier(node) && this.isTopLevelIdentifierReference(node)) {
            this.allReads.add(node);
        }
        else {
            ts.forEachChild(node, this.addAllTopLevelIdentifiers);
        }
    };
    /**
     * TypeScript identifiers are used both when referring to a variable (e.g. `console.log(foo)`)
     * and for names (e.g. `{foo: 123}`). This function determines if the identifier is a top-level
     * variable read, rather than a nested name.
     * @param identifier Identifier to check.
     */
    isTopLevelIdentifierReference(identifier) {
        let node = identifier;
        let parent = node.parent;
        // The parent might be undefined for a synthetic node or if `setParentNodes` is set to false
        // when the SourceFile was created. We can account for such cases using the type checker, at
        // the expense of performance. At the moment of writing, we're keeping it simple since the
        // compiler sets `setParentNodes: true`.
        if (!parent) {
            return false;
        }
        // Unwrap parenthesized identifiers, but use the closest parenthesized expression
        // as the reference node so that we can check cases like `{prop: ((value))}`.
        if (ts.isParenthesizedExpression(parent) && parent.expression === node) {
            while (parent && ts.isParenthesizedExpression(parent)) {
                node = parent;
                parent = parent.parent;
            }
        }
        // Identifier referenced at the top level. Unlikely.
        if (ts.isSourceFile(parent)) {
            return true;
        }
        // Identifier used inside a call is only top-level if it's an argument.
        // This also covers decorators since their expression is usually a call.
        if (ts.isCallExpression(parent)) {
            return parent.expression === node || parent.arguments.includes(node);
        }
        // Identifier used in a nested expression is only top-level if it's the actual expression.
        if (ts.isExpressionStatement(parent) ||
            ts.isPropertyAccessExpression(parent) ||
            ts.isComputedPropertyName(parent) ||
            ts.isTemplateSpan(parent) ||
            ts.isSpreadAssignment(parent) ||
            ts.isSpreadElement(parent) ||
            ts.isAwaitExpression(parent) ||
            ts.isNonNullExpression(parent) ||
            ts.isIfStatement(parent) ||
            ts.isDoStatement(parent) ||
            ts.isWhileStatement(parent) ||
            ts.isSwitchStatement(parent) ||
            ts.isCaseClause(parent) ||
            ts.isThrowStatement(parent) ||
            ts.isNewExpression(parent) ||
            ts.isExpressionWithTypeArguments(parent)) {
            return parent.expression === node;
        }
        // Identifier used in an array is only top-level if it's one of the elements.
        if (ts.isArrayLiteralExpression(parent)) {
            return parent.elements.includes(node);
        }
        // If the parent is an initialized node, the identifier is
        // at the top level if it's the initializer itself.
        if (ts.isPropertyAssignment(parent) ||
            ts.isParameter(parent) ||
            ts.isBindingElement(parent) ||
            ts.isPropertyDeclaration(parent) ||
            ts.isEnumMember(parent)) {
            return parent.initializer === node;
        }
        // Identifier in a function is top level if it's either the name or the initializer.
        if (ts.isVariableDeclaration(parent)) {
            return parent.name === node || parent.initializer === node;
        }
        // Identifier in a declaration is only top level if it's the name.
        // In shorthand assignments the name is also the value.
        if (ts.isClassDeclaration(parent) ||
            ts.isFunctionDeclaration(parent) ||
            ts.isShorthandPropertyAssignment(parent)) {
            return parent.name === node;
        }
        if (ts.isElementAccessExpression(parent)) {
            return parent.expression === node || parent.argumentExpression === node;
        }
        if (ts.isBinaryExpression(parent)) {
            return parent.left === node || parent.right === node;
        }
        if (ts.isForInStatement(parent) || ts.isForOfStatement(parent)) {
            return parent.expression === node || parent.initializer === node;
        }
        if (ts.isForStatement(parent)) {
            return (parent.condition === node || parent.initializer === node || parent.incrementor === node);
        }
        if (ts.isArrowFunction(parent)) {
            return parent.body === node;
        }
        // It's unlikely that we'll run into imports/exports in this use case.
        // We handle them since it's simple and for completeness' sake.
        if (ts.isImportSpecifier(parent) || ts.isExportSpecifier(parent)) {
            return (parent.propertyName || parent.name) === node;
        }
        if (ts.isConditionalExpression(parent)) {
            return parent.condition === node || parent.whenFalse === node || parent.whenTrue === node;
        }
        // Otherwise it's not top-level.
        return false;
    }
    /** Checks if a value is a TypeScript AST node. */
    isTypeScriptNode(value) {
        // If this is too permissive, we can also check for `getSourceFile`. This code runs
        // on a narrow set of use cases so checking for `kind` should be enough.
        return !!value && typeof value.kind === 'number';
    }
}
/** Checks whether a node is a reference to a const enum. */
function isConstEnumReference(node, reflection) {
    const parent = node.parent;
    // Only check identifiers that are in the form of `Foo.bar` where `Foo` is the node being checked.
    if (!parent ||
        !ts.isPropertyAccessExpression(parent) ||
        parent.expression !== node ||
        !ts.isIdentifier(parent.name)) {
        return false;
    }
    const declaration = reflection.getDeclarationOfIdentifier(node);
    return (declaration !== null &&
        ts.isEnumDeclaration(declaration.node) &&
        !!declaration.node.modifiers?.some((m) => m.kind === ts.SyntaxKind.ConstKeyword));
}

/*!
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.dev/license
 */
/**
 * Extracts the HMR metadata for a class declaration.
 * @param clazz Class being analyzed.
 * @param reflection Reflection host.
 * @param compilerHost Compiler host to use when resolving file names.
 * @param rootDirs Root directories configured by the user.
 * @param definition Analyzed component definition.
 * @param factory Analyzed component factory.
 * @param deferBlockMetadata Metadata about the defer blocks in the component.
 * @param classMetadata Analyzed `setClassMetadata` expression, if any.
 * @param debugInfo Analyzed `setClassDebugInfo` expression, if any.
 */
function extractHmrMetatadata(clazz, reflection, evaluator, compilerHost, rootDirs, definition, factory, deferBlockMetadata, classMetadata, debugInfo) {
    if (!reflection.isClass(clazz)) {
        return null;
    }
    const sourceFile = ts.getOriginalNode(clazz).getSourceFile();
    const filePath = getProjectRelativePath(sourceFile.fileName, rootDirs, compilerHost) ||
        compilerHost.getCanonicalFileName(sourceFile.fileName);
    const dependencies = extractHmrDependencies(clazz, definition, factory, deferBlockMetadata, classMetadata, debugInfo, reflection, evaluator);
    if (dependencies === null) {
        return null;
    }
    const meta = {
        type: new o.outputAst.WrappedNodeExpr(clazz.name),
        className: clazz.name.text,
        filePath,
        localDependencies: dependencies.local,
        namespaceDependencies: dependencies.external,
    };
    return meta;
}

/*!
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.dev/license
 */
/**
 * Gets the declaration for the function that replaces the metadata of a class during HMR.
 * @param compilationResults Code generated for the class during compilation.
 * @param meta HMR metadata about the class.
 * @param declaration Class for which the update declaration is being generated.
 */
function getHmrUpdateDeclaration(compilationResults, constantStatements, meta, declaration) {
    const namespaceSpecifiers = meta.namespaceDependencies.reduce((result, current) => {
        result.set(current.moduleName, current.assignedName);
        return result;
    }, new Map());
    const importRewriter = new HmrModuleImportRewriter(namespaceSpecifiers);
    const importManager = new ImportManager({
        ...presetImportManagerForceNamespaceImports,
        rewriter: importRewriter,
    });
    const callback = o.compileHmrUpdateCallback(compilationResults, constantStatements, meta);
    const sourceFile = ts.getOriginalNode(declaration).getSourceFile();
    const node = translateStatement(sourceFile, callback, importManager);
    // The output AST doesn't support modifiers so we have to emit to
    // TS and then update the declaration to add `export default`.
    return ts.factory.updateFunctionDeclaration(node, [
        ts.factory.createToken(ts.SyntaxKind.ExportKeyword),
        ts.factory.createToken(ts.SyntaxKind.DefaultKeyword),
    ], node.asteriskToken, node.name, node.typeParameters, node.parameters, node.type, node.body);
}
class HmrModuleImportRewriter {
    lookup;
    constructor(lookup) {
        this.lookup = lookup;
    }
    rewriteNamespaceImportIdentifier(specifier, moduleName) {
        return this.lookup.has(moduleName) ? this.lookup.get(moduleName) : specifier;
    }
    rewriteSymbol(symbol) {
        return symbol;
    }
    rewriteSpecifier(specifier) {
        return specifier;
    }
}

/*!
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.dev/license
 */
/**
 * Analyzes a component's template to determine if it's using selectorless syntax
 * and to extract the names of the selectorless symbols that are referenced.
 */
function analyzeTemplateForSelectorless(template) {
    const analyzer = new SelectorlessDirectivesAnalyzer();
    o.tmplAstVisitAll(analyzer, template);
    const isSelectorless = analyzer.symbols !== null && analyzer.symbols.size > 0;
    const localReferencedSymbols = analyzer.symbols;
    // The template is considered selectorless only if there
    // are direct references to directives or pipes.
    return { isSelectorless, localReferencedSymbols };
}
/**
 * Visitor that traverses all the template nodes and
 * expressions to look for selectorless references.
 */
class SelectorlessDirectivesAnalyzer extends o.CombinedRecursiveAstVisitor {
    symbols = null;
    visit(node) {
        if (node instanceof o.BindingPipe && node.type === o.BindingPipeType.ReferencedDirectly) {
            this.trackSymbol(node.name);
        }
        super.visit(node);
    }
    visitComponent(component) {
        this.trackSymbol(component.componentName);
        super.visitComponent(component);
    }
    visitDirective(directive) {
        this.trackSymbol(directive.name);
        super.visitDirective(directive);
    }
    trackSymbol(name) {
        this.symbols ??= new Set();
        this.symbols.add(name);
    }
}

/*!
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.dev/license
 */
const ANIMATE_ENTER = 'animate.enter';
const ANIMATE_LEAVE = `animate.leave`;
/**
 * Analyzes a component's template to determine if it's using animate.enter
 * or animate.leave syntax.
 */
function analyzeTemplateForAnimations(template) {
    const analyzer = new AnimationsAnalyzer();
    o.tmplAstVisitAll(analyzer, template);
    return { hasAnimations: analyzer.hasAnimations };
}
/**
 * Visitor that traverses all the template nodes and
 * expressions to look for animation references.
 */
class AnimationsAnalyzer extends o.CombinedRecursiveAstVisitor {
    hasAnimations = false;
    visitElement(element) {
        for (const attr of element.attributes) {
            if (attr.name === ANIMATE_LEAVE || attr.name === ANIMATE_ENTER) {
                this.hasAnimations = true;
            }
        }
        for (const input of element.inputs) {
            if (input.name === ANIMATE_LEAVE || input.name === ANIMATE_ENTER) {
                this.hasAnimations = true;
            }
        }
        super.visitElement(element);
    }
}

const EMPTY_ARRAY = [];
const isUsedDirective = (decl) => decl.kind === o.R3TemplateDependencyKind.Directive;
const isUsedPipe = (decl) => decl.kind === o.R3TemplateDependencyKind.Pipe;
/**
 * `DecoratorHandler` which handles the `@Component` annotation.
 */
class ComponentDecoratorHandler {
    reflector;
    evaluator;
    metaRegistry;
    metaReader;
    scopeReader;
    compilerHost;
    scopeRegistry;
    typeCheckScopeRegistry;
    resourceRegistry;
    isCore;
    strictCtorDeps;
    resourceLoader;
    rootDirs;
    defaultPreserveWhitespaces;
    i18nUseExternalIds;
    enableI18nLegacyMessageIdFormat;
    usePoisonedData;
    i18nNormalizeLineEndingsInICUs;
    moduleResolver;
    cycleAnalyzer;
    cycleHandlingStrategy;
    refEmitter;
    referencesRegistry;
    depTracker;
    injectableRegistry;
    semanticDepGraphUpdater;
    annotateForClosureCompiler;
    perf;
    hostDirectivesResolver;
    importTracker;
    includeClassMetadata;
    compilationMode;
    deferredSymbolTracker;
    forbidOrphanRendering;
    enableBlockSyntax;
    enableLetSyntax;
    externalRuntimeStyles;
    localCompilationExtraImportsTracker;
    jitDeclarationRegistry;
    i18nPreserveSignificantWhitespace;
    strictStandalone;
    enableHmr;
    implicitStandaloneValue;
    typeCheckHostBindings;
    enableSelectorless;
    emitDeclarationOnly;
    constructor(reflector, evaluator, metaRegistry, metaReader, scopeReader, compilerHost, scopeRegistry, typeCheckScopeRegistry, resourceRegistry, isCore, strictCtorDeps, resourceLoader, rootDirs, defaultPreserveWhitespaces, i18nUseExternalIds, enableI18nLegacyMessageIdFormat, usePoisonedData, i18nNormalizeLineEndingsInICUs, moduleResolver, cycleAnalyzer, cycleHandlingStrategy, refEmitter, referencesRegistry, depTracker, injectableRegistry, semanticDepGraphUpdater, annotateForClosureCompiler, perf, hostDirectivesResolver, importTracker, includeClassMetadata, compilationMode, deferredSymbolTracker, forbidOrphanRendering, enableBlockSyntax, enableLetSyntax, externalRuntimeStyles, localCompilationExtraImportsTracker, jitDeclarationRegistry, i18nPreserveSignificantWhitespace, strictStandalone, enableHmr, implicitStandaloneValue, typeCheckHostBindings, enableSelectorless, emitDeclarationOnly) {
        this.reflector = reflector;
        this.evaluator = evaluator;
        this.metaRegistry = metaRegistry;
        this.metaReader = metaReader;
        this.scopeReader = scopeReader;
        this.compilerHost = compilerHost;
        this.scopeRegistry = scopeRegistry;
        this.typeCheckScopeRegistry = typeCheckScopeRegistry;
        this.resourceRegistry = resourceRegistry;
        this.isCore = isCore;
        this.strictCtorDeps = strictCtorDeps;
        this.resourceLoader = resourceLoader;
        this.rootDirs = rootDirs;
        this.defaultPreserveWhitespaces = defaultPreserveWhitespaces;
        this.i18nUseExternalIds = i18nUseExternalIds;
        this.enableI18nLegacyMessageIdFormat = enableI18nLegacyMessageIdFormat;
        this.usePoisonedData = usePoisonedData;
        this.i18nNormalizeLineEndingsInICUs = i18nNormalizeLineEndingsInICUs;
        this.moduleResolver = moduleResolver;
        this.cycleAnalyzer = cycleAnalyzer;
        this.cycleHandlingStrategy = cycleHandlingStrategy;
        this.refEmitter = refEmitter;
        this.referencesRegistry = referencesRegistry;
        this.depTracker = depTracker;
        this.injectableRegistry = injectableRegistry;
        this.semanticDepGraphUpdater = semanticDepGraphUpdater;
        this.annotateForClosureCompiler = annotateForClosureCompiler;
        this.perf = perf;
        this.hostDirectivesResolver = hostDirectivesResolver;
        this.importTracker = importTracker;
        this.includeClassMetadata = includeClassMetadata;
        this.compilationMode = compilationMode;
        this.deferredSymbolTracker = deferredSymbolTracker;
        this.forbidOrphanRendering = forbidOrphanRendering;
        this.enableBlockSyntax = enableBlockSyntax;
        this.enableLetSyntax = enableLetSyntax;
        this.externalRuntimeStyles = externalRuntimeStyles;
        this.localCompilationExtraImportsTracker = localCompilationExtraImportsTracker;
        this.jitDeclarationRegistry = jitDeclarationRegistry;
        this.i18nPreserveSignificantWhitespace = i18nPreserveSignificantWhitespace;
        this.strictStandalone = strictStandalone;
        this.enableHmr = enableHmr;
        this.implicitStandaloneValue = implicitStandaloneValue;
        this.typeCheckHostBindings = typeCheckHostBindings;
        this.enableSelectorless = enableSelectorless;
        this.emitDeclarationOnly = emitDeclarationOnly;
        this.extractTemplateOptions = {
            enableI18nLegacyMessageIdFormat: this.enableI18nLegacyMessageIdFormat,
            i18nNormalizeLineEndingsInICUs: this.i18nNormalizeLineEndingsInICUs,
            usePoisonedData: this.usePoisonedData,
            enableBlockSyntax: this.enableBlockSyntax,
            enableLetSyntax: this.enableLetSyntax,
            enableSelectorless: this.enableSelectorless,
            preserveSignificantWhitespace: this.i18nPreserveSignificantWhitespace,
        };
        this.undecoratedMetadataExtractor = getDirectiveUndecoratedMetadataExtractor(reflector, importTracker);
        // Dependencies can't be deferred during HMR, because the HMR update module can't have
        // dynamic imports and its dependencies need to be passed in directly. If dependencies
        // are deferred, their imports will be deleted so we may lose the reference to them.
        this.canDeferDeps = !enableHmr;
    }
    literalCache = new Map();
    elementSchemaRegistry = new o.DomElementSchemaRegistry();
    undecoratedMetadataExtractor;
    /**
     * During the asynchronous preanalyze phase, it's necessary to parse the template to extract
     * any potential <link> tags which might need to be loaded. This cache ensures that work is not
     * thrown away, and the parsed template is reused during the analyze phase.
     */
    preanalyzeTemplateCache = new Map();
    preanalyzeStylesCache = new Map();
    /** Whether generated code for a component can defer its dependencies. */
    canDeferDeps;
    extractTemplateOptions;
    precedence = HandlerPrecedence.PRIMARY;
    name = 'ComponentDecoratorHandler';
    detect(node, decorators) {
        if (!decorators) {
            return undefined;
        }
        const decorator = findAngularDecorator(decorators, 'Component', this.isCore);
        if (decorator !== undefined) {
            return {
                trigger: decorator.node,
                decorator,
                metadata: decorator,
            };
        }
        else {
            return undefined;
        }
    }
    preanalyze(node, decorator) {
        // In preanalyze, resource URLs associated with the component are asynchronously preloaded via
        // the resourceLoader. This is the only time async operations are allowed for a component.
        // These resources are:
        //
        // - the templateUrl, if there is one
        // - any styleUrls if present
        // - any stylesheets referenced from <link> tags in the template itself
        //
        // As a result of the last one, the template must be parsed as part of preanalysis to extract
        // <link> tags, which may involve waiting for the templateUrl to be resolved first.
        // If preloading isn't possible, then skip this step.
        if (!this.resourceLoader.canPreload) {
            return undefined;
        }
        const meta = resolveLiteral(decorator, this.literalCache);
        const component = reflectObjectLiteral(meta);
        const containingFile = node.getSourceFile().fileName;
        const resolveStyleUrl = (styleUrl) => {
            try {
                const resourceUrl = this.resourceLoader.resolve(styleUrl, containingFile);
                return this.resourceLoader.preload(resourceUrl, {
                    type: 'style',
                    containingFile,
                    className: node.name.text,
                });
            }
            catch {
                // Don't worry about failures to preload. We can handle this problem during analysis by
                // producing a diagnostic.
                return undefined;
            }
        };
        // A Promise that waits for the template and all <link>ed styles within it to be preloaded.
        const templateAndTemplateStyleResources = preloadAndParseTemplate(this.evaluator, this.resourceLoader, this.depTracker, this.preanalyzeTemplateCache, node, decorator, component, containingFile, this.defaultPreserveWhitespaces, this.extractTemplateOptions, this.compilationMode).then((template) => {
            if (template === null) {
                return { templateStyles: [], templateStyleUrls: [] };
            }
            let templateUrl;
            if (template.sourceMapping.type === 'external') {
                templateUrl = template.sourceMapping.templateUrl;
            }
            return {
                templateUrl,
                templateStyles: template.styles,
                templateStyleUrls: template.styleUrls,
            };
        });
        // Extract all the styleUrls in the decorator.
        const componentStyleUrls = extractComponentStyleUrls(this.evaluator, component);
        return templateAndTemplateStyleResources.then(async (templateInfo) => {
            // Extract inline styles, process, and cache for use in synchronous analyze phase
            let styles = null;
            // Order plus className allows inline styles to be identified per component by a preprocessor
            let orderOffset = 0;
            const rawStyles = parseDirectiveStyles(component, this.evaluator, this.compilationMode);
            if (rawStyles?.length) {
                styles = await Promise.all(rawStyles.map((style) => this.resourceLoader.preprocessInline(style, {
                    type: 'style',
                    containingFile,
                    order: orderOffset++,
                    className: node.name.text,
                })));
            }
            if (templateInfo.templateStyles) {
                styles ??= [];
                styles.push(...(await Promise.all(templateInfo.templateStyles.map((style) => this.resourceLoader.preprocessInline(style, {
                    type: 'style',
                    containingFile: templateInfo.templateUrl ?? containingFile,
                    order: orderOffset++,
                    className: node.name.text,
                })))));
            }
            this.preanalyzeStylesCache.set(node, styles);
            if (this.externalRuntimeStyles) {
                // No preanalysis required for style URLs with external runtime styles
                return;
            }
            // Wait for both the template and all styleUrl resources to resolve.
            await Promise.all([
                ...componentStyleUrls.map((styleUrl) => resolveStyleUrl(styleUrl.url)),
                ...templateInfo.templateStyleUrls.map((url) => resolveStyleUrl(url)),
            ]);
        });
    }
    analyze(node, decorator) {
        this.perf.eventCount(exports.PerfEvent.AnalyzeComponent);
        const containingFile = node.getSourceFile().fileName;
        this.literalCache.delete(decorator);
        let diagnostics;
        let isPoisoned = false;
        // @Component inherits @Directive, so begin by extracting the @Directive metadata and building
        // on it.
        const directiveResult = extractDirectiveMetadata(node, decorator, this.reflector, this.importTracker, this.evaluator, this.refEmitter, this.referencesRegistry, this.isCore, this.annotateForClosureCompiler, this.compilationMode, this.elementSchemaRegistry.getDefaultComponentElementName(), this.strictStandalone, this.implicitStandaloneValue, this.emitDeclarationOnly);
        // `extractDirectiveMetadata` returns `jitForced = true` when the `@Component` has
        // set `jit: true`. In this case, compilation of the decorator is skipped. Returning
        // an empty object signifies that no analysis was produced.
        if (directiveResult.jitForced) {
            this.jitDeclarationRegistry.jitDeclarations.add(node);
            return {};
        }
        // Next, read the `@Component`-specific fields.
        const { decorator: component, metadata, inputs, outputs, hostDirectives, rawHostDirectives, } = directiveResult;
        const encapsulation = (this.compilationMode !== exports.CompilationMode.LOCAL
            ? resolveEnumValue(this.evaluator, component, 'encapsulation', 'ViewEncapsulation', this.isCore)
            : resolveEncapsulationEnumValueLocally(component.get('encapsulation'))) ??
            o.ViewEncapsulation.Emulated;
        let changeDetection = null;
        if (this.compilationMode !== exports.CompilationMode.LOCAL) {
            changeDetection = resolveEnumValue(this.evaluator, component, 'changeDetection', 'ChangeDetectionStrategy', this.isCore);
        }
        else if (component.has('changeDetection')) {
            changeDetection = new o.outputAst.WrappedNodeExpr(component.get('changeDetection'));
        }
        let animations = null;
        let legacyAnimationTriggerNames = null;
        if (component.has('animations')) {
            const animationExpression = component.get('animations');
            animations = new o.outputAst.WrappedNodeExpr(animationExpression);
            const animationsValue = this.evaluator.evaluate(animationExpression, legacyAnimationTriggerResolver);
            legacyAnimationTriggerNames = { includesDynamicAnimations: false, staticTriggerNames: [] };
            collectLegacyAnimationNames(animationsValue, legacyAnimationTriggerNames);
        }
        // Go through the root directories for this project, and select the one with the smallest
        // relative path representation.
        const relativeContextFilePath = this.rootDirs.reduce((previous, rootDir) => {
            const candidate = relative(absoluteFrom(rootDir), absoluteFrom(containingFile));
            if (previous === undefined || candidate.length < previous.length) {
                return candidate;
            }
            else {
                return previous;
            }
        }, undefined);
        // Note that we could technically combine the `viewProvidersRequiringFactory` and
        // `providersRequiringFactory` into a single set, but we keep the separate so that
        // we can distinguish where an error is coming from when logging the diagnostics in `resolve`.
        let viewProvidersRequiringFactory = null;
        let providersRequiringFactory = null;
        let wrappedViewProviders = null;
        if (component.has('viewProviders')) {
            const viewProviders = component.get('viewProviders');
            viewProvidersRequiringFactory = resolveProvidersRequiringFactory(viewProviders, this.reflector, this.evaluator);
            wrappedViewProviders = new o.outputAst.WrappedNodeExpr(this.annotateForClosureCompiler
                ? wrapFunctionExpressionsInParens(viewProviders)
                : viewProviders);
        }
        if (component.has('providers')) {
            providersRequiringFactory = resolveProvidersRequiringFactory(component.get('providers'), this.reflector, this.evaluator);
        }
        let resolvedImports = null;
        let resolvedDeferredImports = null;
        let rawImports = component.get('imports') ?? null;
        let rawDeferredImports = component.get('deferredImports') ?? null;
        if ((rawImports || rawDeferredImports) && !metadata.isStandalone) {
            if (diagnostics === undefined) {
                diagnostics = [];
            }
            const importsField = rawImports ? 'imports' : 'deferredImports';
            diagnostics.push(makeDiagnostic(exports.ErrorCode.COMPONENT_NOT_STANDALONE, component.get(importsField), `'${importsField}' is only valid on a component that is standalone.`, [
                makeRelatedInformation(node.name, `Did you forget to add 'standalone: true' to this @Component?`),
            ]));
            // Poison the component so that we don't spam further template type-checking errors that
            // result from misconfigured imports.
            isPoisoned = true;
        }
        else if (this.compilationMode !== exports.CompilationMode.LOCAL &&
            (rawImports || rawDeferredImports)) {
            const importResolvers = combineResolvers([
                createModuleWithProvidersResolver(this.reflector, this.isCore),
                createForwardRefResolver(this.isCore),
            ]);
            const importDiagnostics = [];
            if (rawImports) {
                const expr = rawImports;
                const imported = this.evaluator.evaluate(expr, importResolvers);
                const { imports: flattened, diagnostics } = validateAndFlattenComponentImports(imported, expr, false /* isDeferred */);
                importDiagnostics.push(...diagnostics);
                resolvedImports = flattened;
                rawImports = expr;
            }
            if (rawDeferredImports) {
                const expr = rawDeferredImports;
                const imported = this.evaluator.evaluate(expr, importResolvers);
                const { imports: flattened, diagnostics } = validateAndFlattenComponentImports(imported, expr, true /* isDeferred */);
                importDiagnostics.push(...diagnostics);
                resolvedDeferredImports = flattened;
                rawDeferredImports = expr;
            }
            if (importDiagnostics.length > 0) {
                isPoisoned = true;
                if (diagnostics === undefined) {
                    diagnostics = [];
                }
                diagnostics.push(...importDiagnostics);
            }
        }
        let schemas = null;
        if (component.has('schemas') && !metadata.isStandalone) {
            if (diagnostics === undefined) {
                diagnostics = [];
            }
            diagnostics.push(makeDiagnostic(exports.ErrorCode.COMPONENT_NOT_STANDALONE, component.get('schemas'), `'schemas' is only valid on a component that is standalone.`));
        }
        else if (this.compilationMode !== exports.CompilationMode.LOCAL && component.has('schemas')) {
            schemas = extractSchemas(component.get('schemas'), this.evaluator, 'Component');
        }
        else if (metadata.isStandalone) {
            schemas = [];
        }
        // Parse the template.
        // If a preanalyze phase was executed, the template may already exist in parsed form, so check
        // the preanalyzeTemplateCache.
        // Extract a closure of the template parsing code so that it can be reparsed with different
        // options if needed, like in the indexing pipeline.
        let template;
        if (this.preanalyzeTemplateCache.has(node)) {
            // The template was parsed in preanalyze. Use it and delete it to save memory.
            const preanalyzed = this.preanalyzeTemplateCache.get(node);
            this.preanalyzeTemplateCache.delete(node);
            template = preanalyzed;
        }
        else {
            try {
                const templateDecl = parseTemplateDeclaration(node, decorator, component, containingFile, this.evaluator, this.depTracker, this.resourceLoader, this.defaultPreserveWhitespaces);
                template = extractTemplate(node, templateDecl, this.evaluator, this.depTracker, this.resourceLoader, {
                    enableI18nLegacyMessageIdFormat: this.enableI18nLegacyMessageIdFormat,
                    i18nNormalizeLineEndingsInICUs: this.i18nNormalizeLineEndingsInICUs,
                    usePoisonedData: this.usePoisonedData,
                    enableBlockSyntax: this.enableBlockSyntax,
                    enableLetSyntax: this.enableLetSyntax,
                    enableSelectorless: this.enableSelectorless,
                    preserveSignificantWhitespace: this.i18nPreserveSignificantWhitespace,
                }, this.compilationMode);
                if (this.compilationMode === exports.CompilationMode.LOCAL &&
                    template.errors &&
                    template.errors.length > 0) {
                    // Template errors are handled at the type check phase. But we skip this phase in local
                    // compilation mode. As a result we need to handle the errors now and add them to the diagnostics.
                    if (diagnostics === undefined) {
                        diagnostics = [];
                    }
                    diagnostics.push(...getTemplateDiagnostics(template.errors, 
                    // Type check ID is required as part of the ype check, mainly for mapping the
                    // diagnostic back to its source. But here we are generating the diagnostic outside
                    // of the type check context, and so we skip the template ID.
                    '', template.sourceMapping));
                }
            }
            catch (e) {
                if (e instanceof FatalDiagnosticError) {
                    diagnostics ??= [];
                    diagnostics.push(e.toDiagnostic());
                    isPoisoned = true;
                    // Create an empty template for the missing/invalid template.
                    // A build will still fail in this case. However, for the language service,
                    // this allows the component to exist in the compiler registry and prevents
                    // cascading diagnostics within an IDE due to "missing" components. The
                    // originating template related errors will still be reported in the IDE.
                    template = createEmptyTemplate(node, component, containingFile);
                }
                else {
                    throw e;
                }
            }
        }
        if (component.has('animations')) {
            const { hasAnimations } = analyzeTemplateForAnimations(template.nodes);
            if (hasAnimations) {
                if (diagnostics === undefined) {
                    diagnostics = [];
                }
                diagnostics.push(makeDiagnostic(exports.ErrorCode.COMPONENT_ANIMATIONS_CONFLICT, component.get('animations'), `A component cannot have both the '@Component.animations' property (legacy animations) and use 'animate.enter' or 'animate.leave' in the template.`));
                isPoisoned = true;
            }
        }
        const templateResource = template.declaration.isInline
            ? { path: null, node: component.get('template') }
            : {
                path: absoluteFrom(template.declaration.resolvedTemplateUrl),
                node: template.sourceMapping.node,
            };
        const relativeTemplatePath = getProjectRelativePath(templateResource.path ?? ts.getOriginalNode(node).getSourceFile().fileName, this.rootDirs, this.compilerHost);
        let selectorlessEnabled = false;
        let localReferencedSymbols = null;
        if (this.enableSelectorless) {
            const templateAnalysis = analyzeTemplateForSelectorless(template.nodes);
            selectorlessEnabled = templateAnalysis.isSelectorless;
            localReferencedSymbols = templateAnalysis.localReferencedSymbols;
        }
        if (selectorlessEnabled) {
            if (!metadata.isStandalone) {
                isPoisoned = true;
                diagnostics ??= [];
                diagnostics.push(makeDiagnostic(exports.ErrorCode.COMPONENT_NOT_STANDALONE, component.get('standalone') || node.name, `Cannot use selectorless with a component that is not standalone`));
            }
            else if (rawImports || rawDeferredImports) {
                isPoisoned = true;
                diagnostics ??= [];
                diagnostics.push(makeDiagnostic(exports.ErrorCode.UNSUPPORTED_SELECTORLESS_COMPONENT_FIELD, (rawImports || rawDeferredImports), `Cannot use the "${rawImports === null ? 'deferredImports' : 'imports'}" field in a selectorless component`));
            }
        }
        // Figure out the set of styles. The ordering here is important: external resources (styleUrls)
        // precede inline styles, and styles defined in the template override styles defined in the
        // component.
        let styles = [];
        const externalStyles = [];
        const hostBindingResources = extractHostBindingResources(directiveResult.hostBindingNodes);
        const styleResources = extractInlineStyleResources(component);
        const styleUrls = [
            ...extractComponentStyleUrls(this.evaluator, component),
            ..._extractTemplateStyleUrls(template),
        ];
        for (const styleUrl of styleUrls) {
            try {
                const resourceUrl = this.resourceLoader.resolve(styleUrl.url, containingFile);
                if (this.externalRuntimeStyles) {
                    // External runtime styles are not considered disk-based and may not actually exist on disk
                    externalStyles.push(resourceUrl);
                    continue;
                }
                if (styleUrl.source === 2 /* ResourceTypeForDiagnostics.StylesheetFromDecorator */ &&
                    ts.isStringLiteralLike(styleUrl.expression)) {
                    // Only string literal values from the decorator are considered style resources
                    styleResources.add({
                        path: absoluteFrom(resourceUrl),
                        node: styleUrl.expression,
                    });
                }
                const resourceStr = this.resourceLoader.load(resourceUrl);
                styles.push(resourceStr);
                if (this.depTracker !== null) {
                    this.depTracker.addResourceDependency(node.getSourceFile(), absoluteFrom(resourceUrl));
                }
            }
            catch {
                if (this.depTracker !== null) {
                    // The analysis of this file cannot be re-used if one of the style URLs could
                    // not be resolved or loaded. Future builds should re-analyze and re-attempt
                    // resolution/loading.
                    this.depTracker.recordDependencyAnalysisFailure(node.getSourceFile());
                }
                if (diagnostics === undefined) {
                    diagnostics = [];
                }
                const resourceType = styleUrl.source === 2 /* ResourceTypeForDiagnostics.StylesheetFromDecorator */
                    ? 2 /* ResourceTypeForDiagnostics.StylesheetFromDecorator */
                    : 1 /* ResourceTypeForDiagnostics.StylesheetFromTemplate */;
                diagnostics.push(makeResourceNotFoundError(styleUrl.url, styleUrl.expression, resourceType).toDiagnostic());
            }
        }
        if ((encapsulation === o.ViewEncapsulation.ShadowDom ||
            encapsulation === o.ViewEncapsulation.IsolatedShadowDom) &&
            metadata.selector !== null) {
            const selectorError = checkCustomElementSelectorForErrors(metadata.selector);
            if (selectorError !== null) {
                if (diagnostics === undefined) {
                    diagnostics = [];
                }
                diagnostics.push(makeDiagnostic(exports.ErrorCode.COMPONENT_INVALID_SHADOW_DOM_SELECTOR, component.get('selector'), selectorError));
            }
        }
        // If inline styles were preprocessed use those
        let inlineStyles = null;
        if (this.preanalyzeStylesCache.has(node)) {
            inlineStyles = this.preanalyzeStylesCache.get(node);
            this.preanalyzeStylesCache.delete(node);
            if (inlineStyles?.length) {
                if (this.externalRuntimeStyles) {
                    // When external runtime styles is enabled, a list of URLs is provided
                    externalStyles.push(...inlineStyles);
                }
                else {
                    styles.push(...inlineStyles);
                }
            }
        }
        else {
            // Preprocessing is only supported asynchronously
            // If no style cache entry is present asynchronous preanalyze was not executed.
            // This protects against accidental differences in resource contents when preanalysis
            // is not used with a provided transformResource hook on the ResourceHost.
            if (this.resourceLoader.canPreprocess) {
                throw new Error('Inline resource processing requires asynchronous preanalyze.');
            }
            if (component.has('styles')) {
                const litStyles = parseDirectiveStyles(component, this.evaluator, this.compilationMode);
                if (litStyles !== null) {
                    inlineStyles = [...litStyles];
                    styles.push(...litStyles);
                }
            }
            if (template.styles.length > 0) {
                styles.push(...template.styles);
            }
        }
        // Collect all explicitly deferred symbols from the `@Component.deferredImports` field
        // (if it exists) and populate the `DeferredSymbolTracker` state. These operations are safe
        // for the local compilation mode, since they don't require accessing/resolving symbols
        // outside of the current source file.
        let explicitlyDeferredTypes = null;
        if (metadata.isStandalone && rawDeferredImports !== null) {
            const deferredTypes = this.collectExplicitlyDeferredSymbols(rawDeferredImports);
            for (const [deferredType, importDetails] of deferredTypes) {
                explicitlyDeferredTypes ??= [];
                explicitlyDeferredTypes.push({
                    symbolName: importDetails.name,
                    importPath: importDetails.from,
                    isDefaultImport: isDefaultImport(importDetails.node),
                });
                this.deferredSymbolTracker.markAsDeferrableCandidate(deferredType, importDetails.node, node, true /* isExplicitlyDeferred */);
            }
        }
        const output = {
            analysis: {
                baseClass: readBaseClass$1(node, this.reflector, this.evaluator),
                inputs,
                inputFieldNamesFromMetadataArray: directiveResult.inputFieldNamesFromMetadataArray,
                outputs,
                hostDirectives,
                rawHostDirectives,
                selectorlessEnabled,
                localReferencedSymbols,
                meta: {
                    ...metadata,
                    template,
                    encapsulation,
                    changeDetection,
                    styles,
                    externalStyles,
                    // These will be replaced during the compilation step, after all `NgModule`s have been
                    // analyzed and the full compilation scope for the component can be realized.
                    animations,
                    viewProviders: wrappedViewProviders,
                    i18nUseExternalIds: this.i18nUseExternalIds,
                    relativeContextFilePath,
                    rawImports: rawImports !== null ? new o.outputAst.WrappedNodeExpr(rawImports) : undefined,
                    relativeTemplatePath,
                },
                typeCheckMeta: extractDirectiveTypeCheckMeta(node, inputs, this.reflector),
                classMetadata: this.includeClassMetadata
                    ? extractClassMetadata(node, this.reflector, this.isCore, this.annotateForClosureCompiler, (dec) => transformDecoratorResources(dec, component, styles, template), this.undecoratedMetadataExtractor)
                    : null,
                classDebugInfo: extractClassDebugInfo(node, this.reflector, this.compilerHost, this.rootDirs, 
                /* forbidOrphanRenderering */ this.forbidOrphanRendering),
                template,
                providersRequiringFactory,
                viewProvidersRequiringFactory,
                inlineStyles,
                styleUrls,
                resources: {
                    styles: styleResources,
                    template: templateResource,
                    hostBindings: hostBindingResources,
                },
                isPoisoned,
                legacyAnimationTriggerNames: legacyAnimationTriggerNames,
                rawImports,
                resolvedImports,
                rawDeferredImports,
                resolvedDeferredImports,
                explicitlyDeferredTypes,
                schemas,
                decorator: decorator?.node ?? null,
                hostBindingNodes: directiveResult.hostBindingNodes,
            },
            diagnostics,
        };
        return output;
    }
    symbol(node, analysis) {
        const typeParameters = extractSemanticTypeParameters(node);
        return new ComponentSymbol(node, analysis.meta.selector, analysis.inputs, analysis.outputs, analysis.meta.exportAs, analysis.typeCheckMeta, typeParameters);
    }
    register(node, analysis) {
        // Register this component's information with the `MetadataRegistry`. This ensures that
        // the information about the component is available during the compile() phase.
        const ref = new Reference(node);
        this.metaRegistry.registerDirectiveMetadata({
            kind: MetaKind.Directive,
            matchSource: MatchSource.Selector,
            ref,
            name: node.name.text,
            selector: analysis.meta.selector,
            exportAs: analysis.meta.exportAs,
            inputs: analysis.inputs,
            inputFieldNamesFromMetadataArray: analysis.inputFieldNamesFromMetadataArray,
            outputs: analysis.outputs,
            queries: analysis.meta.queries.map((query) => query.propertyName),
            isComponent: true,
            baseClass: analysis.baseClass,
            hostDirectives: analysis.hostDirectives,
            ...analysis.typeCheckMeta,
            isPoisoned: analysis.isPoisoned,
            isStructural: false,
            isStandalone: analysis.meta.isStandalone,
            isSignal: analysis.meta.isSignal,
            imports: analysis.resolvedImports,
            rawImports: analysis.rawImports,
            deferredImports: analysis.resolvedDeferredImports,
            animationTriggerNames: analysis.legacyAnimationTriggerNames,
            schemas: analysis.schemas,
            decorator: analysis.decorator,
            assumedToExportProviders: false,
            ngContentSelectors: analysis.template.ngContentSelectors,
            preserveWhitespaces: analysis.template.preserveWhitespaces ?? false,
            isExplicitlyDeferred: false,
            selectorlessEnabled: analysis.selectorlessEnabled,
            localReferencedSymbols: analysis.localReferencedSymbols,
        });
        this.resourceRegistry.registerResources(analysis.resources, node);
        this.injectableRegistry.registerInjectable(node, {
            ctorDeps: analysis.meta.deps,
        });
    }
    index(context, node, analysis) {
        if (analysis.isPoisoned && !this.usePoisonedData) {
            return null;
        }
        const scope = this.scopeReader.getScopeForComponent(node);
        const selector = analysis.meta.selector;
        let matcher = null;
        if (scope !== null) {
            const isPoisoned = scope.kind === ComponentScopeKind.NgModule
                ? scope.compilation.isPoisoned
                : scope.isPoisoned;
            if ((isPoisoned || (scope.kind === ComponentScopeKind.NgModule && scope.exported.isPoisoned)) &&
                !this.usePoisonedData) {
                // Don't bother indexing components which had erroneous scopes, unless specifically
                // requested.
                return null;
            }
            matcher = createMatcherFromScope(scope, this.hostDirectivesResolver);
        }
        const binder = new o.R3TargetBinder(matcher);
        const boundTemplate = binder.bind({ template: analysis.template.diagNodes });
        context.addComponent({
            declaration: node,
            selector,
            boundTemplate,
            templateMeta: {
                isInline: analysis.template.declaration.isInline,
                file: analysis.template.file,
            },
        });
        return null;
    }
    typeCheck(ctx, node, meta) {
        if (!ts.isClassDeclaration(node) || (meta.isPoisoned && !this.usePoisonedData)) {
            return;
        }
        const ref = new Reference(node);
        const scope = this.typeCheckScopeRegistry.getTypeCheckScope(ref);
        if (scope.isPoisoned && !this.usePoisonedData) {
            // Don't type-check components that had errors in their scopes, unless requested.
            return;
        }
        const binder = new o.R3TargetBinder(scope.matcher);
        const templateContext = {
            nodes: meta.template.diagNodes,
            pipes: scope.pipes,
            sourceMapping: meta.template.sourceMapping,
            file: meta.template.file,
            parseErrors: meta.template.errors,
            preserveWhitespaces: meta.meta.template.preserveWhitespaces ?? false,
        };
        const hostElement = this.typeCheckHostBindings
            ? createHostElement('component', meta.meta.selector, node, meta.hostBindingNodes.literal, meta.hostBindingNodes.bindingDecorators, meta.hostBindingNodes.listenerDecorators)
            : null;
        const hostBindingsContext = hostElement === null || scope.directivesOnHost === null
            ? null
            : {
                node: hostElement,
                directives: scope.directivesOnHost,
                sourceMapping: { type: 'direct', node },
            };
        ctx.addDirective(ref, binder, scope.schemas, templateContext, hostBindingsContext, meta.meta.isStandalone);
    }
    extendedTemplateCheck(component, extendedTemplateChecker) {
        return extendedTemplateChecker.getDiagnosticsForComponent(component);
    }
    templateSemanticsCheck(component, templateSemanticsChecker) {
        return templateSemanticsChecker.getDiagnosticsForComponent(component);
    }
    resolve(node, analysis, symbol) {
        const metadata = analysis.meta;
        const diagnostics = [];
        const context = getSourceFile(node);
        // Check if there are some import declarations that contain symbols used within
        // the `@Component.deferredImports` field, but those imports contain other symbols
        // and thus the declaration can not be removed. This diagnostics is shared between local and
        // global compilation modes.
        const nonRemovableImports = this.deferredSymbolTracker.getNonRemovableDeferredImports(context, node);
        if (nonRemovableImports.length > 0) {
            for (const importDecl of nonRemovableImports) {
                const diagnostic = makeDiagnostic(exports.ErrorCode.DEFERRED_DEPENDENCY_IMPORTED_EAGERLY, importDecl, `This import contains symbols that are used both inside and outside of the ` +
                    `\`@Component.deferredImports\` fields in the file. This renders all these ` +
                    `defer imports useless as this import remains and its module is eagerly loaded. ` +
                    `To fix this, make sure that all symbols from the import are *only* used within ` +
                    `\`@Component.deferredImports\` arrays and there are no other references to those ` +
                    `symbols present in this file.`);
                diagnostics.push(diagnostic);
            }
            return { diagnostics };
        }
        let data;
        if (this.compilationMode === exports.CompilationMode.LOCAL) {
            // Initial value in local compilation mode.
            data = {
                declarations: EMPTY_ARRAY,
                declarationListEmitMode: !analysis.meta.isStandalone || analysis.rawImports !== null
                    ? 3 /* DeclarationListEmitMode.RuntimeResolved */
                    : 0 /* DeclarationListEmitMode.Direct */,
                deferPerBlockDependencies: this.locateDeferBlocksWithoutScope(analysis.template),
                deferBlockDepsEmitMode: 1 /* DeferBlockDepsEmitMode.PerComponent */,
                deferrableDeclToImportDecl: new Map(),
                deferPerComponentDependencies: analysis.explicitlyDeferredTypes ?? [],
                hasDirectiveDependencies: true,
            };
            if (this.localCompilationExtraImportsTracker === null) {
                // In local compilation mode the resolve phase is only needed for generating extra imports.
                // Otherwise we can skip it.
                return { data };
            }
        }
        else {
            // Initial value in global compilation mode.
            data = {
                declarations: EMPTY_ARRAY,
                declarationListEmitMode: 0 /* DeclarationListEmitMode.Direct */,
                deferPerBlockDependencies: new Map(),
                deferBlockDepsEmitMode: 0 /* DeferBlockDepsEmitMode.PerBlock */,
                deferrableDeclToImportDecl: new Map(),
                deferPerComponentDependencies: [],
                hasDirectiveDependencies: true,
            };
        }
        if (this.semanticDepGraphUpdater !== null && analysis.baseClass instanceof Reference) {
            symbol.baseClass = this.semanticDepGraphUpdater.getSymbol(analysis.baseClass.node);
        }
        if (analysis.isPoisoned && !this.usePoisonedData) {
            return {};
        }
        const scope = this.scopeReader.getScopeForComponent(node);
        if (scope === null) {
            // If there is no scope, we can still use the binder to retrieve *some* information about the
            // deferred blocks.
            data.deferPerBlockDependencies = this.locateDeferBlocksWithoutScope(metadata.template);
        }
        else {
            const { eagerlyUsed, deferBlocks, allDependencies, wholeTemplateUsed, pipes } = this.resolveComponentDependencies(node, context, analysis, scope, metadata, diagnostics);
            const declarations = this.componentDependenciesToDeclarations(node, context, allDependencies, wholeTemplateUsed, pipes);
            if (this.semanticDepGraphUpdater !== null) {
                const getSemanticReference = (decl) => this.semanticDepGraphUpdater.getSemanticReference(decl.ref.node, decl.type);
                symbol.usedDirectives = Array.from(declarations.values())
                    .filter(isUsedDirective)
                    .map(getSemanticReference);
                symbol.usedPipes = Array.from(declarations.values())
                    .filter(isUsedPipe)
                    .map(getSemanticReference);
            }
            // Process information related to defer blocks
            if (this.compilationMode !== exports.CompilationMode.LOCAL) {
                this.resolveDeferBlocks(node, scope, deferBlocks, declarations, data, analysis, eagerlyUsed);
                data.hasDirectiveDependencies =
                    !analysis.meta.isStandalone ||
                        allDependencies.some(({ kind, ref }) => {
                            // Note that `allDependencies` includes ones that aren't
                            // used in the template so we need to filter them out.
                            return ((kind === MetaKind.Directive || kind === MetaKind.NgModule) &&
                                wholeTemplateUsed.has(ref.node));
                        });
            }
            else {
                // We don't have the ability to inspect the component's dependencies in local
                // compilation mode. Assume that it always has directive dependencies in such cases.
                data.hasDirectiveDependencies = true;
            }
            this.handleDependencyCycles(node, context, scope, data, analysis, metadata, declarations, eagerlyUsed, symbol);
        }
        // Run diagnostics only in global mode.
        if (this.compilationMode !== exports.CompilationMode.LOCAL) {
            const nonLocalDiagnostics = this.getNonLocalDiagnostics(node, analysis);
            if (nonLocalDiagnostics !== null) {
                diagnostics.push(...nonLocalDiagnostics);
            }
        }
        if (diagnostics.length > 0) {
            return { diagnostics };
        }
        return { data };
    }
    xi18n(ctx, node, analysis) {
        ctx.updateFromTemplate(analysis.template.content, analysis.template.declaration.resolvedTemplateUrl);
    }
    updateResources(node, analysis) {
        const containingFile = node.getSourceFile().fileName;
        // If the template is external, re-parse it.
        const templateDecl = analysis.template.declaration;
        if (!templateDecl.isInline) {
            analysis.template = extractTemplate(node, templateDecl, this.evaluator, this.depTracker, this.resourceLoader, this.extractTemplateOptions, this.compilationMode);
        }
        // Update any external stylesheets and rebuild the combined 'styles' list.
        // TODO(alxhub): write tests for styles when the primary compiler uses the updateResources
        // path
        let styles = [];
        if (analysis.styleUrls !== null) {
            for (const styleUrl of analysis.styleUrls) {
                try {
                    const resolvedStyleUrl = this.resourceLoader.resolve(styleUrl.url, containingFile);
                    const styleText = this.resourceLoader.load(resolvedStyleUrl);
                    styles.push(styleText);
                }
                catch (e) {
                    // Resource resolve failures should already be in the diagnostics list from the analyze
                    // stage. We do not need to do anything with them when updating resources.
                }
            }
        }
        if (analysis.inlineStyles !== null) {
            for (const styleText of analysis.inlineStyles) {
                styles.push(styleText);
            }
        }
        for (const styleText of analysis.template.styles) {
            styles.push(styleText);
        }
        analysis.meta.styles = styles.filter((s) => s.trim().length > 0);
    }
    compileFull(node, analysis, resolution, pool) {
        if (analysis.template.errors !== null && analysis.template.errors.length > 0) {
            return [];
        }
        const perComponentDeferredDeps = this.canDeferDeps
            ? this.resolveAllDeferredDependencies(resolution)
            : null;
        const defer = this.compileDeferBlocks(resolution);
        const meta = {
            ...analysis.meta,
            ...resolution,
            defer,
        };
        const fac = compileNgFactoryDefField(toFactoryMetadata(meta, o.FactoryTarget.Component));
        if (perComponentDeferredDeps !== null) {
            removeDeferrableTypesFromComponentDecorator(analysis, perComponentDeferredDeps);
        }
        const def = o.compileComponentFromMetadata(meta, pool, this.getNewBindingParser());
        const inputTransformFields = compileInputTransformFields(analysis.inputs);
        const classMetadata = analysis.classMetadata !== null
            ? o.compileComponentClassMetadata(analysis.classMetadata, perComponentDeferredDeps).toStmt()
            : null;
        const debugInfo = analysis.classDebugInfo !== null
            ? o.compileClassDebugInfo(analysis.classDebugInfo).toStmt()
            : null;
        const hmrMeta = this.enableHmr
            ? extractHmrMetatadata(node, this.reflector, this.evaluator, this.compilerHost, this.rootDirs, def, fac, defer, classMetadata, debugInfo)
            : null;
        const hmrInitializer = hmrMeta ? o.compileHmrInitializer(hmrMeta).toStmt() : null;
        const deferrableImports = this.canDeferDeps
            ? this.deferredSymbolTracker.getDeferrableImportDecls()
            : null;
        return compileResults(fac, def, classMetadata, 'Éµcmp', inputTransformFields, deferrableImports, debugInfo, hmrInitializer);
    }
    compilePartial(node, analysis, resolution) {
        if (analysis.template.errors !== null && analysis.template.errors.length > 0) {
            return [];
        }
        const templateInfo = {
            content: analysis.template.content,
            sourceUrl: analysis.template.declaration.resolvedTemplateUrl,
            isInline: analysis.template.declaration.isInline,
            inlineTemplateLiteralExpression: analysis.template.sourceMapping.type === 'direct'
                ? new o.outputAst.WrappedNodeExpr(analysis.template.sourceMapping.node)
                : null,
        };
        const perComponentDeferredDeps = this.canDeferDeps
            ? this.resolveAllDeferredDependencies(resolution)
            : null;
        const defer = this.compileDeferBlocks(resolution);
        const meta = {
            ...analysis.meta,
            ...resolution,
            defer,
        };
        const fac = compileDeclareFactory(toFactoryMetadata(meta, o.FactoryTarget.Component));
        const inputTransformFields = compileInputTransformFields(analysis.inputs);
        const def = o.compileDeclareComponentFromMetadata(meta, analysis.template, templateInfo);
        const classMetadata = analysis.classMetadata !== null
            ? o.compileComponentDeclareClassMetadata(analysis.classMetadata, perComponentDeferredDeps).toStmt()
            : null;
        const hmrMeta = this.enableHmr
            ? extractHmrMetatadata(node, this.reflector, this.evaluator, this.compilerHost, this.rootDirs, def, fac, defer, classMetadata, null)
            : null;
        const hmrInitializer = hmrMeta ? o.compileHmrInitializer(hmrMeta).toStmt() : null;
        const deferrableImports = this.canDeferDeps
            ? this.deferredSymbolTracker.getDeferrableImportDecls()
            : null;
        return compileResults(fac, def, classMetadata, 'Éµcmp', inputTransformFields, deferrableImports, null, hmrInitializer);
    }
    compileLocal(node, analysis, resolution, pool) {
        // In the local compilation mode we can only rely on the information available
        // within the `@Component.deferredImports` array, because in this mode compiler
        // doesn't have information on which dependencies belong to which defer blocks.
        const deferrableTypes = this.canDeferDeps ? analysis.explicitlyDeferredTypes : null;
        const defer = this.compileDeferBlocks(resolution);
        const meta = {
            ...analysis.meta,
            ...resolution,
            defer,
        };
        if (deferrableTypes !== null) {
            removeDeferrableTypesFromComponentDecorator(analysis, deferrableTypes);
        }
        const fac = compileNgFactoryDefField(toFactoryMetadata(meta, o.FactoryTarget.Component));
        const def = o.compileComponentFromMetadata(meta, pool, this.getNewBindingParser());
        const inputTransformFields = compileInputTransformFields(analysis.inputs);
        const classMetadata = analysis.classMetadata !== null
            ? o.compileComponentClassMetadata(analysis.classMetadata, deferrableTypes).toStmt()
            : null;
        const debugInfo = analysis.classDebugInfo !== null
            ? o.compileClassDebugInfo(analysis.classDebugInfo).toStmt()
            : null;
        const hmrMeta = this.enableHmr
            ? extractHmrMetatadata(node, this.reflector, this.evaluator, this.compilerHost, this.rootDirs, def, fac, defer, classMetadata, debugInfo)
            : null;
        const hmrInitializer = hmrMeta ? o.compileHmrInitializer(hmrMeta).toStmt() : null;
        const deferrableImports = this.canDeferDeps
            ? this.deferredSymbolTracker.getDeferrableImportDecls()
            : null;
        return compileResults(fac, def, classMetadata, 'Éµcmp', inputTransformFields, deferrableImports, debugInfo, hmrInitializer);
    }
    compileHmrUpdateDeclaration(node, analysis, resolution) {
        if (analysis.template.errors !== null && analysis.template.errors.length > 0) {
            return null;
        }
        // Create a brand-new constant pool since there shouldn't be any constant sharing.
        const pool = new o.ConstantPool();
        const defer = this.compileDeferBlocks(resolution);
        const meta = {
            ...analysis.meta,
            ...resolution,
            defer,
        };
        const fac = compileNgFactoryDefField(toFactoryMetadata(meta, o.FactoryTarget.Component));
        const def = o.compileComponentFromMetadata(meta, pool, this.getNewBindingParser());
        const classMetadata = analysis.classMetadata !== null
            ? o.compileComponentClassMetadata(analysis.classMetadata, null).toStmt()
            : null;
        const debugInfo = analysis.classDebugInfo !== null
            ? o.compileClassDebugInfo(analysis.classDebugInfo).toStmt()
            : null;
        const hmrMeta = this.enableHmr
            ? extractHmrMetatadata(node, this.reflector, this.evaluator, this.compilerHost, this.rootDirs, def, fac, defer, classMetadata, debugInfo)
            : null;
        const res = compileResults(fac, def, classMetadata, 'Éµcmp', null, null, debugInfo, null);
        return hmrMeta === null || res.length === 0
            ? null
            : getHmrUpdateDeclaration(res, pool.statements, hmrMeta, node);
    }
    /**
     * Determines the dependencies of a component and
     * categorizes them based on how they were introduced.
     */
    resolveComponentDependencies(node, context, analysis, scope, metadata, diagnostics) {
        // Replace the empty components and directives from the analyze() step with a fully expanded
        // scope. This is possible now because during resolve() the whole compilation unit has been
        // fully analyzed.
        //
        // First it needs to be determined if actually importing the directives/pipes used in the
        // template would create a cycle. Currently ngtsc refuses to generate cycles, so an option
        // known as "remote scoping" is used if a cycle would be created. In remote scoping, the
        // module file sets the directives/pipes on the Éµcmp of the component, without
        // requiring new imports (but also in a way that breaks tree shaking).
        //
        // Determining this is challenging, because the TemplateDefinitionBuilder is responsible for
        // matching directives and pipes in the template; however, that doesn't run until the actual
        // compile() step. It's not possible to run template compilation sooner as it requires the
        // ConstantPool for the overall file being compiled (which isn't available until the
        // transform step).
        //
        // Instead, directives/pipes are matched independently here, using the R3TargetBinder. This
        // is an alternative implementation of template matching which is used for template
        // type-checking and will eventually replace matching in the TemplateDefinitionBuilder.
        const isModuleScope = scope.kind === ComponentScopeKind.NgModule;
        const isSelectorlessScope = scope.kind === ComponentScopeKind.Selectorless;
        const pipes = new Map();
        // Dependencies from the `@Component.deferredImports` field.
        const explicitlyDeferredDependencies = scope.kind === ComponentScopeKind.Standalone ? scope.deferredDependencies : null;
        const dependencies = [];
        if (isSelectorlessScope) {
            for (const [localName, dep] of scope.dependencies) {
                // In selectorless the pipes are referred to by their local name.
                if (dep.kind === MetaKind.Pipe) {
                    pipes.set(localName, dep);
                }
                dependencies.push(dep);
            }
        }
        else {
            const scopeDeps = isModuleScope ? scope.compilation.dependencies : scope.dependencies;
            for (const dep of scopeDeps) {
                // Outside of selectorless the pipes are referred to by their defined name.
                if (dep.kind === MetaKind.Pipe && dep.name !== null) {
                    pipes.set(dep.name, dep);
                }
                dependencies.push(dep);
            }
        }
        // Mark the component is an NgModule-based component with its NgModule in a different file
        // then mark this file for extra import generation
        if (isModuleScope && context.fileName !== getSourceFile(scope.ngModule).fileName) {
            this.localCompilationExtraImportsTracker?.markFileForExtraImportGeneration(context);
        }
        // Make sure that `@Component.imports` and `@Component.deferredImports` do not have
        // the same dependencies.
        if (!isSelectorlessScope &&
            metadata.isStandalone &&
            analysis.rawDeferredImports !== null &&
            explicitlyDeferredDependencies !== null &&
            explicitlyDeferredDependencies.length > 0) {
            const diagnostic = validateNoImportOverlap(dependencies, explicitlyDeferredDependencies, analysis.rawDeferredImports);
            if (diagnostic !== null) {
                diagnostics.push(diagnostic);
            }
        }
        // Set up the R3TargetBinder.
        const binder = new o.R3TargetBinder(createMatcherFromScope(scope, this.hostDirectivesResolver));
        let allDependencies = dependencies;
        let deferBlockBinder = binder;
        // If there are any explicitly deferred dependencies (via `@Component.deferredImports`),
        // re-compute the list of dependencies and create a new binder for defer blocks. This
        // is because we have deferred dependencies that are not in the standard imports list
        // and need to be referenced later when determining what dependencies need to be in a
        // defer function / instruction call. Otherwise they end up treated as a standard
        // import, which is wrong.
        if (explicitlyDeferredDependencies !== null && explicitlyDeferredDependencies.length > 0) {
            allDependencies = [...explicitlyDeferredDependencies, ...dependencies];
            const deferBlockMatcher = new o.SelectorMatcher();
            for (const dep of allDependencies) {
                if (dep.kind === MetaKind.Pipe && dep.name !== null) {
                    pipes.set(dep.name, dep);
                }
                else if (dep.kind === MetaKind.Directive && dep.selector !== null) {
                    deferBlockMatcher.addSelectables(o.CssSelector.parse(dep.selector), [dep]);
                }
            }
            deferBlockBinder = new o.R3TargetBinder(deferBlockMatcher);
        }
        // Next, the component template AST is bound using the R3TargetBinder. This produces a
        // BoundTarget, which is similar to a ts.TypeChecker.
        const bound = binder.bind({ template: metadata.template.nodes });
        // Find all defer blocks used in the template and for each block
        // bind its own scope.
        const deferBlocks = new Map();
        for (const deferBlock of bound.getDeferBlocks()) {
            deferBlocks.set(deferBlock, deferBlockBinder.bind({ template: deferBlock.children }));
        }
        // Register all Directives and Pipes used at the top level (outside
        // of any defer blocks), which would be eagerly referenced.
        const eagerlyUsed = new Set();
        if (this.enableHmr) {
            // In HMR we need to preserve all the dependencies, because they have to remain consistent
            // with the initially-generated code no matter what the template looks like.
            for (const dep of dependencies) {
                if (dep.ref.node !== node) {
                    eagerlyUsed.add(dep.ref.node);
                }
                else {
                    const used = bound.getEagerlyUsedDirectives();
                    if (used.some((current) => current.ref.node === node)) {
                        eagerlyUsed.add(node);
                    }
                }
            }
        }
        else {
            for (const dir of bound.getEagerlyUsedDirectives()) {
                eagerlyUsed.add(dir.ref.node);
            }
            for (const name of bound.getEagerlyUsedPipes()) {
                if (pipes.has(name)) {
                    eagerlyUsed.add(pipes.get(name).ref.node);
                }
            }
        }
        // Set of Directives and Pipes used across the entire template,
        // including all defer blocks.
        const wholeTemplateUsed = new Set(eagerlyUsed);
        for (const bound of deferBlocks.values()) {
            for (const dir of bound.getUsedDirectives()) {
                wholeTemplateUsed.add(dir.ref.node);
            }
            for (const name of bound.getUsedPipes()) {
                if (!pipes.has(name)) {
                    continue;
                }
                wholeTemplateUsed.add(pipes.get(name).ref.node);
            }
        }
        return { allDependencies, eagerlyUsed, wholeTemplateUsed, deferBlocks, pipes };
    }
    /**
     * Converts component dependencies into declarations by
     * resolving their metadata and deduplicating them.
     */
    componentDependenciesToDeclarations(node, context, allDependencies, wholeTemplateUsed, pipes) {
        const declarations = new Map();
        // Transform the dependencies list, filtering out unused dependencies.
        for (const dep of allDependencies) {
            // Only emit references to each dependency once.
            if (declarations.has(dep.ref.node)) {
                continue;
            }
            switch (dep.kind) {
                case MetaKind.Directive:
                    if (!wholeTemplateUsed.has(dep.ref.node) || dep.matchSource !== MatchSource.Selector) {
                        continue;
                    }
                    const dirType = this.refEmitter.emit(dep.ref, context);
                    assertSuccessfulReferenceEmit(dirType, node.name, dep.isComponent ? 'component' : 'directive');
                    declarations.set(dep.ref.node, {
                        kind: o.R3TemplateDependencyKind.Directive,
                        ref: dep.ref,
                        type: dirType.expression,
                        importedFile: dirType.importedFile,
                        selector: dep.selector,
                        inputs: dep.inputs.propertyNames,
                        outputs: dep.outputs.propertyNames,
                        exportAs: dep.exportAs,
                        isComponent: dep.isComponent,
                    });
                    break;
                case MetaKind.NgModule:
                    const ngModuleType = this.refEmitter.emit(dep.ref, context);
                    assertSuccessfulReferenceEmit(ngModuleType, node.name, 'NgModule');
                    declarations.set(dep.ref.node, {
                        kind: o.R3TemplateDependencyKind.NgModule,
                        type: ngModuleType.expression,
                        importedFile: ngModuleType.importedFile,
                    });
                    break;
            }
        }
        for (const [localName, dep] of pipes) {
            if (!wholeTemplateUsed.has(dep.ref.node)) {
                continue;
            }
            const pipeType = this.refEmitter.emit(dep.ref, context);
            assertSuccessfulReferenceEmit(pipeType, node.name, 'pipe');
            declarations.set(dep.ref.node, {
                kind: o.R3TemplateDependencyKind.Pipe,
                type: pipeType.expression,
                // Use the local name for pipes to account for selectorless.
                name: localName,
                ref: dep.ref,
                importedFile: pipeType.importedFile,
            });
        }
        return declarations;
    }
    /** Handles any cycles in the dependencies of a component. */
    handleDependencyCycles(node, context, scope, data, analysis, metadata, declarations, eagerlyUsed, symbol) {
        const eagerDeclarations = Array.from(declarations.values()).filter((decl) => {
            return decl.kind === o.R3TemplateDependencyKind.NgModule || eagerlyUsed.has(decl.ref.node);
        });
        const cyclesFromDirectives = new Map();
        const cyclesFromPipes = new Map();
        // Scan through the directives/pipes actually used in the template and check whether any
        // import which needs to be generated would create a cycle. This check is skipped for
        // standalone components as the dependencies of a standalone component have already been
        // imported directly by the user, so Angular won't introduce any imports that aren't already
        // in the user's program.
        if (!metadata.isStandalone) {
            for (const usedDep of eagerDeclarations) {
                const cycle = this._checkForCyclicImport(usedDep.importedFile, usedDep.type, context);
                if (cycle !== null) {
                    switch (usedDep.kind) {
                        case o.R3TemplateDependencyKind.Directive:
                            cyclesFromDirectives.set(usedDep, cycle);
                            break;
                        case o.R3TemplateDependencyKind.Pipe:
                            cyclesFromPipes.set(usedDep, cycle);
                            break;
                    }
                }
            }
        }
        // Check whether any usages of standalone components in imports requires the dependencies
        // array to be wrapped in a closure. This check is technically a heuristic as there's no
        // direct way to check whether a `Reference` came from a `forwardRef`. Instead, we check if
        // the reference is `synthetic`, implying it came from _any_ foreign function resolver,
        // including the `forwardRef` resolver.
        const standaloneImportMayBeForwardDeclared = analysis.resolvedImports !== null && analysis.resolvedImports.some((ref) => ref.synthetic);
        const cycleDetected = cyclesFromDirectives.size !== 0 || cyclesFromPipes.size !== 0;
        if (!cycleDetected) {
            // No cycle was detected. Record the imports that need to be created in the cycle detector
            // so that future cyclic import checks consider their production.
            for (const { type, importedFile } of eagerDeclarations) {
                this.maybeRecordSyntheticImport(importedFile, type, context);
            }
            // Check whether the dependencies arrays in Éµcmp need to be wrapped in a closure.
            // This is required if any dependency reference is to a declaration in the same file
            // but declared after this component.
            const declarationIsForwardDeclared = eagerDeclarations.some((decl) => isExpressionForwardReference(decl.type, node.name, context));
            if (this.compilationMode !== exports.CompilationMode.LOCAL &&
                (declarationIsForwardDeclared || standaloneImportMayBeForwardDeclared)) {
                data.declarationListEmitMode = 1 /* DeclarationListEmitMode.Closure */;
            }
            data.declarations = eagerDeclarations;
            // Register extra local imports.
            if (this.compilationMode === exports.CompilationMode.LOCAL &&
                this.localCompilationExtraImportsTracker !== null) {
                // In global compilation mode `eagerDeclarations` contains "all" the component
                // dependencies, whose import statements will be added to the file. In local compilation
                // mode `eagerDeclarations` only includes the "local" dependencies, meaning those that are
                // declared inside this compilation unit.Here the import info of these local dependencies
                // are added to the tracker so that we can generate extra imports representing these local
                // dependencies. For non-local dependencies we use another technique of adding some
                // best-guess extra imports globally to all files using
                // `localCompilationExtraImportsTracker.addGlobalImportFromIdentifier`.
                for (const { type } of eagerDeclarations) {
                    if (type instanceof o.ExternalExpr && type.value.moduleName) {
                        this.localCompilationExtraImportsTracker.addImportForFile(context, type.value.moduleName);
                    }
                }
            }
        }
        else if (this.cycleHandlingStrategy === 0 /* CycleHandlingStrategy.UseRemoteScoping */) {
            // Declaring the directiveDefs/pipeDefs arrays directly would require imports that would
            // create a cycle. Instead, mark this component as requiring remote scoping, so that the
            // NgModule file will take care of setting the directives for the component.
            this.scopeRegistry.setComponentRemoteScope(node, eagerDeclarations.filter(isUsedDirective).map((dir) => dir.ref), eagerDeclarations.filter(isUsedPipe).map((pipe) => pipe.ref));
            symbol.isRemotelyScoped = true;
            // If a semantic graph is being tracked, record the fact that this component is remotely
            // scoped with the declaring NgModule symbol as the NgModule's emit becomes dependent on
            // the directive/pipe usages of this component.
            if (this.semanticDepGraphUpdater !== null &&
                scope.kind === ComponentScopeKind.NgModule &&
                scope.ngModule !== null) {
                const moduleSymbol = this.semanticDepGraphUpdater.getSymbol(scope.ngModule);
                if (!(moduleSymbol instanceof NgModuleSymbol)) {
                    throw new Error(`AssertionError: Expected ${scope.ngModule.name} to be an NgModuleSymbol.`);
                }
                moduleSymbol.addRemotelyScopedComponent(symbol, symbol.usedDirectives, symbol.usedPipes);
            }
        }
        else {
            // We are not able to handle this cycle so throw an error.
            const relatedMessages = [];
            for (const [dir, cycle] of cyclesFromDirectives) {
                relatedMessages.push(makeCyclicImportInfo(dir.ref, dir.isComponent ? 'component' : 'directive', cycle));
            }
            for (const [pipe, cycle] of cyclesFromPipes) {
                relatedMessages.push(makeCyclicImportInfo(pipe.ref, 'pipe', cycle));
            }
            throw new FatalDiagnosticError(exports.ErrorCode.IMPORT_CYCLE_DETECTED, node, 'One or more import cycles would need to be created to compile this component, ' +
                'which is not supported by the current compiler configuration.', relatedMessages);
        }
    }
    /** Produces diagnostics that require more than local information. */
    getNonLocalDiagnostics(node, analysis) {
        // We shouldn't be able to hit this, but add an assertion just in case the call site changes.
        if (this.compilationMode === exports.CompilationMode.LOCAL) {
            throw new Error('Method cannot be called in local compilation mode.');
        }
        let diagnostics = null;
        // Validate `@Component.imports` and `@Component.deferredImports` fields.
        if (analysis.resolvedImports !== null && analysis.rawImports !== null) {
            const importDiagnostics = validateStandaloneImports(analysis.resolvedImports, analysis.rawImports, this.metaReader, this.scopeReader, false /* isDeferredImport */);
            diagnostics ??= [];
            diagnostics.push(...importDiagnostics);
        }
        if (analysis.resolvedDeferredImports !== null && analysis.rawDeferredImports !== null) {
            const importDiagnostics = validateStandaloneImports(analysis.resolvedDeferredImports, analysis.rawDeferredImports, this.metaReader, this.scopeReader, true /* isDeferredImport */);
            diagnostics ??= [];
            diagnostics.push(...importDiagnostics);
        }
        if (analysis.providersRequiringFactory !== null &&
            analysis.meta.providers instanceof o.outputAst.WrappedNodeExpr) {
            const providerDiagnostics = getProviderDiagnostics(analysis.providersRequiringFactory, analysis.meta.providers.node, this.injectableRegistry);
            diagnostics ??= [];
            diagnostics.push(...providerDiagnostics);
        }
        if (analysis.viewProvidersRequiringFactory !== null &&
            analysis.meta.viewProviders instanceof o.outputAst.WrappedNodeExpr) {
            const viewProviderDiagnostics = getProviderDiagnostics(analysis.viewProvidersRequiringFactory, analysis.meta.viewProviders.node, this.injectableRegistry);
            diagnostics ??= [];
            diagnostics.push(...viewProviderDiagnostics);
        }
        const directiveDiagnostics = getDirectiveDiagnostics(node, this.injectableRegistry, this.evaluator, this.reflector, this.scopeRegistry, this.strictCtorDeps, 'Component');
        if (directiveDiagnostics !== null) {
            diagnostics ??= [];
            diagnostics.push(...directiveDiagnostics);
        }
        const hostDirectivesDiagnostics = analysis.hostDirectives && analysis.rawHostDirectives
            ? validateHostDirectives(analysis.rawHostDirectives, analysis.hostDirectives, this.metaReader)
            : null;
        if (hostDirectivesDiagnostics !== null) {
            diagnostics ??= [];
            diagnostics.push(...hostDirectivesDiagnostics);
        }
        return diagnostics;
    }
    /**
     * Locates defer blocks in case scope information is not available.
     * For example, this happens in the local compilation mode.
     */
    locateDeferBlocksWithoutScope(template) {
        const deferBlocks = new Map();
        const directivelessBinder = new o.R3TargetBinder(null);
        const bound = directivelessBinder.bind({ template: template.nodes });
        const deferredBlocks = bound.getDeferBlocks();
        for (const block of deferredBlocks) {
            // We can't determine the dependencies without a scope so we leave them empty.
            deferBlocks.set(block, []);
        }
        return deferBlocks;
    }
    /**
     * Computes a list of deferrable symbols based on dependencies from
     * the `@Component.imports` field and their usage in `@defer` blocks.
     */
    resolveAllDeferredDependencies(resolution) {
        const seenDeps = new Set();
        const deferrableTypes = [];
        // Go over all dependencies of all defer blocks and update the value of
        // the `isDeferrable` flag and the `importPath` to reflect the current
        // state after visiting all components during the `resolve` phase.
        for (const [_, deps] of resolution.deferPerBlockDependencies) {
            for (const deferBlockDep of deps) {
                const node = deferBlockDep.declaration.node;
                const importInfo = resolution.deferrableDeclToImportDecl.get(node) ?? null;
                if (importInfo !== null && this.deferredSymbolTracker.canDefer(importInfo.node)) {
                    deferBlockDep.isDeferrable = true;
                    deferBlockDep.symbolName = importInfo.name;
                    deferBlockDep.importPath = importInfo.from;
                    deferBlockDep.isDefaultImport = isDefaultImport(importInfo.node);
                    // The same dependency may be used across multiple deferred blocks. De-duplicate it
                    // because it can throw off other logic further down the compilation pipeline.
                    // Note that the logic above needs to run even if the dependency is seen before,
                    // because the object literals are different between each block.
                    if (!seenDeps.has(node)) {
                        seenDeps.add(node);
                        deferrableTypes.push(deferBlockDep);
                    }
                }
            }
        }
        return deferrableTypes;
    }
    /**
     * Collects deferrable symbols from the `@Component.deferredImports` field.
     */
    collectExplicitlyDeferredSymbols(rawDeferredImports) {
        const deferredTypes = new Map();
        if (!ts.isArrayLiteralExpression(rawDeferredImports)) {
            return deferredTypes;
        }
        for (const element of rawDeferredImports.elements) {
            const node = tryUnwrapForwardRef(element, this.reflector) || element;
            if (!ts.isIdentifier(node)) {
                // Can't defer-load non-literal references.
                continue;
            }
            const imp = this.reflector.getImportOfIdentifier(node);
            if (imp !== null) {
                deferredTypes.set(node, imp);
            }
        }
        return deferredTypes;
    }
    /**
     * Check whether adding an import from `origin` to the source-file corresponding to `expr` would
     * create a cyclic import.
     *
     * @returns a `Cycle` object if a cycle would be created, otherwise `null`.
     */
    _checkForCyclicImport(importedFile, expr, origin) {
        const imported = resolveImportedFile(this.moduleResolver, importedFile, expr, origin);
        if (imported === null) {
            return null;
        }
        // Check whether the import is legal.
        return this.cycleAnalyzer.wouldCreateCycle(origin, imported);
    }
    maybeRecordSyntheticImport(importedFile, expr, origin) {
        const imported = resolveImportedFile(this.moduleResolver, importedFile, expr, origin);
        if (imported === null) {
            return;
        }
        this.cycleAnalyzer.recordSyntheticImport(origin, imported);
    }
    /**
     * Resolves information about defer blocks dependencies to make it
     * available for the final `compile` step.
     */
    resolveDeferBlocks(componentClassDecl, scope, deferBlocks, deferrableDecls, resolutionData, analysisData, eagerlyUsedDecls) {
        // Collect all deferred decls from all defer blocks from the entire template
        // to intersect with the information from the `imports` field of a particular
        // Component.
        const allDeferredDecls = new Set();
        for (const [deferBlock, bound] of deferBlocks) {
            const usedDirectives = new Set(bound.getEagerlyUsedDirectives().map((d) => d.ref.node));
            const usedPipes = new Set(bound.getEagerlyUsedPipes());
            let deps;
            if (resolutionData.deferPerBlockDependencies.has(deferBlock)) {
                deps = resolutionData.deferPerBlockDependencies.get(deferBlock);
            }
            else {
                deps = [];
                resolutionData.deferPerBlockDependencies.set(deferBlock, deps);
            }
            for (const decl of Array.from(deferrableDecls.values())) {
                if (decl.kind === o.R3TemplateDependencyKind.NgModule) {
                    continue;
                }
                if (decl.kind === o.R3TemplateDependencyKind.Directive &&
                    !usedDirectives.has(decl.ref.node)) {
                    continue;
                }
                if (decl.kind === o.R3TemplateDependencyKind.Pipe && !usedPipes.has(decl.name)) {
                    continue;
                }
                // Collect initial information about this dependency.
                // `isDeferrable`, `importPath` and `isDefaultImport` will be
                // added later during the `compile` step.
                deps.push({
                    typeReference: decl.type,
                    symbolName: decl.ref.node.name.text,
                    isDeferrable: false,
                    importPath: null,
                    isDefaultImport: false,
                    declaration: decl.ref,
                });
                allDeferredDecls.add(decl.ref.node);
            }
        }
        if (analysisData.meta.isStandalone) {
            // For standalone components with the `imports` and `deferredImports` fields -
            // inspect the list of referenced symbols and mark the ones used in defer blocks
            // as potential candidates for defer loading.
            if (analysisData.rawImports !== null &&
                ts.isArrayLiteralExpression(analysisData.rawImports)) {
                for (const element of analysisData.rawImports.elements) {
                    this.registerDeferrableCandidate(componentClassDecl, element, false /* isDeferredImport */, allDeferredDecls, eagerlyUsedDecls, resolutionData);
                }
            }
            if (analysisData.rawDeferredImports !== null &&
                ts.isArrayLiteralExpression(analysisData.rawDeferredImports)) {
                for (const element of analysisData.rawDeferredImports.elements) {
                    this.registerDeferrableCandidate(componentClassDecl, element, false /* isDeferredImport */, allDeferredDecls, eagerlyUsedDecls, resolutionData);
                }
            }
            // Selectorless references dependencies directly so we register through the identifiers.
            if (scope.kind === ComponentScopeKind.Selectorless) {
                for (const identifier of scope.dependencyIdentifiers) {
                    this.registerDeferrableCandidate(componentClassDecl, identifier, false /* isDeferredImport */, allDeferredDecls, eagerlyUsedDecls, resolutionData);
                }
            }
        }
    }
    /**
     * Inspects provided imports expression (either `@Component.imports` or
     * `@Component.deferredImports`) and registers imported types as deferrable
     * candidates.
     */
    registerDeferrableCandidate(componentClassDecl, element, isDeferredImport, allDeferredDecls, eagerlyUsedDecls, resolutionData) {
        const node = tryUnwrapForwardRef(element, this.reflector) || element;
        if (!ts.isIdentifier(node)) {
            // Can't defer-load non-literal references.
            return;
        }
        const imp = this.reflector.getImportOfIdentifier(node);
        if (imp === null) {
            // Can't defer-load symbols which aren't imported.
            return;
        }
        const decl = this.reflector.getDeclarationOfIdentifier(node);
        if (decl === null) {
            // Can't defer-load symbols which don't exist.
            return;
        }
        if (!isNamedClassDeclaration(decl.node)) {
            // Can't defer-load symbols which aren't classes.
            return;
        }
        // Are we even trying to defer-load this symbol?
        if (!allDeferredDecls.has(decl.node)) {
            return;
        }
        if (eagerlyUsedDecls.has(decl.node)) {
            // Can't defer-load symbols that are eagerly referenced as a dependency
            // in a template outside of a defer block.
            return;
        }
        // Is it a standalone directive/component?
        const dirMeta = this.metaReader.getDirectiveMetadata(new Reference(decl.node));
        if (dirMeta !== null && !dirMeta.isStandalone) {
            return;
        }
        // Is it a standalone pipe?
        const pipeMeta = this.metaReader.getPipeMetadata(new Reference(decl.node));
        if (pipeMeta !== null && !pipeMeta.isStandalone) {
            return;
        }
        if (dirMeta === null && pipeMeta === null) {
            // This is not a directive or a pipe.
            return;
        }
        // Keep track of how this class made it into the current source file.
        // Store the full `Import` info so that callers can correctly determine the
        // exported name (handling aliasing) and the module specifier.
        resolutionData.deferrableDeclToImportDecl.set(decl.node, imp);
        this.deferredSymbolTracker.markAsDeferrableCandidate(node, imp.node, componentClassDecl, isDeferredImport);
    }
    compileDeferBlocks(resolution) {
        const { deferBlockDepsEmitMode: mode, deferPerBlockDependencies: perBlockDeps, deferPerComponentDependencies: perComponentDeps, } = resolution;
        if (mode === 0 /* DeferBlockDepsEmitMode.PerBlock */) {
            if (!perBlockDeps) {
                throw new Error('Internal error: deferPerBlockDependencies must be present when compiling in PerBlock mode');
            }
            const blocks = new Map();
            for (const [block, dependencies] of perBlockDeps) {
                blocks.set(block, dependencies.length === 0 ? null : o.compileDeferResolverFunction({ mode, dependencies }));
            }
            return { mode, blocks };
        }
        if (mode === 1 /* DeferBlockDepsEmitMode.PerComponent */) {
            if (!perComponentDeps) {
                throw new Error('Internal error: deferPerComponentDependencies must be present in PerComponent mode');
            }
            return {
                mode,
                dependenciesFn: perComponentDeps.length === 0
                    ? null
                    : o.compileDeferResolverFunction({ mode, dependencies: perComponentDeps }),
            };
        }
        throw new Error(`Invalid deferBlockDepsEmitMode. Cannot compile deferred block metadata.`);
    }
    /** Creates a new binding parser. */
    getNewBindingParser() {
        return o.makeBindingParser(this.enableSelectorless);
    }
}
function createMatcherFromScope(scope, hostDirectivesResolver) {
    if (scope.kind === ComponentScopeKind.Selectorless) {
        const registry = new Map();
        for (const [name, dep] of scope.dependencies) {
            if (dep.kind === MetaKind.Directive) {
                registry.set(name, [dep, ...hostDirectivesResolver.resolve(dep)]);
            }
        }
        return new o.SelectorlessMatcher(registry);
    }
    const matcher = new o.SelectorMatcher();
    const dependencies = scope.kind === ComponentScopeKind.NgModule
        ? scope.compilation.dependencies
        : scope.dependencies;
    for (const dep of dependencies) {
        if (dep.kind === MetaKind.Directive && dep.selector !== null) {
            matcher.addSelectables(o.CssSelector.parse(dep.selector), [dep]);
        }
    }
    return matcher;
}
/**
 * Drop references to existing imports for deferrable symbols that should be present
 * in the `setClassMetadataAsync` call. Otherwise, an import declaration gets retained.
 */
function removeDeferrableTypesFromComponentDecorator(analysis, deferrableTypes) {
    if (analysis.classMetadata) {
        const deferrableSymbols = new Set(deferrableTypes.map((t) => t.symbolName));
        const rewrittenDecoratorsNode = removeIdentifierReferences(analysis.classMetadata.decorators.node, deferrableSymbols);
        analysis.classMetadata.decorators = new o.outputAst.WrappedNodeExpr(rewrittenDecoratorsNode);
    }
}
/**
 * Validates that `@Component.imports` and `@Component.deferredImports` do not have
 * overlapping dependencies.
 */
function validateNoImportOverlap(eagerDeps, deferredDeps, rawDeferredImports) {
    let diagnostic = null;
    const eagerDepsSet = new Set();
    for (const eagerDep of eagerDeps) {
        eagerDepsSet.add(eagerDep.ref.node);
    }
    for (const deferredDep of deferredDeps) {
        if (eagerDepsSet.has(deferredDep.ref.node)) {
            const classInfo = deferredDep.ref.debugName
                ? `The \`${deferredDep.ref.debugName}\``
                : 'One of the dependencies';
            diagnostic = makeDiagnostic(exports.ErrorCode.DEFERRED_DEPENDENCY_IMPORTED_EAGERLY, getDiagnosticNode(deferredDep.ref, rawDeferredImports), `\`${classInfo}\` is imported via both \`@Component.imports\` and ` +
                `\`@Component.deferredImports\`. To fix this, make sure that ` +
                `dependencies are imported only once.`);
            break;
        }
    }
    return diagnostic;
}
function validateStandaloneImports(importRefs, importExpr, metaReader, scopeReader, isDeferredImport) {
    const diagnostics = [];
    for (const ref of importRefs) {
        const dirMeta = metaReader.getDirectiveMetadata(ref);
        if (dirMeta !== null) {
            if (!dirMeta.isStandalone) {
                // Directly importing a directive that's not standalone is an error.
                diagnostics.push(makeNotStandaloneDiagnostic(scopeReader, ref, importExpr, dirMeta.isComponent ? 'component' : 'directive'));
            }
            continue;
        }
        const pipeMeta = metaReader.getPipeMetadata(ref);
        if (pipeMeta !== null) {
            if (!pipeMeta.isStandalone) {
                diagnostics.push(makeNotStandaloneDiagnostic(scopeReader, ref, importExpr, 'pipe'));
            }
            continue;
        }
        const ngModuleMeta = metaReader.getNgModuleMetadata(ref);
        if (!isDeferredImport && ngModuleMeta !== null) {
            // Importing NgModules is always legal in `@Component.imports`,
            // but not supported in `@Component.deferredImports`.
            continue;
        }
        // Make an error?
        const error = isDeferredImport
            ? makeUnknownComponentDeferredImportDiagnostic(ref, importExpr)
            : makeUnknownComponentImportDiagnostic(ref, importExpr);
        diagnostics.push(error);
    }
    return diagnostics;
}
/** Returns whether an ImportDeclaration is a default import. */
function isDefaultImport(node) {
    return node.importClause !== undefined && node.importClause.namedBindings === undefined;
}

/**
 * Adapts the `compileInjectable` compiler for `@Injectable` decorators to the Ivy compiler.
 */
class InjectableDecoratorHandler {
    reflector;
    evaluator;
    isCore;
    strictCtorDeps;
    injectableRegistry;
    perf;
    includeClassMetadata;
    compilationMode;
    errorOnDuplicateProv;
    constructor(reflector, evaluator, isCore, strictCtorDeps, injectableRegistry, perf, includeClassMetadata, compilationMode, 
    /**
     * What to do if the injectable already contains a Éµprov property.
     *
     * If true then an error diagnostic is reported.
     * If false then there is no error and a new Éµprov property is not added.
     */
    errorOnDuplicateProv = true) {
        this.reflector = reflector;
        this.evaluator = evaluator;
        this.isCore = isCore;
        this.strictCtorDeps = strictCtorDeps;
        this.injectableRegistry = injectableRegistry;
        this.perf = perf;
        this.includeClassMetadata = includeClassMetadata;
        this.compilationMode = compilationMode;
        this.errorOnDuplicateProv = errorOnDuplicateProv;
    }
    precedence = HandlerPrecedence.SHARED;
    name = 'InjectableDecoratorHandler';
    detect(node, decorators) {
        if (!decorators) {
            return undefined;
        }
        const decorator = findAngularDecorator(decorators, 'Injectable', this.isCore);
        if (decorator !== undefined) {
            return {
                trigger: decorator.node,
                decorator: decorator,
                metadata: decorator,
            };
        }
        else {
            return undefined;
        }
    }
    analyze(node, decorator) {
        this.perf.eventCount(exports.PerfEvent.AnalyzeInjectable);
        const meta = extractInjectableMetadata(node, decorator, this.reflector);
        const decorators = this.reflector.getDecoratorsOfDeclaration(node);
        return {
            analysis: {
                meta,
                ctorDeps: extractInjectableCtorDeps(node, meta, decorator, this.reflector, this.isCore, this.strictCtorDeps),
                classMetadata: this.includeClassMetadata
                    ? extractClassMetadata(node, this.reflector, this.isCore)
                    : null,
                // Avoid generating multiple factories if a class has
                // more Angular decorators, apart from Injectable.
                needsFactory: !decorators ||
                    decorators.every((current) => !isAngularCore(current) || current.name === 'Injectable'),
            },
        };
    }
    symbol() {
        return null;
    }
    register(node, analysis) {
        if (this.compilationMode === exports.CompilationMode.LOCAL) {
            return;
        }
        this.injectableRegistry.registerInjectable(node, {
            ctorDeps: analysis.ctorDeps,
        });
    }
    resolve(node, analysis) {
        if (this.compilationMode === exports.CompilationMode.LOCAL) {
            return {};
        }
        if (requiresValidCtor(analysis.meta)) {
            const diagnostic = checkInheritanceOfInjectable(node, this.injectableRegistry, this.reflector, this.evaluator, this.strictCtorDeps, 'Injectable');
            if (diagnostic !== null) {
                return {
                    diagnostics: [diagnostic],
                };
            }
        }
        return {};
    }
    compileFull(node, analysis) {
        return this.compile(compileNgFactoryDefField, (meta) => o.compileInjectable(meta, false), o.compileClassMetadata, node, analysis);
    }
    compilePartial(node, analysis) {
        return this.compile(compileDeclareFactory, o.compileDeclareInjectableFromMetadata, o.compileDeclareClassMetadata, node, analysis);
    }
    compileLocal(node, analysis) {
        return this.compile(compileNgFactoryDefField, (meta) => o.compileInjectable(meta, false), o.compileClassMetadata, node, analysis);
    }
    compile(compileFactoryFn, compileInjectableFn, compileClassMetadataFn, node, analysis) {
        const results = [];
        if (analysis.needsFactory) {
            const meta = analysis.meta;
            const factoryRes = compileFactoryFn(toFactoryMetadata({ ...meta, deps: analysis.ctorDeps }, o.FactoryTarget.Injectable));
            if (analysis.classMetadata !== null) {
                factoryRes.statements.push(compileClassMetadataFn(analysis.classMetadata).toStmt());
            }
            results.push(factoryRes);
        }
        const Éµprov = this.reflector.getMembersOfClass(node).find((member) => member.name === 'Éµprov');
        if (Éµprov !== undefined && this.errorOnDuplicateProv) {
            throw new FatalDiagnosticError(exports.ErrorCode.INJECTABLE_DUPLICATE_PROV, Éµprov.nameNode || Éµprov.node || node, 'Injectables cannot contain a static Éµprov property, because the compiler is going to generate one.');
        }
        if (Éµprov === undefined) {
            // Only add a new Éµprov if there is not one already
            const res = compileInjectableFn(analysis.meta);
            results.push({
                name: 'Éµprov',
                initializer: res.expression,
                statements: res.statements,
                type: res.type,
                deferrableImports: null,
            });
        }
        return results;
    }
}
/**
 * Read metadata from the `@Injectable` decorator and produce the `IvyInjectableMetadata`, the
 * input metadata needed to run `compileInjectable`.
 *
 * A `null` return value indicates this is @Injectable has invalid data.
 */
function extractInjectableMetadata(clazz, decorator, reflector) {
    const name = clazz.name.text;
    const type = wrapTypeReference(reflector, clazz);
    const typeArgumentCount = reflector.getGenericArityOfClass(clazz) || 0;
    if (decorator.args === null) {
        throw new FatalDiagnosticError(exports.ErrorCode.DECORATOR_NOT_CALLED, decorator.node, '@Injectable must be called');
    }
    if (decorator.args.length === 0) {
        return {
            name,
            type,
            typeArgumentCount,
            providedIn: o.createMayBeForwardRefExpression(new o.LiteralExpr(null), 0 /* ForwardRefHandling.None */),
        };
    }
    else if (decorator.args.length === 1) {
        const metaNode = decorator.args[0];
        // Firstly make sure the decorator argument is an inline literal - if not, it's illegal to
        // transport references from one location to another. This is the problem that lowering
        // used to solve - if this restriction proves too undesirable we can re-implement lowering.
        if (!ts.isObjectLiteralExpression(metaNode)) {
            throw new FatalDiagnosticError(exports.ErrorCode.DECORATOR_ARG_NOT_LITERAL, metaNode, `@Injectable argument must be an object literal`);
        }
        // Resolve the fields of the literal into a map of field name to expression.
        const meta = reflectObjectLiteral(metaNode);
        const providedIn = meta.has('providedIn')
            ? getProviderExpression(meta.get('providedIn'), reflector)
            : o.createMayBeForwardRefExpression(new o.LiteralExpr(null), 0 /* ForwardRefHandling.None */);
        let deps = undefined;
        if ((meta.has('useClass') || meta.has('useFactory')) && meta.has('deps')) {
            const depsExpr = meta.get('deps');
            if (!ts.isArrayLiteralExpression(depsExpr)) {
                throw new FatalDiagnosticError(exports.ErrorCode.VALUE_NOT_LITERAL, depsExpr, `@Injectable deps metadata must be an inline array`);
            }
            deps = depsExpr.elements.map((dep) => getDep(dep, reflector));
        }
        const result = { name, type, typeArgumentCount, providedIn };
        if (meta.has('useValue')) {
            result.useValue = getProviderExpression(meta.get('useValue'), reflector);
        }
        else if (meta.has('useExisting')) {
            result.useExisting = getProviderExpression(meta.get('useExisting'), reflector);
        }
        else if (meta.has('useClass')) {
            result.useClass = getProviderExpression(meta.get('useClass'), reflector);
            result.deps = deps;
        }
        else if (meta.has('useFactory')) {
            result.useFactory = new o.WrappedNodeExpr(meta.get('useFactory'));
            result.deps = deps;
        }
        return result;
    }
    else {
        throw new FatalDiagnosticError(exports.ErrorCode.DECORATOR_ARITY_WRONG, decorator.args[2], 'Too many arguments to @Injectable');
    }
}
/**
 * Get the `R3ProviderExpression` for this `expression`.
 *
 * The `useValue`, `useExisting` and `useClass` properties might be wrapped in a `ForwardRef`, which
 * needs to be unwrapped. This function will do that unwrapping and set a flag on the returned
 * object to indicate whether the value needed unwrapping.
 */
function getProviderExpression(expression, reflector) {
    const forwardRefValue = tryUnwrapForwardRef(expression, reflector);
    return o.createMayBeForwardRefExpression(new o.WrappedNodeExpr(forwardRefValue ?? expression), forwardRefValue !== null ? 2 /* ForwardRefHandling.Unwrapped */ : 0 /* ForwardRefHandling.None */);
}
function extractInjectableCtorDeps(clazz, meta, decorator, reflector, isCore, strictCtorDeps) {
    if (decorator.args === null) {
        throw new FatalDiagnosticError(exports.ErrorCode.DECORATOR_NOT_CALLED, decorator.node, '@Injectable must be called');
    }
    let ctorDeps = null;
    if (decorator.args.length === 0) {
        // Ideally, using @Injectable() would have the same effect as using @Injectable({...}), and be
        // subject to the same validation. However, existing Angular code abuses @Injectable, applying
        // it to things like abstract classes with constructors that were never meant for use with
        // Angular's DI.
        //
        // To deal with this, @Injectable() without an argument is more lenient, and if the
        // constructor signature does not work for DI then a factory definition (Éµfac) that throws is
        // generated.
        if (strictCtorDeps && !isAbstractClassDeclaration(clazz)) {
            ctorDeps = getValidConstructorDependencies(clazz, reflector, isCore);
        }
        else {
            ctorDeps = unwrapConstructorDependencies(getConstructorDependencies(clazz, reflector, isCore));
        }
        return ctorDeps;
    }
    else if (decorator.args.length === 1) {
        const rawCtorDeps = getConstructorDependencies(clazz, reflector, isCore);
        if (strictCtorDeps && !isAbstractClassDeclaration(clazz) && requiresValidCtor(meta)) {
            // Since use* was not provided for a concrete class, validate the deps according to
            // strictCtorDeps.
            ctorDeps = validateConstructorDependencies(clazz, rawCtorDeps);
        }
        else {
            ctorDeps = unwrapConstructorDependencies(rawCtorDeps);
        }
    }
    return ctorDeps;
}
function requiresValidCtor(meta) {
    return (meta.useValue === undefined &&
        meta.useExisting === undefined &&
        meta.useClass === undefined &&
        meta.useFactory === undefined);
}
function getDep(dep, reflector) {
    const meta = {
        token: new o.WrappedNodeExpr(dep),
        attributeNameType: null,
        host: false,
        optional: false,
        self: false,
        skipSelf: false,
    };
    function maybeUpdateDecorator(dec, reflector, token) {
        const source = reflector.getImportOfIdentifier(dec);
        if (source === null || source.from !== '@angular/core') {
            return false;
        }
        switch (source.name) {
            case 'Inject':
                if (token !== undefined) {
                    meta.token = new o.WrappedNodeExpr(token);
                }
                break;
            case 'Optional':
                meta.optional = true;
                break;
            case 'SkipSelf':
                meta.skipSelf = true;
                break;
            case 'Self':
                meta.self = true;
                break;
            default:
                return false;
        }
        return true;
    }
    if (ts.isArrayLiteralExpression(dep)) {
        dep.elements.forEach((el) => {
            let isDecorator = false;
            if (ts.isIdentifier(el)) {
                isDecorator = maybeUpdateDecorator(el, reflector);
            }
            else if (ts.isNewExpression(el) && ts.isIdentifier(el.expression)) {
                const token = (el.arguments && el.arguments.length > 0 && el.arguments[0]) || undefined;
                isDecorator = maybeUpdateDecorator(el.expression, reflector, token);
            }
            if (!isDecorator) {
                meta.token = new o.WrappedNodeExpr(el);
            }
        });
    }
    return meta;
}

/**
 * Represents an Angular pipe.
 */
class PipeSymbol extends SemanticSymbol {
    name;
    constructor(decl, name) {
        super(decl);
        this.name = name;
    }
    isPublicApiAffected(previousSymbol) {
        if (!(previousSymbol instanceof PipeSymbol)) {
            return true;
        }
        return this.name !== previousSymbol.name;
    }
    isTypeCheckApiAffected(previousSymbol) {
        return this.isPublicApiAffected(previousSymbol);
    }
}
class PipeDecoratorHandler {
    reflector;
    evaluator;
    metaRegistry;
    scopeRegistry;
    injectableRegistry;
    isCore;
    perf;
    includeClassMetadata;
    compilationMode;
    generateExtraImportsInLocalMode;
    strictStandalone;
    implicitStandaloneValue;
    constructor(reflector, evaluator, metaRegistry, scopeRegistry, injectableRegistry, isCore, perf, includeClassMetadata, compilationMode, generateExtraImportsInLocalMode, strictStandalone, implicitStandaloneValue) {
        this.reflector = reflector;
        this.evaluator = evaluator;
        this.metaRegistry = metaRegistry;
        this.scopeRegistry = scopeRegistry;
        this.injectableRegistry = injectableRegistry;
        this.isCore = isCore;
        this.perf = perf;
        this.includeClassMetadata = includeClassMetadata;
        this.compilationMode = compilationMode;
        this.generateExtraImportsInLocalMode = generateExtraImportsInLocalMode;
        this.strictStandalone = strictStandalone;
        this.implicitStandaloneValue = implicitStandaloneValue;
    }
    precedence = HandlerPrecedence.PRIMARY;
    name = 'PipeDecoratorHandler';
    detect(node, decorators) {
        if (!decorators) {
            return undefined;
        }
        const decorator = findAngularDecorator(decorators, 'Pipe', this.isCore);
        if (decorator !== undefined) {
            return {
                trigger: decorator.node,
                decorator: decorator,
                metadata: decorator,
            };
        }
        else {
            return undefined;
        }
    }
    analyze(clazz, decorator) {
        this.perf.eventCount(exports.PerfEvent.AnalyzePipe);
        const name = clazz.name.text;
        const type = wrapTypeReference(this.reflector, clazz);
        if (decorator.args === null) {
            throw new FatalDiagnosticError(exports.ErrorCode.DECORATOR_NOT_CALLED, decorator.node, `@Pipe must be called`);
        }
        const meta = decorator.args.length === 0 ||
            // TODO(crisbeto): temporary for testing until we've changed
            // the pipe public API not to require a name.
            (ts.isNonNullExpression(decorator.args[0]) &&
                decorator.args[0].expression.kind === ts.SyntaxKind.NullKeyword)
            ? null
            : unwrapExpression(decorator.args[0]);
        let pipeName = null;
        let pipeNameExpr = null;
        let pure = true;
        let isStandalone = this.implicitStandaloneValue;
        if (meta !== null) {
            if (!ts.isObjectLiteralExpression(meta)) {
                throw new FatalDiagnosticError(exports.ErrorCode.DECORATOR_ARG_NOT_LITERAL, meta, '@Pipe must have a literal argument');
            }
            const pipe = reflectObjectLiteral(meta);
            if (!pipe.has('name')) {
                throw new FatalDiagnosticError(exports.ErrorCode.PIPE_MISSING_NAME, meta, `@Pipe decorator is missing name field`);
            }
            pipeNameExpr = pipe.get('name');
            const evaluatedName = this.evaluator.evaluate(pipeNameExpr);
            if (typeof evaluatedName !== 'string') {
                throw createValueHasWrongTypeError(pipeNameExpr, evaluatedName, `@Pipe.name must be a string`);
            }
            pipeName = evaluatedName;
            if (pipe.has('pure')) {
                const expr = pipe.get('pure');
                const pureValue = this.evaluator.evaluate(expr);
                if (typeof pureValue !== 'boolean') {
                    throw createValueHasWrongTypeError(expr, pureValue, `@Pipe.pure must be a boolean`);
                }
                pure = pureValue;
            }
            if (pipe.has('standalone')) {
                const expr = pipe.get('standalone');
                const resolved = this.evaluator.evaluate(expr);
                if (typeof resolved !== 'boolean') {
                    throw createValueHasWrongTypeError(expr, resolved, `standalone flag must be a boolean`);
                }
                isStandalone = resolved;
                if (!isStandalone && this.strictStandalone) {
                    throw new FatalDiagnosticError(exports.ErrorCode.NON_STANDALONE_NOT_ALLOWED, expr, `Only standalone pipes are allowed when 'strictStandalone' is enabled.`);
                }
            }
        }
        return {
            analysis: {
                meta: {
                    name,
                    type,
                    typeArgumentCount: this.reflector.getGenericArityOfClass(clazz) || 0,
                    pipeName,
                    deps: getValidConstructorDependencies(clazz, this.reflector, this.isCore),
                    pure,
                    isStandalone,
                },
                classMetadata: this.includeClassMetadata
                    ? extractClassMetadata(clazz, this.reflector, this.isCore)
                    : null,
                pipeNameExpr,
                decorator: decorator?.node ?? null,
            },
        };
    }
    symbol(node, analysis) {
        return new PipeSymbol(node, analysis.meta.pipeName ?? analysis.meta.name);
    }
    register(node, analysis) {
        const ref = new Reference(node);
        this.metaRegistry.registerPipeMetadata({
            kind: MetaKind.Pipe,
            ref,
            name: analysis.meta.pipeName,
            nameExpr: analysis.pipeNameExpr,
            isStandalone: analysis.meta.isStandalone,
            decorator: analysis.decorator,
            isExplicitlyDeferred: false,
            isPure: analysis.meta.pure,
        });
        this.injectableRegistry.registerInjectable(node, {
            ctorDeps: analysis.meta.deps,
        });
    }
    resolve(node) {
        if (this.compilationMode === exports.CompilationMode.LOCAL) {
            return {};
        }
        const duplicateDeclData = this.scopeRegistry.getDuplicateDeclarations(node);
        if (duplicateDeclData !== null) {
            // This pipe was declared twice (or more).
            return {
                diagnostics: [makeDuplicateDeclarationError(node, duplicateDeclData, 'Pipe')],
            };
        }
        return {};
    }
    compileFull(node, analysis) {
        const fac = compileNgFactoryDefField(toFactoryMetadata(analysis.meta, o.FactoryTarget.Pipe));
        const def = o.compilePipeFromMetadata(analysis.meta);
        const classMetadata = analysis.classMetadata !== null
            ? o.compileClassMetadata(analysis.classMetadata).toStmt()
            : null;
        return compileResults(fac, def, classMetadata, 'Éµpipe', null, null /* deferrableImports */);
    }
    compilePartial(node, analysis) {
        const fac = compileDeclareFactory(toFactoryMetadata(analysis.meta, o.FactoryTarget.Pipe));
        const def = o.compileDeclarePipeFromMetadata(analysis.meta);
        const classMetadata = analysis.classMetadata !== null
            ? o.compileDeclareClassMetadata(analysis.classMetadata).toStmt()
            : null;
        return compileResults(fac, def, classMetadata, 'Éµpipe', null, null /* deferrableImports */);
    }
    compileLocal(node, analysis) {
        const fac = compileNgFactoryDefField(toFactoryMetadata(analysis.meta, o.FactoryTarget.Pipe));
        const def = o.compilePipeFromMetadata(analysis.meta);
        const classMetadata = analysis.classMetadata !== null
            ? o.compileClassMetadata(analysis.classMetadata).toStmt()
            : null;
        return compileResults(fac, def, classMetadata, 'Éµpipe', null, null /* deferrableImports */);
    }
}

/**
 * Analyzes a `ts.Program` for cycles.
 */
class CycleAnalyzer {
    importGraph;
    /**
     * Cycle detection is requested with the same `from` source file for all used directives and pipes
     * within a component, which makes it beneficial to cache the results as long as the `from` source
     * file has not changed. This avoids visiting the import graph that is reachable from multiple
     * directives/pipes more than once.
     */
    cachedResults = null;
    constructor(importGraph) {
        this.importGraph = importGraph;
    }
    /**
     * Check for a cycle to be created in the `ts.Program` by adding an import between `from` and
     * `to`.
     *
     * @returns a `Cycle` object if an import between `from` and `to` would create a cycle; `null`
     *     otherwise.
     */
    wouldCreateCycle(from, to) {
        // Try to reuse the cached results as long as the `from` source file is the same.
        if (this.cachedResults === null || this.cachedResults.from !== from) {
            this.cachedResults = new CycleResults(from, this.importGraph);
        }
        // Import of 'from' -> 'to' is illegal if an edge 'to' -> 'from' already exists.
        return this.cachedResults.wouldBeCyclic(to) ? new Cycle(this.importGraph, from, to) : null;
    }
    /**
     * Record a synthetic import from `from` to `to`.
     *
     * This is an import that doesn't exist in the `ts.Program` but will be considered as part of the
     * import graph for cycle creation.
     */
    recordSyntheticImport(from, to) {
        this.cachedResults = null;
        this.importGraph.addSyntheticImport(from, to);
    }
}
const NgCyclicResult = Symbol('NgCyclicResult');
/**
 * Stores the results of cycle detection in a memory efficient manner. A symbol is attached to
 * source files that indicate what the cyclic analysis result is, as indicated by two markers that
 * are unique to this instance. This alleviates memory pressure in large import graphs, as each
 * execution is able to store its results in the same memory location (i.e. in the symbol
 * on the source file) as earlier executions.
 */
class CycleResults {
    from;
    importGraph;
    cyclic = {};
    acyclic = {};
    constructor(from, importGraph) {
        this.from = from;
        this.importGraph = importGraph;
    }
    wouldBeCyclic(sf) {
        const cached = this.getCachedResult(sf);
        if (cached !== null) {
            // The result for this source file has already been computed, so return its result.
            return cached;
        }
        if (sf === this.from) {
            // We have reached the source file that we want to create an import from, which means that
            // doing so would create a cycle.
            return true;
        }
        // Assume for now that the file will be acyclic; this prevents infinite recursion in the case
        // that `sf` is visited again as part of an existing cycle in the graph.
        this.markAcyclic(sf);
        const imports = this.importGraph.importsOf(sf);
        for (const imported of imports) {
            if (this.wouldBeCyclic(imported)) {
                this.markCyclic(sf);
                return true;
            }
        }
        return false;
    }
    /**
     * Returns whether the source file is already known to be cyclic, or `null` if the result is not
     * yet known.
     */
    getCachedResult(sf) {
        const result = sf[NgCyclicResult];
        if (result === this.cyclic) {
            return true;
        }
        else if (result === this.acyclic) {
            return false;
        }
        else {
            // Either the symbol is missing or its value does not correspond with one of the current
            // result markers. As such, the result is unknown.
            return null;
        }
    }
    markCyclic(sf) {
        sf[NgCyclicResult] = this.cyclic;
    }
    markAcyclic(sf) {
        sf[NgCyclicResult] = this.acyclic;
    }
}
/**
 * Represents an import cycle between `from` and `to` in the program.
 *
 * This class allows us to do the work to compute the cyclic path between `from` and `to` only if
 * needed.
 */
class Cycle {
    importGraph;
    from;
    to;
    constructor(importGraph, from, to) {
        this.importGraph = importGraph;
        this.from = from;
        this.to = to;
    }
    /**
     * Compute an array of source-files that illustrates the cyclic path between `from` and `to`.
     *
     * Note that a `Cycle` will not be created unless a path is available between `to` and `from`,
     * so `findPath()` will never return `null`.
     */
    getPath() {
        return [this.from, ...this.importGraph.findPath(this.to, this.from)];
    }
}

/**
 * A cached graph of imports in the `ts.Program`.
 *
 * The `ImportGraph` keeps track of dependencies (imports) of individual `ts.SourceFile`s. Only
 * dependencies within the same program are tracked; imports into packages on NPM are not.
 */
class ImportGraph {
    checker;
    perf;
    imports = new Map();
    constructor(checker, perf) {
        this.checker = checker;
        this.perf = perf;
    }
    /**
     * List the direct (not transitive) imports of a given `ts.SourceFile`.
     *
     * This operation is cached.
     */
    importsOf(sf) {
        if (!this.imports.has(sf)) {
            this.imports.set(sf, this.scanImports(sf));
        }
        return this.imports.get(sf);
    }
    /**
     * Find an import path from the `start` SourceFile to the `end` SourceFile.
     *
     * This function implements a breadth first search that results in finding the
     * shortest path between the `start` and `end` points.
     *
     * @param start the starting point of the path.
     * @param end the ending point of the path.
     * @returns an array of source files that connect the `start` and `end` source files, or `null` if
     *     no path could be found.
     */
    findPath(start, end) {
        if (start === end) {
            // Escape early for the case where `start` and `end` are the same.
            return [start];
        }
        const found = new Set([start]);
        const queue = [new Found(start, null)];
        while (queue.length > 0) {
            const current = queue.shift();
            const imports = this.importsOf(current.sourceFile);
            for (const importedFile of imports) {
                if (!found.has(importedFile)) {
                    const next = new Found(importedFile, current);
                    if (next.sourceFile === end) {
                        // We have hit the target `end` path so we can stop here.
                        return next.toPath();
                    }
                    found.add(importedFile);
                    queue.push(next);
                }
            }
        }
        return null;
    }
    /**
     * Add a record of an import from `sf` to `imported`, that's not present in the original
     * `ts.Program` but will be remembered by the `ImportGraph`.
     */
    addSyntheticImport(sf, imported) {
        if (isLocalFile(imported)) {
            this.importsOf(sf).add(imported);
        }
    }
    scanImports(sf) {
        return this.perf.inPhase(exports.PerfPhase.CycleDetection, () => {
            const imports = new Set();
            // Look through the source file for import and export statements.
            for (const stmt of sf.statements) {
                if ((!ts.isImportDeclaration(stmt) && !ts.isExportDeclaration(stmt)) ||
                    stmt.moduleSpecifier === undefined) {
                    continue;
                }
                if (ts.isImportDeclaration(stmt) &&
                    stmt.importClause !== undefined &&
                    isTypeOnlyImportClause(stmt.importClause)) {
                    // Exclude type-only imports as they are always elided, so they don't contribute to
                    // cycles.
                    continue;
                }
                const symbol = this.checker.getSymbolAtLocation(stmt.moduleSpecifier);
                if (symbol === undefined || symbol.valueDeclaration === undefined) {
                    // No symbol could be found to skip over this import/export.
                    continue;
                }
                const moduleFile = symbol.valueDeclaration;
                if (ts.isSourceFile(moduleFile) && isLocalFile(moduleFile)) {
                    // Record this local import.
                    imports.add(moduleFile);
                }
            }
            return imports;
        });
    }
}
function isLocalFile(sf) {
    return !sf.isDeclarationFile;
}
function isTypeOnlyImportClause(node) {
    // The clause itself is type-only (e.g. `import type {foo} from '...'`).
    if (node.isTypeOnly) {
        return true;
    }
    // All the specifiers in the cause are type-only (e.g. `import {type a, type b} from '...'`).
    if (node.namedBindings !== undefined &&
        ts.isNamedImports(node.namedBindings) &&
        node.namedBindings.elements.every((specifier) => specifier.isTypeOnly)) {
        return true;
    }
    return false;
}
/**
 * A helper class to track which SourceFiles are being processed when searching for a path in
 * `getPath()` above.
 */
class Found {
    sourceFile;
    parent;
    constructor(sourceFile, parent) {
        this.sourceFile = sourceFile;
        this.parent = parent;
    }
    /**
     * Back track through this found SourceFile and its ancestors to generate an array of
     * SourceFiles that form am import path between two SourceFiles.
     */
    toPath() {
        const array = [];
        let current = this;
        while (current !== null) {
            array.push(current.sourceFile);
            current = current.parent;
        }
        // Pushing and then reversing, O(n), rather than unshifting repeatedly, O(n^2), avoids
        // manipulating the array on every iteration: https://stackoverflow.com/a/26370620
        return array.reverse();
    }
}

/** Type of top-level documentation entry. */
var EntryType;
(function (EntryType) {
    EntryType["Block"] = "block";
    EntryType["Component"] = "component";
    EntryType["Constant"] = "constant";
    EntryType["Decorator"] = "decorator";
    EntryType["Directive"] = "directive";
    EntryType["Element"] = "element";
    EntryType["Enum"] = "enum";
    EntryType["Function"] = "function";
    EntryType["Interface"] = "interface";
    EntryType["NgModule"] = "ng_module";
    EntryType["Pipe"] = "pipe";
    EntryType["TypeAlias"] = "type_alias";
    EntryType["UndecoratedClass"] = "undecorated_class";
    EntryType["InitializerApiFunction"] = "initializer_api_function";
})(EntryType || (EntryType = {}));
/** Types of class members */
var MemberType;
(function (MemberType) {
    MemberType["Property"] = "property";
    MemberType["Method"] = "method";
    MemberType["Getter"] = "getter";
    MemberType["Setter"] = "setter";
    MemberType["EnumItem"] = "enum_item";
})(MemberType || (MemberType = {}));
var DecoratorType;
(function (DecoratorType) {
    DecoratorType["Class"] = "class";
    DecoratorType["Member"] = "member";
    DecoratorType["Parameter"] = "parameter";
})(DecoratorType || (DecoratorType = {}));
/** Informational tags applicable to class members. */
var MemberTags;
(function (MemberTags) {
    MemberTags["Abstract"] = "abstract";
    MemberTags["Static"] = "static";
    MemberTags["Readonly"] = "readonly";
    MemberTags["Protected"] = "protected";
    MemberTags["Optional"] = "optional";
    MemberTags["Input"] = "input";
    MemberTags["Output"] = "output";
    MemberTags["Inherited"] = "override";
})(MemberTags || (MemberTags = {}));

/**
 * RegExp to match the `@` character follow by any Angular decorator, used to escape Angular
 * decorators in JsDoc blocks so that they're not parsed as JsDoc tags.
 */
const decoratorExpression = /@(?=(Injectable|Component|Directive|Pipe|NgModule|Input|Output|HostBinding|HostListener|Inject|Optional|Self|Host|SkipSelf|ViewChild|ViewChildren|ContentChild|ContentChildren))/g;
/** Gets the set of JsDoc tags applied to a node. */
function extractJsDocTags(node) {
    const escapedNode = getEscapedNode(node);
    return ts.getJSDocTags(escapedNode).map((t) => {
        return {
            name: t.tagName.getText(),
            comment: unescapeAngularDecorators(ts.getTextOfJSDocComment(t.comment) ?? ''),
        };
    });
}
/**
 * Gets the JsDoc description for a node. If the node does not have
 * a description, returns the empty string.
 */
function extractJsDocDescription(node) {
    const escapedNode = getEscapedNode(node);
    // If the node is a top-level statement (const, class, function, etc.), we will get
    // a `ts.JSDoc` here. If the node is a `ts.ParameterDeclaration`, we will get
    // a `ts.JSDocParameterTag`.
    const commentOrTag = ts.getJSDocCommentsAndTags(escapedNode).find((d) => {
        return ts.isJSDoc(d) || ts.isJSDocParameterTag(d);
    });
    const comment = commentOrTag?.comment ?? '';
    const description = typeof comment === 'string' ? comment : (ts.getTextOfJSDocComment(comment) ?? '');
    return unescapeAngularDecorators(description);
}
/**
 * Gets the raw JsDoc applied to a node.
 * If the node does not have a JsDoc block, returns the empty string.
 */
function extractRawJsDoc(node) {
    // Assume that any node has at most one JsDoc block.
    const comment = ts.getJSDocCommentsAndTags(node).find(ts.isJSDoc)?.getFullText() ?? '';
    return unescapeAngularDecorators(comment);
}
/**
 * Gets an "escaped" version of the node by copying its raw JsDoc into a new source file
 * on top of a dummy class declaration. For the purposes of JsDoc extraction, we don't actually
 * care about the node itself, only its JsDoc block.
 */
function getEscapedNode(node) {
    // TODO(jelbourn): It's unclear whether we need to escape @param JsDoc, since they're unlikely
    //    to have an Angular decorator on the beginning of a line. If we do need to escape them,
    //    it will require some more complicated copying below.
    if (ts.isParameter(node)) {
        return node;
    }
    const rawComment = extractRawJsDoc(node);
    const escaped = escapeAngularDecorators(rawComment);
    const file = ts.createSourceFile('x.ts', `${escaped}class X {}`, ts.ScriptTarget.ES2020, true);
    return file.statements.find((s) => ts.isClassDeclaration(s));
}
/** Escape the `@` character for Angular decorators. */
function escapeAngularDecorators(comment) {
    return comment.replace(decoratorExpression, '_NG_AT_');
}
/** Unescapes the `@` character for Angular decorators. */
function unescapeAngularDecorators(comment) {
    return comment.replace(/_NG_AT_/g, '@');
}

/** Gets whether a symbol's name indicates it is an Angular-private API. */
function isAngularPrivateName(name) {
    const firstChar = name[0] ?? '';
    return firstChar === 'Éµ' || firstChar === '_';
}

/** Gets a list of all the generic type parameters for a declaration. */
function extractGenerics(declaration) {
    return (declaration.typeParameters?.map((typeParam) => ({
        name: typeParam.name.getText(),
        constraint: typeParam.constraint?.getText(),
        default: typeParam.default?.getText(),
    })) ?? []);
}

/** Gets the string representation of a node's resolved type. */
function extractResolvedTypeString(node, checker) {
    return checker.typeToString(checker.getTypeAtLocation(node), undefined, ts.TypeFormatFlags.NoTruncation);
}

class FunctionExtractor {
    name;
    exportDeclaration;
    typeChecker;
    constructor(name, exportDeclaration, typeChecker) {
        this.name = name;
        this.exportDeclaration = exportDeclaration;
        this.typeChecker = typeChecker;
    }
    extract() {
        // TODO: is there any real situation in which the signature would not be available here?
        //     Is void a better type?
        const signature = this.typeChecker.getSignatureFromDeclaration(this.exportDeclaration);
        const returnType = signature ? extractReturnType(signature, this.typeChecker) : 'unknown';
        const implementation = findImplementationOfFunction(this.exportDeclaration, this.typeChecker) ??
            this.exportDeclaration;
        const type = this.typeChecker.getTypeAtLocation(this.exportDeclaration);
        const overloads = ts.isConstructorDeclaration(this.exportDeclaration)
            ? constructorOverloads(this.exportDeclaration, this.typeChecker)
            : extractCallSignatures(this.name, this.typeChecker, type);
        const jsdocsTags = extractJsDocTags(implementation);
        const description = extractJsDocDescription(implementation);
        return {
            name: this.name,
            signatures: overloads,
            implementation: {
                params: extractAllParams(implementation.parameters, this.typeChecker),
                isNewType: ts.isConstructSignatureDeclaration(implementation),
                returnType,
                returnDescription: jsdocsTags.find((tag) => tag.name === 'returns')?.comment,
                generics: extractGenerics(implementation),
                name: this.name,
                description,
                entryType: EntryType.Function,
                jsdocTags: jsdocsTags,
                rawComment: extractRawJsDoc(implementation),
            },
            entryType: EntryType.Function,
            description,
            jsdocTags: jsdocsTags,
            rawComment: extractRawJsDoc(implementation),
        };
    }
}
function constructorOverloads(constructorDeclaration, typeChecker) {
    const classDeclaration = constructorDeclaration.parent;
    const constructorNode = classDeclaration.members.filter((member) => {
        return ts.isConstructorDeclaration(member) && !member.body;
    });
    return constructorNode.map((n) => {
        return {
            name: 'constructor',
            params: extractAllParams(n.parameters, typeChecker),
            returnType: typeChecker.getTypeAtLocation(classDeclaration)?.symbol.name,
            description: extractJsDocDescription(n),
            entryType: EntryType.Function,
            jsdocTags: extractJsDocTags(n),
            rawComment: extractRawJsDoc(n),
            generics: extractGenerics(n),
            isNewType: false,
        };
    });
}
/** Extracts parameters of the given parameter declaration AST nodes. */
function extractAllParams(params, typeChecker) {
    return params.map((param) => ({
        name: param.name.getText(),
        description: extractJsDocDescription(param),
        type: extractResolvedTypeString(param, typeChecker),
        isOptional: !!(param.questionToken || param.initializer),
        isRestParam: !!param.dotDotDotToken,
    }));
}
/** Filters the list signatures to valid function and initializer API signatures. */
function filterSignatureDeclarations(signatures) {
    const result = [];
    for (const signature of signatures) {
        const decl = signature.getDeclaration();
        if (ts.isFunctionDeclaration(decl) ||
            ts.isCallSignatureDeclaration(decl) ||
            ts.isMethodDeclaration(decl) ||
            ts.isConstructSignatureDeclaration(decl)) {
            result.push({ signature, decl });
        }
    }
    return result;
}
function extractCallSignatures(name, typeChecker, type) {
    return filterSignatureDeclarations(type.getCallSignatures()).map(({ decl, signature }) => ({
        name,
        entryType: EntryType.Function,
        description: extractJsDocDescription(decl),
        generics: extractGenerics(decl),
        isNewType: false,
        jsdocTags: extractJsDocTags(decl),
        params: extractAllParams(decl.parameters, typeChecker),
        rawComment: extractRawJsDoc(decl),
        returnType: extractReturnType(signature, typeChecker),
    }));
}
function extractReturnType(signature, typeChecker) {
    // Handling Type Predicates
    if (signature?.declaration?.type && ts.isTypePredicateNode(signature.declaration.type)) {
        return signature.declaration.type.getText();
    }
    return typeChecker.typeToString(typeChecker.getReturnTypeOfSignature(signature), undefined, 
    // This ensures that e.g. `T | undefined` is not reduced to `T`.
    ts.TypeFormatFlags.NoTypeReduction | ts.TypeFormatFlags.NoTruncation);
}
/** Finds the implementation of the given function declaration overload signature. */
function findImplementationOfFunction(node, typeChecker) {
    if (node.body !== undefined || node.name === undefined) {
        return node;
    }
    const symbol = typeChecker.getSymbolAtLocation(node.name);
    const implementation = symbol?.declarations?.find((s) => ts.isFunctionDeclaration(s) && s.body !== undefined);
    return implementation;
}

/**
 * Check if the member has a JSDoc @internal or a @internal is a normal comment
 */
function isInternal(member) {
    return (extractJsDocTags(member).some((tag) => tag.name === 'internal') ||
        hasLeadingInternalComment(member));
}
/*
 * Check if the member has a comment block with @internal
 */
function hasLeadingInternalComment(member) {
    const memberText = member.getSourceFile().text;
    return (ts.reduceEachLeadingCommentRange(memberText, member.getFullStart(), (pos, end, kind, hasTrailingNewLine, containsInternal) => {
        return containsInternal || memberText.slice(pos, end).includes('@internal');
    }, 
    /* state */ false, 
    /* initial */ false) ?? false);
}

/** Extractor to pull info for API reference documentation for a TypeScript class or interface. */
class PropertiesExtractor {
    declaration;
    typeChecker;
    constructor(declaration, typeChecker) {
        this.declaration = declaration;
        this.typeChecker = typeChecker;
    }
    /** Extract docs info specific to classes. */
    extract() {
        return {
            members: this.extractSignatures().concat(this.extractAllClassMembers()),
            generics: extractGenerics(this.declaration),
        };
    }
    /** Extracts doc info for a class's members. */
    extractAllClassMembers() {
        const members = [];
        for (const member of this.getMemberDeclarations()) {
            if (this.isMemberExcluded(member))
                continue;
            const memberEntry = this.extractClassMember(member);
            if (memberEntry) {
                members.push(memberEntry);
            }
        }
        return members;
    }
    /** Extract docs for a class's members (methods and properties).  */
    extractClassMember(memberDeclaration) {
        if (this.isMethod(memberDeclaration)) {
            return this.extractMethod(memberDeclaration);
        }
        else if (this.isProperty(memberDeclaration) &&
            !this.hasPrivateComputedProperty(memberDeclaration)) {
            return this.extractClassProperty(memberDeclaration);
        }
        else if (ts.isAccessor(memberDeclaration)) {
            return this.extractGetterSetter(memberDeclaration);
        }
        else if (ts.isConstructorDeclaration(memberDeclaration) &&
            memberDeclaration.parameters.length > 0) {
            return this.extractConstructor(memberDeclaration);
        }
        // We only expect methods, properties, and accessors. If we encounter something else,
        // return undefined and let the rest of the program filter it out.
        return undefined;
    }
    /** Extract docs for all call signatures in the current class/interface. */
    extractSignatures() {
        return this.computeAllSignatureDeclarations().map((s) => this.extractSignature(s));
    }
    /** Extracts docs for a class method. */
    extractMethod(methodDeclaration) {
        const functionExtractor = new FunctionExtractor(methodDeclaration.name.getText(), methodDeclaration, this.typeChecker);
        return {
            ...functionExtractor.extract(),
            memberType: MemberType.Method,
            memberTags: this.getMemberTags(methodDeclaration),
        };
    }
    /** Extracts docs for a signature element (usually inside an interface). */
    extractSignature(signature) {
        // No name for the function if we are dealing with call signatures.
        // For construct signatures we are using `new` as the name of the function for now.
        // TODO: Consider exposing a new entry type for signature types.
        const functionExtractor = new FunctionExtractor(ts.isConstructSignatureDeclaration(signature) ? 'new' : '', signature, this.typeChecker);
        return {
            ...functionExtractor.extract(),
            memberType: MemberType.Method,
            memberTags: [],
        };
    }
    /** Extracts doc info for a property declaration. */
    extractClassProperty(propertyDeclaration) {
        return {
            name: propertyDeclaration.name.getText(),
            type: extractResolvedTypeString(propertyDeclaration, this.typeChecker),
            memberType: MemberType.Property,
            memberTags: this.getMemberTags(propertyDeclaration),
            description: extractJsDocDescription(propertyDeclaration),
            jsdocTags: extractJsDocTags(propertyDeclaration),
        };
    }
    /** Extracts doc info for an accessor member (getter/setter). */
    extractGetterSetter(accessor) {
        return {
            ...this.extractClassProperty(accessor),
            memberType: ts.isGetAccessor(accessor) ? MemberType.Getter : MemberType.Setter,
        };
    }
    extractConstructor(constructorDeclaration) {
        const functionExtractor = new FunctionExtractor('constructor', constructorDeclaration, this.typeChecker);
        return {
            ...functionExtractor.extract(),
            memberType: MemberType.Method,
            memberTags: this.getMemberTags(constructorDeclaration),
        };
    }
    extractInterfaceConformance(declaration) {
        const implementClause = declaration.heritageClauses?.find((clause) => clause.token === ts.SyntaxKind.ImplementsKeyword);
        return implementClause?.types.map((m) => m.getText()) ?? [];
    }
    /** Gets the tags for a member (protected, readonly, static, etc.) */
    getMemberTags(member) {
        const tags = this.getMemberTagsFromModifiers(member.modifiers ?? []);
        if (member.questionToken) {
            tags.push(MemberTags.Optional);
        }
        if (member.parent !== this.declaration) {
            tags.push(MemberTags.Inherited);
        }
        return tags;
    }
    /** Computes all signature declarations of the class/interface. */
    computeAllSignatureDeclarations() {
        const type = this.typeChecker.getTypeAtLocation(this.declaration);
        const signatures = [...type.getCallSignatures(), ...type.getConstructSignatures()];
        const result = [];
        for (const signature of signatures) {
            const decl = signature.getDeclaration();
            if (this.isDocumentableSignature(decl) && this.isDocumentableMember(decl)) {
                result.push(decl);
            }
        }
        return result;
    }
    /** Gets all member declarations, including inherited members. */
    getMemberDeclarations() {
        // We rely on TypeScript to resolve all the inherited members to their
        // ultimate form via `getProperties`. This is important because child
        // classes may narrow types or add method overloads.
        const type = this.typeChecker.getTypeAtLocation(this.declaration);
        const members = type.getProperties();
        const constructor = type.getSymbol()?.members?.get(ts.InternalSymbolName.Constructor);
        // While the properties of the declaration type represent the properties that exist
        // on a class *instance*, static members are properties on the class symbol itself.
        const typeOfConstructor = this.typeChecker.getTypeOfSymbol(type.symbol);
        const staticMembers = typeOfConstructor.getProperties();
        const result = [];
        for (const member of [...(constructor ? [constructor] : []), ...members, ...staticMembers]) {
            // A member may have multiple declarations in the case of function overloads.
            const memberDeclarations = this.filterMethodOverloads(member.getDeclarations() ?? []);
            for (const memberDeclaration of memberDeclarations) {
                if (this.isDocumentableMember(memberDeclaration)) {
                    result.push(memberDeclaration);
                }
            }
        }
        return result;
    }
    /** The result only contains properties, method implementations and abstracts */
    filterMethodOverloads(declarations) {
        return declarations.filter((declaration, index) => {
            // Check if the declaration is a function or method
            if (ts.isFunctionDeclaration(declaration) ||
                ts.isMethodDeclaration(declaration) ||
                ts.isConstructorDeclaration(declaration)) {
                // TypeScript ensures that all declarations for a given abstract method appear consecutively.
                const nextDeclaration = declarations[index + 1];
                const isNextMethodWithSameName = nextDeclaration &&
                    ((ts.isMethodDeclaration(nextDeclaration) &&
                        nextDeclaration.name.getText() === declaration.name?.getText()) ||
                        (ts.isConstructorDeclaration(nextDeclaration) &&
                            ts.isConstructorDeclaration(declaration)));
                // Return only the last occurrence of a method to avoid overload duplication.
                // Subsequent overloads or implementations are handled separately by the function extractor.
                return !isNextMethodWithSameName;
            }
            // Include non-method declarations, such as properties, without filtering.
            return true;
        });
    }
    /** Get the tags for a member that come from the declaration modifiers. */
    getMemberTagsFromModifiers(mods) {
        const tags = [];
        for (const mod of mods) {
            const tag = this.getTagForMemberModifier(mod);
            if (tag)
                tags.push(tag);
        }
        return tags;
    }
    /** Gets the doc tag corresponding to a class member modifier (readonly, protected, etc.). */
    getTagForMemberModifier(mod) {
        switch (mod.kind) {
            case ts.SyntaxKind.StaticKeyword:
                return MemberTags.Static;
            case ts.SyntaxKind.ReadonlyKeyword:
                return MemberTags.Readonly;
            case ts.SyntaxKind.ProtectedKeyword:
                return MemberTags.Protected;
            case ts.SyntaxKind.AbstractKeyword:
                return MemberTags.Abstract;
            default:
                return undefined;
        }
    }
    /**
     * Gets whether a given class member should be excluded from public API docs.
     * This is the case if:
     *  - The member does not have a name
     *  - The member is neither a method nor property
     *  - The member is private
     *  - The member has a name that marks it as Angular-internal.
     *  - The member is marked as internal via JSDoc.
     */
    isMemberExcluded(member) {
        if (ts.isConstructorDeclaration(member)) {
            // A constructor has no name
            return false;
        }
        return (!member.name ||
            !this.isDocumentableMember(member) ||
            (!ts.isCallSignatureDeclaration(member) &&
                member.modifiers?.some((mod) => mod.kind === ts.SyntaxKind.PrivateKeyword)) ||
            member.name.getText() === 'prototype' ||
            isAngularPrivateName(member.name.getText()) ||
            isInternal(member));
    }
    /** Gets whether a class member is a method, property, or accessor. */
    isDocumentableMember(member) {
        return (this.isMethod(member) ||
            this.isProperty(member) ||
            ts.isAccessor(member) ||
            ts.isConstructorDeclaration(member) ||
            // Signatures are documentable if they are part of an interface.
            ts.isCallSignatureDeclaration(member));
    }
    /** Check if the parameter is a constructor parameter with a public modifier */
    isPublicConstructorParameterProperty(node) {
        if (ts.isParameterPropertyDeclaration(node, node.parent) && node.modifiers) {
            return node.modifiers.some((modifier) => modifier.kind === ts.SyntaxKind.PublicKeyword);
        }
        return false;
    }
    /** Gets whether a member is a property. */
    isProperty(member) {
        // Classes have declarations, interface have signatures
        return (ts.isPropertyDeclaration(member) ||
            ts.isPropertySignature(member) ||
            this.isPublicConstructorParameterProperty(member));
    }
    /** Gets whether a member is a method. */
    isMethod(member) {
        // Classes have declarations, interface have signatures
        return ts.isMethodDeclaration(member) || ts.isMethodSignature(member);
    }
    /** Gets whether the given signature declaration is documentable. */
    isDocumentableSignature(signature) {
        return (ts.isConstructSignatureDeclaration(signature) || ts.isCallSignatureDeclaration(signature));
    }
    /**
     * Check wether a member has a private computed property name like [ÉµWRITABLE_SIGNAL]
     *
     * This will prevent exposing private computed properties in the docs.
     */
    hasPrivateComputedProperty(property) {
        return (ts.isComputedPropertyName(property.name) && property.name.expression.getText().startsWith('Éµ'));
    }
}

/** Extractor to pull info for API reference documentation for a TypeScript class or interface. */
class ClassExtractor extends PropertiesExtractor {
    constructor(declaration, typeChecker) {
        super(declaration, typeChecker);
    }
    /** Extract docs info specific to classes. */
    extract() {
        return {
            name: this.declaration.name.text,
            isAbstract: this.isAbstract(),
            entryType: EntryType.UndecoratedClass,
            ...super.extract(),
            description: extractJsDocDescription(this.declaration),
            jsdocTags: extractJsDocTags(this.declaration),
            rawComment: extractRawJsDoc(this.declaration),
            extends: this.extractInheritance(this.declaration),
            implements: this.extractInterfaceConformance(this.declaration),
        };
    }
    /** Gets whether the declaration for this extractor is abstract. */
    isAbstract() {
        const modifiers = this.declaration.modifiers ?? [];
        return modifiers.some((mod) => mod.kind === ts.SyntaxKind.AbstractKeyword);
    }
    extractInheritance(declaration) {
        if (!declaration.heritageClauses) {
            return undefined;
        }
        for (const clause of declaration.heritageClauses) {
            if (clause.token === ts.SyntaxKind.ExtendsKeyword) {
                // We are assuming a single class can only extend one class.
                const types = clause.types;
                if (types.length > 0) {
                    const baseClass = types[0];
                    return baseClass.getText();
                }
            }
        }
        return undefined;
    }
}
/** Extractor to pull info for API reference documentation for an Angular directive. */
class DirectiveExtractor extends ClassExtractor {
    reference;
    metadata;
    constructor(declaration, reference, metadata, checker) {
        super(declaration, checker);
        this.reference = reference;
        this.metadata = metadata;
    }
    /** Extract docs info for directives and components (including underlying class info). */
    extract() {
        return {
            ...super.extract(),
            isStandalone: this.metadata.isStandalone,
            selector: this.metadata.selector ?? '',
            exportAs: this.metadata.exportAs ?? [],
            entryType: this.metadata.isComponent ? EntryType.Component : EntryType.Directive,
        };
    }
    /** Extracts docs info for a directive property, including input/output metadata. */
    extractClassProperty(propertyDeclaration) {
        const entry = super.extractClassProperty(propertyDeclaration);
        const inputMetadata = this.getInputMetadata(propertyDeclaration);
        if (inputMetadata) {
            entry.memberTags.push(MemberTags.Input);
            entry.inputAlias = inputMetadata.bindingPropertyName;
            entry.isRequiredInput = inputMetadata.required;
        }
        const outputMetadata = this.getOutputMetadata(propertyDeclaration);
        if (outputMetadata) {
            entry.memberTags.push(MemberTags.Output);
            entry.outputAlias = outputMetadata.bindingPropertyName;
        }
        return entry;
    }
    /** Gets the input metadata for a directive property. */
    getInputMetadata(prop) {
        const propName = prop.name.getText();
        return this.metadata.inputs?.getByClassPropertyName(propName) ?? undefined;
    }
    /** Gets the output metadata for a directive property. */
    getOutputMetadata(prop) {
        const propName = prop.name.getText();
        return this.metadata?.outputs?.getByClassPropertyName(propName) ?? undefined;
    }
}
/** Extractor to pull info for API reference documentation for an Angular pipe. */
class PipeExtractor extends ClassExtractor {
    reference;
    metadata;
    constructor(declaration, reference, metadata, typeChecker) {
        super(declaration, typeChecker);
        this.reference = reference;
        this.metadata = metadata;
    }
    extract() {
        return {
            ...super.extract(),
            pipeName: this.metadata.name,
            entryType: EntryType.Pipe,
            isStandalone: this.metadata.isStandalone,
            usage: extractPipeSyntax(this.metadata, this.declaration),
            isPure: this.metadata.isPure,
        };
    }
}
/** Extractor to pull info for API reference documentation for an Angular pipe. */
class NgModuleExtractor extends ClassExtractor {
    reference;
    metadata;
    constructor(declaration, reference, metadata, typeChecker) {
        super(declaration, typeChecker);
        this.reference = reference;
        this.metadata = metadata;
    }
    extract() {
        return {
            ...super.extract(),
            entryType: EntryType.NgModule,
        };
    }
}
/** Extracts documentation info for a class, potentially including Angular-specific info.  */
function extractClass(classDeclaration, metadataReader, typeChecker) {
    const ref = new Reference(classDeclaration);
    let extractor;
    let directiveMetadata = metadataReader.getDirectiveMetadata(ref);
    let pipeMetadata = metadataReader.getPipeMetadata(ref);
    let ngModuleMetadata = metadataReader.getNgModuleMetadata(ref);
    if (directiveMetadata) {
        extractor = new DirectiveExtractor(classDeclaration, ref, directiveMetadata, typeChecker);
    }
    else if (pipeMetadata) {
        extractor = new PipeExtractor(classDeclaration, ref, pipeMetadata, typeChecker);
    }
    else if (ngModuleMetadata) {
        extractor = new NgModuleExtractor(classDeclaration, ref, ngModuleMetadata, typeChecker);
    }
    else {
        extractor = new ClassExtractor(classDeclaration, typeChecker);
    }
    return extractor.extract();
}
function extractPipeSyntax(metadata, classDeclaration) {
    const transformParams = classDeclaration.members.find((member) => {
        return (ts.isMethodDeclaration(member) &&
            member.name &&
            ts.isIdentifier(member.name) &&
            member.name.getText() === 'transform');
    });
    let paramNames = transformParams.parameters
        // value is the first argument, it's already referenced before the pipe
        .slice(1)
        .map((param) => {
        return param.name.getText();
    });
    return `{{ value_expression | ${metadata.name}${paramNames.length ? ':' + paramNames.join(':') : ''} }}`;
}

/** Name of the tag indicating that an object literal should be shown as an enum in docs. */
const LITERAL_AS_ENUM_TAG = 'object-literal-as-enum';
/** Extracts documentation entry for a constant. */
function extractConstant(declaration, typeChecker) {
    // For constants specifically, we want to get the base type for any literal types.
    // For example, TypeScript by default extracts `const PI = 3.14` as PI having a type of the
    // literal `3.14`. We don't want this behavior for constants, since generally one wants the
    // _value_ of the constant to be able to change between releases without changing the type.
    // `VERSION` is a good example here; the version is always a `string`, but the actual value of
    // the version string shouldn't matter to the type system.
    const resolvedType = typeChecker.getBaseTypeOfLiteralType(typeChecker.getTypeAtLocation(declaration));
    // In the TS AST, the leading comment for a variable declaration is actually
    // on the ancestor `ts.VariableStatement` (since a single variable statement may
    // contain multiple variable declarations).
    const rawComment = extractRawJsDoc(declaration.parent.parent);
    const jsdocTags = extractJsDocTags(declaration);
    const description = extractJsDocDescription(declaration);
    const name = declaration.name.getText();
    // Some constants have to be treated as enums for documentation purposes.
    if (jsdocTags.some((tag) => tag.name === LITERAL_AS_ENUM_TAG)) {
        return {
            name,
            entryType: EntryType.Enum,
            members: extractLiteralPropertiesAsEnumMembers(declaration),
            rawComment,
            description,
            jsdocTags: jsdocTags.filter((tag) => tag.name !== LITERAL_AS_ENUM_TAG),
        };
    }
    return {
        name: name,
        type: typeChecker.typeToString(resolvedType),
        entryType: EntryType.Constant,
        rawComment,
        description,
        jsdocTags,
    };
}
/** Gets whether a given constant is an Angular-added const that should be ignored for docs. */
function isSyntheticAngularConstant(declaration) {
    return declaration.name.getText() === 'USED_FOR_NG_TYPE_CHECKING';
}
/**
 * Extracts the properties of a variable initialized as an object literal as if they were enum
 * members. Will throw for any variables that can't be statically analyzed easily.
 */
function extractLiteralPropertiesAsEnumMembers(declaration) {
    let initializer = declaration.initializer;
    // Unwrap `as` and parenthesized expressions.
    while (initializer &&
        (ts.isAsExpression(initializer) || ts.isParenthesizedExpression(initializer))) {
        initializer = initializer.expression;
    }
    if (initializer === undefined || !ts.isObjectLiteralExpression(initializer)) {
        throw new Error(`Declaration tagged with "${LITERAL_AS_ENUM_TAG}" must be initialized to an object literal, but received ${initializer ? ts.SyntaxKind[initializer.kind] : 'undefined'}`);
    }
    return initializer.properties.map((prop) => {
        if (!ts.isPropertyAssignment(prop) || !ts.isIdentifier(prop.name)) {
            throw new Error(`Property in declaration tagged with "${LITERAL_AS_ENUM_TAG}" must be a property assignment with a static name`);
        }
        if (!ts.isNumericLiteral(prop.initializer) && !ts.isStringLiteralLike(prop.initializer)) {
            throw new Error(`Property in declaration tagged with "${LITERAL_AS_ENUM_TAG}" must be initialized to a number or string literal`);
        }
        return {
            name: prop.name.text,
            type: `${declaration.name.getText()}.${prop.name.text}`,
            value: prop.initializer.getText(),
            memberType: MemberType.EnumItem,
            jsdocTags: extractJsDocTags(prop),
            description: extractJsDocDescription(prop),
            memberTags: [],
        };
    });
}

/** Extractor to pull info for API reference documentation for a TypeScript class or interface. */
class InterfaceExtractor extends PropertiesExtractor {
    constructor(declaration, typeChecker) {
        super(declaration, typeChecker);
    }
    /** Extract docs info specific to classes. */
    extract() {
        return {
            name: this.declaration.name.text,
            entryType: EntryType.Interface,
            ...super.extract(),
            description: extractJsDocDescription(this.declaration),
            jsdocTags: extractJsDocTags(this.declaration),
            rawComment: extractRawJsDoc(this.declaration),
            extends: this.extractInheritance(this.declaration),
            implements: this.extractInterfaceConformance(this.declaration),
        };
    }
    extractInheritance(declaration) {
        if (!declaration.heritageClauses) {
            return [];
        }
        for (const clause of declaration.heritageClauses) {
            if (clause.token === ts.SyntaxKind.ExtendsKeyword) {
                // We are assuming a single class can only extend one class.
                const types = clause.types;
                if (types.length > 0) {
                    return types.map((t) => t.getText());
                }
            }
        }
        return [];
    }
}
/** Extracts documentation info for an interface. */
function extractInterface(declaration, typeChecker) {
    const extractor = new InterfaceExtractor(declaration, typeChecker);
    return extractor.extract();
}

/** Extracts an API documentation entry for an Angular decorator. */
function extractorDecorator(declaration, typeChecker) {
    const documentedNode = getDecoratorJsDocNode(declaration, typeChecker);
    const decoratorType = getDecoratorType(declaration);
    if (!decoratorType) {
        throw new Error(`"${declaration.name.getText()} is not a decorator."`);
    }
    const members = getDecoratorProperties(declaration, typeChecker);
    let signatures = [];
    if (!members) {
        const decoratorInterface = getDecoratorDeclaration(declaration, typeChecker);
        const callSignatures = decoratorInterface.members.filter(ts.isCallSignatureDeclaration);
        signatures = getDecoratorSignatures(callSignatures, typeChecker);
    }
    return {
        name: declaration.name.getText(),
        decoratorType: decoratorType,
        entryType: EntryType.Decorator,
        rawComment: extractRawJsDoc(documentedNode),
        description: extractJsDocDescription(documentedNode),
        jsdocTags: extractJsDocTags(documentedNode),
        members,
        signatures,
    };
}
/** Gets whether the given variable declaration is an Angular decorator declaration. */
function isDecoratorDeclaration(declaration) {
    return !!getDecoratorType(declaration);
}
/** Gets whether an interface is the options interface for a decorator in the same file. */
function isDecoratorOptionsInterface(declaration) {
    return declaration
        .getSourceFile()
        .statements.some((s) => ts.isVariableStatement(s) &&
        s.declarationList.declarations.some((d) => isDecoratorDeclaration(d) && d.name.getText() === declaration.name.getText()));
}
/** Gets the type of decorator, or undefined if the declaration is not a decorator. */
function getDecoratorType(declaration) {
    // All Angular decorators are initialized with one of `makeDecorator`, `makePropDecorator`,
    // or `makeParamDecorator`.
    const initializer = declaration.initializer?.getFullText() ?? '';
    if (initializer.includes('makeDecorator'))
        return DecoratorType.Class;
    if (initializer.includes('makePropDecorator'))
        return DecoratorType.Member;
    if (initializer.includes('makeParamDecorator'))
        return DecoratorType.Parameter;
    return undefined;
}
function getDecoratorDeclaration(declaration, typeChecker) {
    const decoratorName = declaration.name.getText();
    const decoratorDeclaration = declaration;
    const decoratorType = typeChecker.getTypeAtLocation(decoratorDeclaration);
    const aliasDeclaration = decoratorType.getSymbol().getDeclarations()[0];
    const decoratorInterface = aliasDeclaration;
    if (!decoratorInterface || !ts.isInterfaceDeclaration(decoratorInterface)) {
        throw new Error(`No decorator interface found for "${decoratorName}".`);
    }
    return decoratorInterface;
}
/**
 * @returns Interface properties for decorators that are akin to interfaces eg. @Component
 * else return null for decorators that are akin to functions eg. @Inject
 */
function getDecoratorProperties(declaration, typeChecker) {
    // Some decorators like Component, Directive are basically interchangeable with a interface declaration.
    // We want to acount for that and treat them a such.
    // To determine which type of decorator we have, we check the type of the first parameter of its call signature
    const decoratorCallSig = getDecoratorJsDocNode(declaration, typeChecker);
    const decoratorFirstParam = decoratorCallSig.parameters[0];
    const firstParamType = typeChecker.getTypeAtLocation(decoratorFirstParam);
    let firstParamTypeDecl;
    if (firstParamType.isUnion()) {
        // If the first param is a union, we need to get the first type
        // This happens for example when the decorator param is optional (eg @Directive())
        const firstParamTypeUnion = firstParamType.types.find((t) => (t.flags & ts.TypeFlags.Undefined) === 0);
        firstParamTypeDecl = firstParamTypeUnion?.getSymbol()?.getDeclarations()[0];
    }
    else {
        firstParamTypeDecl = firstParamType.getSymbol()?.getDeclarations()[0];
    }
    if (!firstParamTypeDecl || !ts.isInterfaceDeclaration(firstParamTypeDecl)) {
        // At this point we either have on first param, eg for decorators without parameters
        // or we have a decorator that isn't akin to an interface
        // We will threat them as functions (in another function) and return null here
        return null;
    }
    const interfaceDeclaration = firstParamTypeDecl;
    return extractInterface(interfaceDeclaration, typeChecker).members;
}
function getDecoratorSignatures(callSignatures, typeChecker) {
    return callSignatures.map((signatureDecl) => {
        return {
            parameters: extractParams(signatureDecl.parameters, typeChecker),
            jsdocTags: extractJsDocTags(signatureDecl),
        };
    });
}
function extractParams(params, typeChecker) {
    return params.map((param) => ({
        name: param.name.getText(),
        description: extractJsDocDescription(param),
        type: getParamTypeString(param, typeChecker),
        isOptional: !!(param.questionToken || param.initializer),
        isRestParam: !!param.dotDotDotToken,
    }));
}
/**
 * Find the the interface usually suffixed with "Decorator" that describes the decorator.
 */
function getDecoratorInterface(declaration, typeChecker) {
    const name = declaration.name.getText();
    const symbol = typeChecker.getSymbolAtLocation(declaration.name);
    const decoratorType = typeChecker.getTypeOfSymbolAtLocation(symbol, symbol.valueDeclaration);
    // This is the interface xxxxDecorator
    const decoratorInterface = decoratorType.getSymbol()?.getDeclarations()[0];
    if (!decoratorInterface || !ts.isInterfaceDeclaration(decoratorInterface)) {
        throw new Error(`No decorator interface found for "${name}".`);
    }
    return decoratorInterface;
}
/**
 * Gets the call signature node that has the decorator's public JsDoc block.
 *
 * Every decorator has three parts:
 * - A const that has the actual decorator.
 * - An interface with the same name as the const that documents the decorator's options.
 * - An interface suffixed with "Decorator" that has the decorator's call signature and JsDoc block.
 *
 * For the description and JsDoc tags, we need the interface suffixed with "Decorator".
 */
function getDecoratorJsDocNode(declaration, typeChecker) {
    const name = declaration.name.getText();
    const decoratorInterface = getDecoratorInterface(declaration, typeChecker);
    // The public-facing JsDoc for each decorator is on one of its interface's call signatures.
    const callSignature = decoratorInterface.members
        .filter((node) => {
        // The description block lives on one of the call signatures for this interface.
        return ts.isCallSignatureDeclaration(node) && extractRawJsDoc(node);
    })
        .at(-1); // Get the last one, as it is the most complete
    if (!callSignature || !ts.isCallSignatureDeclaration(callSignature)) {
        throw new Error(`No call signature with JsDoc on "${name}Decorator"`);
    }
    return callSignature;
}
/**
 * Advanced function to generate the type string (as single line) for a parameter.
 * Interfaces in unions are expanded.
 */
function getParamTypeString(paramNode, typeChecker) {
    const type = typeChecker.getTypeAtLocation(paramNode);
    const printer = ts.createPrinter({ removeComments: true });
    const sourceFile = paramNode.getSourceFile();
    const replace = [];
    if (type.isUnion()) {
        // The parameter can be a union, this includes optional parameters whiceh are a union of the type and undefined.
        for (const subType of type.types) {
            const decl = subType.getSymbol()?.getDeclarations()?.[0];
            // We only care to expand interfaces
            if (decl && ts.isInterfaceDeclaration(decl) && decl.name.text !== 'Function') {
                // the Function type is actually an interface but we don't want to expand it
                replace.push({
                    initial: subType.symbol.name,
                    replacedWith: expandType(decl, sourceFile, printer),
                });
            }
        }
    }
    // Using a print here instead of typeToString as it doesn't return optional props as a union of undefined
    let result = printer
        .printNode(ts.EmitHint.Unspecified, paramNode, sourceFile)
        // Removing the parameter name, the conditional question mark and the colon (e.g. opts?: {foo: string})
        .replace(new RegExp(`${paramNode.name.getText()}\\??\: `), '')
        // Remove extra spaces/line breaks
        .replaceAll(/\s+/g, ' ');
    // Replace the types we expanded
    for (const { initial, replacedWith } of replace) {
        result = result.replace(initial, replacedWith);
    }
    return result;
}
/**
 * @return a given interface declaration as single line string
 */
function expandType(decl, sourceFile, printer) {
    const props = decl.members
        // printer will return each member with a semicolon at the end
        .map((member) => printer.printNode(ts.EmitHint.Unspecified, member, sourceFile))
        .join(' ')
        .replaceAll(/\s+/g, ' '); // Remove extra spaces/line breaks
    return `{${props}}`;
}

/** Extracts documentation entry for an enum. */
function extractEnum(declaration, typeChecker) {
    return {
        name: declaration.name.getText(),
        entryType: EntryType.Enum,
        members: extractEnumMembers(declaration, typeChecker),
        rawComment: extractRawJsDoc(declaration),
        description: extractJsDocDescription(declaration),
        jsdocTags: extractJsDocTags(declaration),
    };
}
/** Extracts doc info for an enum's members. */
function extractEnumMembers(declaration, checker) {
    return declaration.members.map((member) => ({
        name: member.name.getText(),
        type: extractResolvedTypeString(member, checker),
        value: getEnumMemberValue(member),
        memberType: MemberType.EnumItem,
        jsdocTags: extractJsDocTags(member),
        description: extractJsDocDescription(member),
        memberTags: [],
    }));
}
/** Gets the explicitly assigned value for an enum member, or an empty string if there is none. */
function getEnumMemberValue(memberNode) {
    // If the enum member has a child number literal or string literal,
    // we use that literal as the "value" of the member.
    const literal = memberNode.getChildren().find((n) => {
        return (ts.isNumericLiteral(n) ||
            ts.isStringLiteral(n) ||
            (ts.isPrefixUnaryExpression(n) &&
                n.operator === ts.SyntaxKind.MinusToken &&
                ts.isNumericLiteral(n.operand)));
    });
    return literal?.getText() ?? '';
}

/** JSDoc used to recognize an initializer API function. */
const initializerApiTag = 'initializerApiFunction';
/**
 * Checks whether the given node corresponds to an initializer API function.
 *
 * An initializer API function is a function declaration or variable declaration
 * that is explicitly annotated with `@initializerApiFunction`.
 *
 * Note: The node may be a function overload signature that is automatically
 * resolved to its implementation to detect the JSDoc tag.
 */
function isInitializerApiFunction(node, typeChecker) {
    // If this is matching an overload signature, resolve to the implementation
    // as it would hold the `@initializerApiFunction` tag.
    if (ts.isFunctionDeclaration(node) && node.name !== undefined && node.body === undefined) {
        const implementation = findImplementationOfFunction(node, typeChecker);
        if (implementation !== undefined) {
            node = implementation;
        }
    }
    if (!ts.isFunctionDeclaration(node) && !ts.isVariableDeclaration(node)) {
        return false;
    }
    let tagContainer = ts.isFunctionDeclaration(node) ? node : getContainerVariableStatement(node);
    if (tagContainer === null) {
        return false;
    }
    const tags = ts.getJSDocTags(tagContainer);
    return tags.some((t) => t.tagName.text === initializerApiTag);
}
/**
 * Extracts the given node as initializer API function and returns
 * a docs entry that can be rendered to represent the API function.
 */
function extractInitializerApiFunction(node, typeChecker) {
    if (node.name === undefined || !ts.isIdentifier(node.name)) {
        throw new Error(`Initializer API: Expected literal variable name.`);
    }
    const container = ts.isFunctionDeclaration(node) ? node : getContainerVariableStatement(node);
    if (container === null) {
        throw new Error('Initializer API: Could not find container AST node of variable.');
    }
    const name = node.name.text;
    const type = typeChecker.getTypeAtLocation(node);
    // Top-level call signatures. E.g. `input()`, `input<ReadT>(initialValue: ReadT)`. etc.
    const callFunction = extractFunctionWithOverloads(name, type, typeChecker);
    // Sub-functions like `input.required()`.
    const subFunctions = [];
    for (const property of type.getProperties()) {
        const subName = property.getName();
        const subDecl = property.getDeclarations()?.[0];
        if (subDecl === undefined || !ts.isPropertySignature(subDecl)) {
            throw new Error(`Initializer API: Could not resolve declaration of sub-property: ${name}.${subName}`);
        }
        const subType = typeChecker.getTypeAtLocation(subDecl);
        subFunctions.push(extractFunctionWithOverloads(subName, subType, typeChecker));
    }
    let jsdocTags;
    let description;
    let rawComment;
    // Extract container API documentation.
    // The container description describes the overall function, while
    // we allow the individual top-level call signatures to represent
    // their individual overloads.
    if (ts.isFunctionDeclaration(node)) {
        const implementation = findImplementationOfFunction(node, typeChecker);
        if (implementation === undefined) {
            throw new Error(`Initializer API: Could not find implementation of function: ${name}`);
        }
        callFunction.implementation = {
            name,
            entryType: EntryType.Function,
            isNewType: false,
            description: extractJsDocDescription(implementation),
            generics: extractGenerics(implementation),
            jsdocTags: extractJsDocTags(implementation),
            params: extractAllParams(implementation.parameters, typeChecker),
            rawComment: extractRawJsDoc(implementation),
            returnType: typeChecker.typeToString(typeChecker.getReturnTypeOfSignature(typeChecker.getSignatureFromDeclaration(implementation))),
        };
        jsdocTags = callFunction.implementation.jsdocTags;
        description = callFunction.implementation.description;
        rawComment = callFunction.implementation.description;
    }
    else {
        jsdocTags = extractJsDocTags(container);
        description = extractJsDocDescription(container);
        rawComment = extractRawJsDoc(container);
    }
    // Extract additional docs metadata from the initializer API JSDoc tag.
    const metadataTag = jsdocTags.find((t) => t.name === initializerApiTag);
    if (metadataTag === undefined) {
        throw new Error('Initializer API: Detected initializer API function does ' +
            `not have "@initializerApiFunction" tag: ${name}`);
    }
    let parsedMetadata = undefined;
    if (metadataTag.comment.trim() !== '') {
        try {
            parsedMetadata = JSON.parse(metadataTag.comment);
        }
        catch (e) {
            throw new Error(`Could not parse initializer API function metadata: ${e}`);
        }
    }
    return {
        entryType: EntryType.InitializerApiFunction,
        name,
        description,
        jsdocTags,
        rawComment,
        callFunction,
        subFunctions,
        __docsMetadata__: parsedMetadata,
    };
}
/**
 * Gets the container node of the given variable declaration.
 *
 * A variable declaration may be annotated with e.g. `@initializerApiFunction`,
 * but the JSDoc tag is not attached to the node, but to the containing variable
 * statement.
 */
function getContainerVariableStatement(node) {
    if (!ts.isVariableDeclarationList(node.parent)) {
        return null;
    }
    if (!ts.isVariableStatement(node.parent.parent)) {
        return null;
    }
    return node.parent.parent;
}
/**
 * Extracts all given signatures and returns them as a function with
 * overloads.
 *
 * The implementation of the function may be attached later, or may
 * be non-existent. E.g. initializer APIs declared using an interface
 * with call signatures do not have an associated implementation function
 * that is statically retrievable. The constant holds the overall API description.
 */
function extractFunctionWithOverloads(name, type, typeChecker) {
    return {
        name,
        signatures: extractCallSignatures(name, typeChecker, type),
        // Implementation may be populated later.
        implementation: null,
    };
}

/** Extract the documentation entry for a type alias. */
function extractTypeAlias(declaration) {
    // TODO: this does not yet resolve type queries (`typeof`). We may want to
    //     fix this eventually, but for now it does not appear that any type aliases in
    //     Angular's public API rely on this.
    return {
        name: declaration.name.getText(),
        type: declaration.type.getText(),
        entryType: EntryType.TypeAlias,
        generics: extractGenerics(declaration),
        rawComment: extractRawJsDoc(declaration),
        description: extractJsDocDescription(declaration),
        jsdocTags: extractJsDocTags(declaration),
    };
}

/**
 * For a given SourceFile, it extracts all imported symbols from other Angular packages.
 *
 * @returns a map Symbol => Package, eg: ApplicationRef => @angular/core
 */
function getImportedSymbols(sourceFile) {
    const importSpecifiers = new Map();
    function visit(node) {
        if (ts.isImportDeclaration(node)) {
            let moduleSpecifier = node.moduleSpecifier.getText(sourceFile).replace(/['"]/g, '');
            if (moduleSpecifier.startsWith('@angular/')) {
                const namedBindings = node.importClause?.namedBindings;
                if (namedBindings && ts.isNamedImports(namedBindings)) {
                    namedBindings.elements.forEach((importSpecifier) => {
                        const importName = importSpecifier.name.text;
                        const importAlias = importSpecifier.propertyName
                            ? importSpecifier.propertyName.text
                            : undefined;
                        importSpecifiers.set(importAlias ?? importName, moduleSpecifier);
                    });
                }
            }
        }
        ts.forEachChild(node, visit);
    }
    visit(sourceFile);
    return importSpecifiers;
}

/**
 * Extracts all information from a source file that may be relevant for generating
 * public API documentation.
 */
class DocsExtractor {
    typeChecker;
    metadataReader;
    constructor(typeChecker, metadataReader) {
        this.typeChecker = typeChecker;
        this.metadataReader = metadataReader;
    }
    /**
     * Gets the set of all documentable entries from a source file, including
     * declarations that are re-exported from this file as an entry-point.
     *
     * @param sourceFile The file from which to extract documentable entries.
     */
    extractAll(sourceFile, rootDir, privateModules) {
        const entries = [];
        const symbols = new Map();
        const exportedDeclarations = this.getExportedDeclarations(sourceFile);
        for (const [exportName, node] of exportedDeclarations) {
            // Skip any symbols with an Angular-internal name.
            if (isAngularPrivateName(exportName)) {
                continue;
            }
            const entry = this.extractDeclaration(node);
            if (entry && !isIgnoredDocEntry(entry)) {
                // The source file parameter is the package entry: the index.ts
                // We want the real source file of the declaration.
                const realSourceFile = node.getSourceFile();
                /**
                 * The `sourceFile` from `extractAll` is the main entry-point file of a package.
                 * Usually following a format like `export * from './public_api';`, simply re-exporting.
                 * It is necessary to pick-up every import from the actual source files
                 * where declarations are living, so that we can determine what symbols
                 * are actually referenced in the context of that particular declaration
                 * By doing this, the generation remains independent from other packages
                 */
                const importedSymbols = getImportedSymbols(realSourceFile);
                importedSymbols.forEach((moduleName, symbolName) => {
                    if (symbolName.startsWith('Éµ') || privateModules.has(moduleName)) {
                        return;
                    }
                    if (symbols.has(symbolName) && symbols.get(symbolName) !== moduleName) {
                        // If this ever throws, we need to improve the symbol extraction strategy
                        throw new Error(`Ambigous symbol \`${symbolName}\` exported by both ${symbols.get(symbolName)} & ${moduleName}`);
                    }
                    symbols.set(symbolName, moduleName);
                });
                // Set the source code references for the extracted entry.
                entry.source = {
                    filePath: getRelativeFilePath(realSourceFile, rootDir),
                    // Start & End are off by 1
                    startLine: ts.getLineAndCharacterOfPosition(realSourceFile, node.getStart()).line + 1,
                    endLine: ts.getLineAndCharacterOfPosition(realSourceFile, node.getEnd()).line + 1,
                };
                // The exported name of an API may be different from its declaration name, so
                // use the declaration name.
                entries.push({ ...entry, name: exportName });
            }
        }
        return { entries, symbols };
    }
    /** Extract the doc entry for a single declaration. */
    extractDeclaration(node) {
        // Ignore anonymous classes.
        if (isNamedClassDeclaration(node)) {
            return extractClass(node, this.metadataReader, this.typeChecker);
        }
        if (isInitializerApiFunction(node, this.typeChecker)) {
            return extractInitializerApiFunction(node, this.typeChecker);
        }
        if (ts.isInterfaceDeclaration(node) && !isIgnoredInterface(node)) {
            return extractInterface(node, this.typeChecker);
        }
        if (ts.isFunctionDeclaration(node)) {
            // Name is guaranteed to be set, because it's exported directly.
            const functionExtractor = new FunctionExtractor(node.name.getText(), node, this.typeChecker);
            return functionExtractor.extract();
        }
        if (ts.isVariableDeclaration(node) && !isSyntheticAngularConstant(node)) {
            return isDecoratorDeclaration(node)
                ? extractorDecorator(node, this.typeChecker)
                : extractConstant(node, this.typeChecker);
        }
        if (ts.isTypeAliasDeclaration(node)) {
            return extractTypeAlias(node);
        }
        if (ts.isEnumDeclaration(node)) {
            return extractEnum(node, this.typeChecker);
        }
        return null;
    }
    /** Gets the list of exported declarations for doc extraction. */
    getExportedDeclarations(sourceFile) {
        // Use the reflection host to get all the exported declarations from this
        // source file entry point.
        const reflector = new TypeScriptReflectionHost(this.typeChecker, false, true);
        const exportedDeclarationMap = reflector.getExportsOfModule(sourceFile);
        // Augment each declaration with the exported name in the public API.
        let exportedDeclarations = Array.from(exportedDeclarationMap?.entries() ?? []).map(([exportName, declaration]) => [exportName, declaration.node]);
        // Sort the declaration nodes into declaration position because their order is lost in
        // reading from the export map. This is primarily useful for testing and debugging.
        return exportedDeclarations.sort(([a, declarationA], [b, declarationB]) => declarationA.pos - declarationB.pos);
    }
}
/** Gets whether an interface should be ignored for docs extraction. */
function isIgnoredInterface(node) {
    // We filter out all interfaces that end with "Decorator" because we capture their
    // types as part of the main decorator entry (which are declared as constants).
    // This approach to dealing with decorators is admittedly fuzzy, but this aspect of
    // the framework's source code is unlikely to change. We also filter out the interfaces
    // that contain the decorator options.
    return node.name.getText().endsWith('Decorator') || isDecoratorOptionsInterface(node);
}
/**
 * Whether the doc entry should be ignored.
 *
 * Note: We cannot check whether a node is marked as docs private
 * before extraction because the extractor may find the attached
 * JSDoc tags on different AST nodes. For example, a variable declaration
 * never has JSDoc tags attached, but rather the parent variable statement.
 */
function isIgnoredDocEntry(entry) {
    const isDocsPrivate = entry.jsdocTags.find((e) => e.name === 'docsPrivate');
    if (isDocsPrivate !== undefined && isDocsPrivate.comment === '') {
        throw new Error(`Docs extraction: Entry "${entry.name}" is marked as ` +
            `"@docsPrivate" but without reasoning.`);
    }
    return isDocsPrivate !== undefined;
}
function getRelativeFilePath(sourceFile, rootDir) {
    const fullPath = sourceFile.fileName;
    const relativePath = fullPath.replace(rootDir, '');
    return relativePath;
}

/**
 * Produce `ts.Diagnostic`s for classes that are visible from exported types (e.g. directives
 * exposed by exported `NgModule`s) that are not themselves exported.
 *
 * This function reconciles two concepts:
 *
 * A class is Exported if it's exported from the main library `entryPoint` file.
 * A class is Visible if, via Angular semantics, a downstream consumer can import an Exported class
 * and be affected by the class in question. For example, an Exported NgModule may expose a
 * directive class to its consumers. Consumers that import the NgModule may have the directive
 * applied to elements in their templates. In this case, the directive is considered Visible.
 *
 * `checkForPrivateExports` attempts to verify that all Visible classes are Exported, and report
 * `ts.Diagnostic`s for those that aren't.
 *
 * @param entryPoint `ts.SourceFile` of the library's entrypoint, which should export the library's
 * public API.
 * @param checker `ts.TypeChecker` for the current program.
 * @param refGraph `ReferenceGraph` tracking the visibility of Angular types.
 * @returns an array of `ts.Diagnostic`s representing errors when visible classes are not exported
 * properly.
 */
function checkForPrivateExports(entryPoint, checker, refGraph) {
    const diagnostics = [];
    // Firstly, compute the exports of the entry point. These are all the Exported classes.
    const topLevelExports = new Set();
    // Do this via `ts.TypeChecker.getExportsOfModule`.
    const moduleSymbol = checker.getSymbolAtLocation(entryPoint);
    if (moduleSymbol === undefined) {
        throw new Error(`Internal error: failed to get symbol for entrypoint`);
    }
    const exportedSymbols = checker.getExportsOfModule(moduleSymbol);
    // Loop through the exported symbols, de-alias if needed, and add them to `topLevelExports`.
    // TODO(alxhub): use proper iteration when build.sh is removed. (#27762)
    exportedSymbols.forEach((symbol) => {
        if (symbol.flags & ts.SymbolFlags.Alias) {
            symbol = checker.getAliasedSymbol(symbol);
        }
        const decl = symbol.valueDeclaration;
        if (decl !== undefined) {
            topLevelExports.add(decl);
        }
    });
    // Next, go through each exported class and expand it to the set of classes it makes Visible,
    // using the `ReferenceGraph`. For each Visible class, verify that it's also Exported, and queue
    // an error if it isn't. `checkedSet` ensures only one error is queued per class.
    const checkedSet = new Set();
    // Loop through each Exported class.
    // TODO(alxhub): use proper iteration when the legacy build is removed. (#27762)
    topLevelExports.forEach((mainExport) => {
        // Loop through each class made Visible by the Exported class.
        refGraph.transitiveReferencesOf(mainExport).forEach((transitiveReference) => {
            // Skip classes which have already been checked.
            if (checkedSet.has(transitiveReference)) {
                return;
            }
            checkedSet.add(transitiveReference);
            // Verify that the Visible class is also Exported.
            if (!topLevelExports.has(transitiveReference)) {
                // This is an error, `mainExport` makes `transitiveReference` Visible, but
                // `transitiveReference` is not Exported from the entrypoint. Construct a diagnostic to
                // give to the user explaining the situation.
                const descriptor = getDescriptorOfDeclaration(transitiveReference);
                const name = getNameOfDeclaration(transitiveReference);
                // Construct the path of visibility, from `mainExport` to `transitiveReference`.
                let visibleVia = 'NgModule exports';
                const transitivePath = refGraph.pathFrom(mainExport, transitiveReference);
                if (transitivePath !== null) {
                    visibleVia = transitivePath.map((seg) => getNameOfDeclaration(seg)).join(' -> ');
                }
                const diagnostic = {
                    category: ts.DiagnosticCategory.Error,
                    code: ngErrorCode(exports.ErrorCode.SYMBOL_NOT_EXPORTED),
                    file: transitiveReference.getSourceFile(),
                    ...getPosOfDeclaration(transitiveReference),
                    messageText: `Unsupported private ${descriptor} ${name}. This ${descriptor} is visible to consumers via ${visibleVia}, but is not exported from the top-level library entrypoint.`,
                };
                diagnostics.push(diagnostic);
            }
        });
    });
    return diagnostics;
}
function getPosOfDeclaration(decl) {
    const node = getIdentifierOfDeclaration(decl) || decl;
    return {
        start: node.getStart(),
        length: node.getEnd() + 1 - node.getStart(),
    };
}
function getIdentifierOfDeclaration(decl) {
    if ((ts.isClassDeclaration(decl) ||
        ts.isVariableDeclaration(decl) ||
        ts.isFunctionDeclaration(decl)) &&
        decl.name !== undefined &&
        ts.isIdentifier(decl.name)) {
        return decl.name;
    }
    else {
        return null;
    }
}
function getNameOfDeclaration(decl) {
    const id = getIdentifierOfDeclaration(decl);
    return id !== null ? id.text : '(unnamed)';
}
function getDescriptorOfDeclaration(decl) {
    switch (decl.kind) {
        case ts.SyntaxKind.ClassDeclaration:
            return 'class';
        case ts.SyntaxKind.FunctionDeclaration:
            return 'function';
        case ts.SyntaxKind.VariableDeclaration:
            return 'variable';
        case ts.SyntaxKind.EnumDeclaration:
            return 'enum';
        default:
            return 'declaration';
    }
}

class ReferenceGraph {
    references = new Map();
    add(from, to) {
        if (!this.references.has(from)) {
            this.references.set(from, new Set());
        }
        this.references.get(from).add(to);
    }
    transitiveReferencesOf(target) {
        const set = new Set();
        this.collectTransitiveReferences(set, target);
        return set;
    }
    pathFrom(source, target) {
        return this.collectPathFrom(source, target, new Set());
    }
    collectPathFrom(source, target, seen) {
        if (source === target) {
            // Looking for a path from the target to itself - that path is just the target. This is the
            // "base case" of the search.
            return [target];
        }
        else if (seen.has(source)) {
            // The search has already looked through this source before.
            return null;
        }
        // Consider outgoing edges from `source`.
        seen.add(source);
        if (!this.references.has(source)) {
            // There are no outgoing edges from `source`.
            return null;
        }
        else {
            // Look through the outgoing edges of `source`.
            // TODO(alxhub): use proper iteration when the legacy build is removed. (#27762)
            let candidatePath = null;
            this.references.get(source).forEach((edge) => {
                // Early exit if a path has already been found.
                if (candidatePath !== null) {
                    return;
                }
                // Look for a path from this outgoing edge to `target`.
                const partialPath = this.collectPathFrom(edge, target, seen);
                if (partialPath !== null) {
                    // A path exists from `edge` to `target`. Insert `source` at the beginning.
                    candidatePath = [source, ...partialPath];
                }
            });
            return candidatePath;
        }
    }
    collectTransitiveReferences(set, decl) {
        if (this.references.has(decl)) {
            // TODO(alxhub): use proper iteration when the legacy build is removed. (#27762)
            this.references.get(decl).forEach((ref) => {
                if (!set.has(ref)) {
                    set.add(ref);
                    this.collectTransitiveReferences(set, ref);
                }
            });
        }
    }
}

/**
 * An implementation of the `DependencyTracker` dependency graph API.
 *
 * The `FileDependencyGraph`'s primary job is to determine whether a given file has "logically"
 * changed, given the set of physical changes (direct changes to files on disk).
 *
 * A file is logically changed if at least one of three conditions is met:
 *
 * 1. The file itself has physically changed.
 * 2. One of its dependencies has physically changed.
 * 3. One of its resource dependencies has physically changed.
 */
class FileDependencyGraph {
    nodes = new Map();
    addDependency(from, on) {
        this.nodeFor(from).dependsOn.add(absoluteFromSourceFile(on));
    }
    addResourceDependency(from, resource) {
        this.nodeFor(from).usesResources.add(resource);
    }
    recordDependencyAnalysisFailure(file) {
        this.nodeFor(file).failedAnalysis = true;
    }
    getResourceDependencies(from) {
        const node = this.nodes.get(from);
        return node ? [...node.usesResources] : [];
    }
    /**
     * Update the current dependency graph from a previous one, incorporating a set of physical
     * changes.
     *
     * This method performs two tasks:
     *
     * 1. For files which have not logically changed, their dependencies from `previous` are added to
     *    `this` graph.
     * 2. For files which have logically changed, they're added to a set of logically changed files
     *    which is eventually returned.
     *
     * In essence, for build `n`, this method performs:
     *
     * G(n) + L(n) = G(n - 1) + P(n)
     *
     * where:
     *
     * G(n) = the dependency graph of build `n`
     * L(n) = the logically changed files from build n - 1 to build n.
     * P(n) = the physically changed files from build n - 1 to build n.
     */
    updateWithPhysicalChanges(previous, changedTsPaths, deletedTsPaths, changedResources) {
        const logicallyChanged = new Set();
        for (const sf of previous.nodes.keys()) {
            const sfPath = absoluteFromSourceFile(sf);
            const node = previous.nodeFor(sf);
            if (isLogicallyChanged(sf, node, changedTsPaths, deletedTsPaths, changedResources)) {
                logicallyChanged.add(sfPath);
            }
            else if (!deletedTsPaths.has(sfPath)) {
                this.nodes.set(sf, {
                    dependsOn: new Set(node.dependsOn),
                    usesResources: new Set(node.usesResources),
                    failedAnalysis: false,
                });
            }
        }
        return logicallyChanged;
    }
    nodeFor(sf) {
        if (!this.nodes.has(sf)) {
            this.nodes.set(sf, {
                dependsOn: new Set(),
                usesResources: new Set(),
                failedAnalysis: false,
            });
        }
        return this.nodes.get(sf);
    }
}
/**
 * Determine whether `sf` has logically changed, given its dependencies and the set of physically
 * changed files and resources.
 */
function isLogicallyChanged(sf, node, changedTsPaths, deletedTsPaths, changedResources) {
    // A file is assumed to have logically changed if its dependencies could not be determined
    // accurately.
    if (node.failedAnalysis) {
        return true;
    }
    const sfPath = absoluteFromSourceFile(sf);
    // A file is logically changed if it has physically changed itself (including being deleted).
    if (changedTsPaths.has(sfPath) || deletedTsPaths.has(sfPath)) {
        return true;
    }
    // A file is logically changed if one of its dependencies has physically changed.
    for (const dep of node.dependsOn) {
        if (changedTsPaths.has(dep) || deletedTsPaths.has(dep)) {
            return true;
        }
    }
    // A file is logically changed if one of its resources has physically changed.
    for (const dep of node.usesResources) {
        if (changedResources.has(dep)) {
            return true;
        }
    }
    return false;
}

/**
 * Discriminant of the `IncrementalState` union.
 */
var IncrementalStateKind;
(function (IncrementalStateKind) {
    IncrementalStateKind[IncrementalStateKind["Fresh"] = 0] = "Fresh";
    IncrementalStateKind[IncrementalStateKind["Delta"] = 1] = "Delta";
    IncrementalStateKind[IncrementalStateKind["Analyzed"] = 2] = "Analyzed";
})(IncrementalStateKind || (IncrementalStateKind = {}));

/**
 * Discriminant of the `Phase` type union.
 */
var PhaseKind;
(function (PhaseKind) {
    PhaseKind[PhaseKind["Analysis"] = 0] = "Analysis";
    PhaseKind[PhaseKind["TypeCheckAndEmit"] = 1] = "TypeCheckAndEmit";
})(PhaseKind || (PhaseKind = {}));
/**
 * Manages the incremental portion of an Angular compilation, allowing for reuse of a prior
 * compilation if available, and producing an output state for reuse of the current compilation in a
 * future one.
 */
class IncrementalCompilation {
    depGraph;
    versions;
    step;
    phase;
    /**
     * `IncrementalState` of this compilation if it were to be reused in a subsequent incremental
     * compilation at the current moment.
     *
     * Exposed via the `state` read-only getter.
     */
    _state;
    constructor(state, depGraph, versions, step) {
        this.depGraph = depGraph;
        this.versions = versions;
        this.step = step;
        this._state = state;
        // The compilation begins in analysis phase.
        this.phase = {
            kind: PhaseKind.Analysis,
            semanticDepGraphUpdater: new SemanticDepGraphUpdater(step !== null ? step.priorState.semanticDepGraph : null),
        };
    }
    /**
     * Begin a fresh `IncrementalCompilation`.
     */
    static fresh(program, versions) {
        const state = {
            kind: IncrementalStateKind.Fresh,
        };
        return new IncrementalCompilation(state, new FileDependencyGraph(), versions, /* reuse */ null);
    }
    static incremental(program, newVersions, oldProgram, oldState, modifiedResourceFiles, perf) {
        return perf.inPhase(exports.PerfPhase.Reconciliation, () => {
            const physicallyChangedTsFiles = new Set();
            const changedResourceFiles = new Set(modifiedResourceFiles ?? []);
            let priorAnalysis;
            switch (oldState.kind) {
                case IncrementalStateKind.Fresh:
                    // Since this line of program has never been successfully analyzed to begin with, treat
                    // this as a fresh compilation.
                    return IncrementalCompilation.fresh(program, newVersions);
                case IncrementalStateKind.Analyzed:
                    // The most recent program was analyzed successfully, so we can use that as our prior
                    // state and don't need to consider any other deltas except changes in the most recent
                    // program.
                    priorAnalysis = oldState;
                    break;
                case IncrementalStateKind.Delta:
                    // There is an ancestor program which was analyzed successfully and can be used as a
                    // starting point, but we need to determine what's changed since that program.
                    priorAnalysis = oldState.lastAnalyzedState;
                    for (const sfPath of oldState.physicallyChangedTsFiles) {
                        physicallyChangedTsFiles.add(sfPath);
                    }
                    for (const resourcePath of oldState.changedResourceFiles) {
                        changedResourceFiles.add(resourcePath);
                    }
                    break;
            }
            const oldVersions = priorAnalysis.versions;
            const oldFilesArray = oldProgram.getSourceFiles().map(toOriginalSourceFile);
            const oldFiles = new Set(oldFilesArray);
            const deletedTsFiles = new Set(oldFilesArray.map((sf) => absoluteFromSourceFile(sf)));
            for (const possiblyRedirectedNewFile of program.getSourceFiles()) {
                const sf = toOriginalSourceFile(possiblyRedirectedNewFile);
                const sfPath = absoluteFromSourceFile(sf);
                // Since we're seeing a file in the incoming program with this name, it can't have been
                // deleted.
                deletedTsFiles.delete(sfPath);
                if (oldFiles.has(sf)) {
                    // This source file has the same object identity as in the previous program. We need to
                    // determine if it's really the same file, or if it might have changed versions since the
                    // last program without changing its identity.
                    // If there's no version information available, then this is the same file, and we can
                    // skip it.
                    if (oldVersions === null || newVersions === null) {
                        continue;
                    }
                    // If a version is available for the file from both the prior and the current program, and
                    // that version is the same, then this is the same file, and we can skip it.
                    if (oldVersions.has(sfPath) &&
                        newVersions.has(sfPath) &&
                        oldVersions.get(sfPath) === newVersions.get(sfPath)) {
                        continue;
                    }
                    // Otherwise, assume that the file has changed. Either its versions didn't match, or we
                    // were missing version information about it on one side for some reason.
                }
                // Bail out if a .d.ts file changes - the semantic dep graph is not able to process such
                // changes correctly yet.
                if (sf.isDeclarationFile) {
                    return IncrementalCompilation.fresh(program, newVersions);
                }
                // The file has changed physically, so record it.
                physicallyChangedTsFiles.add(sfPath);
            }
            // Remove any files that have been deleted from the list of physical changes.
            for (const deletedFileName of deletedTsFiles) {
                physicallyChangedTsFiles.delete(resolve(deletedFileName));
            }
            // Use the prior dependency graph to project physical changes into a set of logically changed
            // files.
            const depGraph = new FileDependencyGraph();
            const logicallyChangedTsFiles = depGraph.updateWithPhysicalChanges(priorAnalysis.depGraph, physicallyChangedTsFiles, deletedTsFiles, changedResourceFiles);
            // Physically changed files aren't necessarily counted as logically changed by the dependency
            // graph (files do not have edges to themselves), so add them to the logical changes
            // explicitly.
            for (const sfPath of physicallyChangedTsFiles) {
                logicallyChangedTsFiles.add(sfPath);
            }
            // Start off in a `DeltaIncrementalState` as a delta against the previous successful analysis,
            // until this compilation completes its own analysis.
            const state = {
                kind: IncrementalStateKind.Delta,
                physicallyChangedTsFiles,
                changedResourceFiles,
                lastAnalyzedState: priorAnalysis,
            };
            return new IncrementalCompilation(state, depGraph, newVersions, {
                priorState: priorAnalysis,
                logicallyChangedTsFiles,
            });
        });
    }
    get state() {
        return this._state;
    }
    get semanticDepGraphUpdater() {
        if (this.phase.kind !== PhaseKind.Analysis) {
            throw new Error(`AssertionError: Cannot update the SemanticDepGraph after analysis completes`);
        }
        return this.phase.semanticDepGraphUpdater;
    }
    recordSuccessfulAnalysis(traitCompiler) {
        if (this.phase.kind !== PhaseKind.Analysis) {
            throw new Error(`AssertionError: Incremental compilation in phase ${PhaseKind[this.phase.kind]}, expected Analysis`);
        }
        const { needsEmit, needsTypeCheckEmit, newGraph } = this.phase.semanticDepGraphUpdater.finalize();
        // Determine the set of files which have already been emitted.
        let emitted;
        if (this.step === null) {
            // Since there is no prior compilation, no files have yet been emitted.
            emitted = new Set();
        }
        else {
            // Begin with the files emitted by the prior successful compilation, but remove those which we
            // know need to bee re-emitted.
            emitted = new Set(this.step.priorState.emitted);
            // Files need re-emitted if they've logically changed.
            for (const sfPath of this.step.logicallyChangedTsFiles) {
                emitted.delete(sfPath);
            }
            // Files need re-emitted if they've semantically changed.
            for (const sfPath of needsEmit) {
                emitted.delete(sfPath);
            }
        }
        // Transition to a successfully analyzed compilation. At this point, a subsequent compilation
        // could use this state as a starting point.
        this._state = {
            kind: IncrementalStateKind.Analyzed,
            versions: this.versions,
            depGraph: this.depGraph,
            semanticDepGraph: newGraph,
            priorAnalysis: traitCompiler.getAnalyzedRecords(),
            typeCheckResults: null,
            emitted,
        };
        // We now enter the type-check and emit phase of compilation.
        this.phase = {
            kind: PhaseKind.TypeCheckAndEmit,
            needsEmit,
            needsTypeCheckEmit,
        };
    }
    recordSuccessfulTypeCheck(results) {
        if (this._state.kind !== IncrementalStateKind.Analyzed) {
            throw new Error(`AssertionError: Expected successfully analyzed compilation.`);
        }
        else if (this.phase.kind !== PhaseKind.TypeCheckAndEmit) {
            throw new Error(`AssertionError: Incremental compilation in phase ${PhaseKind[this.phase.kind]}, expected TypeCheck`);
        }
        this._state.typeCheckResults = results;
    }
    recordSuccessfulEmit(sf) {
        if (this._state.kind !== IncrementalStateKind.Analyzed) {
            throw new Error(`AssertionError: Expected successfully analyzed compilation.`);
        }
        this._state.emitted.add(absoluteFromSourceFile(sf));
    }
    priorAnalysisFor(sf) {
        if (this.step === null) {
            return null;
        }
        const sfPath = absoluteFromSourceFile(sf);
        // If the file has logically changed, its previous analysis cannot be reused.
        if (this.step.logicallyChangedTsFiles.has(sfPath)) {
            return null;
        }
        const priorAnalysis = this.step.priorState.priorAnalysis;
        if (!priorAnalysis.has(sf)) {
            return null;
        }
        return priorAnalysis.get(sf);
    }
    priorTypeCheckingResultsFor(sf) {
        if (this.phase.kind !== PhaseKind.TypeCheckAndEmit) {
            throw new Error(`AssertionError: Expected successfully analyzed compilation.`);
        }
        if (this.step === null) {
            return null;
        }
        const sfPath = absoluteFromSourceFile(sf);
        // If the file has logically changed, or its template type-checking results have semantically
        // changed, then past type-checking results cannot be reused.
        if (this.step.logicallyChangedTsFiles.has(sfPath) ||
            this.phase.needsTypeCheckEmit.has(sfPath)) {
            return null;
        }
        // Past results also cannot be reused if they're not available.
        if (this.step.priorState.typeCheckResults === null ||
            !this.step.priorState.typeCheckResults.has(sfPath)) {
            return null;
        }
        const priorResults = this.step.priorState.typeCheckResults.get(sfPath);
        // If the past results relied on inlining, they're not safe for reuse.
        if (priorResults.hasInlines) {
            return null;
        }
        return priorResults;
    }
    safeToSkipEmit(sf) {
        // If this is a fresh compilation, it's never safe to skip an emit.
        if (this.step === null) {
            return false;
        }
        const sfPath = absoluteFromSourceFile(sf);
        // If the file has itself logically changed, it must be emitted.
        if (this.step.logicallyChangedTsFiles.has(sfPath)) {
            return false;
        }
        if (this.phase.kind !== PhaseKind.TypeCheckAndEmit) {
            throw new Error(`AssertionError: Expected successful analysis before attempting to emit files`);
        }
        // If during analysis it was determined that this file has semantically changed, it must be
        // emitted.
        if (this.phase.needsEmit.has(sfPath)) {
            return false;
        }
        // Generally it should be safe to assume here that the file was previously emitted by the last
        // successful compilation. However, as a defense-in-depth against incorrectness, we explicitly
        // check that the last emit included this file, and re-emit it otherwise.
        return this.step.priorState.emitted.has(sfPath);
    }
}
/**
 * To accurately detect whether a source file was affected during an incremental rebuild, the
 * "original" source file needs to be consistently used.
 *
 * First, TypeScript may have created source file redirects when declaration files of the same
 * version of a library are included multiple times. The non-redirected source file should be used
 * to detect changes, as otherwise the redirected source files cause a mismatch when compared to
 * a prior program.
 *
 * Second, the program that is used for template type checking may contain mutated source files, if
 * inline type constructors or inline template type-check blocks had to be used. Such source files
 * store their original, non-mutated source file from the original program in a symbol. For
 * computing the affected files in an incremental build this original source file should be used, as
 * the mutated source file would always be considered affected.
 */
function toOriginalSourceFile(sf) {
    const unredirectedSf = toUnredirectedSourceFile(sf);
    const originalFile = unredirectedSf[NgOriginalFile];
    if (originalFile !== undefined) {
        return originalFile;
    }
    else {
        return unredirectedSf;
    }
}

/**
 * Describes the kind of identifier found in a template.
 */
var IdentifierKind;
(function (IdentifierKind) {
    IdentifierKind[IdentifierKind["Property"] = 0] = "Property";
    IdentifierKind[IdentifierKind["Method"] = 1] = "Method";
    IdentifierKind[IdentifierKind["Element"] = 2] = "Element";
    IdentifierKind[IdentifierKind["Template"] = 3] = "Template";
    IdentifierKind[IdentifierKind["Attribute"] = 4] = "Attribute";
    IdentifierKind[IdentifierKind["Reference"] = 5] = "Reference";
    IdentifierKind[IdentifierKind["Variable"] = 6] = "Variable";
    IdentifierKind[IdentifierKind["LetDeclaration"] = 7] = "LetDeclaration";
    IdentifierKind[IdentifierKind["Component"] = 8] = "Component";
    IdentifierKind[IdentifierKind["Directive"] = 9] = "Directive";
})(IdentifierKind || (IdentifierKind = {}));
/**
 * Describes the absolute byte offsets of a text anchor in a source code.
 */
class AbsoluteSourceSpan {
    start;
    end;
    constructor(start, end) {
        this.start = start;
        this.end = end;
    }
}

/**
 * A context for storing indexing information about components of a program.
 *
 * An `IndexingContext` collects component and template analysis information from
 * `DecoratorHandler`s and exposes them to be indexed.
 */
class IndexingContext {
    components = new Set();
    /**
     * Adds a component to the context.
     */
    addComponent(info) {
        this.components.add(info);
    }
}

/**
 * Visits the AST of a parsed Angular template. Discovers and stores
 * identifiers of interest, deferring to an `ExpressionVisitor` as needed.
 */
let TemplateVisitor$1 = class TemplateVisitor extends o.CombinedRecursiveAstVisitor {
    boundTemplate;
    // Identifiers of interest found in the template.
    identifiers = new Set();
    errors = [];
    currentAstWithSource = null;
    // Map of targets in a template to their identifiers.
    targetIdentifierCache = new Map();
    // Map of elements and templates to their identifiers.
    directiveHostIdentifierCache = new Map();
    /**
     * Creates a template visitor for a bound template target. The bound target can be used when
     * deferred to the expression visitor to get information about the target of an expression.
     *
     * @param boundTemplate bound template target
     */
    constructor(boundTemplate) {
        super();
        this.boundTemplate = boundTemplate;
    }
    /**
     * Add an identifier for an HTML element and visit its children recursively.
     *
     * @param element
     */
    visitElement(element) {
        const elementIdentifier = this.directiveHostToIdentifier(element);
        if (elementIdentifier !== null) {
            this.identifiers.add(elementIdentifier);
        }
        super.visitElement(element);
    }
    visitTemplate(template) {
        const templateIdentifier = this.directiveHostToIdentifier(template);
        if (templateIdentifier !== null) {
            this.identifiers.add(templateIdentifier);
        }
        super.visitTemplate(template);
    }
    visitReference(reference) {
        const referenceIdentifier = this.targetToIdentifier(reference);
        if (referenceIdentifier !== null) {
            this.identifiers.add(referenceIdentifier);
        }
        super.visitReference(reference);
    }
    visitVariable(variable) {
        const variableIdentifier = this.targetToIdentifier(variable);
        if (variableIdentifier !== null) {
            this.identifiers.add(variableIdentifier);
        }
        super.visitVariable(variable);
    }
    visitLetDeclaration(decl) {
        const identifier = this.targetToIdentifier(decl);
        if (identifier !== null) {
            this.identifiers.add(identifier);
        }
        super.visitLetDeclaration(decl);
    }
    visitComponent(component) {
        const identifier = this.directiveHostToIdentifier(component);
        if (identifier !== null) {
            this.identifiers.add(identifier);
        }
        super.visitComponent(component);
    }
    visitDirective(directive) {
        const identifier = this.directiveHostToIdentifier(directive);
        if (identifier !== null) {
            this.identifiers.add(identifier);
        }
        super.visitDirective(directive);
    }
    visitPropertyRead(ast) {
        this.visitIdentifier(ast, IdentifierKind.Property);
        super.visitPropertyRead(ast, null);
    }
    visitBoundAttribute(attribute) {
        const previous = this.currentAstWithSource;
        this.currentAstWithSource = {
            source: attribute.valueSpan?.toString() || null,
            absoluteOffset: attribute.valueSpan ? attribute.valueSpan.start.offset : -1,
        };
        this.visit(attribute.value instanceof o.ASTWithSource ? attribute.value.ast : attribute.value);
        this.currentAstWithSource = previous;
    }
    /** Creates an identifier for a template element or template node. */
    directiveHostToIdentifier(node) {
        // If this node has already been seen, return the cached result.
        if (this.directiveHostIdentifierCache.has(node)) {
            return this.directiveHostIdentifierCache.get(node);
        }
        let name;
        let kind;
        if (node instanceof o.TmplAstTemplate) {
            name = node.tagName ?? 'ng-template';
            kind = IdentifierKind.Template;
        }
        else if (node instanceof o.TmplAstElement) {
            name = node.name;
            kind = IdentifierKind.Element;
        }
        else if (node instanceof o.TmplAstComponent) {
            name = node.fullName;
            kind = IdentifierKind.Component;
        }
        else {
            name = node.name;
            kind = IdentifierKind.Directive;
        }
        // Namespaced elements have a particular format for `node.name` that needs to be handled.
        // For example, an `<svg>` element has a `node.name` of `':svg:svg'`.
        // TODO(alxhub): properly handle namespaced elements
        if ((node instanceof o.TmplAstTemplate || node instanceof o.TmplAstElement) &&
            name.startsWith(':')) {
            name = name.split(':').pop();
        }
        const sourceSpan = node.startSourceSpan;
        // An element's or template's source span can be of the form `<element>`, `<element />`, or
        // `<element></element>`. Only the selector is interesting to the indexer, so the source is
        // searched for the first occurrence of the element (selector) name.
        const start = this.getStartLocation(name, sourceSpan);
        if (start === null) {
            return null;
        }
        const absoluteSpan = new AbsoluteSourceSpan(start, start + name.length);
        // Record the nodes's attributes, which an indexer can later traverse to see if any of them
        // specify a used directive on the node.
        const attributes = node.attributes.map(({ name, sourceSpan }) => {
            return {
                name,
                span: new AbsoluteSourceSpan(sourceSpan.start.offset, sourceSpan.end.offset),
                kind: IdentifierKind.Attribute,
            };
        });
        const usedDirectives = this.boundTemplate.getDirectivesOfNode(node) || [];
        const identifier = {
            name,
            span: absoluteSpan,
            kind,
            attributes: new Set(attributes),
            usedDirectives: new Set(usedDirectives.map((dir) => {
                return {
                    node: dir.ref.node,
                    selector: dir.selector,
                };
            })),
            // cast b/c pre-TypeScript 3.5 unions aren't well discriminated
        };
        this.directiveHostIdentifierCache.set(node, identifier);
        return identifier;
    }
    /** Creates an identifier for a template reference or template variable target. */
    targetToIdentifier(node) {
        // If this node has already been seen, return the cached result.
        if (this.targetIdentifierCache.has(node)) {
            return this.targetIdentifierCache.get(node);
        }
        const { name, sourceSpan } = node;
        const start = this.getStartLocation(name, sourceSpan);
        if (start === null) {
            return null;
        }
        const span = new AbsoluteSourceSpan(start, start + name.length);
        let identifier;
        if (node instanceof o.TmplAstReference) {
            // If the node is a reference, we care about its target. The target can be an element, a
            // template, a directive applied on a template or element (in which case the directive field
            // is non-null), or nothing at all.
            const refTarget = this.boundTemplate.getReferenceTarget(node);
            let target = null;
            if (refTarget) {
                let node = null;
                let directive = null;
                if (refTarget instanceof o.TmplAstElement ||
                    refTarget instanceof o.TmplAstTemplate ||
                    refTarget instanceof o.TmplAstComponent ||
                    refTarget instanceof o.TmplAstDirective) {
                    node = this.directiveHostToIdentifier(refTarget);
                }
                else {
                    node = this.directiveHostToIdentifier(refTarget.node);
                    directive = refTarget.directive.ref.node;
                }
                if (node === null) {
                    return null;
                }
                target = {
                    node,
                    directive,
                };
            }
            identifier = {
                name,
                span,
                kind: IdentifierKind.Reference,
                target,
            };
        }
        else if (node instanceof o.TmplAstVariable) {
            identifier = {
                name,
                span,
                kind: IdentifierKind.Variable,
            };
        }
        else {
            identifier = {
                name,
                span,
                kind: IdentifierKind.LetDeclaration,
            };
        }
        this.targetIdentifierCache.set(node, identifier);
        return identifier;
    }
    /** Gets the start location of a string in a SourceSpan */
    getStartLocation(name, context) {
        const localStr = context.toString();
        if (!localStr.includes(name)) {
            this.errors.push(new Error(`Impossible state: "${name}" not found in "${localStr}"`));
            return null;
        }
        return context.start.offset + localStr.indexOf(name);
    }
    /**
     * Visits a node's expression and adds its identifiers, if any, to the visitor's state.
     * Only ASTs with information about the expression source and its location are visited.
     *
     * @param node node whose expression to visit
     */
    visit(node) {
        if (node instanceof o.ASTWithSource) {
            const previous = this.currentAstWithSource;
            this.currentAstWithSource = { source: node.source, absoluteOffset: node.sourceSpan.start };
            super.visit(node.ast);
            this.currentAstWithSource = previous;
        }
        else {
            super.visit(node);
        }
    }
    /**
     * Visits an identifier, adding it to the identifier store if it is useful for indexing.
     *
     * @param ast expression AST the identifier is in
     * @param kind identifier kind
     */
    visitIdentifier(ast, kind) {
        // Only handle identifiers in expressions that have a source location.
        if (this.currentAstWithSource === null || this.currentAstWithSource.source === null) {
            return;
        }
        // The definition of a non-top-level property such as `bar` in `{{foo.bar}}` is currently
        // impossible to determine by an indexer and unsupported by the indexing module.
        // The indexing module also does not currently support references to identifiers declared in the
        // template itself, which have a non-null expression target.
        if (!(ast.receiver instanceof o.ImplicitReceiver)) {
            return;
        }
        const { absoluteOffset, source: expressionStr } = this.currentAstWithSource;
        // The source span of the requested AST starts at a location that is offset from the expression.
        let identifierStart = ast.sourceSpan.start - absoluteOffset;
        if (ast instanceof o.PropertyRead) {
            // For `PropertyRead` and the identifier starts at the `nameSpan`,
            // not necessarily the `sourceSpan`.
            identifierStart = ast.nameSpan.start - absoluteOffset;
        }
        if (!expressionStr.substring(identifierStart).startsWith(ast.name)) {
            this.errors.push(new Error(`Impossible state: "${ast.name}" not found in "${expressionStr}" at location ${identifierStart}`));
            return;
        }
        // Join the relative position of the expression within a node with the absolute position
        // of the node to get the absolute position of the expression in the source code.
        const absoluteStart = absoluteOffset + identifierStart;
        const span = new AbsoluteSourceSpan(absoluteStart, absoluteStart + ast.name.length);
        const targetAst = this.boundTemplate.getExpressionTarget(ast);
        const target = targetAst ? this.targetToIdentifier(targetAst) : null;
        const identifier = {
            name: ast.name,
            span,
            kind,
            target,
        };
        this.identifiers.add(identifier);
    }
};
/**
 * Traverses a template AST and builds identifiers discovered in it.
 *
 * @param boundTemplate bound template target, which can be used for querying expression targets.
 * @return identifiers in template
 */
function getTemplateIdentifiers(boundTemplate) {
    const visitor = new TemplateVisitor$1(boundTemplate);
    if (boundTemplate.target.template !== undefined) {
        o.tmplAstVisitAll(visitor, boundTemplate.target.template);
    }
    return { identifiers: visitor.identifiers, errors: visitor.errors };
}

/**
 * Generates `IndexedComponent` entries from a `IndexingContext`, which has information
 * about components discovered in the program registered in it.
 *
 * The context must be populated before `generateAnalysis` is called.
 */
function generateAnalysis(context) {
    const analysis = new Map();
    context.components.forEach(({ declaration, selector, boundTemplate, templateMeta }) => {
        const name = declaration.name.getText();
        const usedComponents = new Set();
        const usedDirs = boundTemplate.getUsedDirectives();
        usedDirs.forEach((dir) => {
            if (dir.isComponent) {
                usedComponents.add(dir.ref.node);
            }
        });
        // Get source files for the component and the template. If the template is inline, its source
        // file is the component's.
        const componentFile = new o.ParseSourceFile(declaration.getSourceFile().getFullText(), declaration.getSourceFile().fileName);
        let templateFile;
        if (templateMeta.isInline) {
            templateFile = componentFile;
        }
        else {
            templateFile = templateMeta.file;
        }
        const { identifiers, errors } = getTemplateIdentifiers(boundTemplate);
        analysis.set(declaration, {
            name,
            selector,
            file: componentFile,
            template: {
                identifiers,
                usedComponents,
                isInline: templateMeta.isInline,
                file: templateFile,
            },
            errors,
        });
    });
    return analysis;
}

/**
 * An index of all NgModules that export or re-export a given trait.
 */
class NgModuleIndexImpl {
    metaReader;
    localReader;
    constructor(metaReader, localReader) {
        this.metaReader = metaReader;
        this.localReader = localReader;
    }
    // A map from an NgModule's Class Declaration to the "main" reference to that module, aka the one
    // present in the reader metadata object
    ngModuleAuthoritativeReference = new Map();
    // A map from a Directive/Pipe's class declaration to the class declarations of all re-exporting
    // NgModules
    typeToExportingModules = new Map();
    indexed = false;
    updateWith(cache, key, elem) {
        if (cache.has(key)) {
            cache.get(key).add(elem);
        }
        else {
            const set = new Set();
            set.add(elem);
            cache.set(key, set);
        }
    }
    index() {
        const seenTypesWithReexports = new Map();
        const locallyDeclaredDirsAndNgModules = [
            ...this.localReader.getKnown(MetaKind.NgModule),
            ...this.localReader.getKnown(MetaKind.Directive),
        ];
        for (const decl of locallyDeclaredDirsAndNgModules) {
            // Here it's safe to create a new Reference because these are known local types.
            this.indexTrait(new Reference(decl), seenTypesWithReexports);
        }
        this.indexed = true;
    }
    indexTrait(ref, seenTypesWithReexports) {
        if (seenTypesWithReexports.has(ref.node)) {
            // We've processed this type before.
            return;
        }
        seenTypesWithReexports.set(ref.node, new Set());
        const meta = this.metaReader.getDirectiveMetadata(ref) ?? this.metaReader.getNgModuleMetadata(ref);
        if (meta === null) {
            return;
        }
        // Component + NgModule: recurse into imports
        if (meta.imports !== null) {
            for (const childRef of meta.imports) {
                this.indexTrait(childRef, seenTypesWithReexports);
            }
        }
        if (meta.kind === MetaKind.NgModule) {
            if (!this.ngModuleAuthoritativeReference.has(ref.node)) {
                this.ngModuleAuthoritativeReference.set(ref.node, ref);
            }
            for (const childRef of meta.exports) {
                this.indexTrait(childRef, seenTypesWithReexports);
                const childMeta = this.metaReader.getDirectiveMetadata(childRef) ??
                    this.metaReader.getPipeMetadata(childRef) ??
                    this.metaReader.getNgModuleMetadata(childRef);
                if (childMeta === null) {
                    continue;
                }
                switch (childMeta.kind) {
                    case MetaKind.Directive:
                    case MetaKind.Pipe:
                        this.updateWith(this.typeToExportingModules, childRef.node, ref.node);
                        this.updateWith(seenTypesWithReexports, ref.node, childRef.node);
                        break;
                    case MetaKind.NgModule:
                        if (seenTypesWithReexports.has(childRef.node)) {
                            for (const reexported of seenTypesWithReexports.get(childRef.node)) {
                                this.updateWith(this.typeToExportingModules, reexported, ref.node);
                                this.updateWith(seenTypesWithReexports, ref.node, reexported);
                            }
                        }
                        break;
                }
            }
        }
    }
    getNgModulesExporting(directiveOrPipe) {
        if (!this.indexed) {
            this.index();
        }
        if (!this.typeToExportingModules.has(directiveOrPipe)) {
            return [];
        }
        const refs = [];
        for (const ngModule of this.typeToExportingModules.get(directiveOrPipe)) {
            if (this.ngModuleAuthoritativeReference.has(ngModule)) {
                refs.push(this.ngModuleAuthoritativeReference.get(ngModule));
            }
        }
        return refs;
    }
}

const CSS_PREPROCESSOR_EXT = /(\.scss|\.sass|\.less|\.styl)$/;
const RESOURCE_MARKER = '.$ngresource$';
const RESOURCE_MARKER_TS = RESOURCE_MARKER + '.ts';
/**
 * `ResourceLoader` which delegates to an `NgCompilerAdapter`'s resource loading methods.
 */
class AdapterResourceLoader {
    adapter;
    options;
    cache = new Map();
    fetching = new Map();
    lookupResolutionHost;
    canPreload;
    canPreprocess;
    constructor(adapter, options) {
        this.adapter = adapter;
        this.options = options;
        this.lookupResolutionHost = createLookupResolutionHost(this.adapter);
        this.canPreload = !!this.adapter.readResource;
        this.canPreprocess = !!this.adapter.transformResource;
    }
    /**
     * Resolve the url of a resource relative to the file that contains the reference to it.
     * The return value of this method can be used in the `load()` and `preload()` methods.
     *
     * Uses the provided CompilerHost if it supports mapping resources to filenames.
     * Otherwise, uses a fallback mechanism that searches the module resolution candidates.
     *
     * @param url The, possibly relative, url of the resource.
     * @param fromFile The path to the file that contains the URL of the resource.
     * @returns A resolved url of resource.
     * @throws An error if the resource cannot be resolved.
     */
    resolve(url, fromFile) {
        let resolvedUrl = null;
        if (this.adapter.resourceNameToFileName) {
            resolvedUrl = this.adapter.resourceNameToFileName(url, fromFile, (url, fromFile) => this.fallbackResolve(url, fromFile));
        }
        else {
            resolvedUrl = this.fallbackResolve(url, fromFile);
        }
        if (resolvedUrl === null) {
            throw new Error(`HostResourceResolver: could not resolve ${url} in context of ${fromFile})`);
        }
        return resolvedUrl;
    }
    /**
     * Preload the specified resource, asynchronously.
     *
     * Once the resource is loaded, its value is cached so it can be accessed synchronously via the
     * `load()` method.
     *
     * @param resolvedUrl The url (resolved by a call to `resolve()`) of the resource to preload.
     * @param context Information about the resource such as the type and containing file.
     * @returns A Promise that is resolved once the resource has been loaded or `undefined` if the
     * file has already been loaded.
     * @throws An Error if pre-loading is not available.
     */
    preload(resolvedUrl, context) {
        if (!this.adapter.readResource) {
            throw new Error('HostResourceLoader: the CompilerHost provided does not support pre-loading resources.');
        }
        if (this.cache.has(resolvedUrl)) {
            return undefined;
        }
        else if (this.fetching.has(resolvedUrl)) {
            return this.fetching.get(resolvedUrl);
        }
        let result = this.adapter.readResource(resolvedUrl);
        if (this.adapter.transformResource && context.type === 'style') {
            const resourceContext = {
                type: 'style',
                containingFile: context.containingFile,
                resourceFile: resolvedUrl,
                className: context.className,
            };
            result = Promise.resolve(result).then(async (str) => {
                const transformResult = await this.adapter.transformResource(str, resourceContext);
                return transformResult === null ? str : transformResult.content;
            });
        }
        if (typeof result === 'string') {
            this.cache.set(resolvedUrl, result);
            return undefined;
        }
        else {
            const fetchCompletion = result.then((str) => {
                this.fetching.delete(resolvedUrl);
                this.cache.set(resolvedUrl, str);
            });
            this.fetching.set(resolvedUrl, fetchCompletion);
            return fetchCompletion;
        }
    }
    /**
     * Preprocess the content data of an inline resource, asynchronously.
     *
     * @param data The existing content data from the inline resource.
     * @param context Information regarding the resource such as the type and containing file.
     * @returns A Promise that resolves to the processed data. If no processing occurs, the
     * same data string that was passed to the function will be resolved.
     */
    async preprocessInline(data, context) {
        if (!this.adapter.transformResource || context.type !== 'style') {
            return data;
        }
        const transformResult = await this.adapter.transformResource(data, {
            type: 'style',
            containingFile: context.containingFile,
            resourceFile: null,
            order: context.order,
            className: context.className,
        });
        if (transformResult === null) {
            return data;
        }
        return transformResult.content;
    }
    /**
     * Load the resource at the given url, synchronously.
     *
     * The contents of the resource may have been cached by a previous call to `preload()`.
     *
     * @param resolvedUrl The url (resolved by a call to `resolve()`) of the resource to load.
     * @returns The contents of the resource.
     */
    load(resolvedUrl) {
        if (this.cache.has(resolvedUrl)) {
            return this.cache.get(resolvedUrl);
        }
        const result = this.adapter.readResource
            ? this.adapter.readResource(resolvedUrl)
            : this.adapter.readFile(resolvedUrl);
        if (typeof result !== 'string') {
            throw new Error(`HostResourceLoader: loader(${resolvedUrl}) returned a Promise`);
        }
        this.cache.set(resolvedUrl, result);
        return result;
    }
    /**
     * Invalidate the entire resource cache.
     */
    invalidate() {
        this.cache.clear();
    }
    /**
     * Attempt to resolve `url` in the context of `fromFile`, while respecting the rootDirs
     * option from the tsconfig. First, normalize the file name.
     */
    fallbackResolve(url, fromFile) {
        let candidateLocations;
        if (url.startsWith('/')) {
            // This path is not really an absolute path, but instead the leading '/' means that it's
            // rooted in the project rootDirs. So look for it according to the rootDirs.
            candidateLocations = this.getRootedCandidateLocations(url);
        }
        else {
            // This path is a "relative" path and can be resolved as such. To make this easier on the
            // downstream resolver, the './' prefix is added if missing to distinguish these paths from
            // absolute node_modules paths.
            if (!url.startsWith('.')) {
                url = `./${url}`;
            }
            candidateLocations = this.getResolvedCandidateLocations(url, fromFile);
        }
        for (const candidate of candidateLocations) {
            if (this.adapter.fileExists(candidate)) {
                return candidate;
            }
            else if (CSS_PREPROCESSOR_EXT.test(candidate)) {
                /**
                 * If the user specified styleUrl points to *.scss, but the Sass compiler was run before
                 * Angular, then the resource may have been generated as *.css. Simply try the resolution
                 * again.
                 */
                const cssFallbackUrl = candidate.replace(CSS_PREPROCESSOR_EXT, '.css');
                if (this.adapter.fileExists(cssFallbackUrl)) {
                    return cssFallbackUrl;
                }
            }
        }
        return null;
    }
    getRootedCandidateLocations(url) {
        // The path already starts with '/', so add a '.' to make it relative.
        const segment = ('.' + url);
        return this.adapter.rootDirs.map((rootDir) => join(rootDir, segment));
    }
    /**
     * TypeScript provides utilities to resolve module names, but not resource files (which aren't
     * a part of the ts.Program). However, TypeScript's module resolution can be used creatively
     * to locate where resource files should be expected to exist. Since module resolution returns
     * a list of file names that were considered, the loader can enumerate the possible locations
     * for the file by setting up a module resolution for it that will fail.
     */
    getResolvedCandidateLocations(url, fromFile) {
        const failedLookup = ts.resolveModuleName(url + RESOURCE_MARKER, fromFile, this.options, this.lookupResolutionHost);
        if (failedLookup.failedLookupLocations === undefined) {
            throw new Error(`Internal error: expected to find failedLookupLocations during resolution of resource '${url}' in context of ${fromFile}`);
        }
        return failedLookup.failedLookupLocations
            .filter((candidate) => candidate.endsWith(RESOURCE_MARKER_TS))
            .map((candidate) => candidate.slice(0, -RESOURCE_MARKER_TS.length));
    }
}
/**
 * Derives a `ts.ModuleResolutionHost` from a compiler adapter that recognizes the special resource
 * marker and does not go to the filesystem for these requests, as they are known not to exist.
 */
function createLookupResolutionHost(adapter) {
    return {
        directoryExists(directoryName) {
            if (directoryName.includes(RESOURCE_MARKER)) {
                return false;
            }
            else if (adapter.directoryExists !== undefined) {
                return adapter.directoryExists(directoryName);
            }
            else {
                // TypeScript's module resolution logic assumes that the directory exists when no host
                // implementation is available.
                return true;
            }
        },
        fileExists(fileName) {
            if (fileName.includes(RESOURCE_MARKER)) {
                return false;
            }
            else {
                return adapter.fileExists(fileName);
            }
        },
        readFile: adapter.readFile.bind(adapter),
        getCurrentDirectory: adapter.getCurrentDirectory.bind(adapter),
        getDirectories: adapter.getDirectories?.bind(adapter),
        realpath: adapter.realpath?.bind(adapter),
        trace: adapter.trace?.bind(adapter),
        useCaseSensitiveFileNames: typeof adapter.useCaseSensitiveFileNames === 'function'
            ? adapter.useCaseSensitiveFileNames.bind(adapter)
            : adapter.useCaseSensitiveFileNames,
    };
}

/**
 * Computes scopes for standalone components based on their `imports`, expanding imported NgModule
 * scopes where necessary.
 */
class StandaloneComponentScopeReader {
    metaReader;
    localModuleReader;
    dtsModuleReader;
    cache = new Map();
    constructor(metaReader, localModuleReader, dtsModuleReader) {
        this.metaReader = metaReader;
        this.localModuleReader = localModuleReader;
        this.dtsModuleReader = dtsModuleReader;
    }
    getScopeForComponent(clazz) {
        if (!this.cache.has(clazz)) {
            const clazzRef = new Reference(clazz);
            const clazzMeta = this.metaReader.getDirectiveMetadata(clazzRef);
            if (clazzMeta === null ||
                !clazzMeta.isComponent ||
                !clazzMeta.isStandalone ||
                clazzMeta.selectorlessEnabled) {
                this.cache.set(clazz, null);
                return null;
            }
            // A standalone component always has itself in scope, so add `clazzMeta` during
            // initialization.
            const dependencies = new Set([clazzMeta]);
            const deferredDependencies = new Set();
            const seen = new Set([clazz]);
            let isPoisoned = clazzMeta.isPoisoned;
            if (clazzMeta.imports !== null) {
                for (const ref of clazzMeta.imports) {
                    if (seen.has(ref.node)) {
                        continue;
                    }
                    seen.add(ref.node);
                    const dirMeta = this.metaReader.getDirectiveMetadata(ref);
                    if (dirMeta !== null) {
                        dependencies.add({ ...dirMeta, ref });
                        isPoisoned = isPoisoned || dirMeta.isPoisoned || !dirMeta.isStandalone;
                        continue;
                    }
                    const pipeMeta = this.metaReader.getPipeMetadata(ref);
                    if (pipeMeta !== null) {
                        dependencies.add({ ...pipeMeta, ref });
                        isPoisoned = isPoisoned || !pipeMeta.isStandalone;
                        continue;
                    }
                    const ngModuleMeta = this.metaReader.getNgModuleMetadata(ref);
                    if (ngModuleMeta !== null) {
                        dependencies.add({ ...ngModuleMeta, ref });
                        let ngModuleScope;
                        if (ref.node.getSourceFile().isDeclarationFile) {
                            ngModuleScope = this.dtsModuleReader.resolve(ref);
                        }
                        else {
                            ngModuleScope = this.localModuleReader.getScopeOfModule(ref.node);
                        }
                        if (ngModuleScope === null) {
                            // This technically shouldn't happen, but mark the scope as poisoned just in case.
                            isPoisoned = true;
                            continue;
                        }
                        isPoisoned = isPoisoned || ngModuleScope.exported.isPoisoned;
                        for (const dep of ngModuleScope.exported.dependencies) {
                            if (!seen.has(dep.ref.node)) {
                                seen.add(dep.ref.node);
                                dependencies.add(dep);
                            }
                        }
                        continue;
                    }
                    // Import was not a component/directive/pipe/NgModule, which is an error and poisons the
                    // scope.
                    isPoisoned = true;
                }
            }
            if (clazzMeta.deferredImports !== null) {
                for (const ref of clazzMeta.deferredImports) {
                    const dirMeta = this.metaReader.getDirectiveMetadata(ref);
                    if (dirMeta !== null) {
                        deferredDependencies.add({ ...dirMeta, ref, isExplicitlyDeferred: true });
                        isPoisoned = isPoisoned || dirMeta.isPoisoned || !dirMeta.isStandalone;
                        continue;
                    }
                    const pipeMeta = this.metaReader.getPipeMetadata(ref);
                    if (pipeMeta !== null) {
                        deferredDependencies.add({ ...pipeMeta, ref, isExplicitlyDeferred: true });
                        isPoisoned = isPoisoned || !pipeMeta.isStandalone;
                        continue;
                    }
                }
            }
            this.cache.set(clazz, {
                kind: ComponentScopeKind.Standalone,
                component: clazz,
                dependencies: Array.from(dependencies),
                deferredDependencies: Array.from(deferredDependencies),
                isPoisoned,
                schemas: clazzMeta.schemas ?? [],
            });
        }
        return this.cache.get(clazz);
    }
    getRemoteScope() {
        return null;
    }
}

/*!
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.dev/license
 */
/** Names of known signal functions. */
const SIGNAL_FNS = new Set([
    'WritableSignal',
    'Signal',
    'InputSignal',
    'InputSignalWithTransform',
    'ModelSignal',
]);
/** Returns whether a symbol is a reference to a signal. */
function isSignalReference(symbol) {
    return ((symbol.kind === exports.SymbolKind.Expression ||
        symbol.kind === exports.SymbolKind.Variable ||
        symbol.kind === exports.SymbolKind.LetDeclaration) &&
        // Note that `tsType.symbol` isn't optional in the typings,
        // but it appears that it can be undefined at runtime.
        ((symbol.tsType.symbol !== undefined && isSignalSymbol(symbol.tsType.symbol)) ||
            (symbol.tsType.aliasSymbol !== undefined && isSignalSymbol(symbol.tsType.aliasSymbol))));
}
/** Checks whether a symbol points to a signal. */
function isSignalSymbol(symbol) {
    const declarations = symbol.getDeclarations();
    return (declarations !== undefined &&
        declarations.some((decl) => {
            const fileName = decl.getSourceFile().fileName;
            return ((ts.isInterfaceDeclaration(decl) || ts.isTypeAliasDeclaration(decl)) &&
                SIGNAL_FNS.has(decl.name.text) &&
                (fileName.includes('@angular/core') ||
                    fileName.includes('angular2/rc/packages/core') ||
                    fileName.includes('bin/packages/core')) // for local usage in some tests
            );
        }));
}

/**
 * This abstract class provides a base implementation for the run method.
 */
class TemplateCheckWithVisitor {
    /**
     * Base implementation for run function, visits all nodes in template and calls
     * `visitNode()` for each one.
     */
    run(ctx, component, template) {
        const visitor = new TemplateVisitor(ctx, component, this);
        return visitor.getDiagnostics(template);
    }
}
/**
 * Visits all nodes in a template (TmplAstNode and AST) and calls `visitNode` for each one.
 */
class TemplateVisitor extends o.CombinedRecursiveAstVisitor {
    ctx;
    component;
    check;
    diagnostics = [];
    constructor(ctx, component, check) {
        super();
        this.ctx = ctx;
        this.component = component;
        this.check = check;
    }
    visit(node) {
        this.diagnostics.push(...this.check.visitNode(this.ctx, this.component, node));
        super.visit(node);
    }
    visitTemplate(template) {
        const isInlineTemplate = template.tagName === 'ng-template';
        this.visitAllTemplateNodes(template.attributes);
        if (isInlineTemplate) {
            // Only visit input/outputs if this isn't an inline template node generated for a structural
            // directive (like `<div *ngIf></div>`). These nodes would be visited when the underlying
            // element of an inline template node is processed.
            this.visitAllTemplateNodes(template.inputs);
            this.visitAllTemplateNodes(template.outputs);
        }
        this.visitAllTemplateNodes(template.directives);
        // `templateAttrs` aren't transferred over to the inner element so we always have to visit them.
        this.visitAllTemplateNodes(template.templateAttrs);
        this.visitAllTemplateNodes(template.variables);
        this.visitAllTemplateNodes(template.references);
        this.visitAllTemplateNodes(template.children);
    }
    getDiagnostics(template) {
        this.diagnostics = [];
        this.visitAllTemplateNodes(template);
        return this.diagnostics;
    }
}

/** Names of known signal instance properties. */
const SIGNAL_INSTANCE_PROPERTIES = new Set(['set', 'update', 'asReadonly']);
/**
 * Names of known function instance properties.
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function#instance_properties
 */
const FUNCTION_INSTANCE_PROPERTIES = new Set(['name', 'length', 'prototype']);
/**
 * Ensures Signals are invoked when used in template interpolations.
 */
class InterpolatedSignalCheck extends TemplateCheckWithVisitor {
    code = exports.ErrorCode.INTERPOLATED_SIGNAL_NOT_INVOKED;
    visitNode(ctx, component, node) {
        // interpolations like `{{ mySignal }}`
        if (node instanceof o.Interpolation) {
            return node.expressions
                .map((item) => (item instanceof o.PrefixNot ? item.expression : item))
                .filter((item) => item instanceof o.PropertyRead)
                .flatMap((item) => buildDiagnosticForSignal(ctx, item, component));
        }
        // check bound inputs like `[prop]="mySignal"` on an element or inline template
        else if (node instanceof o.TmplAstElement && node.inputs.length > 0) {
            const directivesOfElement = ctx.templateTypeChecker.getDirectivesOfNode(component, node);
            return node.inputs.flatMap((input) => checkBoundAttribute(ctx, component, directivesOfElement, input));
        }
        else if (node instanceof o.TmplAstTemplate && node.tagName === 'ng-template') {
            const directivesOfElement = ctx.templateTypeChecker.getDirectivesOfNode(component, node);
            const inputDiagnostics = node.inputs.flatMap((input) => {
                return checkBoundAttribute(ctx, component, directivesOfElement, input);
            });
            const templateAttrDiagnostics = node.templateAttrs.flatMap((attr) => {
                if (!(attr instanceof o.TmplAstBoundAttribute)) {
                    return [];
                }
                return checkBoundAttribute(ctx, component, directivesOfElement, attr);
            });
            return inputDiagnostics.concat(templateAttrDiagnostics);
        }
        // if blocks like `@if(mySignal) { ... }`
        else if (node instanceof o.TmplAstIfBlock) {
            return node.branches
                .map((branch) => branch.expression)
                .filter((expr) => expr instanceof o.ASTWithSource)
                .map((expr) => {
                const ast = expr.ast;
                return ast instanceof o.PrefixNot ? ast.expression : ast;
            })
                .filter((ast) => ast instanceof o.PropertyRead)
                .flatMap((item) => buildDiagnosticForSignal(ctx, item, component));
        }
        // switch blocks like `@switch(mySignal) { ... }`
        else if (node instanceof o.TmplAstSwitchBlock && node.expression instanceof o.ASTWithSource) {
            const expression = node.expression.ast instanceof o.PrefixNot
                ? node.expression.ast.expression
                : node.expression.ast;
            if (expression instanceof o.PropertyRead) {
                return buildDiagnosticForSignal(ctx, expression, component);
            }
        }
        return [];
    }
}
function checkBoundAttribute(ctx, component, directivesOfElement, node) {
    // we skip the check if the node is an input binding
    if (directivesOfElement !== null &&
        directivesOfElement.some((dir) => dir.inputs.getByBindingPropertyName(node.name) !== null)) {
        return [];
    }
    // otherwise, we check if the node is
    const nodeAst = isPropertyReadNodeAst(node);
    if (
    // a bound property like `[prop]="mySignal"`
    (node.type === o.BindingType.Property ||
        // or a class binding like `[class.myClass]="mySignal"`
        node.type === o.BindingType.Class ||
        // or a style binding like `[style.width]="mySignal"`
        node.type === o.BindingType.Style ||
        // or an attribute binding like `[attr.role]="mySignal"`
        node.type === o.BindingType.Attribute ||
        // or an animation binding like `[animate.enter]="mySignal"`
        node.type === o.BindingType.Animation ||
        // or an animation binding like `[@myAnimation]="mySignal"`
        node.type === o.BindingType.LegacyAnimation) &&
        nodeAst) {
        return buildDiagnosticForSignal(ctx, nodeAst, component);
    }
    return [];
}
function isPropertyReadNodeAst(node) {
    if (node.value instanceof o.ASTWithSource === false) {
        return undefined;
    }
    if (node.value.ast instanceof o.PrefixNot && node.value.ast.expression instanceof o.PropertyRead) {
        return node.value.ast.expression;
    }
    if (node.value.ast instanceof o.PropertyRead) {
        return node.value.ast;
    }
    return undefined;
}
function isFunctionInstanceProperty(name) {
    return FUNCTION_INSTANCE_PROPERTIES.has(name);
}
function isSignalInstanceProperty(name) {
    return SIGNAL_INSTANCE_PROPERTIES.has(name);
}
function buildDiagnosticForSignal(ctx, node, component) {
    // check for `{{ mySignal }}`
    const symbol = ctx.templateTypeChecker.getSymbolOfNode(node, component);
    if (symbol !== null && symbol.kind === exports.SymbolKind.Expression && isSignalReference(symbol)) {
        const templateMapping = ctx.templateTypeChecker.getSourceMappingAtTcbLocation(symbol.tcbLocation);
        const errorString = `${node.name} is a function and should be invoked: ${node.name}()`;
        const diagnostic = ctx.makeTemplateDiagnostic(templateMapping.span, errorString);
        return [diagnostic];
    }
    // check for `{{ mySignal.name }}` or `{{ mySignal.length }}` or `{{ mySignal.prototype }}`
    // as these are the names of instance properties of Function, the compiler does _not_ throw an
    // error.
    // We also check for `{{ mySignal.set }}` or `{{ mySignal.update }}` or
    // `{{ mySignal.asReadonly }}` as these are the names of instance properties of Signal
    if (!isFunctionInstanceProperty(node.name) && !isSignalInstanceProperty(node.name)) {
        return [];
    }
    const symbolOfReceiver = ctx.templateTypeChecker.getSymbolOfNode(node.receiver, component);
    if (symbolOfReceiver !== null &&
        symbolOfReceiver.kind === exports.SymbolKind.Expression &&
        isSignalReference(symbolOfReceiver)) {
        const templateMapping = ctx.templateTypeChecker.getSourceMappingAtTcbLocation(symbolOfReceiver.tcbLocation);
        const errorString = `${node.receiver.name} is a function and should be invoked: ${node.receiver.name}()`;
        const diagnostic = ctx.makeTemplateDiagnostic(templateMapping.span, errorString);
        return [diagnostic];
    }
    return [];
}
const factory$f = {
    code: exports.ErrorCode.INTERPOLATED_SIGNAL_NOT_INVOKED,
    name: ExtendedTemplateDiagnosticName.INTERPOLATED_SIGNAL_NOT_INVOKED,
    create: () => new InterpolatedSignalCheck(),
};

/**
 * Ensures the two-way binding syntax is correct.
 * Parentheses should be inside the brackets "[()]".
 * Will return diagnostic information when "([])" is found.
 */
class InvalidBananaInBoxCheck extends TemplateCheckWithVisitor {
    code = exports.ErrorCode.INVALID_BANANA_IN_BOX;
    visitNode(ctx, component, node) {
        if (!(node instanceof o.TmplAstBoundEvent))
            return [];
        const name = node.name;
        if (!name.startsWith('[') || !name.endsWith(']'))
            return [];
        const boundSyntax = node.sourceSpan.toString();
        const expectedBoundSyntax = boundSyntax.replace(`(${name})`, `[(${name.slice(1, -1)})]`);
        const diagnostic = ctx.makeTemplateDiagnostic(node.sourceSpan, `In the two-way binding syntax the parentheses should be inside the brackets, ex. '${expectedBoundSyntax}'.
        Find more at https://angular.dev/guide/templates/two-way-binding`);
        return [diagnostic];
    }
}
const factory$e = {
    code: exports.ErrorCode.INVALID_BANANA_IN_BOX,
    name: ExtendedTemplateDiagnosticName.INVALID_BANANA_IN_BOX,
    create: () => new InvalidBananaInBoxCheck(),
};

/**
 * The list of known control flow directives present in the `CommonModule`,
 * and their corresponding imports.
 *
 * Note: there is no `ngSwitch` here since it's typically used as a regular
 * binding (e.g. `[ngSwitch]`), however the `ngSwitchCase` and `ngSwitchDefault`
 * are used as structural directives and a warning would be generated. Once the
 * `CommonModule` is included, the `ngSwitch` would also be covered.
 */
const KNOWN_CONTROL_FLOW_DIRECTIVES$1 = new Map([
    ['ngIf', { directive: 'NgIf', builtIn: '@if' }],
    ['ngFor', { directive: 'NgFor', builtIn: '@for' }],
    ['ngSwitchCase', { directive: 'NgSwitchCase', builtIn: '@switch with @case' }],
    ['ngSwitchDefault', { directive: 'NgSwitchDefault', builtIn: '@switch with @default' }],
]);
/**
 * Ensures that there are no known control flow directives (such as *ngIf and *ngFor)
 * used in a template of a *standalone* component without importing a `CommonModule`. Returns
 * diagnostics in case such a directive is detected.
 *
 * Note: this check only handles the cases when structural directive syntax is used (e.g. `*ngIf`).
 * Regular binding syntax (e.g. `[ngIf]`) is handled separately in type checker and treated as a
 * hard error instead of a warning.
 */
class MissingControlFlowDirectiveCheck extends TemplateCheckWithVisitor {
    code = exports.ErrorCode.MISSING_CONTROL_FLOW_DIRECTIVE;
    run(ctx, component, template) {
        const componentMetadata = ctx.templateTypeChecker.getDirectiveMetadata(component);
        // Avoid running this check for non-standalone components.
        if (!componentMetadata || !componentMetadata.isStandalone) {
            return [];
        }
        return super.run(ctx, component, template);
    }
    visitNode(ctx, component, node) {
        if (!(node instanceof o.TmplAstTemplate))
            return [];
        const controlFlowAttr = node.templateAttrs.find((attr) => KNOWN_CONTROL_FLOW_DIRECTIVES$1.has(attr.name));
        if (!controlFlowAttr)
            return [];
        const symbol = ctx.templateTypeChecker.getSymbolOfNode(node, component);
        if (symbol === null || symbol.directives.length > 0) {
            return [];
        }
        const sourceSpan = controlFlowAttr.keySpan || controlFlowAttr.sourceSpan;
        const directiveAndBuiltIn = KNOWN_CONTROL_FLOW_DIRECTIVES$1.get(controlFlowAttr.name);
        const errorMessage = `The \`*${controlFlowAttr.name}\` directive was used in the template, ` +
            `but neither the \`${directiveAndBuiltIn?.directive}\` directive nor the \`CommonModule\` was imported. ` +
            `Use Angular's built-in control flow ${directiveAndBuiltIn?.builtIn} or ` +
            `make sure that either the \`${directiveAndBuiltIn?.directive}\` directive or the \`CommonModule\` ` +
            `is included in the \`@Component.imports\` array of this component.`;
        const diagnostic = ctx.makeTemplateDiagnostic(sourceSpan, errorMessage);
        return [diagnostic];
    }
}
const factory$d = {
    code: exports.ErrorCode.MISSING_CONTROL_FLOW_DIRECTIVE,
    name: ExtendedTemplateDiagnosticName.MISSING_CONTROL_FLOW_DIRECTIVE,
    create: (options) => {
        return new MissingControlFlowDirectiveCheck();
    },
};

/**
 * Ensures a user doesn't forget to omit `let` when using ngfor.
 * Will return diagnostic information when `let` is missing.
 */
class MissingNgForOfLetCheck extends TemplateCheckWithVisitor {
    code = exports.ErrorCode.MISSING_NGFOROF_LET;
    visitNode(ctx, component, node) {
        if (!(node instanceof o.TmplAstTemplate)) {
            return [];
        }
        if (node.templateAttrs.length === 0) {
            return [];
        }
        const attr = node.templateAttrs.find((x) => x.name === 'ngFor');
        if (attr === undefined) {
            return [];
        }
        if (node.variables.length > 0) {
            return [];
        }
        const errorString = 'Your ngFor is missing a value. Did you forget to add the `let` keyword?';
        const diagnostic = ctx.makeTemplateDiagnostic(attr.sourceSpan, errorString);
        return [diagnostic];
    }
}
const factory$c = {
    code: exports.ErrorCode.MISSING_NGFOROF_LET,
    name: ExtendedTemplateDiagnosticName.MISSING_NGFOROF_LET,
    create: () => new MissingNgForOfLetCheck(),
};

/**
 * The list of known control flow directives present in the `CommonModule`.
 *
 * If these control flow directives are missing they will be reported by a separate diagnostic.
 */
const KNOWN_CONTROL_FLOW_DIRECTIVES = new Set([
    'ngIf',
    'ngFor',
    'ngForOf',
    'ngForTrackBy',
    'ngSwitchCase',
    'ngSwitchDefault',
    'ngIfThen',
    'ngIfElse',
]);
/**
 * Ensures that there are no structural directives (something like *select or *featureFlag)
 * used in a template of a *standalone* component without importing the directive. Returns
 * diagnostics in case such a directive is detected.
 *
 * Note: this check only handles the cases when structural directive syntax is used (e.g. `*featureFlag`).
 * Regular binding syntax (e.g. `[featureFlag]`) is handled separately in type checker and treated as a
 * hard error instead of a warning.
 */
class MissingStructuralDirectiveCheck extends TemplateCheckWithVisitor {
    code = exports.ErrorCode.MISSING_STRUCTURAL_DIRECTIVE;
    run(ctx, component, template) {
        const componentMetadata = ctx.templateTypeChecker.getDirectiveMetadata(component);
        // Avoid running this check for non-standalone components.
        if (!componentMetadata || !componentMetadata.isStandalone) {
            return [];
        }
        return super.run(ctx, component, template);
    }
    visitNode(ctx, component, node) {
        if (!(node instanceof o.TmplAstTemplate))
            return [];
        const customStructuralDirective = node.templateAttrs.find((attr) => !KNOWN_CONTROL_FLOW_DIRECTIVES.has(attr.name));
        if (!customStructuralDirective)
            return [];
        const symbol = ctx.templateTypeChecker.getSymbolOfNode(node, component);
        // Check if there's a directive that matches the structural directive we're checking.
        // The structural directive *foo desugars to [foo], so we need to check if any
        // directive's selector would match the attribute [foo].
        const hasStructuralDirective = symbol?.directives.some((dir) => dir.selector?.includes(`[${customStructuralDirective.name}]`));
        if (hasStructuralDirective)
            return [];
        const sourceSpan = customStructuralDirective.keySpan || customStructuralDirective.sourceSpan;
        const errorMessage = `A structural directive \`${customStructuralDirective.name}\` was used in the template ` +
            `without a corresponding import in the component. ` +
            `Make sure that the directive is included in the \`@Component.imports\` array of this component.`;
        return [ctx.makeTemplateDiagnostic(sourceSpan, errorMessage)];
    }
}
const factory$b = {
    code: exports.ErrorCode.MISSING_STRUCTURAL_DIRECTIVE,
    name: ExtendedTemplateDiagnosticName.MISSING_STRUCTURAL_DIRECTIVE,
    create: () => new MissingStructuralDirectiveCheck(),
};

/**
 * Ensures the left side of a nullish coalescing operation is nullable.
 * Returns diagnostics for the cases where the operator is useless.
 * This check should only be use if `strictNullChecks` is enabled,
 * otherwise it would produce inaccurate results.
 */
class NullishCoalescingNotNullableCheck extends TemplateCheckWithVisitor {
    code = exports.ErrorCode.NULLISH_COALESCING_NOT_NULLABLE;
    visitNode(ctx, component, node) {
        if (!(node instanceof o.Binary) || node.operation !== '??')
            return [];
        const symbolLeft = ctx.templateTypeChecker.getSymbolOfNode(node.left, component);
        if (symbolLeft === null || symbolLeft.kind !== exports.SymbolKind.Expression) {
            return [];
        }
        const typeLeft = symbolLeft.tsType;
        if (typeLeft.flags & (ts.TypeFlags.Any | ts.TypeFlags.Unknown)) {
            // We should not make assumptions about the any and unknown types; using a nullish coalescing
            // operator is acceptable for those.
            return [];
        }
        // If the left operand's type is different from its non-nullable self, then it must
        // contain a null or undefined so this nullish coalescing operator is useful. No diagnostic to
        // report.
        if (typeLeft.getNonNullableType() !== typeLeft)
            return [];
        const symbol = ctx.templateTypeChecker.getSymbolOfNode(node, component);
        if (symbol.kind !== exports.SymbolKind.Expression) {
            return [];
        }
        const templateMapping = ctx.templateTypeChecker.getSourceMappingAtTcbLocation(symbol.tcbLocation);
        if (templateMapping === null) {
            return [];
        }
        const diagnostic = ctx.makeTemplateDiagnostic(templateMapping.span, `The left side of this nullish coalescing operation does not include 'null' or 'undefined' in its type, therefore the '??' operator can be safely removed.`);
        return [diagnostic];
    }
}
const factory$a = {
    code: exports.ErrorCode.NULLISH_COALESCING_NOT_NULLABLE,
    name: ExtendedTemplateDiagnosticName.NULLISH_COALESCING_NOT_NULLABLE,
    create: (options) => {
        // Require `strictNullChecks` to be enabled.
        const strictNullChecks = options.strictNullChecks === undefined ? !!options.strict : !!options.strictNullChecks;
        if (!strictNullChecks) {
            return null;
        }
        return new NullishCoalescingNotNullableCheck();
    },
};

/**
 * Ensures the left side of an optional chain operation is nullable.
 * Returns diagnostics for the cases where the operator is useless.
 * This check should only be use if `strictNullChecks` is enabled,
 * otherwise it would produce inaccurate results.
 */
class OptionalChainNotNullableCheck extends TemplateCheckWithVisitor {
    noUncheckedIndexedAccess;
    code = exports.ErrorCode.OPTIONAL_CHAIN_NOT_NULLABLE;
    constructor(noUncheckedIndexedAccess) {
        super();
        this.noUncheckedIndexedAccess = noUncheckedIndexedAccess;
    }
    visitNode(ctx, component, node) {
        if (!(node instanceof o.SafeCall) &&
            !(node instanceof o.SafePropertyRead) &&
            !(node instanceof o.SafeKeyedRead)) {
            return [];
        }
        // When `noUncheckedIndexedAccess` is disabled, an indexed access is not checked
        // and may result in `undefined`.
        if (node.receiver instanceof o.KeyedRead && !this.noUncheckedIndexedAccess) {
            return [];
        }
        const symbolLeft = ctx.templateTypeChecker.getSymbolOfNode(node.receiver, component);
        if (symbolLeft === null || symbolLeft.kind !== exports.SymbolKind.Expression) {
            return [];
        }
        const typeLeft = symbolLeft.tsType;
        if (typeLeft.flags & (ts.TypeFlags.Any | ts.TypeFlags.Unknown)) {
            // We should not make assumptions about the any and unknown types; using a nullish coalescing
            // operator is acceptable for those.
            return [];
        }
        // If the left operand's type is different from its non-nullable self, then it must
        // contain a null or undefined so this nullish coalescing operator is useful. No diagnostic to
        // report.
        if (typeLeft.getNonNullableType() !== typeLeft)
            return [];
        const symbol = ctx.templateTypeChecker.getSymbolOfNode(node, component);
        if (symbol.kind !== exports.SymbolKind.Expression) {
            return [];
        }
        const templateMapping = ctx.templateTypeChecker.getSourceMappingAtTcbLocation(symbol.tcbLocation);
        if (templateMapping === null) {
            return [];
        }
        const advice = node instanceof o.SafePropertyRead
            ? `the '?.' operator can be replaced with the '.' operator`
            : `the '?.' operator can be safely removed`;
        const diagnostic = ctx.makeTemplateDiagnostic(templateMapping.span, `The left side of this optional chain operation does not include 'null' or 'undefined' in its type, therefore ${advice}.`);
        return [diagnostic];
    }
}
const factory$9 = {
    code: exports.ErrorCode.OPTIONAL_CHAIN_NOT_NULLABLE,
    name: ExtendedTemplateDiagnosticName.OPTIONAL_CHAIN_NOT_NULLABLE,
    create: (options) => {
        // Require `strictNullChecks` to be enabled.
        const strictNullChecks = options.strictNullChecks === undefined ? !!options.strict : !!options.strictNullChecks;
        if (!strictNullChecks) {
            return null;
        }
        const noUncheckedIndexedAccess = !!options.noUncheckedIndexedAccess;
        return new OptionalChainNotNullableCheck(noUncheckedIndexedAccess);
    },
};

const NG_SKIP_HYDRATION_ATTR_NAME = 'ngSkipHydration';
/**
 * Ensures that the special attribute `ngSkipHydration` is not a binding and has no other
 * value than `"true"` or an empty value.
 */
class NgSkipHydrationSpec extends TemplateCheckWithVisitor {
    code = exports.ErrorCode.SKIP_HYDRATION_NOT_STATIC;
    visitNode(ctx, component, node) {
        /** Binding should always error */
        if (node instanceof o.TmplAstBoundAttribute && node.name === NG_SKIP_HYDRATION_ATTR_NAME) {
            const errorString = `ngSkipHydration should not be used as a binding.`;
            const diagnostic = ctx.makeTemplateDiagnostic(node.sourceSpan, errorString);
            return [diagnostic];
        }
        /** No value, empty string or `"true"` are the only valid values */
        const acceptedValues = ['true', '' /* empty string */];
        if (node instanceof o.TmplAstTextAttribute &&
            node.name === NG_SKIP_HYDRATION_ATTR_NAME &&
            !acceptedValues.includes(node.value) &&
            node.value !== undefined) {
            const errorString = `ngSkipHydration only accepts "true" or "" as value or no value at all. For example 'ngSkipHydration="true"' or 'ngSkipHydration'`;
            const diagnostic = ctx.makeTemplateDiagnostic(node.sourceSpan, errorString);
            return [diagnostic];
        }
        return [];
    }
}
const factory$8 = {
    code: exports.ErrorCode.SKIP_HYDRATION_NOT_STATIC,
    name: ExtendedTemplateDiagnosticName.SKIP_HYDRATION_NOT_STATIC,
    create: () => new NgSkipHydrationSpec(),
};

const STYLE_SUFFIXES = ['px', '%', 'em'];
/**
 * A check which detects when the `.px`, `.%`, and `.em` suffixes are used with an attribute
 * binding. These suffixes are only available for style bindings.
 */
class SuffixNotSupportedCheck extends TemplateCheckWithVisitor {
    code = exports.ErrorCode.SUFFIX_NOT_SUPPORTED;
    visitNode(ctx, component, node) {
        if (!(node instanceof o.TmplAstBoundAttribute))
            return [];
        if (!node.keySpan.toString().startsWith('attr.') ||
            !STYLE_SUFFIXES.some((suffix) => node.name.endsWith(`.${suffix}`))) {
            return [];
        }
        const diagnostic = ctx.makeTemplateDiagnostic(node.keySpan, `The ${STYLE_SUFFIXES.map((suffix) => `'.${suffix}'`).join(', ')} suffixes are only supported on style bindings.`);
        return [diagnostic];
    }
}
const factory$7 = {
    code: exports.ErrorCode.SUFFIX_NOT_SUPPORTED,
    name: ExtendedTemplateDiagnosticName.SUFFIX_NOT_SUPPORTED,
    create: () => new SuffixNotSupportedCheck(),
};

/**
 * Ensures that attributes that have the "special" angular binding prefix (attr., style., and
 * class.) are interpreted as bindings. For example, `<div attr.id="my-id"></div>` will not
 * interpret this as an `AttributeBinding` to `id` but rather just a `TmplAstTextAttribute`. This
 * is likely not the intent of the developer. Instead, the intent is likely to have the `id` be set
 * to 'my-id'.
 */
class TextAttributeNotBindingSpec extends TemplateCheckWithVisitor {
    code = exports.ErrorCode.TEXT_ATTRIBUTE_NOT_BINDING;
    visitNode(ctx, component, node) {
        if (!(node instanceof o.TmplAstTextAttribute))
            return [];
        const name = node.name;
        if (!name.startsWith('attr.') && !name.startsWith('style.') && !name.startsWith('class.')) {
            return [];
        }
        let errorString;
        if (name.startsWith('attr.')) {
            const staticAttr = name.replace('attr.', '');
            errorString = `Static attributes should be written without the 'attr.' prefix.`;
            if (node.value) {
                errorString += ` For example, ${staticAttr}="${node.value}".`;
            }
        }
        else {
            const expectedKey = `[${name}]`;
            const expectedValue = 
            // true/false are special cases because we don't want to convert them to strings but
            // rather maintain the logical true/false when bound.
            node.value === 'true' || node.value === 'false' ? node.value : `'${node.value}'`;
            errorString = 'Attribute, style, and class bindings should be enclosed with square braces.';
            if (node.value) {
                errorString += ` For example, '${expectedKey}="${expectedValue}"'.`;
            }
        }
        const diagnostic = ctx.makeTemplateDiagnostic(node.sourceSpan, errorString);
        return [diagnostic];
    }
}
const factory$6 = {
    code: exports.ErrorCode.TEXT_ATTRIBUTE_NOT_BINDING,
    name: ExtendedTemplateDiagnosticName.TEXT_ATTRIBUTE_NOT_BINDING,
    create: () => new TextAttributeNotBindingSpec(),
};

/**
 * Ensures that function in event bindings are called. For example, `<button (click)="myFunc"></button>`
 * will not call `myFunc` when the button is clicked. Instead, it should be `<button (click)="myFunc()"></button>`.
 * This is likely not the intent of the developer. Instead, the intent is likely to call `myFunc`.
 */
class UninvokedFunctionInEventBindingSpec extends TemplateCheckWithVisitor {
    code = exports.ErrorCode.UNINVOKED_FUNCTION_IN_EVENT_BINDING;
    visitNode(ctx, component, node) {
        // If the node is not a bound event, skip it.
        if (!(node instanceof o.TmplAstBoundEvent))
            return [];
        // If the node is not a regular or animation event, skip it.
        if (node.type !== o.ParsedEventType.Regular && node.type !== o.ParsedEventType.LegacyAnimation)
            return [];
        if (!(node.handler instanceof o.ASTWithSource))
            return [];
        const sourceExpressionText = node.handler.source || '';
        if (node.handler.ast instanceof o.Chain) {
            // (click)="increment; decrement"
            return node.handler.ast.expressions.flatMap((expression) => assertExpressionInvoked$1(expression, component, node, sourceExpressionText, ctx));
        }
        if (node.handler.ast instanceof o.Conditional) {
            // (click)="true ? increment : decrement"
            const { trueExp, falseExp } = node.handler.ast;
            return [trueExp, falseExp].flatMap((expression) => assertExpressionInvoked$1(expression, component, node, sourceExpressionText, ctx));
        }
        // (click)="increment"
        return assertExpressionInvoked$1(node.handler.ast, component, node, sourceExpressionText, ctx);
    }
}
/**
 * Asserts that the expression is invoked.
 * If the expression is a property read, and it has a call signature, a diagnostic is generated.
 */
function assertExpressionInvoked$1(expression, component, node, expressionText, ctx) {
    if (expression instanceof o.Call || expression instanceof o.SafeCall) {
        return []; // If the method is called, skip it.
    }
    if (!(expression instanceof o.PropertyRead) && !(expression instanceof o.SafePropertyRead)) {
        return []; // If the expression is not a property read, skip it.
    }
    const symbol = ctx.templateTypeChecker.getSymbolOfNode(expression, component);
    if (symbol !== null && symbol.kind === exports.SymbolKind.Expression) {
        if (symbol.tsType.getCallSignatures()?.length > 0) {
            const fullExpressionText = generateStringFromExpression$1(expression, expressionText);
            const errorString = `Function in event binding should be invoked: ${fullExpressionText}()`;
            return [ctx.makeTemplateDiagnostic(node.sourceSpan, errorString)];
        }
    }
    return [];
}
function generateStringFromExpression$1(expression, source) {
    return source.substring(expression.span.start, expression.span.end);
}
const factory$5 = {
    code: exports.ErrorCode.UNINVOKED_FUNCTION_IN_EVENT_BINDING,
    name: ExtendedTemplateDiagnosticName.UNINVOKED_FUNCTION_IN_EVENT_BINDING,
    create: () => new UninvokedFunctionInEventBindingSpec(),
};

/**
 * Ensures that parentheses are used to disambiguate precedence when nullish coalescing is mixed
 * with logical and/or. Returns diagnostics for the cases where parentheses are needed.
 */
class UnparenthesizedNullishCoalescing extends TemplateCheckWithVisitor {
    code = exports.ErrorCode.UNPARENTHESIZED_NULLISH_COALESCING;
    visitNode(ctx, component, node) {
        if (node instanceof o.Binary) {
            if (node.operation === '&&' || node.operation === '||') {
                if ((node.left instanceof o.Binary && node.left.operation === '??') ||
                    (node.right instanceof o.Binary && node.right.operation === '??')) {
                    const symbol = ctx.templateTypeChecker.getSymbolOfNode(node, component);
                    if (symbol?.kind !== exports.SymbolKind.Expression) {
                        return [];
                    }
                    const sourceMapping = ctx.templateTypeChecker.getSourceMappingAtTcbLocation(symbol.tcbLocation);
                    if (sourceMapping === null) {
                        return [];
                    }
                    const diagnostic = ctx.makeTemplateDiagnostic(sourceMapping.span, `Parentheses are required to disambiguate precedence when mixing '??' with '&&' and '||'.`);
                    return [diagnostic];
                }
            }
        }
        return [];
    }
}
const factory$4 = {
    code: exports.ErrorCode.UNPARENTHESIZED_NULLISH_COALESCING,
    name: ExtendedTemplateDiagnosticName.UNPARENTHESIZED_NULLISH_COALESCING,
    create: () => new UnparenthesizedNullishCoalescing(),
};

/**
 * Ensures that all `@let` declarations in a template are used.
 */
class UnusedLetDeclarationCheck extends TemplateCheckWithVisitor {
    code = exports.ErrorCode.UNUSED_LET_DECLARATION;
    analysis = new Map();
    run(ctx, component, template) {
        super.run(ctx, component, template);
        const diagnostics = [];
        const { allLetDeclarations, usedLetDeclarations } = this.getAnalysis(component);
        for (const decl of allLetDeclarations) {
            if (!usedLetDeclarations.has(decl)) {
                diagnostics.push(ctx.makeTemplateDiagnostic(decl.sourceSpan, `@let ${decl.name} is declared but its value is never read.`));
            }
        }
        this.analysis.clear();
        return diagnostics;
    }
    visitNode(ctx, component, node) {
        if (node instanceof o.TmplAstLetDeclaration) {
            this.getAnalysis(component).allLetDeclarations.add(node);
        }
        else if (node instanceof o.AST) {
            const unwrappedNode = node instanceof o.ASTWithSource ? node.ast : node;
            const target = ctx.templateTypeChecker.getExpressionTarget(unwrappedNode, component);
            if (target !== null && target instanceof o.TmplAstLetDeclaration) {
                this.getAnalysis(component).usedLetDeclarations.add(target);
            }
        }
        return [];
    }
    getAnalysis(node) {
        if (!this.analysis.has(node)) {
            this.analysis.set(node, { allLetDeclarations: new Set(), usedLetDeclarations: new Set() });
        }
        return this.analysis.get(node);
    }
}
const factory$3 = {
    code: exports.ErrorCode.UNUSED_LET_DECLARATION,
    name: ExtendedTemplateDiagnosticName.UNUSED_LET_DECLARATION,
    create: () => new UnusedLetDeclarationCheck(),
};

/**
 * Ensures that track functions in @for loops are invoked.
 */
class UninvokedTrackFunctionCheck extends TemplateCheckWithVisitor {
    code = exports.ErrorCode.UNINVOKED_TRACK_FUNCTION;
    visitNode(ctx, component, node) {
        if (!(node instanceof o.TmplAstForLoopBlock) || !node.trackBy) {
            return [];
        }
        if (node.trackBy.ast instanceof o.Call || node.trackBy.ast instanceof o.SafeCall) {
            // If the method is called, skip it.
            return [];
        }
        if (!(node.trackBy.ast instanceof o.PropertyRead) &&
            !(node.trackBy.ast instanceof o.SafePropertyRead)) {
            // If the expression is not a property read, skip it.
            return [];
        }
        const symbol = ctx.templateTypeChecker.getSymbolOfNode(node.trackBy.ast, component);
        if (symbol !== null &&
            symbol.kind === exports.SymbolKind.Expression &&
            symbol.tsType.getCallSignatures()?.length > 0) {
            const fullExpressionText = generateStringFromExpression(node.trackBy.ast, node.trackBy.source || '');
            const errorString = `The track function in the @for block should be invoked: ${fullExpressionText}(/* arguments */)`;
            return [ctx.makeTemplateDiagnostic(node.sourceSpan, errorString)];
        }
        return [];
    }
}
function generateStringFromExpression(expression, source) {
    return source.substring(expression.span.start, expression.span.end);
}
const factory$2 = {
    code: exports.ErrorCode.UNINVOKED_TRACK_FUNCTION,
    name: ExtendedTemplateDiagnosticName.UNINVOKED_TRACK_FUNCTION,
    create: () => new UninvokedTrackFunctionCheck(),
};

class UninvokedFunctionInTextInterpolation extends TemplateCheckWithVisitor {
    code = exports.ErrorCode.UNINVOKED_FUNCTION_IN_TEXT_INTERPOLATION;
    visitNode(ctx, component, node) {
        // interpolations like `{{ myFunction }}`
        if (node instanceof o.Interpolation) {
            return node.expressions.flatMap((item) => assertExpressionInvoked(item, component, ctx));
        }
        return [];
    }
}
function assertExpressionInvoked(expression, component, ctx) {
    if (!(expression instanceof o.PropertyRead) && !(expression instanceof o.SafePropertyRead)) {
        return []; // If the expression is not a property read, skip it.
    }
    const symbol = ctx.templateTypeChecker.getSymbolOfNode(expression, component);
    if (symbol !== null && symbol.kind === exports.SymbolKind.Expression) {
        if (symbol.tsType.getCallSignatures()?.length > 0) {
            const errorString = `Function in text interpolation should be invoked: ${expression.name}()`;
            const templateMapping = ctx.templateTypeChecker.getSourceMappingAtTcbLocation(symbol.tcbLocation);
            return [ctx.makeTemplateDiagnostic(templateMapping.span, errorString)];
        }
    }
    return [];
}
const factory$1 = {
    code: exports.ErrorCode.UNINVOKED_FUNCTION_IN_TEXT_INTERPOLATION,
    name: ExtendedTemplateDiagnosticName.UNINVOKED_FUNCTION_IN_TEXT_INTERPOLATION,
    create: () => new UninvokedFunctionInTextInterpolation(),
};

/**
 * This check implements warnings for unreachable or redundant @defer triggers.
 * Emits ErrorCode.DEFER_TRIGGER_MISCONFIGURATION with messages matching the project's
 * expected text.
 */
class DeferTriggerMisconfiguration extends TemplateCheckWithVisitor {
    code = exports.ErrorCode.DEFER_TRIGGER_MISCONFIGURATION;
    visitNode(ctx, component, node) {
        if (!(node instanceof o.TmplAstDeferredBlock))
            return [];
        const mainKeys = Object.keys(node.triggers);
        const prefetchKeys = Object.keys(node.prefetchTriggers);
        // Gather actual trigger objects for mains and prefetch (only defined ones)
        const mains = mainKeys
            .map((k) => node.triggers[k])
            .filter((t) => t !== undefined && t !== null);
        const prefetches = prefetchKeys
            .map((k) => node.prefetchTriggers[k])
            .filter((t) => t !== undefined && t !== null);
        const diags = [];
        //  'on immediate' dominance
        const hasImmediateMain = mains.some((t) => t instanceof o.TmplAstImmediateDeferredTrigger);
        if (hasImmediateMain) {
            if (mains.length > 1) {
                const msg = `The 'immediate' trigger makes additional triggers redundant.`;
                diags.push(ctx.makeTemplateDiagnostic(node.sourceSpan, msg));
            }
            if (prefetches.length > 0) {
                const msg = `Prefetch triggers have no effect because 'immediate' executes earlier.`;
                diags.push(ctx.makeTemplateDiagnostic(node.sourceSpan, msg));
            }
        }
        // If there is exactly one main and at least one prefetch, compare them.
        if (mains.length === 1 && prefetches.length > 0) {
            const main = mains[0];
            for (const pre of prefetches) {
                // Timer vs Timer: warn when prefetch delay >= main delay
                const isTimerTriggger = main instanceof o.TmplAstTimerDeferredTrigger && pre instanceof o.TmplAstTimerDeferredTrigger;
                if (isTimerTriggger) {
                    const mainDelay = main.delay;
                    const preDelay = pre.delay;
                    if (preDelay >= mainDelay) {
                        const msg = `The Prefetch 'timer(${preDelay}ms)' is not scheduled before the main 'timer(${mainDelay}ms)', so it wonât run prior to rendering. Lower the prefetch delay or remove it.`;
                        diags.push(ctx.makeTemplateDiagnostic(pre.sourceSpan ?? node.sourceSpan, msg));
                    }
                }
                // Reference-based triggers (hover/interaction/viewport): only warn if both
                // have a reference and the references are identical. If references differ
                // (or one is missing), the prefetch targets a different element and
                // provides potential value.
                const isHoverTrigger = main instanceof o.TmplAstHoverDeferredTrigger && pre instanceof o.TmplAstHoverDeferredTrigger;
                const isInteractionTrigger = main instanceof o.TmplAstInteractionDeferredTrigger &&
                    pre instanceof o.TmplAstInteractionDeferredTrigger;
                const isViewportTrigger = main instanceof o.TmplAstViewportDeferredTrigger &&
                    pre instanceof o.TmplAstViewportDeferredTrigger;
                if (isHoverTrigger || isInteractionTrigger || isViewportTrigger) {
                    const mainRef = main.reference;
                    const preRef = pre.reference;
                    if (mainRef && preRef && mainRef === preRef) {
                        const kindName = main.constructor.name.replace('DeferredTrigger', '').toLowerCase();
                        const msg = `Prefetch '${kindName}' matches the main trigger and provides no benefit. Remove the prefetch modifier.`;
                        diags.push(ctx.makeTemplateDiagnostic(pre.sourceSpan ?? node.sourceSpan, msg));
                    }
                    // otherwise, different references or missing reference => no warning
                    continue;
                }
                // Syntactic identical: same class for immediate/idle/never etc. (timers handled above)
                if (main.constructor === pre.constructor &&
                    !(main instanceof o.TmplAstTimerDeferredTrigger)) {
                    const kind = main instanceof o.TmplAstImmediateDeferredTrigger
                        ? 'immediate'
                        : main.constructor.name.replace('DeferredTrigger', '').toLowerCase();
                    const msg = `Prefetch '${kind}' matches the main trigger and provides no benefit. Remove the prefetch modifier.`;
                    diags.push(ctx.makeTemplateDiagnostic(pre.sourceSpan ?? node.sourceSpan, msg));
                }
            }
        }
        return diags;
    }
}
const factory = {
    code: exports.ErrorCode.DEFER_TRIGGER_MISCONFIGURATION,
    name: ExtendedTemplateDiagnosticName.DEFER_TRIGGER_MISCONFIGURATION,
    create: () => new DeferTriggerMisconfiguration(),
};

/**
 * A label referring to a `ts.DiagnosticCategory` or `'suppress'`, meaning the associated diagnostic
 * should not be displayed at all.
 *
 * @publicApi
 */
exports.DiagnosticCategoryLabel = void 0;
(function (DiagnosticCategoryLabel) {
    /** Treat the diagnostic as a warning, don't fail the compilation. */
    DiagnosticCategoryLabel["Warning"] = "warning";
    /** Treat the diagnostic as a hard error, fail the compilation. */
    DiagnosticCategoryLabel["Error"] = "error";
    /** Ignore the diagnostic altogether. */
    DiagnosticCategoryLabel["Suppress"] = "suppress";
})(exports.DiagnosticCategoryLabel || (exports.DiagnosticCategoryLabel = {}));

class ExtendedTemplateCheckerImpl {
    partialCtx;
    templateChecks;
    constructor(templateTypeChecker, typeChecker, templateCheckFactories, options) {
        this.partialCtx = { templateTypeChecker, typeChecker };
        this.templateChecks = new Map();
        for (const factory of templateCheckFactories) {
            // Read the diagnostic category from compiler options.
            const category = diagnosticLabelToCategory(options?.extendedDiagnostics?.checks?.[factory.name] ??
                options?.extendedDiagnostics?.defaultCategory ??
                exports.DiagnosticCategoryLabel.Warning);
            // Skip the diagnostic if suppressed via compiler options.
            if (category === null) {
                continue;
            }
            // Try to create the check.
            const check = factory.create(options);
            // Skip the diagnostic if it was disabled due to unsupported options. For example, this can
            // happen if the check requires `strictNullChecks: true` but that flag is disabled in compiler
            // options.
            if (check === null) {
                continue;
            }
            // Use the check.
            this.templateChecks.set(check, category);
        }
    }
    getDiagnosticsForComponent(component) {
        const template = this.partialCtx.templateTypeChecker.getTemplate(component);
        // Skip checks if component has no template. This can happen if the user writes a
        // `@Component()` but doesn't add the template, could happen in the language service
        // when users are in the middle of typing code.
        if (template === null) {
            return [];
        }
        const diagnostics = [];
        for (const [check, category] of this.templateChecks.entries()) {
            const ctx = {
                ...this.partialCtx,
                // Wrap `templateTypeChecker.makeTemplateDiagnostic()` to implicitly provide all the known
                // options.
                makeTemplateDiagnostic: (span, message, relatedInformation) => {
                    return this.partialCtx.templateTypeChecker.makeTemplateDiagnostic(component, span, category, check.code, message, relatedInformation);
                },
            };
            diagnostics.push(...check.run(ctx, component, template));
        }
        return diagnostics;
    }
}
/**
 * Converts a `DiagnosticCategoryLabel` to its equivalent `ts.DiagnosticCategory` or `null` if
 * the label is `DiagnosticCategoryLabel.Suppress`.
 */
function diagnosticLabelToCategory(label) {
    switch (label) {
        case exports.DiagnosticCategoryLabel.Warning:
            return ts.DiagnosticCategory.Warning;
        case exports.DiagnosticCategoryLabel.Error:
            return ts.DiagnosticCategory.Error;
        case exports.DiagnosticCategoryLabel.Suppress:
            return null;
        default:
            return assertNever(label);
    }
}
function assertNever(value) {
    throw new Error(`Unexpected call to 'assertNever()' with value:\n${value}`);
}

const ALL_DIAGNOSTIC_FACTORIES = [
    factory$e,
    factory$a,
    factory$9,
    factory$d,
    factory$6,
    factory$c,
    factory$b,
    factory$7,
    factory$f,
    factory$5,
    factory$3,
    factory$8,
    factory$4,
    factory$2,
    factory$1,
    factory,
];
const SUPPORTED_DIAGNOSTIC_NAMES = new Set([
    ExtendedTemplateDiagnosticName.CONTROL_FLOW_PREVENTING_CONTENT_PROJECTION,
    ExtendedTemplateDiagnosticName.UNUSED_STANDALONE_IMPORTS,
    ...ALL_DIAGNOSTIC_FACTORIES.map((factory) => factory.name),
]);

class TemplateSemanticsCheckerImpl {
    templateTypeChecker;
    constructor(templateTypeChecker) {
        this.templateTypeChecker = templateTypeChecker;
    }
    getDiagnosticsForComponent(component) {
        const template = this.templateTypeChecker.getTemplate(component);
        return template !== null
            ? TemplateSemanticsVisitor.visit(template, component, this.templateTypeChecker)
            : [];
    }
}
/** Visitor that verifies the semantics of a template. */
class TemplateSemanticsVisitor extends o.TmplAstRecursiveVisitor {
    expressionVisitor;
    constructor(expressionVisitor) {
        super();
        this.expressionVisitor = expressionVisitor;
    }
    static visit(nodes, component, templateTypeChecker) {
        const diagnostics = [];
        const expressionVisitor = new ExpressionsSemanticsVisitor(templateTypeChecker, component, diagnostics);
        const templateVisitor = new TemplateSemanticsVisitor(expressionVisitor);
        nodes.forEach((node) => node.visit(templateVisitor));
        return diagnostics;
    }
    visitBoundEvent(event) {
        super.visitBoundEvent(event);
        event.handler.visit(this.expressionVisitor, event);
    }
}
/** Visitor that verifies the semantics of the expressions within a template. */
class ExpressionsSemanticsVisitor extends o.RecursiveAstVisitor {
    templateTypeChecker;
    component;
    diagnostics;
    constructor(templateTypeChecker, component, diagnostics) {
        super();
        this.templateTypeChecker = templateTypeChecker;
        this.component = component;
        this.diagnostics = diagnostics;
    }
    visitBinary(ast, context) {
        if (o.Binary.isAssignmentOperation(ast.operation) && ast.left instanceof o.PropertyRead) {
            this.checkForIllegalWriteInEventBinding(ast.left, context);
        }
        else {
            super.visitBinary(ast, context);
        }
    }
    visitPropertyRead(ast, context) {
        super.visitPropertyRead(ast, context);
        this.checkForIllegalWriteInTwoWayBinding(ast, context);
    }
    checkForIllegalWriteInEventBinding(ast, context) {
        if (!(context instanceof o.TmplAstBoundEvent) || !(ast.receiver instanceof o.ImplicitReceiver)) {
            return;
        }
        const target = this.templateTypeChecker.getExpressionTarget(ast, this.component);
        if (target instanceof o.TmplAstVariable) {
            const errorMessage = `Cannot use variable '${target.name}' as the left-hand side of an assignment expression. Template variables are read-only.`;
            this.diagnostics.push(this.makeIllegalTemplateVarDiagnostic(target, context, errorMessage));
        }
    }
    checkForIllegalWriteInTwoWayBinding(ast, context) {
        // Only check top-level property reads inside two-way bindings for illegal assignments.
        if (!(context instanceof o.TmplAstBoundEvent) ||
            context.type !== o.ParsedEventType.TwoWay ||
            !(ast.receiver instanceof o.ImplicitReceiver) ||
            ast !== unwrapAstWithSource(context.handler)) {
            return;
        }
        const target = this.templateTypeChecker.getExpressionTarget(ast, this.component);
        const isVariable = target instanceof o.TmplAstVariable;
        const isLet = target instanceof o.TmplAstLetDeclaration;
        if (!isVariable && !isLet) {
            return;
        }
        // Two-way bindings to template variables are only allowed if the variables are signals.
        const symbol = this.templateTypeChecker.getSymbolOfNode(target, this.component);
        if (symbol !== null && !isSignalReference(symbol)) {
            let errorMessage;
            if (isVariable) {
                errorMessage = `Cannot use a non-signal variable '${target.name}' in a two-way binding expression. Template variables are read-only.`;
            }
            else {
                errorMessage = `Cannot use non-signal @let declaration '${target.name}' in a two-way binding expression. @let declarations are read-only.`;
            }
            this.diagnostics.push(this.makeIllegalTemplateVarDiagnostic(target, context, errorMessage));
        }
    }
    makeIllegalTemplateVarDiagnostic(target, expressionNode, errorMessage) {
        const span = target instanceof o.TmplAstVariable ? target.valueSpan || target.sourceSpan : target.sourceSpan;
        return this.templateTypeChecker.makeTemplateDiagnostic(this.component, expressionNode.handlerSpan, ts.DiagnosticCategory.Error, ngErrorCode(exports.ErrorCode.WRITE_TO_READ_ONLY_VARIABLE), errorMessage, [
            {
                text: `'${target.name}' is declared here.`,
                start: span.start.offset,
                end: span.end.offset,
                sourceFile: this.component.getSourceFile(),
            },
        ]);
    }
}
function unwrapAstWithSource(ast) {
    return ast instanceof o.ASTWithSource ? ast.ast : ast;
}

/*!
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.dev/license
 */
/** APIs whose usages should be checked by the rule. */
const APIS_TO_CHECK$1 = [
    INPUT_INITIALIZER_FN,
    MODEL_INITIALIZER_FN,
    ...OUTPUT_INITIALIZER_FNS,
    ...QUERY_INITIALIZER_FNS,
];
/**
 * Rule that flags any initializer APIs that are used outside of an initializer.
 */
class InitializerApiUsageRule {
    reflector;
    importedSymbolsTracker;
    constructor(reflector, importedSymbolsTracker) {
        this.reflector = reflector;
        this.importedSymbolsTracker = importedSymbolsTracker;
    }
    shouldCheck(sourceFile) {
        // Skip the traversal if there are no imports of the initializer APIs.
        return APIS_TO_CHECK$1.some(({ functionName, owningModule }) => {
            return (this.importedSymbolsTracker.hasNamedImport(sourceFile, functionName, owningModule) ||
                this.importedSymbolsTracker.hasNamespaceImport(sourceFile, owningModule));
        });
    }
    checkNode(node) {
        // We only care about call expressions.
        if (!ts.isCallExpression(node)) {
            return null;
        }
        // Unwrap any parenthesized and `as` expressions since they don't affect the runtime behavior.
        while (node.parent &&
            (ts.isParenthesizedExpression(node.parent) || ts.isAsExpression(node.parent))) {
            node = node.parent;
        }
        if (!node.parent || !ts.isCallExpression(node)) {
            return null;
        }
        const identifiedInitializer = tryParseInitializerApi(APIS_TO_CHECK$1, node, this.reflector, this.importedSymbolsTracker);
        if (identifiedInitializer === null) {
            return null;
        }
        const functionName = identifiedInitializer.api.functionName +
            (identifiedInitializer.isRequired ? '.required' : '');
        if (ts.isPropertyDeclaration(node.parent) && node.parent.initializer === node) {
            let closestClass = node.parent;
            while (closestClass && !ts.isClassDeclaration(closestClass)) {
                closestClass = closestClass.parent;
            }
            if (closestClass && ts.isClassDeclaration(closestClass)) {
                const decorators = this.reflector.getDecoratorsOfDeclaration(closestClass);
                const isComponentOrDirective = decorators !== null &&
                    decorators.some((decorator) => {
                        return (decorator.import?.from === '@angular/core' &&
                            (decorator.name === 'Component' || decorator.name === 'Directive'));
                    });
                return isComponentOrDirective
                    ? null
                    : makeDiagnostic(exports.ErrorCode.UNSUPPORTED_INITIALIZER_API_USAGE, node, `Unsupported call to the ${functionName} function. This function can only be used as the initializer ` +
                        `of a property on a @Component or @Directive class.`);
            }
        }
        return makeDiagnostic(exports.ErrorCode.UNSUPPORTED_INITIALIZER_API_USAGE, node, `Unsupported call to the ${functionName} function. This function can only be called in the initializer of a class member.`);
    }
}

/*!
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.dev/license
 */
/**
 * Rule that flags unused symbols inside of the `imports` array of a component.
 */
class UnusedStandaloneImportsRule {
    templateTypeChecker;
    typeCheckingConfig;
    importedSymbolsTracker;
    constructor(templateTypeChecker, typeCheckingConfig, importedSymbolsTracker) {
        this.templateTypeChecker = templateTypeChecker;
        this.typeCheckingConfig = typeCheckingConfig;
        this.importedSymbolsTracker = importedSymbolsTracker;
    }
    shouldCheck(sourceFile) {
        return (this.typeCheckingConfig.unusedStandaloneImports !== 'suppress' &&
            (this.importedSymbolsTracker.hasNamedImport(sourceFile, 'Component', '@angular/core') ||
                this.importedSymbolsTracker.hasNamespaceImport(sourceFile, '@angular/core')));
    }
    checkNode(node) {
        if (!ts.isClassDeclaration(node)) {
            return null;
        }
        const metadata = this.templateTypeChecker.getDirectiveMetadata(node);
        if (!metadata ||
            !metadata.isStandalone ||
            metadata.rawImports === null ||
            metadata.imports === null ||
            metadata.imports.length === 0) {
            return null;
        }
        const usedDirectives = this.templateTypeChecker.getUsedDirectives(node);
        const usedPipes = this.templateTypeChecker.getUsedPipes(node);
        // These will be null if the component is invalid for some reason.
        if (!usedDirectives || !usedPipes) {
            return null;
        }
        const unused = this.getUnusedSymbols(metadata, new Set(usedDirectives.map((dir) => dir.ref.node)), new Set(usedPipes));
        if (unused === null) {
            return null;
        }
        const propertyAssignment = closestNode(metadata.rawImports, ts.isPropertyAssignment);
        const category = this.typeCheckingConfig.unusedStandaloneImports === 'error'
            ? ts.DiagnosticCategory.Error
            : ts.DiagnosticCategory.Warning;
        if (unused.length === metadata.imports.length && propertyAssignment !== null) {
            return makeDiagnostic(exports.ErrorCode.UNUSED_STANDALONE_IMPORTS, propertyAssignment.name, 'All imports are unused', undefined, category);
        }
        return unused.map((ref) => {
            const diagnosticNode = ref.getIdentityInExpression(metadata.rawImports) ||
                ref.getIdentityIn(node.getSourceFile()) ||
                metadata.rawImports;
            return makeDiagnostic(exports.ErrorCode.UNUSED_STANDALONE_IMPORTS, diagnosticNode, `${ref.node.name.text} is not used within the template of ${metadata.name}`, undefined, category);
        });
    }
    getUnusedSymbols(metadata, usedDirectives, usedPipes) {
        const { imports, rawImports } = metadata;
        if (imports === null || rawImports === null) {
            return null;
        }
        let unused = null;
        for (const current of imports) {
            const currentNode = current.node;
            const dirMeta = this.templateTypeChecker.getDirectiveMetadata(currentNode);
            if (dirMeta !== null) {
                if (dirMeta.isStandalone &&
                    !usedDirectives.has(currentNode) &&
                    !this.isPotentialSharedReference(current, rawImports)) {
                    unused ??= [];
                    unused.push(current);
                }
                continue;
            }
            const pipeMeta = this.templateTypeChecker.getPipeMetadata(currentNode);
            if (pipeMeta !== null &&
                pipeMeta.isStandalone &&
                pipeMeta.name !== null &&
                !usedPipes.has(pipeMeta.name) &&
                !this.isPotentialSharedReference(current, rawImports)) {
                unused ??= [];
                unused.push(current);
            }
        }
        return unused;
    }
    /**
     * Determines if an import reference *might* be coming from a shared imports array.
     * @param reference Reference to be checked.
     * @param rawImports AST node that defines the `imports` array.
     */
    isPotentialSharedReference(reference, rawImports) {
        // If the reference is defined directly in the `imports` array, it cannot be shared.
        if (reference.getIdentityInExpression(rawImports) !== null) {
            return false;
        }
        // The reference might be shared if it comes from an exported array. If the variable is local
        /// to the file, then it likely isn't shared. Note that this has the potential for false
        // positives if a non-exported array of imports is shared between components in the same
        // file. This scenario is unlikely and even if we report the diagnostic for it, it would be
        // okay since the user only has to refactor components within the same file, rather than the
        // entire application.
        let current = reference.getIdentityIn(rawImports.getSourceFile());
        while (current !== null) {
            if (ts.isVariableStatement(current)) {
                return !!current.modifiers?.some((m) => m.kind === ts.SyntaxKind.ExportKeyword);
            }
            // `Node.parent` can be undefined, but the TS types don't reflect it.
            // Coerce to null so the value is consitent with the type.
            current = current.parent ?? null;
        }
        // Otherwise the reference likely comes from an imported
        // symbol like an array of shared common components.
        return true;
    }
}
/** Gets the closest parent node of a certain type. */
function closestNode(start, predicate) {
    let current = start.parent;
    while (current) {
        if (predicate(current)) {
            return current;
        }
        else {
            current = current.parent;
        }
    }
    return null;
}

/*!
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.dev/license
 */
/** APIs whose usages should be checked by the rule. */
const APIS_TO_CHECK = [
    INPUT_INITIALIZER_FN,
    MODEL_INITIALIZER_FN,
    ...QUERY_INITIALIZER_FNS,
];
/**
 * Rule that flags forbidden invocations of required initializers in property initializers and constructors.
 */
class ForbiddenRequiredInitializersInvocationRule {
    reflector;
    importedSymbolsTracker;
    constructor(reflector, importedSymbolsTracker) {
        this.reflector = reflector;
        this.importedSymbolsTracker = importedSymbolsTracker;
    }
    shouldCheck(sourceFile) {
        // Skip the traversal if there are no imports of the initializer APIs.
        return APIS_TO_CHECK.some(({ functionName, owningModule }) => {
            return (this.importedSymbolsTracker.hasNamedImport(sourceFile, functionName, owningModule) ||
                this.importedSymbolsTracker.hasNamespaceImport(sourceFile, owningModule));
        });
    }
    checkNode(node) {
        if (!ts.isClassDeclaration(node))
            return null;
        const requiredInitializerDeclarations = node.members.filter((m) => ts.isPropertyDeclaration(m) && this.isPropDeclarationARequiredInitializer(m));
        const diagnostics = [];
        // Handling of the usages in props initializations
        for (let decl of node.members) {
            if (!ts.isPropertyDeclaration(decl))
                continue;
            const initiallizerExpr = decl.initializer;
            if (!initiallizerExpr)
                continue;
            checkForbiddenInvocation(initiallizerExpr);
        }
        function checkForbiddenInvocation(node) {
            if (ts.isArrowFunction(node) || ts.isFunctionExpression(node))
                return;
            if (ts.isPropertyAccessExpression(node) &&
                node.expression.kind === ts.SyntaxKind.ThisKeyword &&
                // With the following we make sure we only flag invoked required initializers
                ts.isCallExpression(node.parent) &&
                node.parent.expression === node) {
                const requiredProp = requiredInitializerDeclarations.find((prop) => prop.name.getText() === node.name.getText());
                if (requiredProp) {
                    const initializerFn = requiredProp.initializer.expression.expression.getText();
                    diagnostics.push(makeDiagnostic(exports.ErrorCode.FORBIDDEN_REQUIRED_INITIALIZER_INVOCATION, node, `\`${node.name.getText()}\` is a required \`${initializerFn}\` and does not have a value in this context.`));
                }
            }
            return node.forEachChild(checkForbiddenInvocation);
        }
        const ctor = getConstructorFromClass(node);
        if (ctor) {
            checkForbiddenInvocation(ctor);
        }
        return diagnostics;
    }
    isPropDeclarationARequiredInitializer(node) {
        if (!node.initializer)
            return false;
        const identifiedInitializer = tryParseInitializerApi(APIS_TO_CHECK, node.initializer, this.reflector, this.importedSymbolsTracker);
        if (identifiedInitializer === null || !identifiedInitializer.isRequired)
            return false;
        return true;
    }
}
function getConstructorFromClass(node) {
    // We also check for a constructor body to avoid picking up parent constructors.
    return node.members.find((m) => ts.isConstructorDeclaration(m) && m.body !== undefined);
}

/*!
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.dev/license
 */
/**
 * Validates that TypeScript files match a specific set of rules set by the Angular compiler.
 */
class SourceFileValidator {
    rules;
    constructor(reflector, importedSymbolsTracker, templateTypeChecker, typeCheckingConfig) {
        this.rules = [new InitializerApiUsageRule(reflector, importedSymbolsTracker)];
        this.rules.push(new UnusedStandaloneImportsRule(templateTypeChecker, typeCheckingConfig, importedSymbolsTracker));
        this.rules.push(new ForbiddenRequiredInitializersInvocationRule(reflector, importedSymbolsTracker));
    }
    /**
     * Gets the diagnostics for a specific file, or null if the file is valid.
     * @param sourceFile File to be checked.
     */
    getDiagnosticsForFile(sourceFile) {
        if (sourceFile.isDeclarationFile || sourceFile.fileName.endsWith('.ngtypecheck.ts')) {
            return null;
        }
        let rulesToRun = null;
        for (const rule of this.rules) {
            if (rule.shouldCheck(sourceFile)) {
                rulesToRun ??= [];
                rulesToRun.push(rule);
            }
        }
        if (rulesToRun === null) {
            return null;
        }
        let fileDiagnostics = null;
        sourceFile.forEachChild(function walk(node) {
            // Note: non-null assertion is here because of g3.
            for (const rule of rulesToRun) {
                const nodeDiagnostics = rule.checkNode(node);
                if (nodeDiagnostics !== null) {
                    fileDiagnostics ??= [];
                    if (Array.isArray(nodeDiagnostics)) {
                        fileDiagnostics.push(...nodeDiagnostics);
                    }
                    else {
                        fileDiagnostics.push(nodeDiagnostics);
                    }
                }
            }
            node.forEachChild(walk);
        });
        return fileDiagnostics;
    }
}

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var re = {exports: {}};

var constants;
var hasRequiredConstants;

function requireConstants () {
	if (hasRequiredConstants) return constants;
	hasRequiredConstants = 1;

	// Note: this is the semver.org version of the spec that it implements
	// Not necessarily the package version of this code.
	const SEMVER_SPEC_VERSION = '2.0.0';

	const MAX_LENGTH = 256;
	const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
	/* istanbul ignore next */ 9007199254740991;

	// Max safe segment length for coercion.
	const MAX_SAFE_COMPONENT_LENGTH = 16;

	// Max safe length for a build identifier. The max length minus 6 characters for
	// the shortest version with a build 0.0.0+BUILD.
	const MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;

	const RELEASE_TYPES = [
	  'major',
	  'premajor',
	  'minor',
	  'preminor',
	  'patch',
	  'prepatch',
	  'prerelease',
	];

	constants = {
	  MAX_LENGTH,
	  MAX_SAFE_COMPONENT_LENGTH,
	  MAX_SAFE_BUILD_LENGTH,
	  MAX_SAFE_INTEGER,
	  RELEASE_TYPES,
	  SEMVER_SPEC_VERSION,
	  FLAG_INCLUDE_PRERELEASE: 0b001,
	  FLAG_LOOSE: 0b010,
	};
	return constants;
}

var debug_1;
var hasRequiredDebug;

function requireDebug () {
	if (hasRequiredDebug) return debug_1;
	hasRequiredDebug = 1;

	const debug = (
	  typeof process === 'object' &&
	  process.env &&
	  process.env.NODE_DEBUG &&
	  /\bsemver\b/i.test(process.env.NODE_DEBUG)
	) ? (...args) => console.error('SEMVER', ...args)
	  : () => {};

	debug_1 = debug;
	return debug_1;
}

var hasRequiredRe;

function requireRe () {
	if (hasRequiredRe) return re.exports;
	hasRequiredRe = 1;
	(function (module, exports) {

		const {
		  MAX_SAFE_COMPONENT_LENGTH,
		  MAX_SAFE_BUILD_LENGTH,
		  MAX_LENGTH,
		} = requireConstants();
		const debug = requireDebug();
		exports = module.exports = {};

		// The actual regexps go on exports.re
		const re = exports.re = [];
		const safeRe = exports.safeRe = [];
		const src = exports.src = [];
		const safeSrc = exports.safeSrc = [];
		const t = exports.t = {};
		let R = 0;

		const LETTERDASHNUMBER = '[a-zA-Z0-9-]';

		// Replace some greedy regex tokens to prevent regex dos issues. These regex are
		// used internally via the safeRe object since all inputs in this library get
		// normalized first to trim and collapse all extra whitespace. The original
		// regexes are exported for userland consumption and lower level usage. A
		// future breaking change could export the safer regex only with a note that
		// all input should have extra whitespace removed.
		const safeRegexReplacements = [
		  ['\\s', 1],
		  ['\\d', MAX_LENGTH],
		  [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH],
		];

		const makeSafeRegex = (value) => {
		  for (const [token, max] of safeRegexReplacements) {
		    value = value
		      .split(`${token}*`).join(`${token}{0,${max}}`)
		      .split(`${token}+`).join(`${token}{1,${max}}`);
		  }
		  return value
		};

		const createToken = (name, value, isGlobal) => {
		  const safe = makeSafeRegex(value);
		  const index = R++;
		  debug(name, index, value);
		  t[name] = index;
		  src[index] = value;
		  safeSrc[index] = safe;
		  re[index] = new RegExp(value, isGlobal ? 'g' : undefined);
		  safeRe[index] = new RegExp(safe, isGlobal ? 'g' : undefined);
		};

		// The following Regular Expressions can be used for tokenizing,
		// validating, and parsing SemVer version strings.

		// ## Numeric Identifier
		// A single `0`, or a non-zero digit followed by zero or more digits.

		createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*');
		createToken('NUMERICIDENTIFIERLOOSE', '\\d+');

		// ## Non-numeric Identifier
		// Zero or more digits, followed by a letter or hyphen, and then zero or
		// more letters, digits, or hyphens.

		createToken('NONNUMERICIDENTIFIER', `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);

		// ## Main Version
		// Three dot-separated numeric identifiers.

		createToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\.` +
		                   `(${src[t.NUMERICIDENTIFIER]})\\.` +
		                   `(${src[t.NUMERICIDENTIFIER]})`);

		createToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
		                        `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
		                        `(${src[t.NUMERICIDENTIFIERLOOSE]})`);

		// ## Pre-release Version Identifier
		// A numeric identifier, or a non-numeric identifier.
		// Non-numberic identifiers include numberic identifiers but can be longer.
		// Therefore non-numberic identifiers must go first.

		createToken('PRERELEASEIDENTIFIER', `(?:${src[t.NONNUMERICIDENTIFIER]
		}|${src[t.NUMERICIDENTIFIER]})`);

		createToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NONNUMERICIDENTIFIER]
		}|${src[t.NUMERICIDENTIFIERLOOSE]})`);

		// ## Pre-release Version
		// Hyphen, followed by one or more dot-separated pre-release version
		// identifiers.

		createToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]
		}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);

		createToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]
		}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);

		// ## Build Metadata Identifier
		// Any combination of digits, letters, or hyphens.

		createToken('BUILDIDENTIFIER', `${LETTERDASHNUMBER}+`);

		// ## Build Metadata
		// Plus sign, followed by one or more period-separated build metadata
		// identifiers.

		createToken('BUILD', `(?:\\+(${src[t.BUILDIDENTIFIER]
		}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);

		// ## Full Version String
		// A main version, followed optionally by a pre-release version and
		// build metadata.

		// Note that the only major, minor, patch, and pre-release sections of
		// the version string are capturing groups.  The build metadata is not a
		// capturing group, because it should not ever be used in version
		// comparison.

		createToken('FULLPLAIN', `v?${src[t.MAINVERSION]
		}${src[t.PRERELEASE]}?${
		  src[t.BUILD]}?`);

		createToken('FULL', `^${src[t.FULLPLAIN]}$`);

		// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
		// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
		// common in the npm registry.
		createToken('LOOSEPLAIN', `[v=\\s]*${src[t.MAINVERSIONLOOSE]
		}${src[t.PRERELEASELOOSE]}?${
		  src[t.BUILD]}?`);

		createToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`);

		createToken('GTLT', '((?:<|>)?=?)');

		// Something like "2.*" or "1.2.x".
		// Note that "x.x" is a valid xRange identifer, meaning "any version"
		// Only the first item is strictly required.
		createToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
		createToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);

		createToken('XRANGEPLAIN', `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` +
		                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
		                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
		                   `(?:${src[t.PRERELEASE]})?${
		                     src[t.BUILD]}?` +
		                   `)?)?`);

		createToken('XRANGEPLAINLOOSE', `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +
		                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
		                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
		                        `(?:${src[t.PRERELEASELOOSE]})?${
		                          src[t.BUILD]}?` +
		                        `)?)?`);

		createToken('XRANGE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
		createToken('XRANGELOOSE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);

		// Coercion.
		// Extract anything that could conceivably be a part of a valid semver
		createToken('COERCEPLAIN', `${'(^|[^\\d])' +
		              '(\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +
		              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
		              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
		createToken('COERCE', `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
		createToken('COERCEFULL', src[t.COERCEPLAIN] +
		              `(?:${src[t.PRERELEASE]})?` +
		              `(?:${src[t.BUILD]})?` +
		              `(?:$|[^\\d])`);
		createToken('COERCERTL', src[t.COERCE], true);
		createToken('COERCERTLFULL', src[t.COERCEFULL], true);

		// Tilde ranges.
		// Meaning is "reasonably at or greater than"
		createToken('LONETILDE', '(?:~>?)');

		createToken('TILDETRIM', `(\\s*)${src[t.LONETILDE]}\\s+`, true);
		exports.tildeTrimReplace = '$1~';

		createToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
		createToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);

		// Caret ranges.
		// Meaning is "at least and backwards compatible with"
		createToken('LONECARET', '(?:\\^)');

		createToken('CARETTRIM', `(\\s*)${src[t.LONECARET]}\\s+`, true);
		exports.caretTrimReplace = '$1^';

		createToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
		createToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);

		// A simple gt/lt/eq thing, or just "" to indicate "any version"
		createToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
		createToken('COMPARATOR', `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);

		// An expression to strip any whitespace between the gtlt and the thing
		// it modifies, so that `> 1.2.3` ==> `>1.2.3`
		createToken('COMPARATORTRIM', `(\\s*)${src[t.GTLT]
		}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
		exports.comparatorTrimReplace = '$1$2$3';

		// Something like `1.2.3 - 1.2.4`
		// Note that these all use the loose form, because they'll be
		// checked against either the strict or loose comparator form
		// later.
		createToken('HYPHENRANGE', `^\\s*(${src[t.XRANGEPLAIN]})` +
		                   `\\s+-\\s+` +
		                   `(${src[t.XRANGEPLAIN]})` +
		                   `\\s*$`);

		createToken('HYPHENRANGELOOSE', `^\\s*(${src[t.XRANGEPLAINLOOSE]})` +
		                        `\\s+-\\s+` +
		                        `(${src[t.XRANGEPLAINLOOSE]})` +
		                        `\\s*$`);

		// Star ranges basically just allow anything at all.
		createToken('STAR', '(<|>)?=?\\s*\\*');
		// >=0.0.0 is like a star
		createToken('GTE0', '^\\s*>=\\s*0\\.0\\.0\\s*$');
		createToken('GTE0PRE', '^\\s*>=\\s*0\\.0\\.0-0\\s*$'); 
	} (re, re.exports));
	return re.exports;
}

var parseOptions_1;
var hasRequiredParseOptions;

function requireParseOptions () {
	if (hasRequiredParseOptions) return parseOptions_1;
	hasRequiredParseOptions = 1;

	// parse out just the options we care about
	const looseOption = Object.freeze({ loose: true });
	const emptyOpts = Object.freeze({ });
	const parseOptions = options => {
	  if (!options) {
	    return emptyOpts
	  }

	  if (typeof options !== 'object') {
	    return looseOption
	  }

	  return options
	};
	parseOptions_1 = parseOptions;
	return parseOptions_1;
}

var identifiers;
var hasRequiredIdentifiers;

function requireIdentifiers () {
	if (hasRequiredIdentifiers) return identifiers;
	hasRequiredIdentifiers = 1;

	const numeric = /^[0-9]+$/;
	const compareIdentifiers = (a, b) => {
	  if (typeof a === 'number' && typeof b === 'number') {
	    return a === b ? 0 : a < b ? -1 : 1
	  }

	  const anum = numeric.test(a);
	  const bnum = numeric.test(b);

	  if (anum && bnum) {
	    a = +a;
	    b = +b;
	  }

	  return a === b ? 0
	    : (anum && !bnum) ? -1
	    : (bnum && !anum) ? 1
	    : a < b ? -1
	    : 1
	};

	const rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);

	identifiers = {
	  compareIdentifiers,
	  rcompareIdentifiers,
	};
	return identifiers;
}

var semver$2;
var hasRequiredSemver$1;

function requireSemver$1 () {
	if (hasRequiredSemver$1) return semver$2;
	hasRequiredSemver$1 = 1;

	const debug = requireDebug();
	const { MAX_LENGTH, MAX_SAFE_INTEGER } = requireConstants();
	const { safeRe: re, t } = requireRe();

	const parseOptions = requireParseOptions();
	const { compareIdentifiers } = requireIdentifiers();
	class SemVer {
	  constructor (version, options) {
	    options = parseOptions(options);

	    if (version instanceof SemVer) {
	      if (version.loose === !!options.loose &&
	        version.includePrerelease === !!options.includePrerelease) {
	        return version
	      } else {
	        version = version.version;
	      }
	    } else if (typeof version !== 'string') {
	      throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`)
	    }

	    if (version.length > MAX_LENGTH) {
	      throw new TypeError(
	        `version is longer than ${MAX_LENGTH} characters`
	      )
	    }

	    debug('SemVer', version, options);
	    this.options = options;
	    this.loose = !!options.loose;
	    // this isn't actually relevant for versions, but keep it so that we
	    // don't run into trouble passing this.options around.
	    this.includePrerelease = !!options.includePrerelease;

	    const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);

	    if (!m) {
	      throw new TypeError(`Invalid Version: ${version}`)
	    }

	    this.raw = version;

	    // these are actually numbers
	    this.major = +m[1];
	    this.minor = +m[2];
	    this.patch = +m[3];

	    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
	      throw new TypeError('Invalid major version')
	    }

	    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
	      throw new TypeError('Invalid minor version')
	    }

	    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
	      throw new TypeError('Invalid patch version')
	    }

	    // numberify any prerelease numeric ids
	    if (!m[4]) {
	      this.prerelease = [];
	    } else {
	      this.prerelease = m[4].split('.').map((id) => {
	        if (/^[0-9]+$/.test(id)) {
	          const num = +id;
	          if (num >= 0 && num < MAX_SAFE_INTEGER) {
	            return num
	          }
	        }
	        return id
	      });
	    }

	    this.build = m[5] ? m[5].split('.') : [];
	    this.format();
	  }

	  format () {
	    this.version = `${this.major}.${this.minor}.${this.patch}`;
	    if (this.prerelease.length) {
	      this.version += `-${this.prerelease.join('.')}`;
	    }
	    return this.version
	  }

	  toString () {
	    return this.version
	  }

	  compare (other) {
	    debug('SemVer.compare', this.version, this.options, other);
	    if (!(other instanceof SemVer)) {
	      if (typeof other === 'string' && other === this.version) {
	        return 0
	      }
	      other = new SemVer(other, this.options);
	    }

	    if (other.version === this.version) {
	      return 0
	    }

	    return this.compareMain(other) || this.comparePre(other)
	  }

	  compareMain (other) {
	    if (!(other instanceof SemVer)) {
	      other = new SemVer(other, this.options);
	    }

	    if (this.major < other.major) {
	      return -1
	    }
	    if (this.major > other.major) {
	      return 1
	    }
	    if (this.minor < other.minor) {
	      return -1
	    }
	    if (this.minor > other.minor) {
	      return 1
	    }
	    if (this.patch < other.patch) {
	      return -1
	    }
	    if (this.patch > other.patch) {
	      return 1
	    }
	    return 0
	  }

	  comparePre (other) {
	    if (!(other instanceof SemVer)) {
	      other = new SemVer(other, this.options);
	    }

	    // NOT having a prerelease is > having one
	    if (this.prerelease.length && !other.prerelease.length) {
	      return -1
	    } else if (!this.prerelease.length && other.prerelease.length) {
	      return 1
	    } else if (!this.prerelease.length && !other.prerelease.length) {
	      return 0
	    }

	    let i = 0;
	    do {
	      const a = this.prerelease[i];
	      const b = other.prerelease[i];
	      debug('prerelease compare', i, a, b);
	      if (a === undefined && b === undefined) {
	        return 0
	      } else if (b === undefined) {
	        return 1
	      } else if (a === undefined) {
	        return -1
	      } else if (a === b) {
	        continue
	      } else {
	        return compareIdentifiers(a, b)
	      }
	    } while (++i)
	  }

	  compareBuild (other) {
	    if (!(other instanceof SemVer)) {
	      other = new SemVer(other, this.options);
	    }

	    let i = 0;
	    do {
	      const a = this.build[i];
	      const b = other.build[i];
	      debug('build compare', i, a, b);
	      if (a === undefined && b === undefined) {
	        return 0
	      } else if (b === undefined) {
	        return 1
	      } else if (a === undefined) {
	        return -1
	      } else if (a === b) {
	        continue
	      } else {
	        return compareIdentifiers(a, b)
	      }
	    } while (++i)
	  }

	  // preminor will bump the version up to the next minor release, and immediately
	  // down to pre-release. premajor and prepatch work the same way.
	  inc (release, identifier, identifierBase) {
	    if (release.startsWith('pre')) {
	      if (!identifier && identifierBase === false) {
	        throw new Error('invalid increment argument: identifier is empty')
	      }
	      // Avoid an invalid semver results
	      if (identifier) {
	        const match = `-${identifier}`.match(this.options.loose ? re[t.PRERELEASELOOSE] : re[t.PRERELEASE]);
	        if (!match || match[1] !== identifier) {
	          throw new Error(`invalid identifier: ${identifier}`)
	        }
	      }
	    }

	    switch (release) {
	      case 'premajor':
	        this.prerelease.length = 0;
	        this.patch = 0;
	        this.minor = 0;
	        this.major++;
	        this.inc('pre', identifier, identifierBase);
	        break
	      case 'preminor':
	        this.prerelease.length = 0;
	        this.patch = 0;
	        this.minor++;
	        this.inc('pre', identifier, identifierBase);
	        break
	      case 'prepatch':
	        // If this is already a prerelease, it will bump to the next version
	        // drop any prereleases that might already exist, since they are not
	        // relevant at this point.
	        this.prerelease.length = 0;
	        this.inc('patch', identifier, identifierBase);
	        this.inc('pre', identifier, identifierBase);
	        break
	      // If the input is a non-prerelease version, this acts the same as
	      // prepatch.
	      case 'prerelease':
	        if (this.prerelease.length === 0) {
	          this.inc('patch', identifier, identifierBase);
	        }
	        this.inc('pre', identifier, identifierBase);
	        break
	      case 'release':
	        if (this.prerelease.length === 0) {
	          throw new Error(`version ${this.raw} is not a prerelease`)
	        }
	        this.prerelease.length = 0;
	        break

	      case 'major':
	        // If this is a pre-major version, bump up to the same major version.
	        // Otherwise increment major.
	        // 1.0.0-5 bumps to 1.0.0
	        // 1.1.0 bumps to 2.0.0
	        if (
	          this.minor !== 0 ||
	          this.patch !== 0 ||
	          this.prerelease.length === 0
	        ) {
	          this.major++;
	        }
	        this.minor = 0;
	        this.patch = 0;
	        this.prerelease = [];
	        break
	      case 'minor':
	        // If this is a pre-minor version, bump up to the same minor version.
	        // Otherwise increment minor.
	        // 1.2.0-5 bumps to 1.2.0
	        // 1.2.1 bumps to 1.3.0
	        if (this.patch !== 0 || this.prerelease.length === 0) {
	          this.minor++;
	        }
	        this.patch = 0;
	        this.prerelease = [];
	        break
	      case 'patch':
	        // If this is not a pre-release version, it will increment the patch.
	        // If it is a pre-release it will bump up to the same patch version.
	        // 1.2.0-5 patches to 1.2.0
	        // 1.2.0 patches to 1.2.1
	        if (this.prerelease.length === 0) {
	          this.patch++;
	        }
	        this.prerelease = [];
	        break
	      // This probably shouldn't be used publicly.
	      // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
	      case 'pre': {
	        const base = Number(identifierBase) ? 1 : 0;

	        if (this.prerelease.length === 0) {
	          this.prerelease = [base];
	        } else {
	          let i = this.prerelease.length;
	          while (--i >= 0) {
	            if (typeof this.prerelease[i] === 'number') {
	              this.prerelease[i]++;
	              i = -2;
	            }
	          }
	          if (i === -1) {
	            // didn't increment anything
	            if (identifier === this.prerelease.join('.') && identifierBase === false) {
	              throw new Error('invalid increment argument: identifier already exists')
	            }
	            this.prerelease.push(base);
	          }
	        }
	        if (identifier) {
	          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
	          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
	          let prerelease = [identifier, base];
	          if (identifierBase === false) {
	            prerelease = [identifier];
	          }
	          if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
	            if (isNaN(this.prerelease[1])) {
	              this.prerelease = prerelease;
	            }
	          } else {
	            this.prerelease = prerelease;
	          }
	        }
	        break
	      }
	      default:
	        throw new Error(`invalid increment argument: ${release}`)
	    }
	    this.raw = this.format();
	    if (this.build.length) {
	      this.raw += `+${this.build.join('.')}`;
	    }
	    return this
	  }
	}

	semver$2 = SemVer;
	return semver$2;
}

var parse_1;
var hasRequiredParse;

function requireParse () {
	if (hasRequiredParse) return parse_1;
	hasRequiredParse = 1;

	const SemVer = requireSemver$1();
	const parse = (version, options, throwErrors = false) => {
	  if (version instanceof SemVer) {
	    return version
	  }
	  try {
	    return new SemVer(version, options)
	  } catch (er) {
	    if (!throwErrors) {
	      return null
	    }
	    throw er
	  }
	};

	parse_1 = parse;
	return parse_1;
}

var valid_1;
var hasRequiredValid$1;

function requireValid$1 () {
	if (hasRequiredValid$1) return valid_1;
	hasRequiredValid$1 = 1;

	const parse = requireParse();
	const valid = (version, options) => {
	  const v = parse(version, options);
	  return v ? v.version : null
	};
	valid_1 = valid;
	return valid_1;
}

var clean_1;
var hasRequiredClean;

function requireClean () {
	if (hasRequiredClean) return clean_1;
	hasRequiredClean = 1;

	const parse = requireParse();
	const clean = (version, options) => {
	  const s = parse(version.trim().replace(/^[=v]+/, ''), options);
	  return s ? s.version : null
	};
	clean_1 = clean;
	return clean_1;
}

var inc_1;
var hasRequiredInc;

function requireInc () {
	if (hasRequiredInc) return inc_1;
	hasRequiredInc = 1;

	const SemVer = requireSemver$1();

	const inc = (version, release, options, identifier, identifierBase) => {
	  if (typeof (options) === 'string') {
	    identifierBase = identifier;
	    identifier = options;
	    options = undefined;
	  }

	  try {
	    return new SemVer(
	      version instanceof SemVer ? version.version : version,
	      options
	    ).inc(release, identifier, identifierBase).version
	  } catch (er) {
	    return null
	  }
	};
	inc_1 = inc;
	return inc_1;
}

var diff_1;
var hasRequiredDiff;

function requireDiff () {
	if (hasRequiredDiff) return diff_1;
	hasRequiredDiff = 1;

	const parse = requireParse();

	const diff = (version1, version2) => {
	  const v1 = parse(version1, null, true);
	  const v2 = parse(version2, null, true);
	  const comparison = v1.compare(v2);

	  if (comparison === 0) {
	    return null
	  }

	  const v1Higher = comparison > 0;
	  const highVersion = v1Higher ? v1 : v2;
	  const lowVersion = v1Higher ? v2 : v1;
	  const highHasPre = !!highVersion.prerelease.length;
	  const lowHasPre = !!lowVersion.prerelease.length;

	  if (lowHasPre && !highHasPre) {
	    // Going from prerelease -> no prerelease requires some special casing

	    // If the low version has only a major, then it will always be a major
	    // Some examples:
	    // 1.0.0-1 -> 1.0.0
	    // 1.0.0-1 -> 1.1.1
	    // 1.0.0-1 -> 2.0.0
	    if (!lowVersion.patch && !lowVersion.minor) {
	      return 'major'
	    }

	    // If the main part has no difference
	    if (lowVersion.compareMain(highVersion) === 0) {
	      if (lowVersion.minor && !lowVersion.patch) {
	        return 'minor'
	      }
	      return 'patch'
	    }
	  }

	  // add the `pre` prefix if we are going to a prerelease version
	  const prefix = highHasPre ? 'pre' : '';

	  if (v1.major !== v2.major) {
	    return prefix + 'major'
	  }

	  if (v1.minor !== v2.minor) {
	    return prefix + 'minor'
	  }

	  if (v1.patch !== v2.patch) {
	    return prefix + 'patch'
	  }

	  // high and low are preleases
	  return 'prerelease'
	};

	diff_1 = diff;
	return diff_1;
}

var major_1;
var hasRequiredMajor;

function requireMajor () {
	if (hasRequiredMajor) return major_1;
	hasRequiredMajor = 1;

	const SemVer = requireSemver$1();
	const major = (a, loose) => new SemVer(a, loose).major;
	major_1 = major;
	return major_1;
}

var minor_1;
var hasRequiredMinor;

function requireMinor () {
	if (hasRequiredMinor) return minor_1;
	hasRequiredMinor = 1;

	const SemVer = requireSemver$1();
	const minor = (a, loose) => new SemVer(a, loose).minor;
	minor_1 = minor;
	return minor_1;
}

var patch_1;
var hasRequiredPatch;

function requirePatch () {
	if (hasRequiredPatch) return patch_1;
	hasRequiredPatch = 1;

	const SemVer = requireSemver$1();
	const patch = (a, loose) => new SemVer(a, loose).patch;
	patch_1 = patch;
	return patch_1;
}

var prerelease_1;
var hasRequiredPrerelease;

function requirePrerelease () {
	if (hasRequiredPrerelease) return prerelease_1;
	hasRequiredPrerelease = 1;

	const parse = requireParse();
	const prerelease = (version, options) => {
	  const parsed = parse(version, options);
	  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null
	};
	prerelease_1 = prerelease;
	return prerelease_1;
}

var compare_1;
var hasRequiredCompare;

function requireCompare () {
	if (hasRequiredCompare) return compare_1;
	hasRequiredCompare = 1;

	const SemVer = requireSemver$1();
	const compare = (a, b, loose) =>
	  new SemVer(a, loose).compare(new SemVer(b, loose));

	compare_1 = compare;
	return compare_1;
}

var rcompare_1;
var hasRequiredRcompare;

function requireRcompare () {
	if (hasRequiredRcompare) return rcompare_1;
	hasRequiredRcompare = 1;

	const compare = requireCompare();
	const rcompare = (a, b, loose) => compare(b, a, loose);
	rcompare_1 = rcompare;
	return rcompare_1;
}

var compareLoose_1;
var hasRequiredCompareLoose;

function requireCompareLoose () {
	if (hasRequiredCompareLoose) return compareLoose_1;
	hasRequiredCompareLoose = 1;

	const compare = requireCompare();
	const compareLoose = (a, b) => compare(a, b, true);
	compareLoose_1 = compareLoose;
	return compareLoose_1;
}

var compareBuild_1;
var hasRequiredCompareBuild;

function requireCompareBuild () {
	if (hasRequiredCompareBuild) return compareBuild_1;
	hasRequiredCompareBuild = 1;

	const SemVer = requireSemver$1();
	const compareBuild = (a, b, loose) => {
	  const versionA = new SemVer(a, loose);
	  const versionB = new SemVer(b, loose);
	  return versionA.compare(versionB) || versionA.compareBuild(versionB)
	};
	compareBuild_1 = compareBuild;
	return compareBuild_1;
}

var sort_1;
var hasRequiredSort;

function requireSort () {
	if (hasRequiredSort) return sort_1;
	hasRequiredSort = 1;

	const compareBuild = requireCompareBuild();
	const sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
	sort_1 = sort;
	return sort_1;
}

var rsort_1;
var hasRequiredRsort;

function requireRsort () {
	if (hasRequiredRsort) return rsort_1;
	hasRequiredRsort = 1;

	const compareBuild = requireCompareBuild();
	const rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
	rsort_1 = rsort;
	return rsort_1;
}

var gt_1;
var hasRequiredGt;

function requireGt () {
	if (hasRequiredGt) return gt_1;
	hasRequiredGt = 1;

	const compare = requireCompare();
	const gt = (a, b, loose) => compare(a, b, loose) > 0;
	gt_1 = gt;
	return gt_1;
}

var lt_1;
var hasRequiredLt;

function requireLt () {
	if (hasRequiredLt) return lt_1;
	hasRequiredLt = 1;

	const compare = requireCompare();
	const lt = (a, b, loose) => compare(a, b, loose) < 0;
	lt_1 = lt;
	return lt_1;
}

var eq_1;
var hasRequiredEq;

function requireEq () {
	if (hasRequiredEq) return eq_1;
	hasRequiredEq = 1;

	const compare = requireCompare();
	const eq = (a, b, loose) => compare(a, b, loose) === 0;
	eq_1 = eq;
	return eq_1;
}

var neq_1;
var hasRequiredNeq;

function requireNeq () {
	if (hasRequiredNeq) return neq_1;
	hasRequiredNeq = 1;

	const compare = requireCompare();
	const neq = (a, b, loose) => compare(a, b, loose) !== 0;
	neq_1 = neq;
	return neq_1;
}

var gte_1;
var hasRequiredGte;

function requireGte () {
	if (hasRequiredGte) return gte_1;
	hasRequiredGte = 1;

	const compare = requireCompare();
	const gte = (a, b, loose) => compare(a, b, loose) >= 0;
	gte_1 = gte;
	return gte_1;
}

var lte_1;
var hasRequiredLte;

function requireLte () {
	if (hasRequiredLte) return lte_1;
	hasRequiredLte = 1;

	const compare = requireCompare();
	const lte = (a, b, loose) => compare(a, b, loose) <= 0;
	lte_1 = lte;
	return lte_1;
}

var cmp_1;
var hasRequiredCmp;

function requireCmp () {
	if (hasRequiredCmp) return cmp_1;
	hasRequiredCmp = 1;

	const eq = requireEq();
	const neq = requireNeq();
	const gt = requireGt();
	const gte = requireGte();
	const lt = requireLt();
	const lte = requireLte();

	const cmp = (a, op, b, loose) => {
	  switch (op) {
	    case '===':
	      if (typeof a === 'object') {
	        a = a.version;
	      }
	      if (typeof b === 'object') {
	        b = b.version;
	      }
	      return a === b

	    case '!==':
	      if (typeof a === 'object') {
	        a = a.version;
	      }
	      if (typeof b === 'object') {
	        b = b.version;
	      }
	      return a !== b

	    case '':
	    case '=':
	    case '==':
	      return eq(a, b, loose)

	    case '!=':
	      return neq(a, b, loose)

	    case '>':
	      return gt(a, b, loose)

	    case '>=':
	      return gte(a, b, loose)

	    case '<':
	      return lt(a, b, loose)

	    case '<=':
	      return lte(a, b, loose)

	    default:
	      throw new TypeError(`Invalid operator: ${op}`)
	  }
	};
	cmp_1 = cmp;
	return cmp_1;
}

var coerce_1;
var hasRequiredCoerce;

function requireCoerce () {
	if (hasRequiredCoerce) return coerce_1;
	hasRequiredCoerce = 1;

	const SemVer = requireSemver$1();
	const parse = requireParse();
	const { safeRe: re, t } = requireRe();

	const coerce = (version, options) => {
	  if (version instanceof SemVer) {
	    return version
	  }

	  if (typeof version === 'number') {
	    version = String(version);
	  }

	  if (typeof version !== 'string') {
	    return null
	  }

	  options = options || {};

	  let match = null;
	  if (!options.rtl) {
	    match = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
	  } else {
	    // Find the right-most coercible string that does not share
	    // a terminus with a more left-ward coercible string.
	    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
	    // With includePrerelease option set, '1.2.3.4-rc' wants to coerce '2.3.4-rc', not '2.3.4'
	    //
	    // Walk through the string checking with a /g regexp
	    // Manually set the index so as to pick up overlapping matches.
	    // Stop when we get a match that ends at the string end, since no
	    // coercible string can be more right-ward without the same terminus.
	    const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
	    let next;
	    while ((next = coerceRtlRegex.exec(version)) &&
	        (!match || match.index + match[0].length !== version.length)
	    ) {
	      if (!match ||
	            next.index + next[0].length !== match.index + match[0].length) {
	        match = next;
	      }
	      coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
	    }
	    // leave it in a clean state
	    coerceRtlRegex.lastIndex = -1;
	  }

	  if (match === null) {
	    return null
	  }

	  const major = match[2];
	  const minor = match[3] || '0';
	  const patch = match[4] || '0';
	  const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : '';
	  const build = options.includePrerelease && match[6] ? `+${match[6]}` : '';

	  return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options)
	};
	coerce_1 = coerce;
	return coerce_1;
}

var lrucache;
var hasRequiredLrucache;

function requireLrucache () {
	if (hasRequiredLrucache) return lrucache;
	hasRequiredLrucache = 1;

	class LRUCache {
	  constructor () {
	    this.max = 1000;
	    this.map = new Map();
	  }

	  get (key) {
	    const value = this.map.get(key);
	    if (value === undefined) {
	      return undefined
	    } else {
	      // Remove the key from the map and add it to the end
	      this.map.delete(key);
	      this.map.set(key, value);
	      return value
	    }
	  }

	  delete (key) {
	    return this.map.delete(key)
	  }

	  set (key, value) {
	    const deleted = this.delete(key);

	    if (!deleted && value !== undefined) {
	      // If cache is full, delete the least recently used item
	      if (this.map.size >= this.max) {
	        const firstKey = this.map.keys().next().value;
	        this.delete(firstKey);
	      }

	      this.map.set(key, value);
	    }

	    return this
	  }
	}

	lrucache = LRUCache;
	return lrucache;
}

var range;
var hasRequiredRange;

function requireRange () {
	if (hasRequiredRange) return range;
	hasRequiredRange = 1;

	const SPACE_CHARACTERS = /\s+/g;

	// hoisted class for cyclic dependency
	class Range {
	  constructor (range, options) {
	    options = parseOptions(options);

	    if (range instanceof Range) {
	      if (
	        range.loose === !!options.loose &&
	        range.includePrerelease === !!options.includePrerelease
	      ) {
	        return range
	      } else {
	        return new Range(range.raw, options)
	      }
	    }

	    if (range instanceof Comparator) {
	      // just put it in the set and return
	      this.raw = range.value;
	      this.set = [[range]];
	      this.formatted = undefined;
	      return this
	    }

	    this.options = options;
	    this.loose = !!options.loose;
	    this.includePrerelease = !!options.includePrerelease;

	    // First reduce all whitespace as much as possible so we do not have to rely
	    // on potentially slow regexes like \s*. This is then stored and used for
	    // future error messages as well.
	    this.raw = range.trim().replace(SPACE_CHARACTERS, ' ');

	    // First, split on ||
	    this.set = this.raw
	      .split('||')
	      // map the range to a 2d array of comparators
	      .map(r => this.parseRange(r.trim()))
	      // throw out any comparator lists that are empty
	      // this generally means that it was not a valid range, which is allowed
	      // in loose mode, but will still throw if the WHOLE range is invalid.
	      .filter(c => c.length);

	    if (!this.set.length) {
	      throw new TypeError(`Invalid SemVer Range: ${this.raw}`)
	    }

	    // if we have any that are not the null set, throw out null sets.
	    if (this.set.length > 1) {
	      // keep the first one, in case they're all null sets
	      const first = this.set[0];
	      this.set = this.set.filter(c => !isNullSet(c[0]));
	      if (this.set.length === 0) {
	        this.set = [first];
	      } else if (this.set.length > 1) {
	        // if we have any that are *, then the range is just *
	        for (const c of this.set) {
	          if (c.length === 1 && isAny(c[0])) {
	            this.set = [c];
	            break
	          }
	        }
	      }
	    }

	    this.formatted = undefined;
	  }

	  get range () {
	    if (this.formatted === undefined) {
	      this.formatted = '';
	      for (let i = 0; i < this.set.length; i++) {
	        if (i > 0) {
	          this.formatted += '||';
	        }
	        const comps = this.set[i];
	        for (let k = 0; k < comps.length; k++) {
	          if (k > 0) {
	            this.formatted += ' ';
	          }
	          this.formatted += comps[k].toString().trim();
	        }
	      }
	    }
	    return this.formatted
	  }

	  format () {
	    return this.range
	  }

	  toString () {
	    return this.range
	  }

	  parseRange (range) {
	    // memoize range parsing for performance.
	    // this is a very hot path, and fully deterministic.
	    const memoOpts =
	      (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) |
	      (this.options.loose && FLAG_LOOSE);
	    const memoKey = memoOpts + ':' + range;
	    const cached = cache.get(memoKey);
	    if (cached) {
	      return cached
	    }

	    const loose = this.options.loose;
	    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
	    const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
	    range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
	    debug('hyphen replace', range);

	    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
	    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
	    debug('comparator trim', range);

	    // `~ 1.2.3` => `~1.2.3`
	    range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
	    debug('tilde trim', range);

	    // `^ 1.2.3` => `^1.2.3`
	    range = range.replace(re[t.CARETTRIM], caretTrimReplace);
	    debug('caret trim', range);

	    // At this point, the range is completely trimmed and
	    // ready to be split into comparators.

	    let rangeList = range
	      .split(' ')
	      .map(comp => parseComparator(comp, this.options))
	      .join(' ')
	      .split(/\s+/)
	      // >=0.0.0 is equivalent to *
	      .map(comp => replaceGTE0(comp, this.options));

	    if (loose) {
	      // in loose mode, throw out any that are not valid comparators
	      rangeList = rangeList.filter(comp => {
	        debug('loose invalid filter', comp, this.options);
	        return !!comp.match(re[t.COMPARATORLOOSE])
	      });
	    }
	    debug('range list', rangeList);

	    // if any comparators are the null set, then replace with JUST null set
	    // if more than one comparator, remove any * comparators
	    // also, don't include the same comparator more than once
	    const rangeMap = new Map();
	    const comparators = rangeList.map(comp => new Comparator(comp, this.options));
	    for (const comp of comparators) {
	      if (isNullSet(comp)) {
	        return [comp]
	      }
	      rangeMap.set(comp.value, comp);
	    }
	    if (rangeMap.size > 1 && rangeMap.has('')) {
	      rangeMap.delete('');
	    }

	    const result = [...rangeMap.values()];
	    cache.set(memoKey, result);
	    return result
	  }

	  intersects (range, options) {
	    if (!(range instanceof Range)) {
	      throw new TypeError('a Range is required')
	    }

	    return this.set.some((thisComparators) => {
	      return (
	        isSatisfiable(thisComparators, options) &&
	        range.set.some((rangeComparators) => {
	          return (
	            isSatisfiable(rangeComparators, options) &&
	            thisComparators.every((thisComparator) => {
	              return rangeComparators.every((rangeComparator) => {
	                return thisComparator.intersects(rangeComparator, options)
	              })
	            })
	          )
	        })
	      )
	    })
	  }

	  // if ANY of the sets match ALL of its comparators, then pass
	  test (version) {
	    if (!version) {
	      return false
	    }

	    if (typeof version === 'string') {
	      try {
	        version = new SemVer(version, this.options);
	      } catch (er) {
	        return false
	      }
	    }

	    for (let i = 0; i < this.set.length; i++) {
	      if (testSet(this.set[i], version, this.options)) {
	        return true
	      }
	    }
	    return false
	  }
	}

	range = Range;

	const LRU = requireLrucache();
	const cache = new LRU();

	const parseOptions = requireParseOptions();
	const Comparator = requireComparator();
	const debug = requireDebug();
	const SemVer = requireSemver$1();
	const {
	  safeRe: re,
	  t,
	  comparatorTrimReplace,
	  tildeTrimReplace,
	  caretTrimReplace,
	} = requireRe();
	const { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = requireConstants();

	const isNullSet = c => c.value === '<0.0.0-0';
	const isAny = c => c.value === '';

	// take a set of comparators and determine whether there
	// exists a version which can satisfy it
	const isSatisfiable = (comparators, options) => {
	  let result = true;
	  const remainingComparators = comparators.slice();
	  let testComparator = remainingComparators.pop();

	  while (result && remainingComparators.length) {
	    result = remainingComparators.every((otherComparator) => {
	      return testComparator.intersects(otherComparator, options)
	    });

	    testComparator = remainingComparators.pop();
	  }

	  return result
	};

	// comprised of xranges, tildes, stars, and gtlt's at this point.
	// already replaced the hyphen ranges
	// turn into a set of JUST comparators.
	const parseComparator = (comp, options) => {
	  comp = comp.replace(re[t.BUILD], '');
	  debug('comp', comp, options);
	  comp = replaceCarets(comp, options);
	  debug('caret', comp);
	  comp = replaceTildes(comp, options);
	  debug('tildes', comp);
	  comp = replaceXRanges(comp, options);
	  debug('xrange', comp);
	  comp = replaceStars(comp, options);
	  debug('stars', comp);
	  return comp
	};

	const isX = id => !id || id.toLowerCase() === 'x' || id === '*';

	// ~, ~> --> * (any, kinda silly)
	// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0
	// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0
	// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0
	// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0
	// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0
	// ~0.0.1 --> >=0.0.1 <0.1.0-0
	const replaceTildes = (comp, options) => {
	  return comp
	    .trim()
	    .split(/\s+/)
	    .map((c) => replaceTilde(c, options))
	    .join(' ')
	};

	const replaceTilde = (comp, options) => {
	  const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
	  return comp.replace(r, (_, M, m, p, pr) => {
	    debug('tilde', comp, _, M, m, p, pr);
	    let ret;

	    if (isX(M)) {
	      ret = '';
	    } else if (isX(m)) {
	      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
	    } else if (isX(p)) {
	      // ~1.2 == >=1.2.0 <1.3.0-0
	      ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
	    } else if (pr) {
	      debug('replaceTilde pr', pr);
	      ret = `>=${M}.${m}.${p}-${pr
	      } <${M}.${+m + 1}.0-0`;
	    } else {
	      // ~1.2.3 == >=1.2.3 <1.3.0-0
	      ret = `>=${M}.${m}.${p
	      } <${M}.${+m + 1}.0-0`;
	    }

	    debug('tilde return', ret);
	    return ret
	  })
	};

	// ^ --> * (any, kinda silly)
	// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0
	// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0
	// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0
	// ^1.2.3 --> >=1.2.3 <2.0.0-0
	// ^1.2.0 --> >=1.2.0 <2.0.0-0
	// ^0.0.1 --> >=0.0.1 <0.0.2-0
	// ^0.1.0 --> >=0.1.0 <0.2.0-0
	const replaceCarets = (comp, options) => {
	  return comp
	    .trim()
	    .split(/\s+/)
	    .map((c) => replaceCaret(c, options))
	    .join(' ')
	};

	const replaceCaret = (comp, options) => {
	  debug('caret', comp, options);
	  const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
	  const z = options.includePrerelease ? '-0' : '';
	  return comp.replace(r, (_, M, m, p, pr) => {
	    debug('caret', comp, _, M, m, p, pr);
	    let ret;

	    if (isX(M)) {
	      ret = '';
	    } else if (isX(m)) {
	      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
	    } else if (isX(p)) {
	      if (M === '0') {
	        ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
	      } else {
	        ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
	      }
	    } else if (pr) {
	      debug('replaceCaret pr', pr);
	      if (M === '0') {
	        if (m === '0') {
	          ret = `>=${M}.${m}.${p}-${pr
	          } <${M}.${m}.${+p + 1}-0`;
	        } else {
	          ret = `>=${M}.${m}.${p}-${pr
	          } <${M}.${+m + 1}.0-0`;
	        }
	      } else {
	        ret = `>=${M}.${m}.${p}-${pr
	        } <${+M + 1}.0.0-0`;
	      }
	    } else {
	      debug('no pr');
	      if (M === '0') {
	        if (m === '0') {
	          ret = `>=${M}.${m}.${p
	          }${z} <${M}.${m}.${+p + 1}-0`;
	        } else {
	          ret = `>=${M}.${m}.${p
	          }${z} <${M}.${+m + 1}.0-0`;
	        }
	      } else {
	        ret = `>=${M}.${m}.${p
	        } <${+M + 1}.0.0-0`;
	      }
	    }

	    debug('caret return', ret);
	    return ret
	  })
	};

	const replaceXRanges = (comp, options) => {
	  debug('replaceXRanges', comp, options);
	  return comp
	    .split(/\s+/)
	    .map((c) => replaceXRange(c, options))
	    .join(' ')
	};

	const replaceXRange = (comp, options) => {
	  comp = comp.trim();
	  const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
	  return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
	    debug('xRange', comp, ret, gtlt, M, m, p, pr);
	    const xM = isX(M);
	    const xm = xM || isX(m);
	    const xp = xm || isX(p);
	    const anyX = xp;

	    if (gtlt === '=' && anyX) {
	      gtlt = '';
	    }

	    // if we're including prereleases in the match, then we need
	    // to fix this to -0, the lowest possible prerelease value
	    pr = options.includePrerelease ? '-0' : '';

	    if (xM) {
	      if (gtlt === '>' || gtlt === '<') {
	        // nothing is allowed
	        ret = '<0.0.0-0';
	      } else {
	        // nothing is forbidden
	        ret = '*';
	      }
	    } else if (gtlt && anyX) {
	      // we know patch is an x, because we have any x at all.
	      // replace X with 0
	      if (xm) {
	        m = 0;
	      }
	      p = 0;

	      if (gtlt === '>') {
	        // >1 => >=2.0.0
	        // >1.2 => >=1.3.0
	        gtlt = '>=';
	        if (xm) {
	          M = +M + 1;
	          m = 0;
	          p = 0;
	        } else {
	          m = +m + 1;
	          p = 0;
	        }
	      } else if (gtlt === '<=') {
	        // <=0.7.x is actually <0.8.0, since any 0.7.x should
	        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
	        gtlt = '<';
	        if (xm) {
	          M = +M + 1;
	        } else {
	          m = +m + 1;
	        }
	      }

	      if (gtlt === '<') {
	        pr = '-0';
	      }

	      ret = `${gtlt + M}.${m}.${p}${pr}`;
	    } else if (xm) {
	      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
	    } else if (xp) {
	      ret = `>=${M}.${m}.0${pr
	      } <${M}.${+m + 1}.0-0`;
	    }

	    debug('xRange return', ret);

	    return ret
	  })
	};

	// Because * is AND-ed with everything else in the comparator,
	// and '' means "any version", just remove the *s entirely.
	const replaceStars = (comp, options) => {
	  debug('replaceStars', comp, options);
	  // Looseness is ignored here.  star is always as loose as it gets!
	  return comp
	    .trim()
	    .replace(re[t.STAR], '')
	};

	const replaceGTE0 = (comp, options) => {
	  debug('replaceGTE0', comp, options);
	  return comp
	    .trim()
	    .replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '')
	};

	// This function is passed to string.replace(re[t.HYPHENRANGE])
	// M, m, patch, prerelease, build
	// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
	// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do
	// 1.2 - 3.4 => >=1.2.0 <3.5.0-0
	// TODO build?
	const hyphenReplace = incPr => ($0,
	  from, fM, fm, fp, fpr, fb,
	  to, tM, tm, tp, tpr) => {
	  if (isX(fM)) {
	    from = '';
	  } else if (isX(fm)) {
	    from = `>=${fM}.0.0${incPr ? '-0' : ''}`;
	  } else if (isX(fp)) {
	    from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`;
	  } else if (fpr) {
	    from = `>=${from}`;
	  } else {
	    from = `>=${from}${incPr ? '-0' : ''}`;
	  }

	  if (isX(tM)) {
	    to = '';
	  } else if (isX(tm)) {
	    to = `<${+tM + 1}.0.0-0`;
	  } else if (isX(tp)) {
	    to = `<${tM}.${+tm + 1}.0-0`;
	  } else if (tpr) {
	    to = `<=${tM}.${tm}.${tp}-${tpr}`;
	  } else if (incPr) {
	    to = `<${tM}.${tm}.${+tp + 1}-0`;
	  } else {
	    to = `<=${to}`;
	  }

	  return `${from} ${to}`.trim()
	};

	const testSet = (set, version, options) => {
	  for (let i = 0; i < set.length; i++) {
	    if (!set[i].test(version)) {
	      return false
	    }
	  }

	  if (version.prerelease.length && !options.includePrerelease) {
	    // Find the set of versions that are allowed to have prereleases
	    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
	    // That should allow `1.2.3-pr.2` to pass.
	    // However, `1.2.4-alpha.notready` should NOT be allowed,
	    // even though it's within the range set by the comparators.
	    for (let i = 0; i < set.length; i++) {
	      debug(set[i].semver);
	      if (set[i].semver === Comparator.ANY) {
	        continue
	      }

	      if (set[i].semver.prerelease.length > 0) {
	        const allowed = set[i].semver;
	        if (allowed.major === version.major &&
	            allowed.minor === version.minor &&
	            allowed.patch === version.patch) {
	          return true
	        }
	      }
	    }

	    // Version has a -pre, but it's not one of the ones we like.
	    return false
	  }

	  return true
	};
	return range;
}

var comparator;
var hasRequiredComparator;

function requireComparator () {
	if (hasRequiredComparator) return comparator;
	hasRequiredComparator = 1;

	const ANY = Symbol('SemVer ANY');
	// hoisted class for cyclic dependency
	class Comparator {
	  static get ANY () {
	    return ANY
	  }

	  constructor (comp, options) {
	    options = parseOptions(options);

	    if (comp instanceof Comparator) {
	      if (comp.loose === !!options.loose) {
	        return comp
	      } else {
	        comp = comp.value;
	      }
	    }

	    comp = comp.trim().split(/\s+/).join(' ');
	    debug('comparator', comp, options);
	    this.options = options;
	    this.loose = !!options.loose;
	    this.parse(comp);

	    if (this.semver === ANY) {
	      this.value = '';
	    } else {
	      this.value = this.operator + this.semver.version;
	    }

	    debug('comp', this);
	  }

	  parse (comp) {
	    const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
	    const m = comp.match(r);

	    if (!m) {
	      throw new TypeError(`Invalid comparator: ${comp}`)
	    }

	    this.operator = m[1] !== undefined ? m[1] : '';
	    if (this.operator === '=') {
	      this.operator = '';
	    }

	    // if it literally is just '>' or '' then allow anything.
	    if (!m[2]) {
	      this.semver = ANY;
	    } else {
	      this.semver = new SemVer(m[2], this.options.loose);
	    }
	  }

	  toString () {
	    return this.value
	  }

	  test (version) {
	    debug('Comparator.test', version, this.options.loose);

	    if (this.semver === ANY || version === ANY) {
	      return true
	    }

	    if (typeof version === 'string') {
	      try {
	        version = new SemVer(version, this.options);
	      } catch (er) {
	        return false
	      }
	    }

	    return cmp(version, this.operator, this.semver, this.options)
	  }

	  intersects (comp, options) {
	    if (!(comp instanceof Comparator)) {
	      throw new TypeError('a Comparator is required')
	    }

	    if (this.operator === '') {
	      if (this.value === '') {
	        return true
	      }
	      return new Range(comp.value, options).test(this.value)
	    } else if (comp.operator === '') {
	      if (comp.value === '') {
	        return true
	      }
	      return new Range(this.value, options).test(comp.semver)
	    }

	    options = parseOptions(options);

	    // Special cases where nothing can possibly be lower
	    if (options.includePrerelease &&
	      (this.value === '<0.0.0-0' || comp.value === '<0.0.0-0')) {
	      return false
	    }
	    if (!options.includePrerelease &&
	      (this.value.startsWith('<0.0.0') || comp.value.startsWith('<0.0.0'))) {
	      return false
	    }

	    // Same direction increasing (> or >=)
	    if (this.operator.startsWith('>') && comp.operator.startsWith('>')) {
	      return true
	    }
	    // Same direction decreasing (< or <=)
	    if (this.operator.startsWith('<') && comp.operator.startsWith('<')) {
	      return true
	    }
	    // same SemVer and both sides are inclusive (<= or >=)
	    if (
	      (this.semver.version === comp.semver.version) &&
	      this.operator.includes('=') && comp.operator.includes('=')) {
	      return true
	    }
	    // opposite directions less than
	    if (cmp(this.semver, '<', comp.semver, options) &&
	      this.operator.startsWith('>') && comp.operator.startsWith('<')) {
	      return true
	    }
	    // opposite directions greater than
	    if (cmp(this.semver, '>', comp.semver, options) &&
	      this.operator.startsWith('<') && comp.operator.startsWith('>')) {
	      return true
	    }
	    return false
	  }
	}

	comparator = Comparator;

	const parseOptions = requireParseOptions();
	const { safeRe: re, t } = requireRe();
	const cmp = requireCmp();
	const debug = requireDebug();
	const SemVer = requireSemver$1();
	const Range = requireRange();
	return comparator;
}

var satisfies_1;
var hasRequiredSatisfies;

function requireSatisfies () {
	if (hasRequiredSatisfies) return satisfies_1;
	hasRequiredSatisfies = 1;

	const Range = requireRange();
	const satisfies = (version, range, options) => {
	  try {
	    range = new Range(range, options);
	  } catch (er) {
	    return false
	  }
	  return range.test(version)
	};
	satisfies_1 = satisfies;
	return satisfies_1;
}

var toComparators_1;
var hasRequiredToComparators;

function requireToComparators () {
	if (hasRequiredToComparators) return toComparators_1;
	hasRequiredToComparators = 1;

	const Range = requireRange();

	// Mostly just for testing and legacy API reasons
	const toComparators = (range, options) =>
	  new Range(range, options).set
	    .map(comp => comp.map(c => c.value).join(' ').trim().split(' '));

	toComparators_1 = toComparators;
	return toComparators_1;
}

var maxSatisfying_1;
var hasRequiredMaxSatisfying;

function requireMaxSatisfying () {
	if (hasRequiredMaxSatisfying) return maxSatisfying_1;
	hasRequiredMaxSatisfying = 1;

	const SemVer = requireSemver$1();
	const Range = requireRange();

	const maxSatisfying = (versions, range, options) => {
	  let max = null;
	  let maxSV = null;
	  let rangeObj = null;
	  try {
	    rangeObj = new Range(range, options);
	  } catch (er) {
	    return null
	  }
	  versions.forEach((v) => {
	    if (rangeObj.test(v)) {
	      // satisfies(v, range, options)
	      if (!max || maxSV.compare(v) === -1) {
	        // compare(max, v, true)
	        max = v;
	        maxSV = new SemVer(max, options);
	      }
	    }
	  });
	  return max
	};
	maxSatisfying_1 = maxSatisfying;
	return maxSatisfying_1;
}

var minSatisfying_1;
var hasRequiredMinSatisfying;

function requireMinSatisfying () {
	if (hasRequiredMinSatisfying) return minSatisfying_1;
	hasRequiredMinSatisfying = 1;

	const SemVer = requireSemver$1();
	const Range = requireRange();
	const minSatisfying = (versions, range, options) => {
	  let min = null;
	  let minSV = null;
	  let rangeObj = null;
	  try {
	    rangeObj = new Range(range, options);
	  } catch (er) {
	    return null
	  }
	  versions.forEach((v) => {
	    if (rangeObj.test(v)) {
	      // satisfies(v, range, options)
	      if (!min || minSV.compare(v) === 1) {
	        // compare(min, v, true)
	        min = v;
	        minSV = new SemVer(min, options);
	      }
	    }
	  });
	  return min
	};
	minSatisfying_1 = minSatisfying;
	return minSatisfying_1;
}

var minVersion_1;
var hasRequiredMinVersion;

function requireMinVersion () {
	if (hasRequiredMinVersion) return minVersion_1;
	hasRequiredMinVersion = 1;

	const SemVer = requireSemver$1();
	const Range = requireRange();
	const gt = requireGt();

	const minVersion = (range, loose) => {
	  range = new Range(range, loose);

	  let minver = new SemVer('0.0.0');
	  if (range.test(minver)) {
	    return minver
	  }

	  minver = new SemVer('0.0.0-0');
	  if (range.test(minver)) {
	    return minver
	  }

	  minver = null;
	  for (let i = 0; i < range.set.length; ++i) {
	    const comparators = range.set[i];

	    let setMin = null;
	    comparators.forEach((comparator) => {
	      // Clone to avoid manipulating the comparator's semver object.
	      const compver = new SemVer(comparator.semver.version);
	      switch (comparator.operator) {
	        case '>':
	          if (compver.prerelease.length === 0) {
	            compver.patch++;
	          } else {
	            compver.prerelease.push(0);
	          }
	          compver.raw = compver.format();
	          /* fallthrough */
	        case '':
	        case '>=':
	          if (!setMin || gt(compver, setMin)) {
	            setMin = compver;
	          }
	          break
	        case '<':
	        case '<=':
	          /* Ignore maximum versions */
	          break
	        /* istanbul ignore next */
	        default:
	          throw new Error(`Unexpected operation: ${comparator.operator}`)
	      }
	    });
	    if (setMin && (!minver || gt(minver, setMin))) {
	      minver = setMin;
	    }
	  }

	  if (minver && range.test(minver)) {
	    return minver
	  }

	  return null
	};
	minVersion_1 = minVersion;
	return minVersion_1;
}

var valid;
var hasRequiredValid;

function requireValid () {
	if (hasRequiredValid) return valid;
	hasRequiredValid = 1;

	const Range = requireRange();
	const validRange = (range, options) => {
	  try {
	    // Return '*' instead of '' so that truthiness works.
	    // This will throw if it's invalid anyway
	    return new Range(range, options).range || '*'
	  } catch (er) {
	    return null
	  }
	};
	valid = validRange;
	return valid;
}

var outside_1;
var hasRequiredOutside;

function requireOutside () {
	if (hasRequiredOutside) return outside_1;
	hasRequiredOutside = 1;

	const SemVer = requireSemver$1();
	const Comparator = requireComparator();
	const { ANY } = Comparator;
	const Range = requireRange();
	const satisfies = requireSatisfies();
	const gt = requireGt();
	const lt = requireLt();
	const lte = requireLte();
	const gte = requireGte();

	const outside = (version, range, hilo, options) => {
	  version = new SemVer(version, options);
	  range = new Range(range, options);

	  let gtfn, ltefn, ltfn, comp, ecomp;
	  switch (hilo) {
	    case '>':
	      gtfn = gt;
	      ltefn = lte;
	      ltfn = lt;
	      comp = '>';
	      ecomp = '>=';
	      break
	    case '<':
	      gtfn = lt;
	      ltefn = gte;
	      ltfn = gt;
	      comp = '<';
	      ecomp = '<=';
	      break
	    default:
	      throw new TypeError('Must provide a hilo val of "<" or ">"')
	  }

	  // If it satisfies the range it is not outside
	  if (satisfies(version, range, options)) {
	    return false
	  }

	  // From now on, variable terms are as if we're in "gtr" mode.
	  // but note that everything is flipped for the "ltr" function.

	  for (let i = 0; i < range.set.length; ++i) {
	    const comparators = range.set[i];

	    let high = null;
	    let low = null;

	    comparators.forEach((comparator) => {
	      if (comparator.semver === ANY) {
	        comparator = new Comparator('>=0.0.0');
	      }
	      high = high || comparator;
	      low = low || comparator;
	      if (gtfn(comparator.semver, high.semver, options)) {
	        high = comparator;
	      } else if (ltfn(comparator.semver, low.semver, options)) {
	        low = comparator;
	      }
	    });

	    // If the edge version comparator has a operator then our version
	    // isn't outside it
	    if (high.operator === comp || high.operator === ecomp) {
	      return false
	    }

	    // If the lowest version comparator has an operator and our version
	    // is less than it then it isn't higher than the range
	    if ((!low.operator || low.operator === comp) &&
	        ltefn(version, low.semver)) {
	      return false
	    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
	      return false
	    }
	  }
	  return true
	};

	outside_1 = outside;
	return outside_1;
}

var gtr_1;
var hasRequiredGtr;

function requireGtr () {
	if (hasRequiredGtr) return gtr_1;
	hasRequiredGtr = 1;

	// Determine if version is greater than all the versions possible in the range.
	const outside = requireOutside();
	const gtr = (version, range, options) => outside(version, range, '>', options);
	gtr_1 = gtr;
	return gtr_1;
}

var ltr_1;
var hasRequiredLtr;

function requireLtr () {
	if (hasRequiredLtr) return ltr_1;
	hasRequiredLtr = 1;

	const outside = requireOutside();
	// Determine if version is less than all the versions possible in the range
	const ltr = (version, range, options) => outside(version, range, '<', options);
	ltr_1 = ltr;
	return ltr_1;
}

var intersects_1;
var hasRequiredIntersects;

function requireIntersects () {
	if (hasRequiredIntersects) return intersects_1;
	hasRequiredIntersects = 1;

	const Range = requireRange();
	const intersects = (r1, r2, options) => {
	  r1 = new Range(r1, options);
	  r2 = new Range(r2, options);
	  return r1.intersects(r2, options)
	};
	intersects_1 = intersects;
	return intersects_1;
}

var simplify;
var hasRequiredSimplify;

function requireSimplify () {
	if (hasRequiredSimplify) return simplify;
	hasRequiredSimplify = 1;

	// given a set of versions and a range, create a "simplified" range
	// that includes the same versions that the original range does
	// If the original range is shorter than the simplified one, return that.
	const satisfies = requireSatisfies();
	const compare = requireCompare();
	simplify = (versions, range, options) => {
	  const set = [];
	  let first = null;
	  let prev = null;
	  const v = versions.sort((a, b) => compare(a, b, options));
	  for (const version of v) {
	    const included = satisfies(version, range, options);
	    if (included) {
	      prev = version;
	      if (!first) {
	        first = version;
	      }
	    } else {
	      if (prev) {
	        set.push([first, prev]);
	      }
	      prev = null;
	      first = null;
	    }
	  }
	  if (first) {
	    set.push([first, null]);
	  }

	  const ranges = [];
	  for (const [min, max] of set) {
	    if (min === max) {
	      ranges.push(min);
	    } else if (!max && min === v[0]) {
	      ranges.push('*');
	    } else if (!max) {
	      ranges.push(`>=${min}`);
	    } else if (min === v[0]) {
	      ranges.push(`<=${max}`);
	    } else {
	      ranges.push(`${min} - ${max}`);
	    }
	  }
	  const simplified = ranges.join(' || ');
	  const original = typeof range.raw === 'string' ? range.raw : String(range);
	  return simplified.length < original.length ? simplified : range
	};
	return simplify;
}

var subset_1;
var hasRequiredSubset;

function requireSubset () {
	if (hasRequiredSubset) return subset_1;
	hasRequiredSubset = 1;

	const Range = requireRange();
	const Comparator = requireComparator();
	const { ANY } = Comparator;
	const satisfies = requireSatisfies();
	const compare = requireCompare();

	// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:
	// - Every simple range `r1, r2, ...` is a null set, OR
	// - Every simple range `r1, r2, ...` which is not a null set is a subset of
	//   some `R1, R2, ...`
	//
	// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:
	// - If c is only the ANY comparator
	//   - If C is only the ANY comparator, return true
	//   - Else if in prerelease mode, return false
	//   - else replace c with `[>=0.0.0]`
	// - If C is only the ANY comparator
	//   - if in prerelease mode, return true
	//   - else replace C with `[>=0.0.0]`
	// - Let EQ be the set of = comparators in c
	// - If EQ is more than one, return true (null set)
	// - Let GT be the highest > or >= comparator in c
	// - Let LT be the lowest < or <= comparator in c
	// - If GT and LT, and GT.semver > LT.semver, return true (null set)
	// - If any C is a = range, and GT or LT are set, return false
	// - If EQ
	//   - If GT, and EQ does not satisfy GT, return true (null set)
	//   - If LT, and EQ does not satisfy LT, return true (null set)
	//   - If EQ satisfies every C, return true
	//   - Else return false
	// - If GT
	//   - If GT.semver is lower than any > or >= comp in C, return false
	//   - If GT is >=, and GT.semver does not satisfy every C, return false
	//   - If GT.semver has a prerelease, and not in prerelease mode
	//     - If no C has a prerelease and the GT.semver tuple, return false
	// - If LT
	//   - If LT.semver is greater than any < or <= comp in C, return false
	//   - If LT is <=, and LT.semver does not satisfy every C, return false
	//   - If GT.semver has a prerelease, and not in prerelease mode
	//     - If no C has a prerelease and the LT.semver tuple, return false
	// - Else return true

	const subset = (sub, dom, options = {}) => {
	  if (sub === dom) {
	    return true
	  }

	  sub = new Range(sub, options);
	  dom = new Range(dom, options);
	  let sawNonNull = false;

	  OUTER: for (const simpleSub of sub.set) {
	    for (const simpleDom of dom.set) {
	      const isSub = simpleSubset(simpleSub, simpleDom, options);
	      sawNonNull = sawNonNull || isSub !== null;
	      if (isSub) {
	        continue OUTER
	      }
	    }
	    // the null set is a subset of everything, but null simple ranges in
	    // a complex range should be ignored.  so if we saw a non-null range,
	    // then we know this isn't a subset, but if EVERY simple range was null,
	    // then it is a subset.
	    if (sawNonNull) {
	      return false
	    }
	  }
	  return true
	};

	const minimumVersionWithPreRelease = [new Comparator('>=0.0.0-0')];
	const minimumVersion = [new Comparator('>=0.0.0')];

	const simpleSubset = (sub, dom, options) => {
	  if (sub === dom) {
	    return true
	  }

	  if (sub.length === 1 && sub[0].semver === ANY) {
	    if (dom.length === 1 && dom[0].semver === ANY) {
	      return true
	    } else if (options.includePrerelease) {
	      sub = minimumVersionWithPreRelease;
	    } else {
	      sub = minimumVersion;
	    }
	  }

	  if (dom.length === 1 && dom[0].semver === ANY) {
	    if (options.includePrerelease) {
	      return true
	    } else {
	      dom = minimumVersion;
	    }
	  }

	  const eqSet = new Set();
	  let gt, lt;
	  for (const c of sub) {
	    if (c.operator === '>' || c.operator === '>=') {
	      gt = higherGT(gt, c, options);
	    } else if (c.operator === '<' || c.operator === '<=') {
	      lt = lowerLT(lt, c, options);
	    } else {
	      eqSet.add(c.semver);
	    }
	  }

	  if (eqSet.size > 1) {
	    return null
	  }

	  let gtltComp;
	  if (gt && lt) {
	    gtltComp = compare(gt.semver, lt.semver, options);
	    if (gtltComp > 0) {
	      return null
	    } else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<=')) {
	      return null
	    }
	  }

	  // will iterate one or zero times
	  for (const eq of eqSet) {
	    if (gt && !satisfies(eq, String(gt), options)) {
	      return null
	    }

	    if (lt && !satisfies(eq, String(lt), options)) {
	      return null
	    }

	    for (const c of dom) {
	      if (!satisfies(eq, String(c), options)) {
	        return false
	      }
	    }

	    return true
	  }

	  let higher, lower;
	  let hasDomLT, hasDomGT;
	  // if the subset has a prerelease, we need a comparator in the superset
	  // with the same tuple and a prerelease, or it's not a subset
	  let needDomLTPre = lt &&
	    !options.includePrerelease &&
	    lt.semver.prerelease.length ? lt.semver : false;
	  let needDomGTPre = gt &&
	    !options.includePrerelease &&
	    gt.semver.prerelease.length ? gt.semver : false;
	  // exception: <1.2.3-0 is the same as <1.2.3
	  if (needDomLTPre && needDomLTPre.prerelease.length === 1 &&
	      lt.operator === '<' && needDomLTPre.prerelease[0] === 0) {
	    needDomLTPre = false;
	  }

	  for (const c of dom) {
	    hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>=';
	    hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<=';
	    if (gt) {
	      if (needDomGTPre) {
	        if (c.semver.prerelease && c.semver.prerelease.length &&
	            c.semver.major === needDomGTPre.major &&
	            c.semver.minor === needDomGTPre.minor &&
	            c.semver.patch === needDomGTPre.patch) {
	          needDomGTPre = false;
	        }
	      }
	      if (c.operator === '>' || c.operator === '>=') {
	        higher = higherGT(gt, c, options);
	        if (higher === c && higher !== gt) {
	          return false
	        }
	      } else if (gt.operator === '>=' && !satisfies(gt.semver, String(c), options)) {
	        return false
	      }
	    }
	    if (lt) {
	      if (needDomLTPre) {
	        if (c.semver.prerelease && c.semver.prerelease.length &&
	            c.semver.major === needDomLTPre.major &&
	            c.semver.minor === needDomLTPre.minor &&
	            c.semver.patch === needDomLTPre.patch) {
	          needDomLTPre = false;
	        }
	      }
	      if (c.operator === '<' || c.operator === '<=') {
	        lower = lowerLT(lt, c, options);
	        if (lower === c && lower !== lt) {
	          return false
	        }
	      } else if (lt.operator === '<=' && !satisfies(lt.semver, String(c), options)) {
	        return false
	      }
	    }
	    if (!c.operator && (lt || gt) && gtltComp !== 0) {
	      return false
	    }
	  }

	  // if there was a < or >, and nothing in the dom, then must be false
	  // UNLESS it was limited by another range in the other direction.
	  // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0
	  if (gt && hasDomLT && !lt && gtltComp !== 0) {
	    return false
	  }

	  if (lt && hasDomGT && !gt && gtltComp !== 0) {
	    return false
	  }

	  // we needed a prerelease range in a specific tuple, but didn't get one
	  // then this isn't a subset.  eg >=1.2.3-pre is not a subset of >=1.0.0,
	  // because it includes prereleases in the 1.2.3 tuple
	  if (needDomGTPre || needDomLTPre) {
	    return false
	  }

	  return true
	};

	// >=1.2.3 is lower than >1.2.3
	const higherGT = (a, b, options) => {
	  if (!a) {
	    return b
	  }
	  const comp = compare(a.semver, b.semver, options);
	  return comp > 0 ? a
	    : comp < 0 ? b
	    : b.operator === '>' && a.operator === '>=' ? b
	    : a
	};

	// <=1.2.3 is higher than <1.2.3
	const lowerLT = (a, b, options) => {
	  if (!a) {
	    return b
	  }
	  const comp = compare(a.semver, b.semver, options);
	  return comp < 0 ? a
	    : comp > 0 ? b
	    : b.operator === '<' && a.operator === '<=' ? b
	    : a
	};

	subset_1 = subset;
	return subset_1;
}

var semver$1;
var hasRequiredSemver;

function requireSemver () {
	if (hasRequiredSemver) return semver$1;
	hasRequiredSemver = 1;

	// just pre-load all the stuff that index.js lazily exports
	const internalRe = requireRe();
	const constants = requireConstants();
	const SemVer = requireSemver$1();
	const identifiers = requireIdentifiers();
	const parse = requireParse();
	const valid = requireValid$1();
	const clean = requireClean();
	const inc = requireInc();
	const diff = requireDiff();
	const major = requireMajor();
	const minor = requireMinor();
	const patch = requirePatch();
	const prerelease = requirePrerelease();
	const compare = requireCompare();
	const rcompare = requireRcompare();
	const compareLoose = requireCompareLoose();
	const compareBuild = requireCompareBuild();
	const sort = requireSort();
	const rsort = requireRsort();
	const gt = requireGt();
	const lt = requireLt();
	const eq = requireEq();
	const neq = requireNeq();
	const gte = requireGte();
	const lte = requireLte();
	const cmp = requireCmp();
	const coerce = requireCoerce();
	const Comparator = requireComparator();
	const Range = requireRange();
	const satisfies = requireSatisfies();
	const toComparators = requireToComparators();
	const maxSatisfying = requireMaxSatisfying();
	const minSatisfying = requireMinSatisfying();
	const minVersion = requireMinVersion();
	const validRange = requireValid();
	const outside = requireOutside();
	const gtr = requireGtr();
	const ltr = requireLtr();
	const intersects = requireIntersects();
	const simplifyRange = requireSimplify();
	const subset = requireSubset();
	semver$1 = {
	  parse,
	  valid,
	  clean,
	  inc,
	  diff,
	  major,
	  minor,
	  patch,
	  prerelease,
	  compare,
	  rcompare,
	  compareLoose,
	  compareBuild,
	  sort,
	  rsort,
	  gt,
	  lt,
	  eq,
	  neq,
	  gte,
	  lte,
	  cmp,
	  coerce,
	  Comparator,
	  Range,
	  satisfies,
	  toComparators,
	  maxSatisfying,
	  minSatisfying,
	  minVersion,
	  validRange,
	  outside,
	  gtr,
	  ltr,
	  intersects,
	  simplifyRange,
	  subset,
	  SemVer,
	  re: internalRe.re,
	  src: internalRe.src,
	  tokens: internalRe.t,
	  SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
	  RELEASE_TYPES: constants.RELEASE_TYPES,
	  compareIdentifiers: identifiers.compareIdentifiers,
	  rcompareIdentifiers: identifiers.rcompareIdentifiers,
	};
	return semver$1;
}

var semverExports = requireSemver();
var semver = /*@__PURE__*/getDefaultExportFromCjs(semverExports);

/*!
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.dev/license
 */
// Note: semver isn't available internally so this import will be commented out.
// When adding more dependencies here, the caretaker may have to update a patch internally.
/**
 * Whether a version of `@angular/core` supports a specific feature.
 * @param coreVersion Current version of core.
 * @param minVersion Minimum required version for the feature.
 */
function coreVersionSupportsFeature(coreVersion, minVersion) {
    // A version of `21.0.0-next.9+sha-b41a070` usually means that core is at head so it supports
    // all features. Use string interpolation prevent the placeholder from being replaced
    // with the current version during build time.
    if (coreVersion === `0.0.0-${'PLACEHOLDER'}`) {
        return true;
    }
    return semver.satisfies(coreVersion, minVersion, { includePrerelease: true });
}

/**
 * Whether a given decorator should be treated as an Angular decorator.
 * Either it's used in @angular/core, or it's imported from there.
 */
function isAngularDecorator(decorator, isCore) {
    return isCore || (decorator.import !== null && decorator.import.from === '@angular/core');
}
/**
 * Extracts the type of the decorator (the function or expression invoked), as well as all the
 * arguments passed to the decorator. Returns an AST with the form:
 *
 *     // For @decorator(arg1, arg2)
 *     { type: decorator, args: [arg1, arg2] }
 */
function extractMetadataFromSingleDecorator(decorator, diagnostics) {
    const metadataProperties = [];
    const expr = decorator.expression;
    switch (expr.kind) {
        case ts.SyntaxKind.Identifier:
            // The decorator was a plain @Foo.
            metadataProperties.push(ts.factory.createPropertyAssignment('type', expr));
            break;
        case ts.SyntaxKind.CallExpression:
            // The decorator was a call, like @Foo(bar).
            const call = expr;
            metadataProperties.push(ts.factory.createPropertyAssignment('type', call.expression));
            if (call.arguments.length) {
                const args = [];
                for (const arg of call.arguments) {
                    args.push(arg);
                }
                const argsArrayLiteral = ts.factory.createArrayLiteralExpression(ts.factory.createNodeArray(args, true));
                metadataProperties.push(ts.factory.createPropertyAssignment('args', argsArrayLiteral));
            }
            break;
        default:
            diagnostics.push({
                file: decorator.getSourceFile(),
                start: decorator.getStart(),
                length: decorator.getEnd() - decorator.getStart(),
                messageText: `${ts.SyntaxKind[decorator.kind]} not implemented in gathering decorator metadata.`,
                category: ts.DiagnosticCategory.Error,
                code: 0,
            });
            break;
    }
    return ts.factory.createObjectLiteralExpression(metadataProperties);
}
/**
 * createCtorParametersClassProperty creates a static 'ctorParameters' property containing
 * downleveled decorator information.
 *
 * The property contains an arrow function that returns an array of object literals of the shape:
 *     static ctorParameters = () => [{
 *       type: SomeClass|undefined,  // the type of the param that's decorated, if it's a value.
 *       decorators: [{
 *         type: DecoratorFn,  // the type of the decorator that's invoked.
 *         args: [ARGS],       // the arguments passed to the decorator.
 *       }]
 *     }];
 */
function createCtorParametersClassProperty(diagnostics, entityNameToExpression, ctorParameters, isClosureCompilerEnabled) {
    const params = [];
    for (const ctorParam of ctorParameters) {
        if (!ctorParam.type && ctorParam.decorators.length === 0) {
            params.push(ts.factory.createNull());
            continue;
        }
        const paramType = ctorParam.type
            ? typeReferenceToExpression(entityNameToExpression, ctorParam.type)
            : undefined;
        const members = [
            ts.factory.createPropertyAssignment('type', paramType || ts.factory.createIdentifier('undefined')),
        ];
        const decorators = [];
        for (const deco of ctorParam.decorators) {
            decorators.push(extractMetadataFromSingleDecorator(deco, diagnostics));
        }
        if (decorators.length) {
            members.push(ts.factory.createPropertyAssignment('decorators', ts.factory.createArrayLiteralExpression(decorators)));
        }
        params.push(ts.factory.createObjectLiteralExpression(members));
    }
    const initializer = ts.factory.createArrowFunction(undefined, undefined, [], undefined, ts.factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken), ts.factory.createArrayLiteralExpression(params, true));
    const ctorProp = ts.factory.createPropertyDeclaration([ts.factory.createToken(ts.SyntaxKind.StaticKeyword)], 'ctorParameters', undefined, undefined, initializer);
    return ctorProp;
}
/**
 * Returns an expression representing the (potentially) value part for the given node.
 *
 * This is a partial re-implementation of TypeScript's serializeTypeReferenceNode. This is a
 * workaround for https://github.com/Microsoft/TypeScript/issues/17516 (serializeTypeReferenceNode
 * not being exposed). In practice this implementation is sufficient for Angular's use of type
 * metadata.
 */
function typeReferenceToExpression(entityNameToExpression, node) {
    let kind = node.kind;
    if (ts.isLiteralTypeNode(node)) {
        // Treat literal types like their base type (boolean, string, number).
        kind = node.literal.kind;
    }
    switch (kind) {
        case ts.SyntaxKind.FunctionType:
        case ts.SyntaxKind.ConstructorType:
            return ts.factory.createIdentifier('Function');
        case ts.SyntaxKind.ArrayType:
        case ts.SyntaxKind.TupleType:
            return ts.factory.createIdentifier('Array');
        case ts.SyntaxKind.TypePredicate:
        case ts.SyntaxKind.TrueKeyword:
        case ts.SyntaxKind.FalseKeyword:
        case ts.SyntaxKind.BooleanKeyword:
            return ts.factory.createIdentifier('Boolean');
        case ts.SyntaxKind.StringLiteral:
        case ts.SyntaxKind.StringKeyword:
            return ts.factory.createIdentifier('String');
        case ts.SyntaxKind.ObjectKeyword:
            return ts.factory.createIdentifier('Object');
        case ts.SyntaxKind.NumberKeyword:
        case ts.SyntaxKind.NumericLiteral:
            return ts.factory.createIdentifier('Number');
        case ts.SyntaxKind.TypeReference:
            const typeRef = node;
            // Ignore any generic types, just return the base type.
            return entityNameToExpression(typeRef.typeName);
        case ts.SyntaxKind.UnionType:
            const childTypeNodes = node.types.filter((t) => !(ts.isLiteralTypeNode(t) && t.literal.kind === ts.SyntaxKind.NullKeyword));
            return childTypeNodes.length === 1
                ? typeReferenceToExpression(entityNameToExpression, childTypeNodes[0])
                : undefined;
        default:
            return undefined;
    }
}
/**
 * Checks whether a given symbol refers to a value that exists at runtime (as distinct from a type).
 *
 * Expands aliases, which is important for the case where
 *   import * as x from 'some-module';
 * and x is now a value (the module object).
 */
function symbolIsRuntimeValue(typeChecker, symbol) {
    if (symbol.flags & ts.SymbolFlags.Alias) {
        symbol = typeChecker.getAliasedSymbol(symbol);
    }
    // Note that const enums are a special case, because
    // while they have a value, they don't exist at runtime.
    return (symbol.flags & ts.SymbolFlags.Value & ts.SymbolFlags.ConstEnumExcludes) !== 0;
}
/**
 * Gets a transformer for downleveling Angular constructor parameter and property decorators.
 *
 * Note that Angular class decorators are never processed as those rely on side effects that
 * would otherwise no longer be executed. i.e. the creation of a component definition.
 *
 * @param typeChecker Reference to the program's type checker.
 * @param host Reflection host that is used for determining decorators.
 * @param diagnostics List which will be populated with diagnostics if any.
 * @param isCore Whether the current TypeScript program is for the `@angular/core` package.
 * @param isClosureCompilerEnabled Whether closure annotations need to be added where needed.
 * @param shouldTransformClass Optional function to check if a given class should be transformed.
 */
function getDownlevelDecoratorsTransform(typeChecker, host, diagnostics, isCore, isClosureCompilerEnabled, shouldTransformClass) {
    /**
     * createPropDecoratorsClassProperty creates a static 'propDecorators'
     * property containing type information for every property that has a
     * decorator applied.
     *
     *     static propDecorators: {[key: string]: {type: Function, args?:
     * any[]}[]} = { propA: [{type: MyDecorator, args: [1, 2]}, ...],
     *       ...
     *     };
     */
    function createPropDecoratorsClassProperty(diagnostics, properties) {
        //  `static propDecorators: {[key: string]: ` + {type: Function, args?:
        //  any[]}[] + `} = {\n`);
        const entries = [];
        for (const [name, decorators] of properties.entries()) {
            entries.push(ts.factory.createPropertyAssignment(name, ts.factory.createArrayLiteralExpression(decorators.map((deco) => extractMetadataFromSingleDecorator(deco, diagnostics)))));
        }
        const initializer = ts.factory.createObjectLiteralExpression(entries, true);
        const prop = ts.factory.createPropertyDeclaration([ts.factory.createToken(ts.SyntaxKind.StaticKeyword)], 'propDecorators', undefined, undefined, initializer);
        return prop;
    }
    return (context) => {
        // Ensure that referenced type symbols are not elided by TypeScript. Imports for
        // such parameter type symbols previously could be type-only, but now might be also
        // used in the `ctorParameters` static property as a value. We want to make sure
        // that TypeScript does not elide imports for such type references. Read more
        // about this in the description for `loadIsReferencedAliasDeclarationPatch`.
        const referencedParameterTypes = loadIsReferencedAliasDeclarationPatch(context);
        /**
         * Converts an EntityName (from a type annotation) to an expression (accessing a value).
         *
         * For a given qualified name, this walks depth first to find the leftmost identifier,
         * and then converts the path into a property access that can be used as expression.
         */
        function entityNameToExpression(name) {
            const symbol = typeChecker.getSymbolAtLocation(name);
            // Check if the entity name references a symbol that is an actual value. If it is not, it
            // cannot be referenced by an expression, so return undefined.
            if (!symbol ||
                !symbolIsRuntimeValue(typeChecker, symbol) ||
                !symbol.declarations ||
                symbol.declarations.length === 0) {
                return undefined;
            }
            // If we deal with a qualified name, build up a property access expression
            // that could be used in the JavaScript output.
            if (ts.isQualifiedName(name)) {
                const containerExpr = entityNameToExpression(name.left);
                if (containerExpr === undefined) {
                    return undefined;
                }
                return ts.factory.createPropertyAccessExpression(containerExpr, name.right);
            }
            const decl = symbol.declarations[0];
            // If the given entity name has been resolved to an alias import declaration,
            // ensure that the alias declaration is not elided by TypeScript, and use its
            // name identifier to reference it at runtime.
            if (isAliasImportDeclaration(decl)) {
                referencedParameterTypes?.add(decl);
                // If the entity name resolves to an alias import declaration, we reference the
                // entity based on the alias import name. This ensures that TypeScript properly
                // resolves the link to the import. Cloning the original entity name identifier
                // could lead to an incorrect resolution at local scope. e.g. Consider the following
                // snippet: `constructor(Dep: Dep) {}`. In such a case, the local `Dep` identifier
                // would resolve to the actual parameter name, and not to the desired import.
                // This happens because the entity name identifier symbol is internally considered
                // as type-only and therefore TypeScript tries to resolve it as value manually.
                // We can help TypeScript and avoid this non-reliable resolution by using an identifier
                // that is not type-only and is directly linked to the import alias declaration.
                if (decl.name !== undefined) {
                    return ts.setOriginalNode(ts.factory.createIdentifier(decl.name.text), decl.name);
                }
            }
            // Clone the original entity name identifier so that it can be used to reference
            // its value at runtime. This is used when the identifier is resolving to a file
            // local declaration (otherwise it would resolve to an alias import declaration).
            return ts.setOriginalNode(ts.factory.createIdentifier(name.text), name);
        }
        /**
         * Transforms a class element. Returns a three tuple of name, transformed element, and
         * decorators found. Returns an undefined name if there are no decorators to lower on the
         * element, or the element has an exotic name.
         */
        function transformClassElement(element) {
            element = ts.visitEachChild(element, decoratorDownlevelVisitor, context);
            const decoratorsToKeep = [];
            const toLower = [];
            const decorators = host.getDecoratorsOfDeclaration(element) || [];
            for (const decorator of decorators) {
                // We only deal with concrete nodes in TypeScript sources, so we don't
                // need to handle synthetically created decorators.
                const decoratorNode = decorator.node;
                if (!isAngularDecorator(decorator, isCore)) {
                    decoratorsToKeep.push(decoratorNode);
                    continue;
                }
                toLower.push(decoratorNode);
            }
            if (!toLower.length)
                return [undefined, element, []];
            if (!element.name || !ts.isIdentifier(element.name)) {
                // Method has a weird name, e.g.
                //   [Symbol.foo]() {...}
                diagnostics.push({
                    file: element.getSourceFile(),
                    start: element.getStart(),
                    length: element.getEnd() - element.getStart(),
                    messageText: `Cannot process decorators for class element with non-analyzable name.`,
                    category: ts.DiagnosticCategory.Error,
                    code: 0,
                });
                return [undefined, element, []];
            }
            const elementModifiers = ts.canHaveModifiers(element) ? ts.getModifiers(element) : undefined;
            let modifiers;
            if (decoratorsToKeep.length || elementModifiers?.length) {
                modifiers = ts.setTextRange(ts.factory.createNodeArray([...decoratorsToKeep, ...(elementModifiers || [])]), element.modifiers);
            }
            return [element.name.text, cloneClassElementWithModifiers(element, modifiers), toLower];
        }
        /**
         * Transforms a constructor. Returns the transformed constructor and the list of parameter
         * information collected, consisting of decorators and optional type.
         */
        function transformConstructor(ctor) {
            ctor = ts.visitEachChild(ctor, decoratorDownlevelVisitor, context);
            const newParameters = [];
            const oldParameters = ctor.parameters;
            const parametersInfo = [];
            for (const param of oldParameters) {
                const decoratorsToKeep = [];
                const paramInfo = { decorators: [], type: null };
                const decorators = host.getDecoratorsOfDeclaration(param) || [];
                for (const decorator of decorators) {
                    // We only deal with concrete nodes in TypeScript sources, so we don't
                    // need to handle synthetically created decorators.
                    const decoratorNode = decorator.node;
                    if (!isAngularDecorator(decorator, isCore)) {
                        decoratorsToKeep.push(decoratorNode);
                        continue;
                    }
                    paramInfo.decorators.push(decoratorNode);
                }
                if (param.type) {
                    // param has a type provided, e.g. "foo: Bar".
                    // The type will be emitted as a value expression in entityNameToExpression, which takes
                    // care not to emit anything for types that cannot be expressed as a value (e.g.
                    // interfaces).
                    paramInfo.type = param.type;
                }
                parametersInfo.push(paramInfo);
                // Must pass 'undefined' to avoid emitting decorator metadata.
                let modifiers;
                const paramModifiers = ts.getModifiers(param);
                if (decoratorsToKeep.length || paramModifiers?.length) {
                    modifiers = [...decoratorsToKeep, ...(paramModifiers || [])];
                }
                const newParam = ts.factory.updateParameterDeclaration(param, modifiers, param.dotDotDotToken, param.name, param.questionToken, param.type, param.initializer);
                newParameters.push(newParam);
            }
            const updated = ts.factory.updateConstructorDeclaration(ctor, ts.getModifiers(ctor), newParameters, ctor.body);
            return [updated, parametersInfo];
        }
        /**
         * Transforms a single class declaration:
         * - dispatches to strip decorators on members
         * - converts decorators on the class to annotations
         * - creates a ctorParameters property
         * - creates a propDecorators property
         */
        function transformClassDeclaration(classDecl) {
            const newMembers = [];
            const decoratedProperties = new Map();
            let classParameters = null;
            for (const member of classDecl.members) {
                switch (member.kind) {
                    case ts.SyntaxKind.PropertyDeclaration:
                    case ts.SyntaxKind.GetAccessor:
                    case ts.SyntaxKind.SetAccessor:
                    case ts.SyntaxKind.MethodDeclaration: {
                        const [name, newMember, decorators] = transformClassElement(member);
                        newMembers.push(newMember);
                        if (name)
                            decoratedProperties.set(name, decorators);
                        continue;
                    }
                    case ts.SyntaxKind.Constructor: {
                        const ctor = member;
                        if (!ctor.body)
                            break;
                        const [newMember, parametersInfo] = transformConstructor(member);
                        classParameters = parametersInfo;
                        newMembers.push(newMember);
                        continue;
                    }
                }
                newMembers.push(ts.visitEachChild(member, decoratorDownlevelVisitor, context));
            }
            // Note: The `ReflectionHost.getDecoratorsOfDeclaration()` method will not
            // return all decorators, but only ones that could be possible Angular decorators.
            const possibleAngularDecorators = host.getDecoratorsOfDeclaration(classDecl) || [];
            // Keep track if we come across an Angular class decorator. This is used
            // to determine whether constructor parameters should be captured or not.
            const hasAngularDecorator = possibleAngularDecorators.some((d) => isAngularDecorator(d, isCore));
            if (classParameters) {
                if (hasAngularDecorator || classParameters.some((p) => !!p.decorators.length)) {
                    // Capture constructor parameters if the class has Angular decorator applied,
                    // or if any of the parameters has decorators applied directly.
                    newMembers.push(createCtorParametersClassProperty(diagnostics, entityNameToExpression, classParameters));
                }
            }
            if (decoratedProperties.size) {
                newMembers.push(createPropDecoratorsClassProperty(diagnostics, decoratedProperties));
            }
            const members = ts.setTextRange(ts.factory.createNodeArray(newMembers, classDecl.members.hasTrailingComma), classDecl.members);
            return ts.factory.updateClassDeclaration(classDecl, classDecl.modifiers, classDecl.name, classDecl.typeParameters, classDecl.heritageClauses, members);
        }
        /**
         * Transformer visitor that looks for Angular decorators and replaces them with
         * downleveled static properties. Also collects constructor type metadata for
         * class declaration that are decorated with an Angular decorator.
         */
        function decoratorDownlevelVisitor(node) {
            if (ts.isClassDeclaration(node) &&
                (shouldTransformClass === undefined || shouldTransformClass(node))) {
                return transformClassDeclaration(node);
            }
            return ts.visitEachChild(node, decoratorDownlevelVisitor, context);
        }
        return (sf) => {
            // Downlevel decorators and constructor parameter types. We will keep track of all
            // referenced constructor parameter types so that we can instruct TypeScript to
            // not elide their imports if they previously were only type-only.
            return ts.visitEachChild(sf, decoratorDownlevelVisitor, context);
        };
    };
}
function cloneClassElementWithModifiers(node, modifiers) {
    let clone;
    if (ts.isMethodDeclaration(node)) {
        clone = ts.factory.createMethodDeclaration(modifiers, node.asteriskToken, node.name, node.questionToken, node.typeParameters, node.parameters, node.type, node.body);
    }
    else if (ts.isPropertyDeclaration(node)) {
        clone = ts.factory.createPropertyDeclaration(modifiers, node.name, node.questionToken, node.type, node.initializer);
    }
    else if (ts.isGetAccessor(node)) {
        clone = ts.factory.createGetAccessorDeclaration(modifiers, node.name, node.parameters, node.type, node.body);
    }
    else if (ts.isSetAccessor(node)) {
        clone = ts.factory.createSetAccessorDeclaration(modifiers, node.name, node.parameters, node.body);
    }
    else {
        throw new Error(`Unsupported decorated member with kind ${ts.SyntaxKind[node.kind]}`);
    }
    return ts.setOriginalNode(clone, node);
}

/**
 * Creates an import and access for a given Angular core import while
 * ensuring the decorator symbol access can be traced back to an Angular core
 * import in order to make the synthetic decorator compatible with the JIT
 * decorator downlevel transform.
 */
function createSyntheticAngularCoreDecoratorAccess(factory, importManager, ngClassDecorator, sourceFile, decoratorName) {
    const classDecoratorIdentifier = ts.isIdentifier(ngClassDecorator.identifier)
        ? ngClassDecorator.identifier
        : ngClassDecorator.identifier.expression;
    return factory.createPropertyAccessExpression(importManager.addImport({
        exportModuleSpecifier: '@angular/core',
        exportSymbolName: null,
        requestedFile: sourceFile,
    }), 
    // The synthetic identifier may be checked later by the downlevel decorators
    // transform to resolve to an Angular import using `getSymbolAtLocation`. We trick
    // the transform to think it's not synthetic and comes from Angular core.
    ts.setOriginalNode(factory.createIdentifier(decoratorName), classDecoratorIdentifier));
}
/** Casts the given expression as `any`. */
function castAsAny(factory, expr) {
    return factory.createAsExpression(expr, factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword));
}

/**
 * Transform that will automatically add an `@Input` decorator for all signal
 * inputs in Angular classes. The decorator will capture metadata of the signal
 * input, derived from the `input()/input.required()` initializer.
 *
 * This transform is useful for JIT environments where signal inputs would like to be
 * used. e.g. for Angular CLI unit testing. In such environments, signal inputs are not
 * statically retrievable at runtime. JIT compilation needs to know about all possible inputs
 * before instantiating directives. A decorator exposes this information to the class without
 * the class needing to be instantiated.
 */
const signalInputsTransform = (member, sourceFile, host, factory, importTracker, importManager, classDecorator, isCore) => {
    // If the field already is decorated, we handle this gracefully and skip it.
    if (host
        .getDecoratorsOfDeclaration(member.node)
        ?.some((d) => isAngularDecorator$2(d, 'Input', isCore))) {
        return member.node;
    }
    const inputMapping = tryParseSignalInputMapping(member, host, importTracker);
    if (inputMapping === null) {
        return member.node;
    }
    const fields = {
        'isSignal': factory.createTrue(),
        'alias': factory.createStringLiteral(inputMapping.bindingPropertyName),
        'required': inputMapping.required ? factory.createTrue() : factory.createFalse(),
        // For signal inputs, transforms are captured by the input signal. The runtime will
        // determine whether a transform needs to be run via the input signal, so the `transform`
        // option is always `undefined`.
        'transform': factory.createIdentifier('undefined'),
    };
    const newDecorator = factory.createDecorator(factory.createCallExpression(createSyntheticAngularCoreDecoratorAccess(factory, importManager, classDecorator, sourceFile, 'Input'), undefined, [
        // Cast to `any` because `isSignal` will be private, and in case this
        // transform is used directly as a pre-compilation step, the decorator should
        // not fail. It is already validated now due to us parsing the input metadata.
        castAsAny(factory, factory.createObjectLiteralExpression(Object.entries(fields).map(([name, value]) => factory.createPropertyAssignment(name, value)))),
    ]));
    return factory.updatePropertyDeclaration(member.node, [newDecorator, ...(member.node.modifiers ?? [])], member.name, member.node.questionToken, member.node.type, member.node.initializer);
};

/**
 * Transform that automatically adds `@Input` and `@Output` to members initialized as `model()`.
 * It is useful for JIT environments where models can't be recognized based on the initializer.
 */
const signalModelTransform = (member, sourceFile, host, factory, importTracker, importManager, classDecorator, isCore) => {
    if (host.getDecoratorsOfDeclaration(member.node)?.some((d) => {
        return isAngularDecorator$2(d, 'Input', isCore) || isAngularDecorator$2(d, 'Output', isCore);
    })) {
        return member.node;
    }
    const modelMapping = tryParseSignalModelMapping(member, host, importTracker);
    if (modelMapping === null) {
        return member.node;
    }
    const inputConfig = factory.createObjectLiteralExpression([
        factory.createPropertyAssignment('isSignal', modelMapping.input.isSignal ? factory.createTrue() : factory.createFalse()),
        factory.createPropertyAssignment('alias', factory.createStringLiteral(modelMapping.input.bindingPropertyName)),
        factory.createPropertyAssignment('required', modelMapping.input.required ? factory.createTrue() : factory.createFalse()),
    ]);
    const inputDecorator = createDecorator('Input', 
    // Config is cast to `any` because `isSignal` will be private, and in case this
    // transform is used directly as a pre-compilation step, the decorator should
    // not fail. It is already validated now due to us parsing the input metadata.
    factory.createAsExpression(inputConfig, factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword)), classDecorator, factory, sourceFile, importManager);
    const outputDecorator = createDecorator('Output', factory.createStringLiteral(modelMapping.output.bindingPropertyName), classDecorator, factory, sourceFile, importManager);
    return factory.updatePropertyDeclaration(member.node, [inputDecorator, outputDecorator, ...(member.node.modifiers ?? [])], member.node.name, member.node.questionToken, member.node.type, member.node.initializer);
};
function createDecorator(name, config, classDecorator, factory, sourceFile, importManager) {
    const callTarget = createSyntheticAngularCoreDecoratorAccess(factory, importManager, classDecorator, sourceFile, name);
    return factory.createDecorator(factory.createCallExpression(callTarget, undefined, [config]));
}

/**
 * Transform that will automatically add an `@Output` decorator for all initializer API
 * outputs in Angular classes. The decorator will capture metadata of the output, such
 * as the alias.
 *
 * This transform is useful for JIT environments. In such environments, such outputs are not
 * statically retrievable at runtime. JIT compilation needs to know about all possible outputs
 * before instantiating directives. A decorator exposes this information to the class without
 * the class needing to be instantiated.
 */
const initializerApiOutputTransform = (member, sourceFile, host, factory, importTracker, importManager, classDecorator, isCore) => {
    // If the field already is decorated, we handle this gracefully and skip it.
    if (host
        .getDecoratorsOfDeclaration(member.node)
        ?.some((d) => isAngularDecorator$2(d, 'Output', isCore))) {
        return member.node;
    }
    const output = tryParseInitializerBasedOutput(member, host, importTracker);
    if (output === null) {
        return member.node;
    }
    const newDecorator = factory.createDecorator(factory.createCallExpression(createSyntheticAngularCoreDecoratorAccess(factory, importManager, classDecorator, sourceFile, 'Output'), undefined, [factory.createStringLiteral(output.metadata.bindingPropertyName)]));
    return factory.updatePropertyDeclaration(member.node, [newDecorator, ...(member.node.modifiers ?? [])], member.node.name, member.node.questionToken, member.node.type, member.node.initializer);
};

/** Maps a query function to its decorator. */
const queryFunctionToDecorator = {
    'viewChild': 'ViewChild',
    'viewChildren': 'ViewChildren',
    'contentChild': 'ContentChild',
    'contentChildren': 'ContentChildren',
};
/**
 * Transform that will automatically add query decorators for all signal-based
 * queries in Angular classes. The decorator will capture metadata of the signal
 * query, derived from the initializer-based API call.
 *
 * This transform is useful for JIT environments where signal queries would like to be
 * used. e.g. for Angular CLI unit testing. In such environments, signal queries are not
 * statically retrievable at runtime. JIT compilation needs to know about all possible queries
 * before instantiating directives to construct the definition. A decorator exposes this
 * information to the class without the class needing to be instantiated.
 */
const queryFunctionsTransforms = (member, sourceFile, host, factory, importTracker, importManager, classDecorator, isCore) => {
    const decorators = host.getDecoratorsOfDeclaration(member.node);
    // If the field already is decorated, we handle this gracefully and skip it.
    const queryDecorators = decorators && getAngularDecorators(decorators, queryDecoratorNames, isCore);
    if (queryDecorators !== null && queryDecorators.length > 0) {
        return member.node;
    }
    const queryDefinition = tryParseSignalQueryFromInitializer(member, host, importTracker);
    if (queryDefinition === null) {
        return member.node;
    }
    const callArgs = queryDefinition.call.arguments;
    const newDecorator = factory.createDecorator(factory.createCallExpression(createSyntheticAngularCoreDecoratorAccess(factory, importManager, classDecorator, sourceFile, queryFunctionToDecorator[queryDefinition.name]), undefined, 
    // All positional arguments of the query functions can be mostly re-used as is
    // for the decorator. i.e. predicate is always first argument. Options are second.
    [
        queryDefinition.call.arguments[0],
        // Note: Casting as `any` because `isSignal` is not publicly exposed and this
        // transform might pre-transform TS sources.
        castAsAny(factory, factory.createObjectLiteralExpression([
            ...(callArgs.length > 1 ? [factory.createSpreadAssignment(callArgs[1])] : []),
            factory.createPropertyAssignment('isSignal', factory.createTrue()),
        ])),
    ]));
    return factory.updatePropertyDeclaration(member.node, [newDecorator, ...(member.node.modifiers ?? [])], member.node.name, member.node.questionToken, member.node.type, member.node.initializer);
};

/** Decorators for classes that should be transformed. */
const decoratorsWithInputs = ['Directive', 'Component'];
/**
 * List of possible property transforms.
 * The first one matched on a class member will apply.
 */
const propertyTransforms = [
    signalInputsTransform,
    initializerApiOutputTransform,
    queryFunctionsTransforms,
    signalModelTransform,
];
/**
 * Creates an AST transform that looks for Angular classes and transforms
 * initializer-based declared members to work with JIT compilation.
 *
 * For example, an `input()` member may be transformed to add an `@Input`
 * decorator for JIT.
 *
 * @param host Reflection host
 * @param importTracker Import tracker for efficient import checking.
 * @param isCore Whether this transforms runs against `@angular/core`.
 * @param shouldTransformClass Optional function to check if a given class should be transformed.
 */
function getInitializerApiJitTransform(host, importTracker, isCore, shouldTransformClass) {
    return (ctx) => {
        return (sourceFile) => {
            const importManager = new ImportManager();
            sourceFile = ts.visitNode(sourceFile, createTransformVisitor(ctx, host, importManager, importTracker, isCore, shouldTransformClass), ts.isSourceFile);
            return importManager.transformTsFile(ctx, sourceFile);
        };
    };
}
function createTransformVisitor(ctx, host, importManager, importTracker, isCore, shouldTransformClass) {
    const visitor = (node) => {
        if (ts.isClassDeclaration(node) && node.name !== undefined) {
            const originalNode = ts.getOriginalNode(node, ts.isClassDeclaration);
            // Note: Attempt to detect the `angularDecorator` on the original node of the class.
            // That is because e.g. Tsickle or other transforms might have transformed the node
            // already to transform decorators.
            const angularDecorator = host
                .getDecoratorsOfDeclaration(originalNode)
                ?.find((d) => decoratorsWithInputs.some((name) => isAngularDecorator$2(d, name, isCore)));
            if (angularDecorator !== undefined &&
                (shouldTransformClass === undefined || shouldTransformClass(node))) {
                let hasChanged = false;
                const sourceFile = originalNode.getSourceFile();
                const members = node.members.map((memberNode) => {
                    if (!ts.isPropertyDeclaration(memberNode)) {
                        return memberNode;
                    }
                    const member = reflectClassMember(memberNode);
                    if (member === null) {
                        return memberNode;
                    }
                    // Find the first matching transform and update the class member.
                    for (const transform of propertyTransforms) {
                        const newNode = transform({ ...member, node: memberNode }, sourceFile, host, ctx.factory, importTracker, importManager, angularDecorator, isCore);
                        if (newNode !== member.node) {
                            hasChanged = true;
                            return newNode;
                        }
                    }
                    return memberNode;
                });
                if (hasChanged) {
                    return ctx.factory.updateClassDeclaration(node, node.modifiers, node.name, node.typeParameters, node.heritageClauses, members);
                }
            }
        }
        return ts.visitEachChild(node, visitor, ctx);
    };
    return visitor;
}

/**
 * JIT transform for Angular applications. Used by the Angular CLI for unit tests and
 * explicit JIT applications.
 *
 * The transforms include:
 *
 *  - A transform for downleveling Angular decorators and Angular-decorated class constructor
 *    parameters for dependency injection. This transform can be used by the CLI for JIT-mode
 *    compilation where constructor parameters and associated Angular decorators should be
 *    downleveled so that apps are not exposed to the ES2015 temporal dead zone limitation
 *    in TypeScript. See https://github.com/angular/angular-cli/pull/14473 for more details.
 *
 *  - A transform for adding `@Input` to signal inputs. Signal inputs cannot be recognized
 *    at runtime using reflection. That is because the class would need to be instantiated-
 *    but is not possible before creation. To fix this for JIT, a decorator is automatically
 *    added that will declare the input as a signal input while also capturing the necessary
 *    metadata
 */
function angularJitApplicationTransform(program, isCore = false, shouldTransformClass) {
    const typeChecker = program.getTypeChecker();
    const reflectionHost = new TypeScriptReflectionHost(typeChecker);
    const importTracker = new ImportedSymbolsTracker();
    const downlevelDecoratorTransform = getDownlevelDecoratorsTransform(typeChecker, reflectionHost, [], isCore, 
    /* enableClosureCompiler */ false, shouldTransformClass);
    const initializerApisJitTransform = getInitializerApiJitTransform(reflectionHost, importTracker, isCore, shouldTransformClass);
    return (ctx) => {
        return (sourceFile) => {
            sourceFile = initializerApisJitTransform(ctx)(sourceFile);
            sourceFile = downlevelDecoratorTransform(ctx)(sourceFile);
            return sourceFile;
        };
    };
}

/**
 * Discriminant type for a `CompilationTicket`.
 */
var CompilationTicketKind;
(function (CompilationTicketKind) {
    CompilationTicketKind[CompilationTicketKind["Fresh"] = 0] = "Fresh";
    CompilationTicketKind[CompilationTicketKind["IncrementalTypeScript"] = 1] = "IncrementalTypeScript";
    CompilationTicketKind[CompilationTicketKind["IncrementalResource"] = 2] = "IncrementalResource";
})(CompilationTicketKind || (CompilationTicketKind = {}));
/**
 * Create a `CompilationTicket` for a brand new compilation, using no prior state.
 */
function freshCompilationTicket(tsProgram, options, incrementalBuildStrategy, programDriver, perfRecorder, enableTemplateTypeChecker, usePoisonedData) {
    return {
        kind: CompilationTicketKind.Fresh,
        tsProgram,
        options,
        incrementalBuildStrategy,
        programDriver,
        enableTemplateTypeChecker,
        usePoisonedData,
        perfRecorder: perfRecorder ?? ActivePerfRecorder.zeroedToNow(),
    };
}
/**
 * Create a `CompilationTicket` as efficiently as possible, based on a previous `NgCompiler`
 * instance and a new `ts.Program`.
 */
function incrementalFromCompilerTicket(oldCompiler, newProgram, incrementalBuildStrategy, programDriver, modifiedResourceFiles, perfRecorder) {
    const oldProgram = oldCompiler.getCurrentProgram();
    const oldState = oldCompiler.incrementalStrategy.getIncrementalState(oldProgram);
    if (oldState === null) {
        // No incremental step is possible here, since no IncrementalState was found for the old
        // program.
        return freshCompilationTicket(newProgram, oldCompiler.options, incrementalBuildStrategy, programDriver, perfRecorder, oldCompiler.enableTemplateTypeChecker, oldCompiler.usePoisonedData);
    }
    if (perfRecorder === null) {
        perfRecorder = ActivePerfRecorder.zeroedToNow();
    }
    const incrementalCompilation = IncrementalCompilation.incremental(newProgram, versionMapFromProgram(newProgram, programDriver), oldProgram, oldState, modifiedResourceFiles, perfRecorder);
    return {
        kind: CompilationTicketKind.IncrementalTypeScript,
        enableTemplateTypeChecker: oldCompiler.enableTemplateTypeChecker,
        usePoisonedData: oldCompiler.usePoisonedData,
        options: oldCompiler.options,
        incrementalBuildStrategy,
        incrementalCompilation,
        programDriver,
        newProgram,
        perfRecorder,
    };
}
/**
 * The heart of the Angular Ivy compiler.
 *
 * The `NgCompiler` provides an API for performing Angular compilation within a custom TypeScript
 * compiler. Each instance of `NgCompiler` supports a single compilation, which might be
 * incremental.
 *
 * `NgCompiler` is lazy, and does not perform any of the work of the compilation until one of its
 * output methods (e.g. `getDiagnostics`) is called.
 *
 * See the README.md for more information.
 */
class NgCompiler {
    adapter;
    options;
    inputProgram;
    programDriver;
    incrementalStrategy;
    incrementalCompilation;
    usePoisonedData;
    livePerfRecorder;
    /**
     * Lazily evaluated state of the compilation.
     *
     * This is created on demand by calling `ensureAnalyzed`.
     */
    compilation = null;
    /**
     * Any diagnostics related to the construction of the compilation.
     *
     * These are diagnostics which arose during setup of the host and/or program.
     */
    constructionDiagnostics = [];
    /**
     * Non-template diagnostics related to the program itself. Does not include template
     * diagnostics because the template type checker memoizes them itself.
     *
     * This is set by (and memoizes) `getNonTemplateDiagnostics`.
     */
    nonTemplateDiagnostics = null;
    closureCompilerEnabled;
    currentProgram;
    entryPoint;
    moduleResolver;
    resourceManager;
    cycleAnalyzer;
    ignoreForDiagnostics;
    ignoreForEmit;
    enableTemplateTypeChecker;
    enableBlockSyntax;
    enableLetSyntax;
    angularCoreVersion;
    enableHmr;
    implicitStandaloneValue;
    enableSelectorless;
    emitDeclarationOnly;
    /**
     * `NgCompiler` can be reused for multiple compilations (for resource-only changes), and each
     * new compilation uses a fresh `PerfRecorder`. Thus, classes created with a lifespan of the
     * `NgCompiler` use a `DelegatingPerfRecorder` so the `PerfRecorder` they write to can be updated
     * with each fresh compilation.
     */
    delegatingPerfRecorder;
    /**
     * Convert a `CompilationTicket` into an `NgCompiler` instance for the requested compilation.
     *
     * Depending on the nature of the compilation request, the `NgCompiler` instance may be reused
     * from a previous compilation and updated with any changes, it may be a new instance which
     * incrementally reuses state from a previous compilation, or it may represent a fresh
     * compilation entirely.
     */
    static fromTicket(ticket, adapter) {
        switch (ticket.kind) {
            case CompilationTicketKind.Fresh:
                return new NgCompiler(adapter, ticket.options, ticket.tsProgram, ticket.programDriver, ticket.incrementalBuildStrategy, IncrementalCompilation.fresh(ticket.tsProgram, versionMapFromProgram(ticket.tsProgram, ticket.programDriver)), ticket.enableTemplateTypeChecker, ticket.usePoisonedData, ticket.perfRecorder);
            case CompilationTicketKind.IncrementalTypeScript:
                return new NgCompiler(adapter, ticket.options, ticket.newProgram, ticket.programDriver, ticket.incrementalBuildStrategy, ticket.incrementalCompilation, ticket.enableTemplateTypeChecker, ticket.usePoisonedData, ticket.perfRecorder);
            case CompilationTicketKind.IncrementalResource:
                const compiler = ticket.compiler;
                compiler.updateWithChangedResources(ticket.modifiedResourceFiles, ticket.perfRecorder);
                return compiler;
        }
    }
    constructor(adapter, options, inputProgram, programDriver, incrementalStrategy, incrementalCompilation, enableTemplateTypeChecker, usePoisonedData, livePerfRecorder) {
        this.adapter = adapter;
        this.options = options;
        this.inputProgram = inputProgram;
        this.programDriver = programDriver;
        this.incrementalStrategy = incrementalStrategy;
        this.incrementalCompilation = incrementalCompilation;
        this.usePoisonedData = usePoisonedData;
        this.livePerfRecorder = livePerfRecorder;
        this.angularCoreVersion = options['_angularCoreVersion'] ?? null;
        this.delegatingPerfRecorder = new DelegatingPerfRecorder(this.perfRecorder);
        this.usePoisonedData = usePoisonedData || !!options._compilePoisonedComponents;
        this.enableTemplateTypeChecker =
            enableTemplateTypeChecker || !!options._enableTemplateTypeChecker;
        this.enableBlockSyntax =
            this.angularCoreVersion === null ||
                coreVersionSupportsFeature(this.angularCoreVersion, '>= 17.0.0');
        this.enableLetSyntax =
            this.angularCoreVersion === null ||
                coreVersionSupportsFeature(this.angularCoreVersion, '>= 18.1.0');
        this.enableSelectorless = options['_enableSelectorless'] ?? false;
        this.emitDeclarationOnly =
            !!options.emitDeclarationOnly && !!options._experimentalAllowEmitDeclarationOnly;
        // Standalone by default is enabled since v19. We need to toggle it here,
        // because the language service extension may be running with the latest
        // version of the compiler against an older version of Angular.
        this.implicitStandaloneValue =
            this.angularCoreVersion === null ||
                coreVersionSupportsFeature(this.angularCoreVersion, '>= 19.0.0');
        this.enableHmr = !!options['_enableHmr'];
        this.constructionDiagnostics.push(...this.adapter.constructionDiagnostics, ...verifyCompatibleTypeCheckOptions(this.options), ...verifyEmitDeclarationOnly(this.options));
        this.currentProgram = inputProgram;
        this.closureCompilerEnabled = !!this.options.annotateForClosureCompiler;
        this.entryPoint =
            adapter.entryPoint !== null ? getSourceFileOrNull(inputProgram, adapter.entryPoint) : null;
        const moduleResolutionCache = ts.createModuleResolutionCache(this.adapter.getCurrentDirectory(), 
        // doen't retain a reference to `this`, if other closures in the constructor here reference
        // `this` internally then a closure created here would retain them. This can cause major
        // memory leak issues since the `moduleResolutionCache` is a long-lived object and finds its
        // way into all kinds of places inside TS internal objects.
        this.adapter.getCanonicalFileName.bind(this.adapter));
        this.moduleResolver = new ModuleResolver(inputProgram, this.options, this.adapter, moduleResolutionCache);
        this.resourceManager = new AdapterResourceLoader(adapter, this.options);
        this.cycleAnalyzer = new CycleAnalyzer(new ImportGraph(inputProgram.getTypeChecker(), this.delegatingPerfRecorder));
        this.incrementalStrategy.setIncrementalState(this.incrementalCompilation.state, inputProgram);
        this.ignoreForDiagnostics = new Set(inputProgram.getSourceFiles().filter((sf) => this.adapter.isShim(sf)));
        this.ignoreForEmit = this.adapter.ignoreForEmit;
        let dtsFileCount = 0;
        let nonDtsFileCount = 0;
        for (const sf of inputProgram.getSourceFiles()) {
            if (sf.isDeclarationFile) {
                dtsFileCount++;
            }
            else {
                nonDtsFileCount++;
            }
        }
        livePerfRecorder.eventCount(exports.PerfEvent.InputDtsFile, dtsFileCount);
        livePerfRecorder.eventCount(exports.PerfEvent.InputTsFile, nonDtsFileCount);
    }
    get perfRecorder() {
        return this.livePerfRecorder;
    }
    updateWithChangedResources(changedResources, perfRecorder) {
        this.livePerfRecorder = perfRecorder;
        this.delegatingPerfRecorder.target = perfRecorder;
        perfRecorder.inPhase(exports.PerfPhase.ResourceUpdate, () => {
            if (this.compilation === null) {
                // Analysis hasn't happened yet, so no update is necessary - any changes to resources will
                // be captured by the initial analysis pass itself.
                return;
            }
            this.resourceManager.invalidate();
            const classesToUpdate = new Set();
            for (const resourceFile of changedResources) {
                for (const templateClass of this.getComponentsWithTemplateFile(resourceFile)) {
                    classesToUpdate.add(templateClass);
                }
                for (const styleClass of this.getComponentsWithStyleFile(resourceFile)) {
                    classesToUpdate.add(styleClass);
                }
            }
            for (const clazz of classesToUpdate) {
                this.compilation.traitCompiler.updateResources(clazz);
                if (!ts.isClassDeclaration(clazz)) {
                    continue;
                }
                this.compilation.templateTypeChecker.invalidateClass(clazz);
            }
        });
    }
    /**
     * Get the resource dependencies of a file.
     *
     * If the file is not part of the compilation, an empty array will be returned.
     */
    getResourceDependencies(file) {
        this.ensureAnalyzed();
        return this.incrementalCompilation.depGraph.getResourceDependencies(file);
    }
    /**
     * Get all Angular-related diagnostics for this compilation.
     */
    getDiagnostics() {
        const diagnostics = [...this.getNonTemplateDiagnostics()];
        // Type check code may throw fatal diagnostic errors if e.g. the type check
        // block cannot be generated. Gracefully return the associated diagnostic.
        // Note: If a fatal diagnostic is raised, do not repeat the same diagnostics
        // by running the extended template checking code, which will attempt to
        // generate the same TCB.
        try {
            diagnostics.push(...this.getTemplateDiagnostics(), ...this.runAdditionalChecks());
        }
        catch (err) {
            if (!isFatalDiagnosticError(err)) {
                throw err;
            }
            diagnostics.push(err.toDiagnostic());
        }
        return this.addMessageTextDetails(diagnostics);
    }
    /**
     * Get all Angular-related diagnostics for this compilation.
     *
     * If a `ts.SourceFile` is passed, only diagnostics related to that file are returned.
     */
    getDiagnosticsForFile(file, optimizeFor) {
        const diagnostics = [
            ...this.getNonTemplateDiagnostics().filter((diag) => diag.file === file),
        ];
        // Type check code may throw fatal diagnostic errors if e.g. the type check
        // block cannot be generated. Gracefully return the associated diagnostic.
        // Note: If a fatal diagnostic is raised, do not repeat the same diagnostics
        // by running the extended template checking code, which will attempt to
        // generate the same TCB.
        try {
            diagnostics.push(...this.getTemplateDiagnosticsForFile(file, optimizeFor), ...this.runAdditionalChecks(file));
        }
        catch (err) {
            if (!isFatalDiagnosticError(err)) {
                throw err;
            }
            diagnostics.push(err.toDiagnostic());
        }
        return this.addMessageTextDetails(diagnostics);
    }
    /**
     * Get all `ts.Diagnostic`s currently available that pertain to the given component.
     */
    getDiagnosticsForComponent(component) {
        const compilation = this.ensureAnalyzed();
        const ttc = compilation.templateTypeChecker;
        const diagnostics = [];
        // Type check code may throw fatal diagnostic errors if e.g. the type check
        // block cannot be generated. Gracefully return the associated diagnostic.
        // Note: If a fatal diagnostic is raised, do not repeat the same diagnostics
        // by running the extended template checking code, which will attempt to
        // generate the same TCB.
        try {
            diagnostics.push(...ttc.getDiagnosticsForComponent(component));
            const { extendedTemplateChecker, templateSemanticsChecker } = compilation;
            if (templateSemanticsChecker !== null) {
                diagnostics.push(...templateSemanticsChecker.getDiagnosticsForComponent(component));
            }
            if (this.options.strictTemplates && extendedTemplateChecker !== null) {
                diagnostics.push(...extendedTemplateChecker.getDiagnosticsForComponent(component));
            }
        }
        catch (err) {
            if (!isFatalDiagnosticError(err)) {
                throw err;
            }
            diagnostics.push(err.toDiagnostic());
        }
        return this.addMessageTextDetails(diagnostics);
    }
    /**
     * Add Angular.io error guide links to diagnostics for this compilation.
     */
    addMessageTextDetails(diagnostics) {
        return diagnostics.map((diag) => {
            if (diag.code && COMPILER_ERRORS_WITH_GUIDES.has(ngErrorCode(diag.code))) {
                return {
                    ...diag,
                    messageText: diag.messageText +
                        `. Find more at ${ERROR_DETAILS_PAGE_BASE_URL}/NG${ngErrorCode(diag.code)}`,
                };
            }
            return diag;
        });
    }
    /**
     * Get all setup-related diagnostics for this compilation.
     */
    getOptionDiagnostics() {
        return this.constructionDiagnostics;
    }
    /**
     * Get the current `ts.Program` known to this `NgCompiler`.
     *
     * Compilation begins with an input `ts.Program`, and during template type-checking operations new
     * `ts.Program`s may be produced using the `ProgramDriver`. The most recent such `ts.Program` to
     * be produced is available here.
     *
     * This `ts.Program` serves two key purposes:
     *
     * * As an incremental starting point for creating the next `ts.Program` based on files that the
     *   user has changed (for clients using the TS compiler program APIs).
     *
     * * As the "before" point for an incremental compilation invocation, to determine what's changed
     *   between the old and new programs (for all compilations).
     */
    getCurrentProgram() {
        return this.currentProgram;
    }
    getTemplateTypeChecker() {
        if (!this.enableTemplateTypeChecker) {
            throw new Error('The `TemplateTypeChecker` does not work without `enableTemplateTypeChecker`.');
        }
        return this.ensureAnalyzed().templateTypeChecker;
    }
    /**
     * Retrieves the `ts.Declaration`s for any component(s) which use the given template file.
     */
    getComponentsWithTemplateFile(templateFilePath) {
        const { resourceRegistry } = this.ensureAnalyzed();
        return resourceRegistry.getComponentsWithTemplate(resolve(templateFilePath));
    }
    /**
     * Retrieves the `ts.Declaration`s for any component(s) which use the given template file.
     */
    getComponentsWithStyleFile(styleFilePath) {
        const { resourceRegistry } = this.ensureAnalyzed();
        return resourceRegistry.getComponentsWithStyle(resolve(styleFilePath));
    }
    /**
     * Retrieves external resources for the given directive.
     */
    getDirectiveResources(classDecl) {
        if (!isNamedClassDeclaration(classDecl)) {
            return null;
        }
        const { resourceRegistry } = this.ensureAnalyzed();
        const styles = resourceRegistry.getStyles(classDecl);
        const template = resourceRegistry.getTemplate(classDecl);
        const hostBindings = resourceRegistry.getHostBindings(classDecl);
        return { styles, template, hostBindings };
    }
    getMeta(classDecl) {
        if (!isNamedClassDeclaration(classDecl)) {
            return null;
        }
        const ref = new Reference(classDecl);
        const { metaReader } = this.ensureAnalyzed();
        const meta = metaReader.getPipeMetadata(ref) ?? metaReader.getDirectiveMetadata(ref);
        if (meta === null) {
            return null;
        }
        return meta;
    }
    /**
     * Perform Angular's analysis step (as a precursor to `getDiagnostics` or `prepareEmit`)
     * asynchronously.
     *
     * Normally, this operation happens lazily whenever `getDiagnostics` or `prepareEmit` are called.
     * However, certain consumers may wish to allow for an asynchronous phase of analysis, where
     * resources such as `styleUrls` are resolved asynchronously. In these cases `analyzeAsync` must
     * be called first, and its `Promise` awaited prior to calling any other APIs of `NgCompiler`.
     */
    async analyzeAsync() {
        if (this.compilation !== null) {
            return;
        }
        await this.perfRecorder.inPhase(exports.PerfPhase.Analysis, async () => {
            this.compilation = this.makeCompilation();
            const promises = [];
            for (const sf of this.inputProgram.getSourceFiles()) {
                if (sf.isDeclarationFile) {
                    continue;
                }
                let analysisPromise = this.compilation.traitCompiler.analyzeAsync(sf);
                if (analysisPromise !== undefined) {
                    promises.push(analysisPromise);
                }
            }
            await Promise.all(promises);
            this.perfRecorder.memory(exports.PerfCheckpoint.Analysis);
            this.resolveCompilation(this.compilation.traitCompiler);
        });
    }
    /**
     * Fetch transformers and other information which is necessary for a consumer to `emit` the
     * program with Angular-added definitions.
     */
    prepareEmit() {
        const compilation = this.ensureAnalyzed();
        // Untag all the files, otherwise TS 5.4 may end up emitting
        // references to typecheck files (see #56945 and #57135).
        untagAllTsFiles(this.inputProgram);
        const coreImportsFrom = compilation.isCore ? getR3SymbolsFile(this.inputProgram) : null;
        let importRewriter;
        if (coreImportsFrom !== null) {
            importRewriter = new R3SymbolsImportRewriter(coreImportsFrom.fileName);
        }
        else {
            importRewriter = new NoopImportRewriter();
        }
        const defaultImportTracker = new DefaultImportTracker();
        const before = [
            ivyTransformFactory(compilation.traitCompiler, compilation.reflector, importRewriter, defaultImportTracker, compilation.localCompilationExtraImportsTracker, this.delegatingPerfRecorder, compilation.isCore, this.closureCompilerEnabled, this.emitDeclarationOnly),
            aliasTransformFactory(compilation.traitCompiler.exportStatements),
            defaultImportTracker.importPreservingTransformer(),
        ];
        // If there are JIT declarations, wire up the JIT transform and efficiently
        // run it against the target declarations.
        if (compilation.supportJitMode && compilation.jitDeclarationRegistry.jitDeclarations.size > 0) {
            const { jitDeclarations } = compilation.jitDeclarationRegistry;
            const jitDeclarationsArray = Array.from(jitDeclarations);
            const jitDeclarationOriginalNodes = new Set(jitDeclarationsArray.map((d) => ts.getOriginalNode(d)));
            const sourceFilesWithJit = new Set(jitDeclarationsArray.map((d) => d.getSourceFile().fileName));
            before.push((ctx) => {
                const reflectionHost = new TypeScriptReflectionHost(this.inputProgram.getTypeChecker());
                const jitTransform = angularJitApplicationTransform(this.inputProgram, compilation.isCore, (node) => {
                    // Class may be synthetic at this point due to Ivy transform.
                    node = ts.getOriginalNode(node, ts.isClassDeclaration);
                    return reflectionHost.isClass(node) && jitDeclarationOriginalNodes.has(node);
                })(ctx);
                return (sourceFile) => {
                    if (!sourceFilesWithJit.has(sourceFile.fileName)) {
                        return sourceFile;
                    }
                    return jitTransform(sourceFile);
                };
            });
        }
        // Typescript transformer to add debugName metadata to signal functions.
        before.push(signalMetadataTransform(this.inputProgram));
        const afterDeclarations = [];
        // In local compilation mode we don't make use of .d.ts files for Angular compilation, so their
        // transformation can be ditched.
        if ((this.options.compilationMode !== 'experimental-local' || this.emitDeclarationOnly) &&
            compilation.dtsTransforms !== null) {
            // If we are emitting declarations only, the script transformations are skipped by the TS
            // compiler, so we have to add them to the afterDeclarations transforms to run their analysis
            // because the declaration transform depends on their metadata output.
            if (this.emitDeclarationOnly) {
                afterDeclarations.push(...before);
            }
            afterDeclarations.push(declarationTransformFactory(compilation.dtsTransforms, compilation.reflector, compilation.refEmitter, importRewriter));
        }
        // Only add aliasing re-exports to the .d.ts output if the `AliasingHost` requests it.
        if (compilation.aliasingHost !== null && compilation.aliasingHost.aliasExportsInDts) {
            afterDeclarations.push(aliasTransformFactory(compilation.traitCompiler.exportStatements));
        }
        return { transformers: { before, afterDeclarations } };
    }
    /**
     * Run the indexing process and return a `Map` of all indexed components.
     *
     * See the `indexing` package for more details.
     */
    getIndexedComponents() {
        const compilation = this.ensureAnalyzed();
        const context = new IndexingContext();
        compilation.traitCompiler.index(context);
        return generateAnalysis(context);
    }
    /**
     * Gets information for the current program that may be used to generate API
     * reference documentation. This includes Angular-specific information, such
     * as component inputs and outputs.
     *
     * @param entryPoint Path to the entry point for the package for which API
     *     docs should be extracted.
     *
     * @returns A map of symbols with their associated module, eg: ApplicationRef => @angular/core
     */
    getApiDocumentation(entryPoint, privateModules) {
        const compilation = this.ensureAnalyzed();
        const checker = this.inputProgram.getTypeChecker();
        const docsExtractor = new DocsExtractor(checker, compilation.metaReader);
        const entryPointSourceFile = this.inputProgram.getSourceFiles().find((sourceFile) => {
            // TODO: this will need to be more specific than `.includes`, but the exact path comparison
            //     will be easier to figure out when the pipeline is running end-to-end.
            return sourceFile.fileName.includes(entryPoint);
        });
        if (!entryPointSourceFile) {
            throw new Error(`Entry point "${entryPoint}" not found in program sources.`);
        }
        // TODO: Technically the current directory is not the root dir.
        // Should probably be derived from the config.
        const rootDir = this.inputProgram.getCurrentDirectory();
        return docsExtractor.extractAll(entryPointSourceFile, rootDir, privateModules);
    }
    /**
     * Collect i18n messages into the `Xi18nContext`.
     */
    xi18n(ctx) {
        // Note that the 'resolve' phase is not strictly necessary for xi18n, but this is not currently
        // optimized.
        const compilation = this.ensureAnalyzed();
        compilation.traitCompiler.xi18n(ctx);
    }
    /**
     * Emits the JavaScript module that can be used to replace the metadata of a class during HMR.
     * @param node Class for which to generate the update module.
     */
    emitHmrUpdateModule(node) {
        const { traitCompiler, reflector } = this.ensureAnalyzed();
        if (!reflector.isClass(node)) {
            return null;
        }
        const callback = traitCompiler.compileHmrUpdateCallback(node);
        if (callback === null) {
            return null;
        }
        const sourceFile = node.getSourceFile();
        const printer = ts.createPrinter();
        const nodeText = printer.printNode(ts.EmitHint.Unspecified, callback, sourceFile);
        return ts.transpileModule(nodeText, {
            compilerOptions: {
                ...this.options,
                // Some module types can produce additional code (see #60795) whereas we need the
                // HMR update module to use a native `export`. Override the `target` and `module`
                // to ensure that it looks as expected.
                module: ts.ModuleKind.ES2022,
                target: ts.ScriptTarget.ES2022,
            },
            fileName: sourceFile.fileName,
            reportDiagnostics: false,
        }).outputText;
    }
    ensureAnalyzed() {
        if (this.compilation === null) {
            this.analyzeSync();
        }
        return this.compilation;
    }
    analyzeSync() {
        this.perfRecorder.inPhase(exports.PerfPhase.Analysis, () => {
            this.compilation = this.makeCompilation();
            for (const sf of this.inputProgram.getSourceFiles()) {
                if (sf.isDeclarationFile) {
                    continue;
                }
                this.compilation.traitCompiler.analyzeSync(sf);
            }
            this.perfRecorder.memory(exports.PerfCheckpoint.Analysis);
            this.resolveCompilation(this.compilation.traitCompiler);
        });
    }
    resolveCompilation(traitCompiler) {
        this.perfRecorder.inPhase(exports.PerfPhase.Resolve, () => {
            traitCompiler.resolve();
            // At this point, analysis is complete and the compiler can now calculate which files need to
            // be emitted, so do that.
            this.incrementalCompilation.recordSuccessfulAnalysis(traitCompiler);
            this.perfRecorder.memory(exports.PerfCheckpoint.Resolve);
        });
    }
    get fullTemplateTypeCheck() {
        // Determine the strictness level of type checking based on compiler options. As
        // `strictTemplates` is a superset of `fullTemplateTypeCheck`, the former implies the latter.
        // Also see `verifyCompatibleTypeCheckOptions` where it is verified that `fullTemplateTypeCheck`
        // is not disabled when `strictTemplates` is enabled.
        const strictTemplates = !!this.options.strictTemplates;
        return strictTemplates || !!this.options.fullTemplateTypeCheck;
    }
    getTypeCheckingConfig() {
        // Determine the strictness level of type checking based on compiler options. As
        // `strictTemplates` is a superset of `fullTemplateTypeCheck`, the former implies the latter.
        // Also see `verifyCompatibleTypeCheckOptions` where it is verified that `fullTemplateTypeCheck`
        // is not disabled when `strictTemplates` is enabled.
        const strictTemplates = !!this.options.strictTemplates;
        const useInlineTypeConstructors = this.programDriver.supportsInlineOperations;
        const checkTwoWayBoundEvents = this.options['_checkTwoWayBoundEvents'] ?? false;
        // Check whether the loaded version of `@angular/core` in the `ts.Program` supports unwrapping
        // writable signals for type-checking. Only Angular versions greater than 17.2 have the necessary
        // symbols to type check signals in two-way bindings. We also allow version 0.0.0 in case somebody is
        // using Angular at head.
        const allowSignalsInTwoWayBindings = this.angularCoreVersion === null ||
            coreVersionSupportsFeature(this.angularCoreVersion, '>= 17.2.0-0');
        const allowDomEventAssertion = this.angularCoreVersion === null ||
            coreVersionSupportsFeature(this.angularCoreVersion, '>= 20.2.0');
        // First select a type-checking configuration, based on whether full template type-checking is
        // requested.
        let typeCheckingConfig;
        if (this.fullTemplateTypeCheck) {
            typeCheckingConfig = {
                applyTemplateContextGuards: strictTemplates,
                checkQueries: false,
                checkTemplateBodies: true,
                alwaysCheckSchemaInTemplateBodies: true,
                checkTypeOfInputBindings: strictTemplates,
                honorAccessModifiersForInputBindings: false,
                checkControlFlowBodies: true,
                strictNullInputBindings: strictTemplates,
                checkTypeOfAttributes: strictTemplates,
                // Even in full template type-checking mode, DOM binding checks are not quite ready yet.
                checkTypeOfDomBindings: false,
                checkTypeOfOutputEvents: strictTemplates,
                checkTypeOfAnimationEvents: strictTemplates,
                // Checking of DOM events currently has an adverse effect on developer experience,
                // e.g. for `<input (blur)="update($event.target.value)">` enabling this check results in:
                // - error TS2531: Object is possibly 'null'.
                // - error TS2339: Property 'value' does not exist on type 'EventTarget'.
                checkTypeOfDomEvents: strictTemplates,
                checkTypeOfDomReferences: strictTemplates,
                // Non-DOM references have the correct type in View Engine so there is no strictness flag.
                checkTypeOfNonDomReferences: true,
                // Pipes are checked in View Engine so there is no strictness flag.
                checkTypeOfPipes: true,
                strictSafeNavigationTypes: strictTemplates,
                useContextGenericType: strictTemplates,
                strictLiteralTypes: true,
                enableTemplateTypeChecker: this.enableTemplateTypeChecker,
                useInlineTypeConstructors,
                // Warnings for suboptimal type inference are only enabled if in Language Service mode
                // (providing the full TemplateTypeChecker API) and if strict mode is not enabled. In strict
                // mode, the user is in full control of type inference.
                suggestionsForSuboptimalTypeInference: this.enableTemplateTypeChecker && !strictTemplates,
                controlFlowPreventingContentProjection: this.options.extendedDiagnostics?.defaultCategory || exports.DiagnosticCategoryLabel.Warning,
                unusedStandaloneImports: this.options.extendedDiagnostics?.defaultCategory || exports.DiagnosticCategoryLabel.Warning,
                allowSignalsInTwoWayBindings,
                checkTwoWayBoundEvents,
                allowDomEventAssertion,
            };
        }
        else {
            typeCheckingConfig = {
                applyTemplateContextGuards: false,
                checkQueries: false,
                checkTemplateBodies: false,
                checkControlFlowBodies: false,
                // Enable deep schema checking in "basic" template type-checking mode only if Closure
                // compilation is requested, which is a good proxy for "only in google3".
                alwaysCheckSchemaInTemplateBodies: this.closureCompilerEnabled,
                checkTypeOfInputBindings: false,
                strictNullInputBindings: false,
                honorAccessModifiersForInputBindings: false,
                checkTypeOfAttributes: false,
                checkTypeOfDomBindings: false,
                checkTypeOfOutputEvents: false,
                checkTypeOfAnimationEvents: false,
                checkTypeOfDomEvents: false,
                checkTypeOfDomReferences: false,
                checkTypeOfNonDomReferences: false,
                checkTypeOfPipes: false,
                strictSafeNavigationTypes: false,
                useContextGenericType: false,
                strictLiteralTypes: false,
                enableTemplateTypeChecker: this.enableTemplateTypeChecker,
                useInlineTypeConstructors,
                // In "basic" template type-checking mode, no warnings are produced since most things are
                // not checked anyways.
                suggestionsForSuboptimalTypeInference: false,
                controlFlowPreventingContentProjection: this.options.extendedDiagnostics?.defaultCategory || exports.DiagnosticCategoryLabel.Warning,
                unusedStandaloneImports: this.options.extendedDiagnostics?.defaultCategory || exports.DiagnosticCategoryLabel.Warning,
                allowSignalsInTwoWayBindings,
                checkTwoWayBoundEvents,
                allowDomEventAssertion,
            };
        }
        // Apply explicitly configured strictness flags on top of the default configuration
        // based on "fullTemplateTypeCheck".
        if (this.options.strictInputTypes !== undefined) {
            typeCheckingConfig.checkTypeOfInputBindings = this.options.strictInputTypes;
            typeCheckingConfig.applyTemplateContextGuards = this.options.strictInputTypes;
        }
        if (this.options.strictInputAccessModifiers !== undefined) {
            typeCheckingConfig.honorAccessModifiersForInputBindings =
                this.options.strictInputAccessModifiers;
        }
        if (this.options.strictNullInputTypes !== undefined) {
            typeCheckingConfig.strictNullInputBindings = this.options.strictNullInputTypes;
        }
        if (this.options.strictOutputEventTypes !== undefined) {
            typeCheckingConfig.checkTypeOfOutputEvents = this.options.strictOutputEventTypes;
            typeCheckingConfig.checkTypeOfAnimationEvents = this.options.strictOutputEventTypes;
        }
        if (this.options.strictDomEventTypes !== undefined) {
            typeCheckingConfig.checkTypeOfDomEvents = this.options.strictDomEventTypes;
        }
        if (this.options.strictSafeNavigationTypes !== undefined) {
            typeCheckingConfig.strictSafeNavigationTypes = this.options.strictSafeNavigationTypes;
        }
        if (this.options.strictDomLocalRefTypes !== undefined) {
            typeCheckingConfig.checkTypeOfDomReferences = this.options.strictDomLocalRefTypes;
        }
        if (this.options.strictAttributeTypes !== undefined) {
            typeCheckingConfig.checkTypeOfAttributes = this.options.strictAttributeTypes;
        }
        if (this.options.strictContextGenerics !== undefined) {
            typeCheckingConfig.useContextGenericType = this.options.strictContextGenerics;
        }
        if (this.options.strictLiteralTypes !== undefined) {
            typeCheckingConfig.strictLiteralTypes = this.options.strictLiteralTypes;
        }
        if (this.options.extendedDiagnostics?.checks?.controlFlowPreventingContentProjection !== undefined) {
            typeCheckingConfig.controlFlowPreventingContentProjection =
                this.options.extendedDiagnostics.checks.controlFlowPreventingContentProjection;
        }
        if (this.options.extendedDiagnostics?.checks?.unusedStandaloneImports !== undefined) {
            typeCheckingConfig.unusedStandaloneImports =
                this.options.extendedDiagnostics.checks.unusedStandaloneImports;
        }
        return typeCheckingConfig;
    }
    getTemplateDiagnostics() {
        const compilation = this.ensureAnalyzed();
        const diagnostics = [];
        // Get diagnostics for all files.
        for (const sf of this.inputProgram.getSourceFiles()) {
            if (sf.isDeclarationFile || this.adapter.isShim(sf)) {
                continue;
            }
            diagnostics.push(...compilation.templateTypeChecker.getDiagnosticsForFile(sf, exports.OptimizeFor.WholeProgram));
        }
        const program = this.programDriver.getProgram();
        this.incrementalStrategy.setIncrementalState(this.incrementalCompilation.state, program);
        this.currentProgram = program;
        return diagnostics;
    }
    getTemplateDiagnosticsForFile(sf, optimizeFor) {
        const compilation = this.ensureAnalyzed();
        // Get the diagnostics.
        const diagnostics = [];
        if (!sf.isDeclarationFile && !this.adapter.isShim(sf)) {
            diagnostics.push(...compilation.templateTypeChecker.getDiagnosticsForFile(sf, optimizeFor));
        }
        const program = this.programDriver.getProgram();
        this.incrementalStrategy.setIncrementalState(this.incrementalCompilation.state, program);
        this.currentProgram = program;
        return diagnostics;
    }
    getNonTemplateDiagnostics() {
        if (this.nonTemplateDiagnostics === null) {
            const compilation = this.ensureAnalyzed();
            this.nonTemplateDiagnostics = [...compilation.traitCompiler.diagnostics];
            if (this.entryPoint !== null && compilation.exportReferenceGraph !== null) {
                this.nonTemplateDiagnostics.push(...checkForPrivateExports(this.entryPoint, this.inputProgram.getTypeChecker(), compilation.exportReferenceGraph));
            }
        }
        return this.nonTemplateDiagnostics;
    }
    runAdditionalChecks(sf) {
        const diagnostics = [];
        const compilation = this.ensureAnalyzed();
        const { extendedTemplateChecker, templateSemanticsChecker, sourceFileValidator } = compilation;
        const files = sf ? [sf] : this.inputProgram.getSourceFiles();
        for (const sf of files) {
            if (sourceFileValidator !== null) {
                const sourceFileDiagnostics = sourceFileValidator.getDiagnosticsForFile(sf);
                if (sourceFileDiagnostics !== null) {
                    diagnostics.push(...sourceFileDiagnostics);
                }
            }
            if (templateSemanticsChecker !== null) {
                diagnostics.push(...compilation.traitCompiler.runAdditionalChecks(sf, (clazz, handler) => {
                    return handler.templateSemanticsCheck?.(clazz, templateSemanticsChecker) || null;
                }));
            }
            if (this.options.strictTemplates && extendedTemplateChecker !== null) {
                diagnostics.push(...compilation.traitCompiler.runAdditionalChecks(sf, (clazz, handler) => {
                    return handler.extendedTemplateCheck?.(clazz, extendedTemplateChecker) || null;
                }));
            }
        }
        return diagnostics;
    }
    makeCompilation() {
        const isCore = this.options._isAngularCoreCompilation ?? isAngularCorePackage(this.inputProgram);
        // Note: If this compilation builds `@angular/core`, we always build in full compilation
        // mode. Code inside the core package is always compatible with itself, so it does not
        // make sense to go through the indirection of partial compilation
        let compilationMode = exports.CompilationMode.FULL;
        if (!isCore) {
            switch (this.options.compilationMode) {
                case 'full':
                    compilationMode = exports.CompilationMode.FULL;
                    break;
                case 'partial':
                    compilationMode = exports.CompilationMode.PARTIAL;
                    break;
                case 'experimental-local':
                    compilationMode = exports.CompilationMode.LOCAL;
                    break;
            }
        }
        if (this.emitDeclarationOnly) {
            compilationMode = exports.CompilationMode.LOCAL;
        }
        const checker = this.inputProgram.getTypeChecker();
        const reflector = new TypeScriptReflectionHost(checker, compilationMode === exports.CompilationMode.LOCAL);
        // Construct the ReferenceEmitter.
        let refEmitter;
        let aliasingHost = null;
        if (this.adapter.unifiedModulesHost === null ||
            (!this.options['_useHostForImportGeneration'] &&
                !this.options['_useHostForImportAndAliasGeneration'])) {
            let localImportStrategy;
            // The strategy used for local, in-project imports depends on whether TS has been configured
            // with rootDirs. If so, then multiple directories may be mapped in the same "module
            // namespace" and the logic of `LogicalProjectStrategy` is required to generate correct
            // imports which may cross these multiple directories. Otherwise, plain relative imports are
            // sufficient.
            if (this.options.rootDirs !== undefined && this.options.rootDirs.length > 0) {
                // rootDirs logic is in effect - use the `LogicalProjectStrategy` for in-project relative
                // imports.
                localImportStrategy = new LogicalProjectStrategy(reflector, new LogicalFileSystem([...this.adapter.rootDirs], this.adapter));
            }
            else {
                // Plain relative imports are all that's needed.
                localImportStrategy = new RelativePathStrategy(reflector);
            }
            // The CompilerHost doesn't have fileNameToModuleName, so build an NPM-centric reference
            // resolution strategy.
            refEmitter = new ReferenceEmitter([
                // First, try to use local identifiers if available.
                new LocalIdentifierStrategy(),
                // Next, attempt to use an absolute import.
                new AbsoluteModuleStrategy(this.inputProgram, checker, this.moduleResolver, reflector),
                // Finally, check if the reference is being written into a file within the project's .ts
                // sources, and use a relative import if so. If this fails, ReferenceEmitter will throw
                // an error.
                localImportStrategy,
            ]);
            // If an entrypoint is present, then all user imports should be directed through the
            // entrypoint and private exports are not needed. The compiler will validate that all
            // publicly visible directives/pipes are importable via this entrypoint.
            if (this.entryPoint === null && this.options.generateDeepReexports === true) {
                // No entrypoint is present and deep re-exports were requested, so configure the aliasing
                // system to generate them.
                aliasingHost = new PrivateExportAliasingHost(reflector);
            }
        }
        else {
            // The CompilerHost supports fileNameToModuleName, so use that to emit imports.
            refEmitter = new ReferenceEmitter([
                // First, try to use local identifiers if available.
                new LocalIdentifierStrategy(),
                // Then use aliased references (this is a workaround to StrictDeps checks).
                ...(this.options['_useHostForImportAndAliasGeneration'] ? [new AliasStrategy()] : []),
                // Then use fileNameToModuleName to emit imports.
                new UnifiedModulesStrategy(reflector, this.adapter.unifiedModulesHost),
            ]);
            if (this.options['_useHostForImportAndAliasGeneration']) {
                aliasingHost = new UnifiedModulesAliasingHost(this.adapter.unifiedModulesHost);
            }
        }
        const evaluator = new PartialEvaluator(reflector, checker, this.incrementalCompilation.depGraph);
        const dtsReader = new DtsMetadataReader(checker, reflector);
        const localMetaRegistry = new LocalMetadataRegistry();
        const localMetaReader = localMetaRegistry;
        const depScopeReader = new MetadataDtsModuleScopeResolver(dtsReader, aliasingHost);
        const metaReader = new CompoundMetadataReader([localMetaReader, dtsReader]);
        const ngModuleIndex = new NgModuleIndexImpl(metaReader, localMetaReader);
        const ngModuleScopeRegistry = new LocalModuleScopeRegistry(localMetaReader, metaReader, depScopeReader, refEmitter, aliasingHost);
        const standaloneScopeReader = new StandaloneComponentScopeReader(metaReader, ngModuleScopeRegistry, depScopeReader);
        const selectorlessScopeReader = new SelectorlessComponentScopeReader(metaReader, reflector);
        const scopeReader = new CompoundComponentScopeReader([
            ngModuleScopeRegistry,
            selectorlessScopeReader,
            standaloneScopeReader,
        ]);
        const semanticDepGraphUpdater = this.incrementalCompilation.semanticDepGraphUpdater;
        const metaRegistry = new CompoundMetadataRegistry([localMetaRegistry, ngModuleScopeRegistry]);
        const injectableRegistry = new InjectableClassRegistry(reflector, isCore);
        const hostDirectivesResolver = new HostDirectivesResolver(metaReader);
        const exportedProviderStatusResolver = new ExportedProviderStatusResolver(metaReader);
        const importTracker = new ImportedSymbolsTracker();
        const typeCheckScopeRegistry = new TypeCheckScopeRegistry(scopeReader, metaReader, hostDirectivesResolver);
        // If a flat module entrypoint was specified, then track references via a `ReferenceGraph` in
        // order to produce proper diagnostics for incorrectly exported directives/pipes/etc. If there
        // is no flat module entrypoint then don't pay the cost of tracking references.
        let referencesRegistry;
        let exportReferenceGraph = null;
        if (this.entryPoint !== null) {
            exportReferenceGraph = new ReferenceGraph();
            referencesRegistry = new ReferenceGraphAdapter(exportReferenceGraph);
        }
        else {
            referencesRegistry = new NoopReferencesRegistry();
        }
        const dtsTransforms = new DtsTransformRegistry();
        const resourceRegistry = new ResourceRegistry();
        const deferredSymbolsTracker = new DeferredSymbolTracker(this.inputProgram.getTypeChecker(), this.options.onlyExplicitDeferDependencyImports ?? false);
        let localCompilationExtraImportsTracker = null;
        if (compilationMode === exports.CompilationMode.LOCAL && this.options.generateExtraImportsInLocalMode) {
            localCompilationExtraImportsTracker = new LocalCompilationExtraImportsTracker(checker);
        }
        // Cycles are handled in full and local compilation modes by "remote scoping".
        // "Remote scoping" does not work well with tree shaking for libraries.
        // So in partial compilation mode, when building a library, a cycle will cause an error.
        const cycleHandlingStrategy = compilationMode === exports.CompilationMode.PARTIAL
            ? 1 /* CycleHandlingStrategy.Error */
            : 0 /* CycleHandlingStrategy.UseRemoteScoping */;
        const strictCtorDeps = this.options.strictInjectionParameters || false;
        const supportJitMode = this.options['supportJitMode'] ?? true;
        const supportTestBed = this.options['supportTestBed'] ?? true;
        const externalRuntimeStyles = this.options['externalRuntimeStyles'] ?? false;
        const typeCheckHostBindings = this.options.typeCheckHostBindings ?? true;
        // Libraries compiled in partial mode could potentially be used with TestBed within an
        // application. Since this is not known at library compilation time, support is required to
        // prevent potential downstream application testing breakage.
        if (supportTestBed === false && compilationMode === exports.CompilationMode.PARTIAL) {
            throw new Error('TestBed support ("supportTestBed" option) cannot be disabled in partial compilation mode.');
        }
        if (supportJitMode === false && compilationMode === exports.CompilationMode.PARTIAL) {
            throw new Error('JIT mode support ("supportJitMode" option) cannot be disabled in partial compilation mode.');
        }
        // Currently forbidOrphanComponents depends on the code generated behind ngJitMode flag. Until
        // we come up with a better design for these flags, it is necessary to have the JIT mode in
        // order for forbidOrphanComponents to be able to work properly.
        if (supportJitMode === false && this.options.forbidOrphanComponents) {
            throw new Error('JIT mode support ("supportJitMode" option) cannot be disabled when forbidOrphanComponents is set to true');
        }
        const jitDeclarationRegistry = new JitDeclarationRegistry();
        // Set up the IvyCompilation, which manages state for the Ivy transformer.
        const handlers = [
            new ComponentDecoratorHandler(reflector, evaluator, metaRegistry, metaReader, scopeReader, this.adapter, ngModuleScopeRegistry, typeCheckScopeRegistry, resourceRegistry, isCore, strictCtorDeps, this.resourceManager, this.adapter.rootDirs, this.options.preserveWhitespaces || false, this.options.i18nUseExternalIds !== false, this.options.enableI18nLegacyMessageIdFormat !== false, this.usePoisonedData, this.options.i18nNormalizeLineEndingsInICUs === true, this.moduleResolver, this.cycleAnalyzer, cycleHandlingStrategy, refEmitter, referencesRegistry, this.incrementalCompilation.depGraph, injectableRegistry, semanticDepGraphUpdater, this.closureCompilerEnabled, this.delegatingPerfRecorder, hostDirectivesResolver, importTracker, supportTestBed, compilationMode, deferredSymbolsTracker, !!this.options.forbidOrphanComponents, this.enableBlockSyntax, this.enableLetSyntax, externalRuntimeStyles, localCompilationExtraImportsTracker, jitDeclarationRegistry, this.options.i18nPreserveWhitespaceForLegacyExtraction ?? true, !!this.options.strictStandalone, this.enableHmr, this.implicitStandaloneValue, typeCheckHostBindings, this.enableSelectorless, this.emitDeclarationOnly),
            // TODO(alxhub): understand why the cast here is necessary (something to do with `null`
            // not being assignable to `unknown` when wrapped in `Readonly`).
            new DirectiveDecoratorHandler(reflector, evaluator, metaRegistry, ngModuleScopeRegistry, metaReader, injectableRegistry, refEmitter, referencesRegistry, isCore, strictCtorDeps, semanticDepGraphUpdater, this.closureCompilerEnabled, this.delegatingPerfRecorder, importTracker, supportTestBed, typeCheckScopeRegistry, compilationMode, jitDeclarationRegistry, resourceRegistry, !!this.options.strictStandalone, this.implicitStandaloneValue, this.usePoisonedData, typeCheckHostBindings, this.emitDeclarationOnly),
            // Pipe handler must be before injectable handler in list so pipe factories are printed
            // before injectable factories (so injectable factories can delegate to them)
            new PipeDecoratorHandler(reflector, evaluator, metaRegistry, ngModuleScopeRegistry, injectableRegistry, isCore, this.delegatingPerfRecorder, supportTestBed, compilationMode, !!this.options.generateExtraImportsInLocalMode, !!this.options.strictStandalone, this.implicitStandaloneValue),
            new InjectableDecoratorHandler(reflector, evaluator, isCore, strictCtorDeps, injectableRegistry, this.delegatingPerfRecorder, supportTestBed, compilationMode),
            new NgModuleDecoratorHandler(reflector, evaluator, metaReader, metaRegistry, ngModuleScopeRegistry, referencesRegistry, exportedProviderStatusResolver, semanticDepGraphUpdater, isCore, refEmitter, this.closureCompilerEnabled, this.options.onlyPublishPublicTypingsForNgModules ?? false, injectableRegistry, this.delegatingPerfRecorder, supportTestBed, supportJitMode, compilationMode, localCompilationExtraImportsTracker, jitDeclarationRegistry, this.emitDeclarationOnly),
        ];
        const traitCompiler = new TraitCompiler(handlers, reflector, this.delegatingPerfRecorder, this.incrementalCompilation, this.options.compileNonExportedClasses !== false, compilationMode, dtsTransforms, semanticDepGraphUpdater, this.adapter, this.emitDeclarationOnly);
        // Template type-checking may use the `ProgramDriver` to produce new `ts.Program`(s). If this
        // happens, they need to be tracked by the `NgCompiler`.
        const notifyingDriver = new NotifyingProgramDriverWrapper(this.programDriver, (program) => {
            this.incrementalStrategy.setIncrementalState(this.incrementalCompilation.state, program);
            this.currentProgram = program;
        });
        const typeCheckingConfig = this.getTypeCheckingConfig();
        const templateTypeChecker = new TemplateTypeCheckerImpl(this.inputProgram, notifyingDriver, traitCompiler, typeCheckingConfig, refEmitter, reflector, this.adapter, this.incrementalCompilation, metaReader, localMetaReader, ngModuleIndex, scopeReader, typeCheckScopeRegistry, this.delegatingPerfRecorder);
        // Only construct the extended template checker if the configuration is valid and usable.
        const extendedTemplateChecker = this.constructionDiagnostics.length === 0
            ? new ExtendedTemplateCheckerImpl(templateTypeChecker, checker, ALL_DIAGNOSTIC_FACTORIES, this.options)
            : null;
        const templateSemanticsChecker = this.constructionDiagnostics.length === 0
            ? new TemplateSemanticsCheckerImpl(templateTypeChecker)
            : null;
        const sourceFileValidator = this.constructionDiagnostics.length === 0
            ? new SourceFileValidator(reflector, importTracker, templateTypeChecker, typeCheckingConfig)
            : null;
        return {
            isCore,
            traitCompiler,
            reflector,
            scopeRegistry: ngModuleScopeRegistry,
            dtsTransforms,
            exportReferenceGraph,
            metaReader,
            typeCheckScopeRegistry,
            aliasingHost,
            refEmitter,
            templateTypeChecker,
            resourceRegistry,
            extendedTemplateChecker,
            localCompilationExtraImportsTracker,
            jitDeclarationRegistry,
            templateSemanticsChecker,
            sourceFileValidator,
            supportJitMode,
        };
    }
}
/**
 * Determine if the given `Program` is @angular/core.
 */
function isAngularCorePackage(program) {
    // Look for its_just_angular.ts somewhere in the program.
    const r3Symbols = getR3SymbolsFile(program);
    if (r3Symbols === null) {
        return false;
    }
    // Look for the constant ITS_JUST_ANGULAR in that file.
    return r3Symbols.statements.some((stmt) => {
        // The statement must be a variable declaration statement.
        if (!ts.isVariableStatement(stmt)) {
            return false;
        }
        // It must be exported.
        const modifiers = ts.getModifiers(stmt);
        if (modifiers === undefined ||
            !modifiers.some((mod) => mod.kind === ts.SyntaxKind.ExportKeyword)) {
            return false;
        }
        // It must declare ITS_JUST_ANGULAR.
        return stmt.declarationList.declarations.some((decl) => {
            // The declaration must match the name.
            if (!ts.isIdentifier(decl.name) || decl.name.text !== 'ITS_JUST_ANGULAR') {
                return false;
            }
            // It must initialize the variable to true.
            if (decl.initializer === undefined || decl.initializer.kind !== ts.SyntaxKind.TrueKeyword) {
                return false;
            }
            // This definition matches.
            return true;
        });
    });
}
/**
 * Find the 'r3_symbols.ts' file in the given `Program`, or return `null` if it wasn't there.
 */
function getR3SymbolsFile(program) {
    return (program.getSourceFiles().find((file) => file.fileName.indexOf('r3_symbols.ts') >= 0) || null);
}
/**
 * Since "strictTemplates" is a true superset of type checking capabilities compared to
 * "fullTemplateTypeCheck", it is required that the latter is not explicitly disabled if the
 * former is enabled.
 */
function* verifyCompatibleTypeCheckOptions(options) {
    if (options.fullTemplateTypeCheck === false && options.strictTemplates === true) {
        yield makeConfigDiagnostic({
            category: ts.DiagnosticCategory.Error,
            code: exports.ErrorCode.CONFIG_STRICT_TEMPLATES_IMPLIES_FULL_TEMPLATE_TYPECHECK,
            messageText: `
Angular compiler option "strictTemplates" is enabled, however "fullTemplateTypeCheck" is disabled.

Having the "strictTemplates" flag enabled implies that "fullTemplateTypeCheck" is also enabled, so
the latter can not be explicitly disabled.

One of the following actions is required:
1. Remove the "fullTemplateTypeCheck" option.
2. Remove "strictTemplates" or set it to 'false'.

More information about the template type checking compiler options can be found in the documentation:
https://angular.dev/tools/cli/template-typecheck
      `.trim(),
        });
    }
    if (options.extendedDiagnostics && options.strictTemplates === false) {
        yield makeConfigDiagnostic({
            category: ts.DiagnosticCategory.Error,
            code: exports.ErrorCode.CONFIG_EXTENDED_DIAGNOSTICS_IMPLIES_STRICT_TEMPLATES,
            messageText: `
Angular compiler option "extendedDiagnostics" is configured, however "strictTemplates" is disabled.

Using "extendedDiagnostics" requires that "strictTemplates" is also enabled.

One of the following actions is required:
1. Remove "strictTemplates: false" to enable it.
2. Remove "extendedDiagnostics" configuration to disable them.
      `.trim(),
        });
    }
    const allowedCategoryLabels = Array.from(Object.values(exports.DiagnosticCategoryLabel));
    const defaultCategory = options.extendedDiagnostics?.defaultCategory;
    if (defaultCategory && !allowedCategoryLabels.includes(defaultCategory)) {
        yield makeConfigDiagnostic({
            category: ts.DiagnosticCategory.Error,
            code: exports.ErrorCode.CONFIG_EXTENDED_DIAGNOSTICS_UNKNOWN_CATEGORY_LABEL,
            messageText: `
Angular compiler option "extendedDiagnostics.defaultCategory" has an unknown diagnostic category: "${defaultCategory}".

Allowed diagnostic categories are:
${allowedCategoryLabels.join('\n')}
      `.trim(),
        });
    }
    for (const [checkName, category] of Object.entries(options.extendedDiagnostics?.checks ?? {})) {
        if (!SUPPORTED_DIAGNOSTIC_NAMES.has(checkName)) {
            yield makeConfigDiagnostic({
                category: ts.DiagnosticCategory.Error,
                code: exports.ErrorCode.CONFIG_EXTENDED_DIAGNOSTICS_UNKNOWN_CHECK,
                messageText: `
Angular compiler option "extendedDiagnostics.checks" has an unknown check: "${checkName}".

Allowed check names are:
${Array.from(SUPPORTED_DIAGNOSTIC_NAMES).join('\n')}
        `.trim(),
            });
        }
        if (!allowedCategoryLabels.includes(category)) {
            yield makeConfigDiagnostic({
                category: ts.DiagnosticCategory.Error,
                code: exports.ErrorCode.CONFIG_EXTENDED_DIAGNOSTICS_UNKNOWN_CATEGORY_LABEL,
                messageText: `
Angular compiler option "extendedDiagnostics.checks['${checkName}']" has an unknown diagnostic category: "${category}".

Allowed diagnostic categories are:
${allowedCategoryLabels.join('\n')}
        `.trim(),
            });
        }
    }
}
function verifyEmitDeclarationOnly(options) {
    if (!options.emitDeclarationOnly || !!options._experimentalAllowEmitDeclarationOnly) {
        return [];
    }
    return [
        makeConfigDiagnostic({
            category: ts.DiagnosticCategory.Error,
            code: exports.ErrorCode.CONFIG_EMIT_DECLARATION_ONLY_UNSUPPORTED,
            messageText: 'TS compiler option "emitDeclarationOnly" is not supported.',
        }),
    ];
}
function makeConfigDiagnostic({ category, code, messageText, }) {
    return {
        category,
        code: ngErrorCode(code),
        file: undefined,
        start: undefined,
        length: undefined,
        messageText,
    };
}
class ReferenceGraphAdapter {
    graph;
    constructor(graph) {
        this.graph = graph;
    }
    add(source, ...references) {
        for (const { node } of references) {
            let sourceFile = node.getSourceFile();
            if (sourceFile === undefined) {
                sourceFile = ts.getOriginalNode(node).getSourceFile();
            }
            // Only record local references (not references into .d.ts files).
            if (sourceFile === undefined || !isDtsPath(sourceFile.fileName)) {
                this.graph.add(source, node);
            }
        }
    }
}
class NotifyingProgramDriverWrapper {
    delegate;
    notifyNewProgram;
    getSourceFileVersion;
    constructor(delegate, notifyNewProgram) {
        this.delegate = delegate;
        this.notifyNewProgram = notifyNewProgram;
        this.getSourceFileVersion = this.delegate.getSourceFileVersion?.bind(this);
    }
    get supportsInlineOperations() {
        return this.delegate.supportsInlineOperations;
    }
    getProgram() {
        return this.delegate.getProgram();
    }
    updateFiles(contents, updateMode) {
        this.delegate.updateFiles(contents, updateMode);
        this.notifyNewProgram(this.delegate.getProgram());
    }
}
function versionMapFromProgram(program, driver) {
    if (driver.getSourceFileVersion === undefined) {
        return null;
    }
    const versions = new Map();
    for (const possiblyRedirectedSourceFile of program.getSourceFiles()) {
        const sf = toUnredirectedSourceFile(possiblyRedirectedSourceFile);
        versions.set(absoluteFromSourceFile(sf), driver.getSourceFileVersion(sf));
    }
    return versions;
}

/**
 * Gets all tsconfig paths from a CLI project by reading the workspace configuration
 * and looking for common tsconfig locations.
 */
async function getProjectTsConfigPaths(tree) {
    // Start with some tsconfig paths that are generally used within CLI projects. Note
    // that we are not interested in IDE-specific tsconfig files (e.g. /tsconfig.json)
    const buildPaths = new Set();
    const testPaths = new Set();
    const workspace = await getWorkspace(tree);
    for (const [, project] of workspace.projects) {
        for (const [name, target] of project.targets) {
            if (name !== 'build' && name !== 'test') {
                continue;
            }
            for (const [, options] of allTargetOptions(target)) {
                const tsConfig = options['tsConfig'];
                // Filter out tsconfig files that don't exist in the CLI project.
                if (typeof tsConfig !== 'string' || !tree.exists(tsConfig)) {
                    continue;
                }
                if (name === 'build') {
                    buildPaths.add(core.normalize(tsConfig));
                }
                else {
                    testPaths.add(core.normalize(tsConfig));
                }
            }
        }
    }
    return {
        buildPaths: [...buildPaths],
        testPaths: [...testPaths],
    };
}
/** Get options for all configurations for the passed builder target. */
function* allTargetOptions(target) {
    if (target.options) {
        yield [undefined, target.options];
    }
    if (!target.configurations) {
        return;
    }
    for (const [name, options] of Object.entries(target.configurations)) {
        if (options) {
            yield [name, options];
        }
    }
}
function createHost(tree) {
    return {
        async readFile(path) {
            const data = tree.read(path);
            if (!data) {
                throw new Error('File not found.');
            }
            return core.virtualFs.fileBufferToString(data);
        },
        async writeFile(path, data) {
            return tree.overwrite(path, data);
        },
        async isDirectory(path) {
            // Approximate a directory check.
            // We don't need to consider empty directories and hence this is a good enough approach.
            // This is also per documentation, see:
            // https://angular.dev/tools/cli/schematics-for-libraries#get-the-project-configuration
            return !tree.exists(path) && tree.getDir(path).subfiles.length > 0;
        },
        async isFile(path) {
            return tree.exists(path);
        },
    };
}
async function getWorkspace(tree) {
    const host = createHost(tree);
    const { workspace } = await core.workspaces.readWorkspace('/', host);
    return workspace;
}

exports.ActivePerfRecorder = ActivePerfRecorder;
exports.DtsMetadataReader = DtsMetadataReader;
exports.DynamicValue = DynamicValue;
exports.FatalDiagnosticError = FatalDiagnosticError;
exports.ImportManager = ImportManager;
exports.NgCompiler = NgCompiler;
exports.NgOriginalFile = NgOriginalFile;
exports.NodeJSFileSystem = NodeJSFileSystem;
exports.PartialEvaluator = PartialEvaluator;
exports.Reference = Reference;
exports.ReferenceEmitter = ReferenceEmitter;
exports.TypeCheckShimGenerator = TypeCheckShimGenerator;
exports.TypeScriptReflectionHost = TypeScriptReflectionHost;
exports.absoluteFrom = absoluteFrom;
exports.absoluteFromSourceFile = absoluteFromSourceFile;
exports.copyFileShimData = copyFileShimData;
exports.dirname = dirname;
exports.extractDecoratorQueryMetadata = extractDecoratorQueryMetadata;
exports.extractTemplate = extractTemplate;
exports.findAngularDecorator = findAngularDecorator;
exports.freshCompilationTicket = freshCompilationTicket;
exports.getAngularDecorators = getAngularDecorators;
exports.getFileSystem = getFileSystem;
exports.getProjectTsConfigPaths = getProjectTsConfigPaths;
exports.getRootDirs = getRootDirs;
exports.incrementalFromCompilerTicket = incrementalFromCompilerTicket;
exports.isDtsPath = isDtsPath;
exports.isFileShimSourceFile = isFileShimSourceFile;
exports.isLocalRelativePath = isLocalRelativePath;
exports.isNonDeclarationTsPath = isNonDeclarationTsPath;
exports.isShim = isShim;
exports.join = join;
exports.ngErrorCode = ngErrorCode;
exports.normalizeSeparators = normalizeSeparators;
exports.parseDecoratorInputTransformFunction = parseDecoratorInputTransformFunction;
exports.queryDecoratorNames = queryDecoratorNames;
exports.reflectObjectLiteral = reflectObjectLiteral;
exports.relativePathBetween = relativePathBetween;
exports.resolve = resolve;
exports.retagAllTsFiles = retagAllTsFiles;
exports.setFileSystem = setFileSystem;
exports.sfExtensionData = sfExtensionData;
exports.toUnredirectedSourceFile = toUnredirectedSourceFile;
exports.untagAllTsFiles = untagAllTsFiles;
exports.unwrapExpression = unwrapExpression;
